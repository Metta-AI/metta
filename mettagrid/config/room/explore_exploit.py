from typing import Set, Tuple, List
import numpy as np
from omegaconf import DictConfig
from mettagrid.config.room.room import Room

class ExploreExploit(Room):
    """
    Places three reward objects (altar, generator, converter) in two regions:
      - Left (sparse): objects are spread out; the agent is placed here.
      - Right (dense): objects are clustered.
    A vertical wall with random gaps is placed along the center to force exploration.
    """
    def __init__(
        self,
        width: int,
        height: int,
        explore_exploit_params: DictConfig,
        agents: int | DictConfig = 1,
        seed=None,
        border_width: int = 0,
        border_object: str = "wall",
    ):
        super().__init__(border_width=border_width, border_object=border_object)
        self._width = width
        self._height = height
        self._params = explore_exploit_params
        self._agents = agents
        self._rng = np.random.default_rng(seed)

    def _build(self) -> np.ndarray:
        self._grid = np.full((self._height, self._width), "empty", dtype='<U50')
        self._placed_positions: Set[Tuple[int, int]] = set()
        mid_x = self._width // 2

        self._place_obstructions(mid_x)
        self._place_sparse_region(mid_x)
        self._place_dense_region(mid_x)
        self._place_agent(mid_x)

        return self._grid

    def _place_obstructions(self, mid_x: int) -> None:
        gap_prob = self._params.get("obstruction_gap_prob", 0.2)
        for y in range(1, self._height - 1):
            if self._rng.random() > gap_prob:
                self._grid[y, mid_x] = "wall"
                self._placed_positions.add((mid_x, y))

    def _place_sparse_region(self, mid_x: int) -> None:
        # Define region A: left side (sparse)
        region_A = (1, mid_x - 1, 1, self._height - 2)  # (x_min, x_max, y_min, y_max)
        min_distance = self._params.get("sparse_min_distance", 5)
        sparse_positions: List[Tuple[int, int]] = []

        for _, symbol in zip(["heart_altar", "generator", "converter"],
                             ["altar", "generator", "converter"]):
            pos = self._sample_position(*region_A, min_distance, existing=sparse_positions)
            sparse_positions.append(pos)
            self._grid[pos[1], pos[0]] = symbol
            self._placed_positions.add(pos)

    def _place_dense_region(self, mid_x: int) -> None:
        # Define region B: right side (dense)
        region_B = (mid_x + 1, self._width - 2, 1, self._height - 2)
        x_min, x_max, y_min, y_max = region_B

        # Choose a random center for a 3x3 candidate cluster area.
        center_x = int(self._rng.integers(x_min, x_max + 1))
        center_y = int(self._rng.integers(y_min, y_max + 1))
        cluster_x_min = max(x_min, center_x - 1)
        cluster_x_max = min(x_max, center_x + 1)
        cluster_y_min = max(y_min, center_y - 1)
        cluster_y_max = min(y_max, center_y + 1)

        # Build candidate positions.
        cluster_area = [(x, y)
                        for x in range(cluster_x_min, cluster_x_max + 1)
                        for y in range(cluster_y_min, cluster_y_max + 1)]
        available = [pos for pos in cluster_area if pos not in self._placed_positions]

        # If fewer than 3 positions are available, expand to the full dense region.
        if len(available) < 3:
            available = [(x, y)
                         for x in range(x_min, x_max + 1)
                         for y in range(y_min, y_max + 1)
                         if (x, y) not in self._placed_positions]

        # Sample three distinct positions if possible.
        if len(available) >= 3:
            available_arr = np.array(available)
            chosen = self._rng.choice(available_arr, size=3, replace=False)
            chosen = [tuple(pos) for pos in chosen]
        else:
            chosen = available

        for pos, obj in zip(chosen, ["altar", "generator", "converter"]):
            self._grid[pos[1], pos[0]] = obj
            self._placed_positions.add(pos)

    def _place_agent(self, mid_x: int) -> None:
        # Place agent in region A (sparse area)
        region_A = (1, mid_x - 1, 1, self._height - 2)
        x_min, x_max, y_min, y_max = region_A

        for _ in range(100):
            x = int(self._rng.integers(x_min, x_max + 1))
            y = int(self._rng.integers(y_min, y_max + 1))
            if (x, y) not in self._placed_positions:
                self._grid[y, x] = "agent.agent"
                self._placed_positions.add((x, y))
                return

        # Fallback if no free position is found.
        self._grid[y_min, x_min] = "agent.agent"
        self._placed_positions.add((x_min, y_min))

    def _sample_position(
        self,
        x_min: int,
        x_max: int,
        y_min: int,
        y_max: int,
        min_distance: int,
        existing: List[Tuple[int, int]]
    ) -> Tuple[int, int]:
        """
        Returns a position (x, y) within the given bounds that is at least min_distance
        (Manhattan) away from all positions in 'existing'.
        """
        for _ in range(100):
            x = int(self._rng.integers(x_min, x_max + 1))
            y = int(self._rng.integers(y_min, y_max + 1))
            pos = (x, y)
            if pos in self._placed_positions:
                continue
            if all(abs(x - ex) + abs(y - ey) >= min_distance for ex, ey in existing):
                return pos
        return (x_min, y_min)
