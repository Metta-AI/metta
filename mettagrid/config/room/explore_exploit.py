from typing import Set, Tuple, List
import numpy as np
from omegaconf import DictConfig

from mettagrid.config.room.room import Room

class ExploreExploit(Room):
    """
    This task places three types of reward-generating objects:
      - A heart altar (represented as "altar")
      - A generator (represented as "generator")
      - A converter (represented as "converter")

    The grid is divided into two regions:
      1. Sparse Region (left side): The objects are spread relatively far apart.
         The agent starts in this area.
      2. Dense Region (right side): The objects are clustered together.

    A vertical wall is placed along the middle with configurable gaps to obstruct passage
    and force the agent to explore.
    """
    def __init__(
        self,
        width: int,
        height: int,
        explore_exploit_params: DictConfig,
        agents: int | DictConfig = 1,
        seed = None,
        border_width: int = 0,
        border_object: str = "wall",
    ):
        super().__init__(border_width=border_width, border_object=border_object)
        self._width = width
        self._height = height
        self._params = explore_exploit_params
        self._agents = agents
        self._rng = np.random.default_rng(seed)

        # Initialize grid: fill with "empty"
        self._grid = np.full((self._height, self._width), "empty", dtype='<U50')
        # Keep track of positions that have been occupied
        self._placed_positions: Set[Tuple[int, int]] = set()

    def _build(self) -> np.ndarray:
        """
        Build the explore–exploit map.
          - The grid is split vertically: left is the sparse region; right is the dense region.
          - A vertical obstruction (wall) is placed between the regions.
          - In the sparse region, objects are placed far apart.
          - In the dense region, objects are clustered.
          - The agent is placed in the sparse region.
        """
        mid_x = self._width // 2

        # 1. Place an obstruction wall at the vertical midpoint.
        self._place_obstructions(mid_x)

        # 2. Place reward elements in the sparse region (left half).
        self._place_sparse_region(mid_x)

        # 3. Place reward elements in the dense region (right half).
        self._place_dense_region(mid_x)

        # 4. Place the agent in the sparse region.
        self._place_agent(mid_x)

        return self._grid

    def _place_obstructions(self, mid_x: int) -> None:
        """
        Create a vertical wall along x = mid_x with gaps.
        The probability of a gap (no wall) is controlled by the parameter
        "obstruction_gap_prob" (default 0.2).
        """
        gap_prob = self._params.get("obstruction_gap_prob", 0.2)
        for y in range(1, self._height - 1):
            if self._rng.random() > gap_prob:
                self._grid[y, mid_x] = "wall"
                self._placed_positions.add((mid_x, y))

    def _place_sparse_region(self, mid_x: int) -> None:
        """
        In the left (sparse) region, place one each of:
          - Heart altar ("altar")
          - Generator ("generator")
          - Converter ("converter")
        The positions are sampled so that they are at least a given Manhattan distance apart.
        """
        region_A_x_min = 1
        region_A_x_max = mid_x - 1
        region_A_y_min = 1
        region_A_y_max = self._height - 2
        min_distance = self._params.get("sparse_min_distance", 5)

        sparse_positions = {}
        for obj, symbol in zip(["heart_altar", "generator", "converter"],
                               ["altar", "generator", "converter"]):
            pos = self._sample_position(region_A_x_min, region_A_x_max,
                                        region_A_y_min, region_A_y_max,
                                        min_distance, existing=list(sparse_positions.values()))
            sparse_positions[obj] = pos
            self._grid[pos[1], pos[0]] = symbol
            self._placed_positions.add(pos)

    def _place_dense_region(self, mid_x: int) -> None:
        """
        In the right (dense) region, place one each of:
          - Heart altar ("altar")
          - Generator ("generator")
          - Converter ("converter")
        To ensure all three objects are placed, we first select a cluster center
        in the dense region. Then, we define a small candidate cluster area (by default, a 3×3 square)
        and sample three distinct positions from it (or from the full dense region if necessary),
        ensuring that they do not overlap with existing placements.
        """
        region_B_x_min = mid_x + 1
        region_B_x_max = self._width - 2
        region_B_y_min = 1
        region_B_y_max = self._height - 2

        # Choose a central point for the cluster.
        center_x = int(self._rng.integers(region_B_x_min, region_B_x_max + 1))
        center_y = int(self._rng.integers(region_B_y_min, region_B_y_max + 1))

        # Define a candidate cluster area (3x3 centered on the chosen center)
        cluster_x_min = max(region_B_x_min, center_x - 1)
        cluster_x_max = min(region_B_x_max, center_x + 1)
        cluster_y_min = max(region_B_y_min, center_y - 1)
        cluster_y_max = min(region_B_y_max, center_y + 1)

        cluster_area = [(x, y)
                        for x in range(cluster_x_min, cluster_x_max + 1)
                        for y in range(cluster_y_min, cluster_y_max + 1)]

        # Filter out positions that are already taken.
        available = [pos for pos in cluster_area if pos not in self._placed_positions]

        # If there are fewer than 3 available positions in the cluster area,
        # expand the candidate area to the whole dense region.
        if len(available) < 3:
            cluster_area = [(x, y)
                            for x in range(region_B_x_min, region_B_x_max + 1)
                            for y in range(region_B_y_min, region_B_y_max + 1)]
            available = [pos for pos in cluster_area if pos not in self._placed_positions]

        # If there are still fewer than 3 available positions, simply take all that are available.
        if len(available) < 3:
            chosen = available
        else:
            # Sample three distinct positions.
            available_arr = np.array(available)
            chosen = self._rng.choice(available_arr, size=3, replace=False)
            chosen = [tuple(pos) for pos in chosen]

        # Map objects to be placed.
        objects = ["altar", "generator", "converter"]
        for pos, obj in zip(chosen, objects):
            self._grid[pos[1], pos[0]] = obj
            self._placed_positions.add(pos)

    def _place_agent(self, mid_x: int) -> None:
        """
        Place the agent ("agent.agent") in the sparse region (left half) at a position
        that has not been occupied by another object.
        """
        region_A_x_min = 1
        region_A_x_max = mid_x - 1
        region_A_y_min = 1
        region_A_y_max = self._height - 2

        for _ in range(100):
            x = int(self._rng.integers(region_A_x_min, region_A_x_max + 1))
            y = int(self._rng.integers(region_A_y_min, region_A_y_max + 1))
            if (x, y) not in self._placed_positions:
                self._grid[y, x] = "agent.agent"
                self._placed_positions.add((x, y))
                return

        # If no free position is found after many tries, default to a corner.
        self._grid[region_A_y_min, region_A_x_min] = "agent.agent"
        self._placed_positions.add((region_A_x_min, region_A_y_min))

    def _sample_position(
        self,
        x_min: int,
        x_max: int,
        y_min: int,
        y_max: int,
        min_distance: int,
        existing: List[Tuple[int, int]]
    ) -> Tuple[int, int]:
        """
        Sample a position (x, y) within the provided bounds that is at least min_distance
        (Manhattan distance) away from all positions in the 'existing' list.
        """
        for _ in range(100):
            x = int(self._rng.integers(x_min, x_max + 1))
            y = int(self._rng.integers(y_min, y_max + 1))
            pos = (x, y)
            if pos in self._placed_positions:
                continue
            if all(abs(x - ex) + abs(y - ey) >= min_distance for ex, ey in existing):
                return pos
        # Fallback: return the minimum coordinate if no valid position is found.
        return (x_min, y_min)
