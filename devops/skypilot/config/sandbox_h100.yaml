resources:
  cloud: aws
  region: us-east-1
  accelerators: "H100:1"
  cpus: 8+
  # image_id is overridden by sandbox.py for A100/H100; keep default here

file_mounts:
  /mnt/s3/softmax-public:
    source: s3://softmax-public
    mode: MOUNT_CACHED
  /mnt/s3/train_dir:
    source: s3://softmax-train-dir
    mode: MOUNT_CACHED

# For A100/H100, we bring our own host image (AMI with R570+) and then
# launch the Docker container explicitly to mirror docker:metta:latest behavior.
setup: |
  set -euo pipefail

  # Ensure Docker is available and running (idempotent)
  if ! command -v docker >/dev/null 2>&1; then
    echo "[SETUP] Installing Docker..."
    # Try apt first (Ubuntu DLAMIs). Ignore failures silently (user images may preinstall Docker).
    if command -v apt-get >/dev/null 2>&1; then
      sudo apt-get update -y || true
      sudo apt-get install -y docker.io || true
      sudo systemctl enable docker || true
    fi
  fi

  if ! systemctl is-active --quiet docker 2>/dev/null; then
    echo "[SETUP] Starting Docker service..."
    sudo systemctl start docker || true
  fi

  # Install NVIDIA Container Toolkit if missing (optional best-effort)
  if ! docker info 2>/dev/null | grep -qi nvidia; then
    echo "[SETUP] NVIDIA Container Toolkit not detected; attempting best-effort install..."
    if command -v apt-get >/dev/null 2>&1; then
      # This follows NVIDIA docs loosely; ignore failures to avoid breaking provisioning.
      distribution=$(. /etc/os-release; echo $ID$VERSION_ID) || true
      curl -fsSL https://nvidia.github.io/libnvidia-container/gpgkey | sudo gpg --dearmor -o /usr/share/keyrings/nvidia-container-toolkit-keyring.gpg || true
      curl -fsSL https://nvidia.github.io/libnvidia-container/$distribution/libnvidia-container.list | \
        sed 's#deb https://#deb [signed-by=/usr/share/keyrings/nvidia-container-toolkit-keyring.gpg] https://#g' | \
        sudo tee /etc/apt/sources.list.d/nvidia-container-toolkit.list >/dev/null || true
      sudo apt-get update -y || true
      sudo apt-get install -y nvidia-container-toolkit || true
      sudo nvidia-ctk runtime configure --runtime=docker || true
      sudo systemctl restart docker || true
    fi
  fi

run: |
  set -euo pipefail

  echo "[RUN] Preparing Docker credentials (if provided by platform)..."
  if [ -n "${SKYPILOT_DOCKER_SERVER:-}" ] && [ -n "${SKYPILOT_DOCKER_USERNAME:-}" ] && [ -n "${SKYPILOT_DOCKER_PASSWORD:-}" ]; then
    echo "$SKYPILOT_DOCKER_PASSWORD" | docker login "$SKYPILOT_DOCKER_SERVER" -u "$SKYPILOT_DOCKER_USERNAME" --password-stdin || true
  else
    echo "[RUN] No SKYPILOT_DOCKER_* creds injected; attempting AWS ECR login..."
    # Ensure AWS CLI is present
    if ! command -v aws >/dev/null 2>&1; then
      if command -v apt-get >/dev/null 2>&1; then
        echo "[RUN] Installing awscli via apt..."
        sudo apt-get update -y || true
        sudo apt-get install -y awscli || true
      fi
    fi
    ECR_SERVER="${SKYPILOT_DOCKER_SERVER:-751442549699.dkr.ecr.us-east-1.amazonaws.com}"
    REGION_FROM_SERVER=$(echo "$ECR_SERVER" | sed -n 's#.*ecr\.\([a-z0-9-]*\)\.amazonaws\.com#\1#p')
    AWS_REGION_EFFECTIVE="${AWS_REGION:-${AWS_DEFAULT_REGION:-${REGION_FROM_SERVER:-us-east-1}}}"
    if command -v aws >/dev/null 2>&1; then
      echo "[RUN] Logging into ECR registry $ECR_SERVER (region=$AWS_REGION_EFFECTIVE)"
      if aws ecr get-login-password --region "$AWS_REGION_EFFECTIVE" | docker login --username AWS --password-stdin "$ECR_SERVER"; then
        echo "[RUN] ECR login successful."
      else
        echo "[RUN] ECR login failed; will rely on existing Docker auth."
      fi
    else
      echo "[RUN] AWS CLI not available; cannot auto-login to ECR."
    fi
  fi

  IMAGE="${SKYPILOT_DOCKER_SERVER:-751442549699.dkr.ecr.us-east-1.amazonaws.com}/metta:latest"
  CONTAINER_NAME="metta"

  echo "[RUN] Ensuring long-lived container '$CONTAINER_NAME' is running..."
  echo "[RUN] Pulling image: $IMAGE"
  if ! docker pull "$IMAGE"; then
    echo "[RUN] Failed to pull $IMAGE; check ECR access and repository name."
    exit 100
  fi
  if ! docker ps -a --format '{{.Names}}' | grep -qx "$CONTAINER_NAME"; then
    echo "[RUN] Creating container $CONTAINER_NAME from $IMAGE"
    docker run -d \
      --name "$CONTAINER_NAME" \
      --gpus all \
      --cap-add=IPC_LOCK \
      --ulimit memlock=-1:-1 \
      --ipc=host \
      --userns=host \
      --restart unless-stopped \
      -p 2222:22 \
      --entrypoint /bin/sh \
      -v /mnt/s3/softmax-public:/mnt/s3/softmax-public \
      -v /mnt/s3/train_dir:/mnt/s3/train_dir \
      -e GITHUB_REPOSITORY="${GITHUB_REPOSITORY:-Metta-AI/metta}" \
      -e METTA_GIT_REF="${METTA_GIT_REF:-main}" \
      -e WANDB_PASSWORD="${WANDB_PASSWORD:-}" \
      -e OBSERVATORY_TOKEN="${OBSERVATORY_TOKEN:-}" \
      -e SKYPILOT_NUM_GPUS_PER_NODE="${SKYPILOT_NUM_GPUS_PER_NODE:-}" \
      -e SKYPILOT_NUM_NODES="${SKYPILOT_NUM_NODES:-}" \
      -e SKYPILOT_NODE_IPS="${SKYPILOT_NODE_IPS:-}" \
      -e SKYPILOT_NODE_RANK="${SKYPILOT_NODE_RANK:-}" \
      "$IMAGE" \
      -c '(/usr/sbin/sshd -D >/var/log/sshd.log 2>&1 &) || true; trap : TERM INT; while :; do sleep 3600; done'

    echo "[RUN] Waiting for container to be running..."
    for i in $(seq 1 30); do
      status=$(docker inspect -f '{{.State.Running}}' "$CONTAINER_NAME" 2>/dev/null || echo false)
      if [ "$status" = "true" ]; then
        break
      fi
      sleep 1
    done
    is_running=$(docker inspect -f '{{.State.Running}}' "$CONTAINER_NAME" 2>/dev/null || echo false)
    if [ "$is_running" != "true" ]; then
      state=$(docker inspect -f '{{.State.Status}}:{{.State.ExitCode}}' "$CONTAINER_NAME" 2>/dev/null || echo unknown)
      echo "[RUN] Container failed to stay running (state=$state). Last logs:"
      docker logs --tail 200 "$CONTAINER_NAME" || true
      exit 101
    fi
  else
    echo "[RUN] Container exists; starting if stopped"
    docker start "$CONTAINER_NAME" >/dev/null
    # Warn if SSH port is not mapped on pre-existing container
    mapped_port=$(docker inspect -f '{{ (index (index .HostConfig.PortBindings \"22/tcp\") 0).HostPort }}' \"$CONTAINER_NAME\" 2>/dev/null || true)
    if [ -z "$mapped_port" ]; then
      echo "[RUN] WARNING: Existing container has no host port mapping for 22/tcp."
      echo "               To enable container SSH, remove the container or recreate with port mapping (-p 2222:22)."
    fi
  fi

  echo "[RUN] Running setup and environment configuration inside container..."
  docker exec -i \
    -e WANDB_PASSWORD="${WANDB_PASSWORD:-}" \
    -e OBSERVATORY_TOKEN="${OBSERVATORY_TOKEN:-}" \
    "$CONTAINER_NAME" bash -lc '
    set -e
    cd /workspace/metta

    # Activate metta venv if present
    if [ -n "$VIRTUAL_ENV" ]; then
      deactivate 2>/dev/null || true
    fi
    if [ -f .venv/bin/activate ]; then
      . .venv/bin/activate
    fi

    # Ensure repo is on the requested ref and install deps/agents
    bash ./devops/skypilot/config/lifecycle/setup.sh

    # Configure runtime env
    bash ./devops/skypilot/config/lifecycle/configure_environment.sh

    METTA_ENV_FILE="$(uv run ./common/src/metta/common/util/constants.py METTA_ENV_FILE)"
    source "$METTA_ENV_FILE"

    echo "Sandbox setup complete. Ready for SSH."
  '

  echo "[RUN] Ensuring OpenSSH server is installed and running inside container..."
  # Install and configure sshd inside the container (idempotent)
  docker exec -i "$CONTAINER_NAME" bash -lc '
    set -euo pipefail
    if ! command -v sshd >/dev/null 2>&1; then
      if command -v apt-get >/dev/null 2>&1; then
        apt-get update -y && apt-get install -y openssh-server
      elif command -v microdnf >/dev/null 2>/dev/null; then
        microdnf install -y openssh-server openssh-clients && microdnf clean all || true
      elif command -v yum >/dev/null 2>&1; then
        yum install -y openssh-server openssh-clients || true
      fi
    fi
    mkdir -p /var/run/sshd
    mkdir -p /root/.ssh
    chmod 700 /root/.ssh
    # Write a fresh sshd_config to ensure predictable settings
    cat >/etc/ssh/sshd_config <<EOF
Port 22
Protocol 2
PermitRootLogin prohibit-password
PasswordAuthentication no
PubkeyAuthentication yes
UsePAM yes
UseDNS no
EOF
    # Harden and enable key-based root login only
    if [ -d /etc/ssh/sshd_config.d ]; then
      printf "%s\\n%s\\n%s\\n%s\\n" \
        "PermitRootLogin prohibit-password" \
        "PasswordAuthentication no" \
        "PubkeyAuthentication yes" \
        "UseDNS no" \
        > /etc/ssh/sshd_config.d/metta.conf
    else
      # Best-effort inline edits
      sed -i "s/^#\\?PasswordAuthentication .*/PasswordAuthentication no/g" /etc/ssh/sshd_config || true
      if grep -q "^PermitRootLogin" /etc/ssh/sshd_config 2>/dev/null; then
        sed -i "s/^PermitRootLogin .*/PermitRootLogin prohibit-password/g" /etc/ssh/sshd_config || true
      else
        echo "PermitRootLogin prohibit-password" >> /etc/ssh/sshd_config
      fi
    fi
    if [ ! -f /etc/ssh/sshd_config.d/metta.conf ]; then
      printf "%s\\n" "PasswordAuthentication no" >> /etc/ssh/sshd_config
    fi
    # Ensure root authorized_keys exists
    mkdir -p /root/.ssh
    touch /root/.ssh/authorized_keys
    chmod 600 /root/.ssh/authorized_keys
  '

  # Copy host authorized_keys into the container's root user for key-based login
  if [ -f "$HOME/.ssh/authorized_keys" ]; then
    echo "[RUN] Installing authorized_keys into container root account"
    cat "$HOME/.ssh/authorized_keys" | docker exec -i "$CONTAINER_NAME" bash -lc 'cat > /root/.ssh/authorized_keys && chmod 600 /root/.ssh/authorized_keys'
  else
    echo "[RUN] WARNING: No $HOME/.ssh/authorized_keys found on host; SSH into container may fail"
  fi

  # Start sshd in the background if not already running
  if ! docker exec -i "$CONTAINER_NAME" bash -lc 'pgrep -x sshd >/dev/null 2>&1'; then
    echo "[RUN] Starting sshd inside container on port 22 (host port 2222)"
    docker exec -d "$CONTAINER_NAME" /usr/sbin/sshd -D || docker exec -d "$CONTAINER_NAME" nohup /usr/sbin/sshd -D >/dev/null 2>&1
    sleep 1
  fi

  # Verify sshd is listening
  docker exec -i "$CONTAINER_NAME" bash -lc 'ss -tlnp 2>/dev/null | grep -E "LISTEN.+:22\\b" || netstat -tlnp 2>/dev/null | grep -E "LISTEN.+:22\\b" || true'

envs:
  GITHUB_REPOSITORY: Metta-AI/metta

  # username and password are acquired automatically by our skypilot-api-server patch, see skypilot-chart/files/ecr.patch
  SKYPILOT_DOCKER_USERNAME: ""
  SKYPILOT_DOCKER_PASSWORD: ""
  SKYPILOT_DOCKER_SERVER: 751442549699.dkr.ecr.us-east-1.amazonaws.com

secrets:
  # configured by launch script based on local credentials
  WANDB_PASSWORD: ""
  OBSERVATORY_TOKEN: ""
