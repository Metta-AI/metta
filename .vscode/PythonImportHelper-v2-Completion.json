[
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "# using this to get Postponed Evaluation of Annotations -- https://www.python.org/dev/peps/pep-0563/",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "RunningMeanStdInPlace",
        "importPath": "sample_factory.algo.utils.running_mean_std",
        "description": "sample_factory.algo.utils.running_mean_std",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.running_mean_std",
        "documentation": {}
    },
    {
        "label": "RunningMeanStdInPlace",
        "importPath": "sample_factory.algo.utils.running_mean_std",
        "description": "sample_factory.algo.utils.running_mean_std",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.running_mean_std",
        "documentation": {}
    },
    {
        "label": "running_mean_std_summaries",
        "importPath": "sample_factory.algo.utils.running_mean_std",
        "description": "sample_factory.algo.utils.running_mean_std",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.running_mean_std",
        "documentation": {}
    },
    {
        "label": "RunningMeanStdDictInPlace",
        "importPath": "sample_factory.algo.utils.running_mean_std",
        "description": "sample_factory.algo.utils.running_mean_std",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.running_mean_std",
        "documentation": {}
    },
    {
        "label": "running_mean_std_summaries",
        "importPath": "sample_factory.algo.utils.running_mean_std",
        "description": "sample_factory.algo.utils.running_mean_std",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.running_mean_std",
        "documentation": {}
    },
    {
        "label": "RunningMeanStdInPlace",
        "importPath": "sample_factory.algo.utils.running_mean_std",
        "description": "sample_factory.algo.utils.running_mean_std",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.running_mean_std",
        "documentation": {}
    },
    {
        "label": "torch",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "torch",
        "description": "torch",
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "nn",
        "importPath": "torch",
        "description": "torch",
        "isExtraImport": true,
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "nn",
        "importPath": "torch",
        "description": "torch",
        "isExtraImport": true,
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "Tensor",
        "importPath": "torch",
        "description": "torch",
        "isExtraImport": true,
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "Tensor",
        "importPath": "torch",
        "description": "torch",
        "isExtraImport": true,
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "nn",
        "importPath": "torch",
        "description": "torch",
        "isExtraImport": true,
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "Tensor",
        "importPath": "torch",
        "description": "torch",
        "isExtraImport": true,
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "Tensor",
        "importPath": "torch",
        "description": "torch",
        "isExtraImport": true,
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "nn",
        "importPath": "torch",
        "description": "torch",
        "isExtraImport": true,
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "Tensor",
        "importPath": "torch",
        "description": "torch",
        "isExtraImport": true,
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "Tensor",
        "importPath": "torch",
        "description": "torch",
        "isExtraImport": true,
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "Tensor",
        "importPath": "torch",
        "description": "torch",
        "isExtraImport": true,
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "nn",
        "importPath": "torch",
        "description": "torch",
        "isExtraImport": true,
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "nn",
        "importPath": "torch",
        "description": "torch",
        "isExtraImport": true,
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "nn",
        "importPath": "torch",
        "description": "torch",
        "isExtraImport": true,
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "nn",
        "importPath": "torch",
        "description": "torch",
        "isExtraImport": true,
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "nn",
        "importPath": "torch",
        "description": "torch",
        "isExtraImport": true,
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "nn",
        "importPath": "torch",
        "description": "torch",
        "isExtraImport": true,
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "nn",
        "importPath": "torch",
        "description": "torch",
        "isExtraImport": true,
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "nn",
        "importPath": "torch",
        "description": "torch",
        "isExtraImport": true,
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "Tensor",
        "importPath": "torch",
        "description": "torch",
        "isExtraImport": true,
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "Tensor",
        "importPath": "torch",
        "description": "torch",
        "isExtraImport": true,
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "Tensor",
        "importPath": "torch",
        "description": "torch",
        "isExtraImport": true,
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "Tensor",
        "importPath": "torch",
        "description": "torch",
        "isExtraImport": true,
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "Tensor",
        "importPath": "torch",
        "description": "torch",
        "isExtraImport": true,
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "Tensor",
        "importPath": "torch",
        "description": "torch",
        "isExtraImport": true,
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "Tensor",
        "importPath": "torch",
        "description": "torch",
        "isExtraImport": true,
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "Tensor",
        "importPath": "torch",
        "description": "torch",
        "isExtraImport": true,
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "Tensor",
        "importPath": "torch",
        "description": "torch",
        "isExtraImport": true,
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "Tensor",
        "importPath": "torch",
        "description": "torch",
        "isExtraImport": true,
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "Tensor",
        "importPath": "torch",
        "description": "torch",
        "isExtraImport": true,
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "Tensor",
        "importPath": "torch",
        "description": "torch",
        "isExtraImport": true,
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "Tensor",
        "importPath": "torch",
        "description": "torch",
        "isExtraImport": true,
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "nn",
        "importPath": "torch",
        "description": "torch",
        "isExtraImport": true,
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "Tensor",
        "importPath": "torch",
        "description": "torch",
        "isExtraImport": true,
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "nn",
        "importPath": "torch",
        "description": "torch",
        "isExtraImport": true,
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "nn",
        "importPath": "torch",
        "description": "torch",
        "isExtraImport": true,
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "Tensor",
        "importPath": "torch",
        "description": "torch",
        "isExtraImport": true,
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "nn",
        "importPath": "torch",
        "description": "torch",
        "isExtraImport": true,
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "nn",
        "importPath": "torch",
        "description": "torch",
        "isExtraImport": true,
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "nn",
        "importPath": "torch",
        "description": "torch",
        "isExtraImport": true,
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "Tensor",
        "importPath": "torch",
        "description": "torch",
        "isExtraImport": true,
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "numel",
        "importPath": "torch",
        "description": "torch",
        "isExtraImport": true,
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "Tensor",
        "importPath": "torch",
        "description": "torch",
        "isExtraImport": true,
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "nn",
        "importPath": "torch",
        "description": "torch",
        "isExtraImport": true,
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "Tensor",
        "importPath": "torch",
        "description": "torch",
        "isExtraImport": true,
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "nn",
        "importPath": "torch",
        "description": "torch",
        "isExtraImport": true,
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "nn",
        "importPath": "torch",
        "description": "torch",
        "isExtraImport": true,
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "nn",
        "importPath": "torch",
        "description": "torch",
        "isExtraImport": true,
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "Tensor",
        "importPath": "torch",
        "description": "torch",
        "isExtraImport": true,
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "nn",
        "importPath": "torch",
        "description": "torch",
        "isExtraImport": true,
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "nn",
        "importPath": "torch",
        "description": "torch",
        "isExtraImport": true,
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "math",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "math",
        "description": "math",
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "tanh",
        "importPath": "math",
        "description": "math",
        "isExtraImport": true,
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "ceil",
        "importPath": "math",
        "description": "math",
        "isExtraImport": true,
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "floor",
        "importPath": "math",
        "description": "math",
        "isExtraImport": true,
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "log",
        "importPath": "math",
        "description": "math",
        "isExtraImport": true,
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "hashlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "hashlib",
        "description": "hashlib",
        "detail": "hashlib",
        "documentation": {}
    },
    {
        "label": "numpy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "numpy",
        "description": "numpy",
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "typing",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "typing",
        "description": "typing",
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "ContextManager",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Set",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Type",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypeVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Sized",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Deque",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Final",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "SupportsFloat",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "OrderedDict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Deque",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "SupportsFloat",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Deque",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "NamedTuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TensorDict",
        "importPath": "tensordict",
        "description": "tensordict",
        "isExtraImport": true,
        "detail": "tensordict",
        "documentation": {}
    },
    {
        "label": "TensorDict",
        "importPath": "tensordict",
        "description": "tensordict",
        "isExtraImport": true,
        "detail": "tensordict",
        "documentation": {}
    },
    {
        "label": "TensorDict",
        "importPath": "tensordict",
        "description": "tensordict",
        "isExtraImport": true,
        "detail": "tensordict",
        "documentation": {}
    },
    {
        "label": "MlpDecoder",
        "importPath": "sample_factory.model.decoder",
        "description": "sample_factory.model.decoder",
        "isExtraImport": true,
        "detail": "sample_factory.model.decoder",
        "documentation": {}
    },
    {
        "label": "Decoder",
        "importPath": "sample_factory.model.decoder",
        "description": "sample_factory.model.decoder",
        "isExtraImport": true,
        "detail": "sample_factory.model.decoder",
        "documentation": {}
    },
    {
        "label": "default_make_decoder_func",
        "importPath": "sample_factory.model.decoder",
        "description": "sample_factory.model.decoder",
        "isExtraImport": true,
        "detail": "sample_factory.model.decoder",
        "documentation": {}
    },
    {
        "label": "AttrDict",
        "importPath": "sample_factory.utils.attr_dict",
        "description": "sample_factory.utils.attr_dict",
        "isExtraImport": true,
        "detail": "sample_factory.utils.attr_dict",
        "documentation": {}
    },
    {
        "label": "AttrDict",
        "importPath": "sample_factory.utils.attr_dict",
        "description": "sample_factory.utils.attr_dict",
        "isExtraImport": true,
        "detail": "sample_factory.utils.attr_dict",
        "documentation": {}
    },
    {
        "label": "AttrDict",
        "importPath": "sample_factory.utils.attr_dict",
        "description": "sample_factory.utils.attr_dict",
        "isExtraImport": true,
        "detail": "sample_factory.utils.attr_dict",
        "documentation": {}
    },
    {
        "label": "AttrDict",
        "importPath": "sample_factory.utils.attr_dict",
        "description": "sample_factory.utils.attr_dict",
        "isExtraImport": true,
        "detail": "sample_factory.utils.attr_dict",
        "documentation": {}
    },
    {
        "label": "AttrDict",
        "importPath": "sample_factory.utils.attr_dict",
        "description": "sample_factory.utils.attr_dict",
        "isExtraImport": true,
        "detail": "sample_factory.utils.attr_dict",
        "documentation": {}
    },
    {
        "label": "AttrDict",
        "importPath": "sample_factory.utils.attr_dict",
        "description": "sample_factory.utils.attr_dict",
        "isExtraImport": true,
        "detail": "sample_factory.utils.attr_dict",
        "documentation": {}
    },
    {
        "label": "AttrDict",
        "importPath": "sample_factory.utils.attr_dict",
        "description": "sample_factory.utils.attr_dict",
        "isExtraImport": true,
        "detail": "sample_factory.utils.attr_dict",
        "documentation": {}
    },
    {
        "label": "AttrDict",
        "importPath": "sample_factory.utils.attr_dict",
        "description": "sample_factory.utils.attr_dict",
        "isExtraImport": true,
        "detail": "sample_factory.utils.attr_dict",
        "documentation": {}
    },
    {
        "label": "AttrDict",
        "importPath": "sample_factory.utils.attr_dict",
        "description": "sample_factory.utils.attr_dict",
        "isExtraImport": true,
        "detail": "sample_factory.utils.attr_dict",
        "documentation": {}
    },
    {
        "label": "AttrDict",
        "importPath": "sample_factory.utils.attr_dict",
        "description": "sample_factory.utils.attr_dict",
        "isExtraImport": true,
        "detail": "sample_factory.utils.attr_dict",
        "documentation": {}
    },
    {
        "label": "AttrDict",
        "importPath": "sample_factory.utils.attr_dict",
        "description": "sample_factory.utils.attr_dict",
        "isExtraImport": true,
        "detail": "sample_factory.utils.attr_dict",
        "documentation": {}
    },
    {
        "label": "AttrDict",
        "importPath": "sample_factory.utils.attr_dict",
        "description": "sample_factory.utils.attr_dict",
        "isExtraImport": true,
        "detail": "sample_factory.utils.attr_dict",
        "documentation": {}
    },
    {
        "label": "AttrDict",
        "importPath": "sample_factory.utils.attr_dict",
        "description": "sample_factory.utils.attr_dict",
        "isExtraImport": true,
        "detail": "sample_factory.utils.attr_dict",
        "documentation": {}
    },
    {
        "label": "AttrDict",
        "importPath": "sample_factory.utils.attr_dict",
        "description": "sample_factory.utils.attr_dict",
        "isExtraImport": true,
        "detail": "sample_factory.utils.attr_dict",
        "documentation": {}
    },
    {
        "label": "AttrDict",
        "importPath": "sample_factory.utils.attr_dict",
        "description": "sample_factory.utils.attr_dict",
        "isExtraImport": true,
        "detail": "sample_factory.utils.attr_dict",
        "documentation": {}
    },
    {
        "label": "AttrDict",
        "importPath": "sample_factory.utils.attr_dict",
        "description": "sample_factory.utils.attr_dict",
        "isExtraImport": true,
        "detail": "sample_factory.utils.attr_dict",
        "documentation": {}
    },
    {
        "label": "AttrDict",
        "importPath": "sample_factory.utils.attr_dict",
        "description": "sample_factory.utils.attr_dict",
        "isExtraImport": true,
        "detail": "sample_factory.utils.attr_dict",
        "documentation": {}
    },
    {
        "label": "AttrDict",
        "importPath": "sample_factory.utils.attr_dict",
        "description": "sample_factory.utils.attr_dict",
        "isExtraImport": true,
        "detail": "sample_factory.utils.attr_dict",
        "documentation": {}
    },
    {
        "label": "AttrDict",
        "importPath": "sample_factory.utils.attr_dict",
        "description": "sample_factory.utils.attr_dict",
        "isExtraImport": true,
        "detail": "sample_factory.utils.attr_dict",
        "documentation": {}
    },
    {
        "label": "AttrDict",
        "importPath": "sample_factory.utils.attr_dict",
        "description": "sample_factory.utils.attr_dict",
        "isExtraImport": true,
        "detail": "sample_factory.utils.attr_dict",
        "documentation": {}
    },
    {
        "label": "FeatureListNormalizer",
        "importPath": "agent.lib.normalizer",
        "description": "agent.lib.normalizer",
        "isExtraImport": true,
        "detail": "agent.lib.normalizer",
        "documentation": {}
    },
    {
        "label": "hydra",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "hydra",
        "description": "hydra",
        "detail": "hydra",
        "documentation": {}
    },
    {
        "label": "initialize",
        "importPath": "hydra",
        "description": "hydra",
        "isExtraImport": true,
        "detail": "hydra",
        "documentation": {}
    },
    {
        "label": "compose",
        "importPath": "hydra",
        "description": "hydra",
        "isExtraImport": true,
        "detail": "hydra",
        "documentation": {}
    },
    {
        "label": "OmegaConf",
        "importPath": "omegaconf",
        "description": "omegaconf",
        "isExtraImport": true,
        "detail": "omegaconf",
        "documentation": {}
    },
    {
        "label": "OmegaConf",
        "importPath": "omegaconf",
        "description": "omegaconf",
        "isExtraImport": true,
        "detail": "omegaconf",
        "documentation": {}
    },
    {
        "label": "DictConfig",
        "importPath": "omegaconf",
        "description": "omegaconf",
        "isExtraImport": true,
        "detail": "omegaconf",
        "documentation": {}
    },
    {
        "label": "ListConfig",
        "importPath": "omegaconf",
        "description": "omegaconf",
        "isExtraImport": true,
        "detail": "omegaconf",
        "documentation": {}
    },
    {
        "label": "OmegaConf",
        "importPath": "omegaconf",
        "description": "omegaconf",
        "isExtraImport": true,
        "detail": "omegaconf",
        "documentation": {}
    },
    {
        "label": "OmegaConf",
        "importPath": "omegaconf",
        "description": "omegaconf",
        "isExtraImport": true,
        "detail": "omegaconf",
        "documentation": {}
    },
    {
        "label": "DictConfig",
        "importPath": "omegaconf",
        "description": "omegaconf",
        "isExtraImport": true,
        "detail": "omegaconf",
        "documentation": {}
    },
    {
        "label": "OmegaConf",
        "importPath": "omegaconf",
        "description": "omegaconf",
        "isExtraImport": true,
        "detail": "omegaconf",
        "documentation": {}
    },
    {
        "label": "OmegaConf",
        "importPath": "omegaconf",
        "description": "omegaconf",
        "isExtraImport": true,
        "detail": "omegaconf",
        "documentation": {}
    },
    {
        "label": "OmegaConf",
        "importPath": "omegaconf",
        "description": "omegaconf",
        "isExtraImport": true,
        "detail": "omegaconf",
        "documentation": {}
    },
    {
        "label": "OmegaConf",
        "importPath": "omegaconf",
        "description": "omegaconf",
        "isExtraImport": true,
        "detail": "omegaconf",
        "documentation": {}
    },
    {
        "label": "OmegaConf",
        "importPath": "omegaconf",
        "description": "omegaconf",
        "isExtraImport": true,
        "detail": "omegaconf",
        "documentation": {}
    },
    {
        "label": "OmegaConf",
        "importPath": "omegaconf",
        "description": "omegaconf",
        "isExtraImport": true,
        "detail": "omegaconf",
        "documentation": {}
    },
    {
        "label": "OmegaConf",
        "importPath": "omegaconf",
        "description": "omegaconf",
        "isExtraImport": true,
        "detail": "omegaconf",
        "documentation": {}
    },
    {
        "label": "OmegaConf",
        "importPath": "omegaconf",
        "description": "omegaconf",
        "isExtraImport": true,
        "detail": "omegaconf",
        "documentation": {}
    },
    {
        "label": "OmegaConf",
        "importPath": "omegaconf",
        "description": "omegaconf",
        "isExtraImport": true,
        "detail": "omegaconf",
        "documentation": {}
    },
    {
        "label": "OmegaConf",
        "importPath": "omegaconf",
        "description": "omegaconf",
        "isExtraImport": true,
        "detail": "omegaconf",
        "documentation": {}
    },
    {
        "label": "OmegaConf",
        "importPath": "omegaconf",
        "description": "omegaconf",
        "isExtraImport": true,
        "detail": "omegaconf",
        "documentation": {}
    },
    {
        "label": "OmegaConf",
        "importPath": "omegaconf",
        "description": "omegaconf",
        "isExtraImport": true,
        "detail": "omegaconf",
        "documentation": {}
    },
    {
        "label": "DictConfig",
        "importPath": "omegaconf",
        "description": "omegaconf",
        "isExtraImport": true,
        "detail": "omegaconf",
        "documentation": {}
    },
    {
        "label": "ListConfig",
        "importPath": "omegaconf",
        "description": "omegaconf",
        "isExtraImport": true,
        "detail": "omegaconf",
        "documentation": {}
    },
    {
        "label": "OmegaConf",
        "importPath": "omegaconf",
        "description": "omegaconf",
        "isExtraImport": true,
        "detail": "omegaconf",
        "documentation": {}
    },
    {
        "label": "ActionParameterizationDefault",
        "importPath": "sample_factory.model.action_parameterization",
        "description": "sample_factory.model.action_parameterization",
        "isExtraImport": true,
        "detail": "sample_factory.model.action_parameterization",
        "documentation": {}
    },
    {
        "label": "ActionParameterizationContinuousNonAdaptiveStddev",
        "importPath": "sample_factory.model.action_parameterization",
        "description": "sample_factory.model.action_parameterization",
        "isExtraImport": true,
        "detail": "sample_factory.model.action_parameterization",
        "documentation": {}
    },
    {
        "label": "ActionParameterizationDefault",
        "importPath": "sample_factory.model.action_parameterization",
        "description": "sample_factory.model.action_parameterization",
        "isExtraImport": true,
        "detail": "sample_factory.model.action_parameterization",
        "documentation": {}
    },
    {
        "label": "ModelCoreRNN",
        "importPath": "sample_factory.model.core",
        "description": "sample_factory.model.core",
        "isExtraImport": true,
        "detail": "sample_factory.model.core",
        "documentation": {}
    },
    {
        "label": "ModelCore",
        "importPath": "sample_factory.model.core",
        "description": "sample_factory.model.core",
        "isExtraImport": true,
        "detail": "sample_factory.model.core",
        "documentation": {}
    },
    {
        "label": "default_make_core_func",
        "importPath": "sample_factory.model.core",
        "description": "sample_factory.model.core",
        "isExtraImport": true,
        "detail": "sample_factory.model.core",
        "documentation": {}
    },
    {
        "label": "ActionSpace",
        "importPath": "sample_factory.utils.typing",
        "description": "sample_factory.utils.typing",
        "isExtraImport": true,
        "detail": "sample_factory.utils.typing",
        "documentation": {}
    },
    {
        "label": "ObsSpace",
        "importPath": "sample_factory.utils.typing",
        "description": "sample_factory.utils.typing",
        "isExtraImport": true,
        "detail": "sample_factory.utils.typing",
        "documentation": {}
    },
    {
        "label": "Device",
        "importPath": "sample_factory.utils.typing",
        "description": "sample_factory.utils.typing",
        "isExtraImport": true,
        "detail": "sample_factory.utils.typing",
        "documentation": {}
    },
    {
        "label": "PolicyID",
        "importPath": "sample_factory.utils.typing",
        "description": "sample_factory.utils.typing",
        "isExtraImport": true,
        "detail": "sample_factory.utils.typing",
        "documentation": {}
    },
    {
        "label": "ActionDistribution",
        "importPath": "sample_factory.utils.typing",
        "description": "sample_factory.utils.typing",
        "isExtraImport": true,
        "detail": "sample_factory.utils.typing",
        "documentation": {}
    },
    {
        "label": "Config",
        "importPath": "sample_factory.utils.typing",
        "description": "sample_factory.utils.typing",
        "isExtraImport": true,
        "detail": "sample_factory.utils.typing",
        "documentation": {}
    },
    {
        "label": "InitModelData",
        "importPath": "sample_factory.utils.typing",
        "description": "sample_factory.utils.typing",
        "isExtraImport": true,
        "detail": "sample_factory.utils.typing",
        "documentation": {}
    },
    {
        "label": "PolicyID",
        "importPath": "sample_factory.utils.typing",
        "description": "sample_factory.utils.typing",
        "isExtraImport": true,
        "detail": "sample_factory.utils.typing",
        "documentation": {}
    },
    {
        "label": "Config",
        "importPath": "sample_factory.utils.typing",
        "description": "sample_factory.utils.typing",
        "isExtraImport": true,
        "detail": "sample_factory.utils.typing",
        "documentation": {}
    },
    {
        "label": "PolicyID",
        "importPath": "sample_factory.utils.typing",
        "description": "sample_factory.utils.typing",
        "isExtraImport": true,
        "detail": "sample_factory.utils.typing",
        "documentation": {}
    },
    {
        "label": "PolicyID",
        "importPath": "sample_factory.utils.typing",
        "description": "sample_factory.utils.typing",
        "isExtraImport": true,
        "detail": "sample_factory.utils.typing",
        "documentation": {}
    },
    {
        "label": "StatusCode",
        "importPath": "sample_factory.utils.typing",
        "description": "sample_factory.utils.typing",
        "isExtraImport": true,
        "detail": "sample_factory.utils.typing",
        "documentation": {}
    },
    {
        "label": "StatusCode",
        "importPath": "sample_factory.utils.typing",
        "description": "sample_factory.utils.typing",
        "isExtraImport": true,
        "detail": "sample_factory.utils.typing",
        "documentation": {}
    },
    {
        "label": "StatusCode",
        "importPath": "sample_factory.utils.typing",
        "description": "sample_factory.utils.typing",
        "isExtraImport": true,
        "detail": "sample_factory.utils.typing",
        "documentation": {}
    },
    {
        "label": "PolicyID",
        "importPath": "sample_factory.utils.typing",
        "description": "sample_factory.utils.typing",
        "isExtraImport": true,
        "detail": "sample_factory.utils.typing",
        "documentation": {}
    },
    {
        "label": "Config",
        "importPath": "sample_factory.utils.typing",
        "description": "sample_factory.utils.typing",
        "isExtraImport": true,
        "detail": "sample_factory.utils.typing",
        "documentation": {}
    },
    {
        "label": "InitModelData",
        "importPath": "sample_factory.utils.typing",
        "description": "sample_factory.utils.typing",
        "isExtraImport": true,
        "detail": "sample_factory.utils.typing",
        "documentation": {}
    },
    {
        "label": "PolicyID",
        "importPath": "sample_factory.utils.typing",
        "description": "sample_factory.utils.typing",
        "isExtraImport": true,
        "detail": "sample_factory.utils.typing",
        "documentation": {}
    },
    {
        "label": "StatusCode",
        "importPath": "sample_factory.utils.typing",
        "description": "sample_factory.utils.typing",
        "isExtraImport": true,
        "detail": "sample_factory.utils.typing",
        "documentation": {}
    },
    {
        "label": "Device",
        "importPath": "sample_factory.utils.typing",
        "description": "sample_factory.utils.typing",
        "isExtraImport": true,
        "detail": "sample_factory.utils.typing",
        "documentation": {}
    },
    {
        "label": "InitModelData",
        "importPath": "sample_factory.utils.typing",
        "description": "sample_factory.utils.typing",
        "isExtraImport": true,
        "detail": "sample_factory.utils.typing",
        "documentation": {}
    },
    {
        "label": "MpQueue",
        "importPath": "sample_factory.utils.typing",
        "description": "sample_factory.utils.typing",
        "isExtraImport": true,
        "detail": "sample_factory.utils.typing",
        "documentation": {}
    },
    {
        "label": "PolicyID",
        "importPath": "sample_factory.utils.typing",
        "description": "sample_factory.utils.typing",
        "isExtraImport": true,
        "detail": "sample_factory.utils.typing",
        "documentation": {}
    },
    {
        "label": "Config",
        "importPath": "sample_factory.utils.typing",
        "description": "sample_factory.utils.typing",
        "isExtraImport": true,
        "detail": "sample_factory.utils.typing",
        "documentation": {}
    },
    {
        "label": "MpQueue",
        "importPath": "sample_factory.utils.typing",
        "description": "sample_factory.utils.typing",
        "isExtraImport": true,
        "detail": "sample_factory.utils.typing",
        "documentation": {}
    },
    {
        "label": "PolicyID",
        "importPath": "sample_factory.utils.typing",
        "description": "sample_factory.utils.typing",
        "isExtraImport": true,
        "detail": "sample_factory.utils.typing",
        "documentation": {}
    },
    {
        "label": "MpQueue",
        "importPath": "sample_factory.utils.typing",
        "description": "sample_factory.utils.typing",
        "isExtraImport": true,
        "detail": "sample_factory.utils.typing",
        "documentation": {}
    },
    {
        "label": "PolicyID",
        "importPath": "sample_factory.utils.typing",
        "description": "sample_factory.utils.typing",
        "isExtraImport": true,
        "detail": "sample_factory.utils.typing",
        "documentation": {}
    },
    {
        "label": "Config",
        "importPath": "sample_factory.utils.typing",
        "description": "sample_factory.utils.typing",
        "isExtraImport": true,
        "detail": "sample_factory.utils.typing",
        "documentation": {}
    },
    {
        "label": "MpQueue",
        "importPath": "sample_factory.utils.typing",
        "description": "sample_factory.utils.typing",
        "isExtraImport": true,
        "detail": "sample_factory.utils.typing",
        "documentation": {}
    },
    {
        "label": "PolicyID",
        "importPath": "sample_factory.utils.typing",
        "description": "sample_factory.utils.typing",
        "isExtraImport": true,
        "detail": "sample_factory.utils.typing",
        "documentation": {}
    },
    {
        "label": "PolicyID",
        "importPath": "sample_factory.utils.typing",
        "description": "sample_factory.utils.typing",
        "isExtraImport": true,
        "detail": "sample_factory.utils.typing",
        "documentation": {}
    },
    {
        "label": "PolicyID",
        "importPath": "sample_factory.utils.typing",
        "description": "sample_factory.utils.typing",
        "isExtraImport": true,
        "detail": "sample_factory.utils.typing",
        "documentation": {}
    },
    {
        "label": "Config",
        "importPath": "sample_factory.utils.typing",
        "description": "sample_factory.utils.typing",
        "isExtraImport": true,
        "detail": "sample_factory.utils.typing",
        "documentation": {}
    },
    {
        "label": "InitModelData",
        "importPath": "sample_factory.utils.typing",
        "description": "sample_factory.utils.typing",
        "isExtraImport": true,
        "detail": "sample_factory.utils.typing",
        "documentation": {}
    },
    {
        "label": "PolicyID",
        "importPath": "sample_factory.utils.typing",
        "description": "sample_factory.utils.typing",
        "isExtraImport": true,
        "detail": "sample_factory.utils.typing",
        "documentation": {}
    },
    {
        "label": "StatusCode",
        "importPath": "sample_factory.utils.typing",
        "description": "sample_factory.utils.typing",
        "isExtraImport": true,
        "detail": "sample_factory.utils.typing",
        "documentation": {}
    },
    {
        "label": "ActionSpace",
        "importPath": "sample_factory.utils.typing",
        "description": "sample_factory.utils.typing",
        "isExtraImport": true,
        "detail": "sample_factory.utils.typing",
        "documentation": {}
    },
    {
        "label": "Config",
        "importPath": "sample_factory.utils.typing",
        "description": "sample_factory.utils.typing",
        "isExtraImport": true,
        "detail": "sample_factory.utils.typing",
        "documentation": {}
    },
    {
        "label": "CreateEnvFunc",
        "importPath": "sample_factory.utils.typing",
        "description": "sample_factory.utils.typing",
        "isExtraImport": true,
        "detail": "sample_factory.utils.typing",
        "documentation": {}
    },
    {
        "label": "Config",
        "importPath": "sample_factory.utils.typing",
        "description": "sample_factory.utils.typing",
        "isExtraImport": true,
        "detail": "sample_factory.utils.typing",
        "documentation": {}
    },
    {
        "label": "Config",
        "importPath": "sample_factory.utils.typing",
        "description": "sample_factory.utils.typing",
        "isExtraImport": true,
        "detail": "sample_factory.utils.typing",
        "documentation": {}
    },
    {
        "label": "PolicyID",
        "importPath": "sample_factory.utils.typing",
        "description": "sample_factory.utils.typing",
        "isExtraImport": true,
        "detail": "sample_factory.utils.typing",
        "documentation": {}
    },
    {
        "label": "Config",
        "importPath": "sample_factory.utils.typing",
        "description": "sample_factory.utils.typing",
        "isExtraImport": true,
        "detail": "sample_factory.utils.typing",
        "documentation": {}
    },
    {
        "label": "Device",
        "importPath": "sample_factory.utils.typing",
        "description": "sample_factory.utils.typing",
        "isExtraImport": true,
        "detail": "sample_factory.utils.typing",
        "documentation": {}
    },
    {
        "label": "MpQueue",
        "importPath": "sample_factory.utils.typing",
        "description": "sample_factory.utils.typing",
        "isExtraImport": true,
        "detail": "sample_factory.utils.typing",
        "documentation": {}
    },
    {
        "label": "PolicyID",
        "importPath": "sample_factory.utils.typing",
        "description": "sample_factory.utils.typing",
        "isExtraImport": true,
        "detail": "sample_factory.utils.typing",
        "documentation": {}
    },
    {
        "label": "Config",
        "importPath": "sample_factory.utils.typing",
        "description": "sample_factory.utils.typing",
        "isExtraImport": true,
        "detail": "sample_factory.utils.typing",
        "documentation": {}
    },
    {
        "label": "Config",
        "importPath": "sample_factory.utils.typing",
        "description": "sample_factory.utils.typing",
        "isExtraImport": true,
        "detail": "sample_factory.utils.typing",
        "documentation": {}
    },
    {
        "label": "Config",
        "importPath": "sample_factory.utils.typing",
        "description": "sample_factory.utils.typing",
        "isExtraImport": true,
        "detail": "sample_factory.utils.typing",
        "documentation": {}
    },
    {
        "label": "CreateEnvFunc",
        "importPath": "sample_factory.utils.typing",
        "description": "sample_factory.utils.typing",
        "isExtraImport": true,
        "detail": "sample_factory.utils.typing",
        "documentation": {}
    },
    {
        "label": "Config",
        "importPath": "sample_factory.utils.typing",
        "description": "sample_factory.utils.typing",
        "isExtraImport": true,
        "detail": "sample_factory.utils.typing",
        "documentation": {}
    },
    {
        "label": "Config",
        "importPath": "sample_factory.utils.typing",
        "description": "sample_factory.utils.typing",
        "isExtraImport": true,
        "detail": "sample_factory.utils.typing",
        "documentation": {}
    },
    {
        "label": "ActionSpace",
        "importPath": "sample_factory.utils.typing",
        "description": "sample_factory.utils.typing",
        "isExtraImport": true,
        "detail": "sample_factory.utils.typing",
        "documentation": {}
    },
    {
        "label": "Config",
        "importPath": "sample_factory.utils.typing",
        "description": "sample_factory.utils.typing",
        "isExtraImport": true,
        "detail": "sample_factory.utils.typing",
        "documentation": {}
    },
    {
        "label": "ObsSpace",
        "importPath": "sample_factory.utils.typing",
        "description": "sample_factory.utils.typing",
        "isExtraImport": true,
        "detail": "sample_factory.utils.typing",
        "documentation": {}
    },
    {
        "label": "Config",
        "importPath": "sample_factory.utils.typing",
        "description": "sample_factory.utils.typing",
        "isExtraImport": true,
        "detail": "sample_factory.utils.typing",
        "documentation": {}
    },
    {
        "label": "Config",
        "importPath": "sample_factory.utils.typing",
        "description": "sample_factory.utils.typing",
        "isExtraImport": true,
        "detail": "sample_factory.utils.typing",
        "documentation": {}
    },
    {
        "label": "Config",
        "importPath": "sample_factory.utils.typing",
        "description": "sample_factory.utils.typing",
        "isExtraImport": true,
        "detail": "sample_factory.utils.typing",
        "documentation": {}
    },
    {
        "label": "ObsSpace",
        "importPath": "sample_factory.utils.typing",
        "description": "sample_factory.utils.typing",
        "isExtraImport": true,
        "detail": "sample_factory.utils.typing",
        "documentation": {}
    },
    {
        "label": "ActionSpace",
        "importPath": "sample_factory.utils.typing",
        "description": "sample_factory.utils.typing",
        "isExtraImport": true,
        "detail": "sample_factory.utils.typing",
        "documentation": {}
    },
    {
        "label": "Config",
        "importPath": "sample_factory.utils.typing",
        "description": "sample_factory.utils.typing",
        "isExtraImport": true,
        "detail": "sample_factory.utils.typing",
        "documentation": {}
    },
    {
        "label": "ObsSpace",
        "importPath": "sample_factory.utils.typing",
        "description": "sample_factory.utils.typing",
        "isExtraImport": true,
        "detail": "sample_factory.utils.typing",
        "documentation": {}
    },
    {
        "label": "Config",
        "importPath": "sample_factory.utils.typing",
        "description": "sample_factory.utils.typing",
        "isExtraImport": true,
        "detail": "sample_factory.utils.typing",
        "documentation": {}
    },
    {
        "label": "Config",
        "importPath": "sample_factory.utils.typing",
        "description": "sample_factory.utils.typing",
        "isExtraImport": true,
        "detail": "sample_factory.utils.typing",
        "documentation": {}
    },
    {
        "label": "PolicyID",
        "importPath": "sample_factory.utils.typing",
        "description": "sample_factory.utils.typing",
        "isExtraImport": true,
        "detail": "sample_factory.utils.typing",
        "documentation": {}
    },
    {
        "label": "Config",
        "importPath": "sample_factory.utils.typing",
        "description": "sample_factory.utils.typing",
        "isExtraImport": true,
        "detail": "sample_factory.utils.typing",
        "documentation": {}
    },
    {
        "label": "Config",
        "importPath": "sample_factory.utils.typing",
        "description": "sample_factory.utils.typing",
        "isExtraImport": true,
        "detail": "sample_factory.utils.typing",
        "documentation": {}
    },
    {
        "label": "StatusCode",
        "importPath": "sample_factory.utils.typing",
        "description": "sample_factory.utils.typing",
        "isExtraImport": true,
        "detail": "sample_factory.utils.typing",
        "documentation": {}
    },
    {
        "label": "Config",
        "importPath": "sample_factory.utils.typing",
        "description": "sample_factory.utils.typing",
        "isExtraImport": true,
        "detail": "sample_factory.utils.typing",
        "documentation": {}
    },
    {
        "label": "Config",
        "importPath": "sample_factory.utils.typing",
        "description": "sample_factory.utils.typing",
        "isExtraImport": true,
        "detail": "sample_factory.utils.typing",
        "documentation": {}
    },
    {
        "label": "Config",
        "importPath": "sample_factory.utils.typing",
        "description": "sample_factory.utils.typing",
        "isExtraImport": true,
        "detail": "sample_factory.utils.typing",
        "documentation": {}
    },
    {
        "label": "Env",
        "importPath": "sample_factory.utils.typing",
        "description": "sample_factory.utils.typing",
        "isExtraImport": true,
        "detail": "sample_factory.utils.typing",
        "documentation": {}
    },
    {
        "label": "PolicyID",
        "importPath": "sample_factory.utils.typing",
        "description": "sample_factory.utils.typing",
        "isExtraImport": true,
        "detail": "sample_factory.utils.typing",
        "documentation": {}
    },
    {
        "label": "PolicyID",
        "importPath": "sample_factory.utils.typing",
        "description": "sample_factory.utils.typing",
        "isExtraImport": true,
        "detail": "sample_factory.utils.typing",
        "documentation": {}
    },
    {
        "label": "PolicyID",
        "importPath": "sample_factory.utils.typing",
        "description": "sample_factory.utils.typing",
        "isExtraImport": true,
        "detail": "sample_factory.utils.typing",
        "documentation": {}
    },
    {
        "label": "Config",
        "importPath": "sample_factory.utils.typing",
        "description": "sample_factory.utils.typing",
        "isExtraImport": true,
        "detail": "sample_factory.utils.typing",
        "documentation": {}
    },
    {
        "label": "ObsSpace",
        "importPath": "sample_factory.utils.typing",
        "description": "sample_factory.utils.typing",
        "isExtraImport": true,
        "detail": "sample_factory.utils.typing",
        "documentation": {}
    },
    {
        "label": "Config",
        "importPath": "sample_factory.utils.typing",
        "description": "sample_factory.utils.typing",
        "isExtraImport": true,
        "detail": "sample_factory.utils.typing",
        "documentation": {}
    },
    {
        "label": "Env",
        "importPath": "sample_factory.utils.typing",
        "description": "sample_factory.utils.typing",
        "isExtraImport": true,
        "detail": "sample_factory.utils.typing",
        "documentation": {}
    },
    {
        "label": "PolicyID",
        "importPath": "sample_factory.utils.typing",
        "description": "sample_factory.utils.typing",
        "isExtraImport": true,
        "detail": "sample_factory.utils.typing",
        "documentation": {}
    },
    {
        "label": "Config",
        "importPath": "sample_factory.utils.typing",
        "description": "sample_factory.utils.typing",
        "isExtraImport": true,
        "detail": "sample_factory.utils.typing",
        "documentation": {}
    },
    {
        "label": "Config",
        "importPath": "sample_factory.utils.typing",
        "description": "sample_factory.utils.typing",
        "isExtraImport": true,
        "detail": "sample_factory.utils.typing",
        "documentation": {}
    },
    {
        "label": "Env",
        "importPath": "sample_factory.utils.typing",
        "description": "sample_factory.utils.typing",
        "isExtraImport": true,
        "detail": "sample_factory.utils.typing",
        "documentation": {}
    },
    {
        "label": "Config",
        "importPath": "sample_factory.utils.typing",
        "description": "sample_factory.utils.typing",
        "isExtraImport": true,
        "detail": "sample_factory.utils.typing",
        "documentation": {}
    },
    {
        "label": "ObsSpace",
        "importPath": "sample_factory.utils.typing",
        "description": "sample_factory.utils.typing",
        "isExtraImport": true,
        "detail": "sample_factory.utils.typing",
        "documentation": {}
    },
    {
        "label": "Config",
        "importPath": "sample_factory.utils.typing",
        "description": "sample_factory.utils.typing",
        "isExtraImport": true,
        "detail": "sample_factory.utils.typing",
        "documentation": {}
    },
    {
        "label": "ObsSpace",
        "importPath": "sample_factory.utils.typing",
        "description": "sample_factory.utils.typing",
        "isExtraImport": true,
        "detail": "sample_factory.utils.typing",
        "documentation": {}
    },
    {
        "label": "Config",
        "importPath": "sample_factory.utils.typing",
        "description": "sample_factory.utils.typing",
        "isExtraImport": true,
        "detail": "sample_factory.utils.typing",
        "documentation": {}
    },
    {
        "label": "Config",
        "importPath": "sample_factory.utils.typing",
        "description": "sample_factory.utils.typing",
        "isExtraImport": true,
        "detail": "sample_factory.utils.typing",
        "documentation": {}
    },
    {
        "label": "ObsSpace",
        "importPath": "sample_factory.utils.typing",
        "description": "sample_factory.utils.typing",
        "isExtraImport": true,
        "detail": "sample_factory.utils.typing",
        "documentation": {}
    },
    {
        "label": "Config",
        "importPath": "sample_factory.utils.typing",
        "description": "sample_factory.utils.typing",
        "isExtraImport": true,
        "detail": "sample_factory.utils.typing",
        "documentation": {}
    },
    {
        "label": "ObsSpace",
        "importPath": "sample_factory.utils.typing",
        "description": "sample_factory.utils.typing",
        "isExtraImport": true,
        "detail": "sample_factory.utils.typing",
        "documentation": {}
    },
    {
        "label": "Config",
        "importPath": "sample_factory.utils.typing",
        "description": "sample_factory.utils.typing",
        "isExtraImport": true,
        "detail": "sample_factory.utils.typing",
        "documentation": {}
    },
    {
        "label": "Config",
        "importPath": "sample_factory.utils.typing",
        "description": "sample_factory.utils.typing",
        "isExtraImport": true,
        "detail": "sample_factory.utils.typing",
        "documentation": {}
    },
    {
        "label": "Config",
        "importPath": "sample_factory.utils.typing",
        "description": "sample_factory.utils.typing",
        "isExtraImport": true,
        "detail": "sample_factory.utils.typing",
        "documentation": {}
    },
    {
        "label": "Config",
        "importPath": "sample_factory.utils.typing",
        "description": "sample_factory.utils.typing",
        "isExtraImport": true,
        "detail": "sample_factory.utils.typing",
        "documentation": {}
    },
    {
        "label": "Config",
        "importPath": "sample_factory.utils.typing",
        "description": "sample_factory.utils.typing",
        "isExtraImport": true,
        "detail": "sample_factory.utils.typing",
        "documentation": {}
    },
    {
        "label": "Config",
        "importPath": "sample_factory.utils.typing",
        "description": "sample_factory.utils.typing",
        "isExtraImport": true,
        "detail": "sample_factory.utils.typing",
        "documentation": {}
    },
    {
        "label": "sample_actions_log_probs",
        "importPath": "sample_factory.algo.utils.action_distributions",
        "description": "sample_factory.algo.utils.action_distributions",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.action_distributions",
        "documentation": {}
    },
    {
        "label": "get_action_distribution",
        "importPath": "sample_factory.algo.utils.action_distributions",
        "description": "sample_factory.algo.utils.action_distributions",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.action_distributions",
        "documentation": {}
    },
    {
        "label": "is_continuous_action_space",
        "importPath": "sample_factory.algo.utils.action_distributions",
        "description": "sample_factory.algo.utils.action_distributions",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.action_distributions",
        "documentation": {}
    },
    {
        "label": "calc_num_actions",
        "importPath": "sample_factory.algo.utils.action_distributions",
        "description": "sample_factory.algo.utils.action_distributions",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.action_distributions",
        "documentation": {}
    },
    {
        "label": "calc_num_action_parameters",
        "importPath": "sample_factory.algo.utils.action_distributions",
        "description": "sample_factory.algo.utils.action_distributions",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.action_distributions",
        "documentation": {}
    },
    {
        "label": "calc_num_actions",
        "importPath": "sample_factory.algo.utils.action_distributions",
        "description": "sample_factory.algo.utils.action_distributions",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.action_distributions",
        "documentation": {}
    },
    {
        "label": "calc_num_action_parameters",
        "importPath": "sample_factory.algo.utils.action_distributions",
        "description": "sample_factory.algo.utils.action_distributions",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.action_distributions",
        "documentation": {}
    },
    {
        "label": "get_action_distribution",
        "importPath": "sample_factory.algo.utils.action_distributions",
        "description": "sample_factory.algo.utils.action_distributions",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.action_distributions",
        "documentation": {}
    },
    {
        "label": "is_continuous_action_space",
        "importPath": "sample_factory.algo.utils.action_distributions",
        "description": "sample_factory.algo.utils.action_distributions",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.action_distributions",
        "documentation": {}
    },
    {
        "label": "is_continuous_action_space",
        "importPath": "sample_factory.algo.utils.action_distributions",
        "description": "sample_factory.algo.utils.action_distributions",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.action_distributions",
        "documentation": {}
    },
    {
        "label": "sample_actions_log_probs",
        "importPath": "sample_factory.algo.utils.action_distributions",
        "description": "sample_factory.algo.utils.action_distributions",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.action_distributions",
        "documentation": {}
    },
    {
        "label": "argmax_actions",
        "importPath": "sample_factory.algo.utils.action_distributions",
        "description": "sample_factory.algo.utils.action_distributions",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.action_distributions",
        "documentation": {}
    },
    {
        "label": "calc_num_action_parameters",
        "importPath": "sample_factory.algo.utils.action_distributions",
        "description": "sample_factory.algo.utils.action_distributions",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.action_distributions",
        "documentation": {}
    },
    {
        "label": "calc_num_actions",
        "importPath": "sample_factory.algo.utils.action_distributions",
        "description": "sample_factory.algo.utils.action_distributions",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.action_distributions",
        "documentation": {}
    },
    {
        "label": "get_action_distribution",
        "importPath": "sample_factory.algo.utils.action_distributions",
        "description": "sample_factory.algo.utils.action_distributions",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.action_distributions",
        "documentation": {}
    },
    {
        "label": "sample_actions_log_probs",
        "importPath": "sample_factory.algo.utils.action_distributions",
        "description": "sample_factory.algo.utils.action_distributions",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.action_distributions",
        "documentation": {}
    },
    {
        "label": "MettaAgentInterface",
        "importPath": "agent.agent_interface",
        "description": "agent.agent_interface",
        "isExtraImport": true,
        "detail": "agent.agent_interface",
        "documentation": {}
    },
    {
        "label": "MultiFeatureSetEncoder",
        "importPath": "agent.feature_encoder",
        "description": "agent.feature_encoder",
        "isExtraImport": true,
        "detail": "agent.feature_encoder",
        "documentation": {}
    },
    {
        "label": "torch.nn",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "torch.nn",
        "description": "torch.nn",
        "detail": "torch.nn",
        "documentation": {}
    },
    {
        "label": "functional",
        "importPath": "torch.nn",
        "description": "torch.nn",
        "isExtraImport": true,
        "detail": "torch.nn",
        "documentation": {}
    },
    {
        "label": "Module",
        "importPath": "torch.nn",
        "description": "torch.nn",
        "isExtraImport": true,
        "detail": "torch.nn",
        "documentation": {}
    },
    {
        "label": "functional",
        "importPath": "torch.nn",
        "description": "torch.nn",
        "isExtraImport": true,
        "detail": "torch.nn",
        "documentation": {}
    },
    {
        "label": "Module",
        "importPath": "torch.nn",
        "description": "torch.nn",
        "isExtraImport": true,
        "detail": "torch.nn",
        "documentation": {}
    },
    {
        "label": "functional",
        "importPath": "torch.nn",
        "description": "torch.nn",
        "isExtraImport": true,
        "detail": "torch.nn",
        "documentation": {}
    },
    {
        "label": "torch.nn.functional",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "torch.nn.functional",
        "description": "torch.nn.functional",
        "detail": "torch.nn.functional",
        "documentation": {}
    },
    {
        "label": "base64",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "base64",
        "description": "base64",
        "detail": "base64",
        "documentation": {}
    },
    {
        "label": "io",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "io",
        "description": "io",
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "StringIO",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "random",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "random",
        "description": "random",
        "detail": "random",
        "documentation": {}
    },
    {
        "label": "threading",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "threading",
        "description": "threading",
        "detail": "threading",
        "documentation": {}
    },
    {
        "label": "Thread",
        "importPath": "threading",
        "description": "threading",
        "isExtraImport": true,
        "detail": "threading",
        "documentation": {}
    },
    {
        "label": "Thread",
        "importPath": "threading",
        "description": "threading",
        "isExtraImport": true,
        "detail": "threading",
        "documentation": {}
    },
    {
        "label": "Thread",
        "importPath": "threading",
        "description": "threading",
        "isExtraImport": true,
        "detail": "threading",
        "documentation": {}
    },
    {
        "label": "Thread",
        "importPath": "threading",
        "description": "threading",
        "isExtraImport": true,
        "detail": "threading",
        "documentation": {}
    },
    {
        "label": "Thread",
        "importPath": "threading",
        "description": "threading",
        "isExtraImport": true,
        "detail": "threading",
        "documentation": {}
    },
    {
        "label": "Thread",
        "importPath": "threading",
        "description": "threading",
        "isExtraImport": true,
        "detail": "threading",
        "documentation": {}
    },
    {
        "label": "Thread",
        "importPath": "threading",
        "description": "threading",
        "isExtraImport": true,
        "detail": "threading",
        "documentation": {}
    },
    {
        "label": "traceback",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "traceback",
        "description": "traceback",
        "detail": "traceback",
        "documentation": {}
    },
    {
        "label": "uuid",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "uuid",
        "description": "uuid",
        "detail": "uuid",
        "documentation": {}
    },
    {
        "label": "UUID",
        "importPath": "uuid",
        "description": "uuid",
        "isExtraImport": true,
        "detail": "uuid",
        "documentation": {}
    },
    {
        "label": "collections",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "collections",
        "description": "collections",
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "OrderedDict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "OrderedDict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "deque",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "deque",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "OrderedDict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "deque",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "OrderedDict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "deque",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "OrderedDict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "deque",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "deque",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "OrderedDict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "deque",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "deque",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "deque",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "deque",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "namedtuple",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "deque",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "deque",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "deque",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "deque",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "deque",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "wandb",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "wandb",
        "description": "wandb",
        "detail": "wandb",
        "documentation": {}
    },
    {
        "label": "attr",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "attr",
        "description": "attr",
        "detail": "attr",
        "documentation": {}
    },
    {
        "label": "evolve",
        "importPath": "attr",
        "description": "attr",
        "isExtraImport": true,
        "detail": "attr",
        "documentation": {}
    },
    {
        "label": "logger",
        "importPath": "loguru",
        "description": "loguru",
        "isExtraImport": true,
        "detail": "loguru",
        "documentation": {}
    },
    {
        "label": "logger",
        "importPath": "loguru",
        "description": "loguru",
        "isExtraImport": true,
        "detail": "loguru",
        "documentation": {}
    },
    {
        "label": "Categorical",
        "importPath": "torch.distributions",
        "description": "torch.distributions",
        "isExtraImport": true,
        "detail": "torch.distributions",
        "documentation": {}
    },
    {
        "label": "Distribution",
        "importPath": "torch.distributions",
        "description": "torch.distributions",
        "isExtraImport": true,
        "detail": "torch.distributions",
        "documentation": {}
    },
    {
        "label": "Normal",
        "importPath": "torch.distributions",
        "description": "torch.distributions",
        "isExtraImport": true,
        "detail": "torch.distributions",
        "documentation": {}
    },
    {
        "label": "Normal",
        "importPath": "torch.distributions",
        "description": "torch.distributions",
        "isExtraImport": true,
        "detail": "torch.distributions",
        "documentation": {}
    },
    {
        "label": "Normal",
        "importPath": "torch.distributions",
        "description": "torch.distributions",
        "isExtraImport": true,
        "detail": "torch.distributions",
        "documentation": {}
    },
    {
        "label": "Categorical",
        "importPath": "torch.distributions",
        "description": "torch.distributions",
        "isExtraImport": true,
        "detail": "torch.distributions",
        "documentation": {}
    },
    {
        "label": "Categorical",
        "importPath": "torch.distributions",
        "description": "torch.distributions",
        "isExtraImport": true,
        "detail": "torch.distributions",
        "documentation": {}
    },
    {
        "label": "Independent",
        "importPath": "torch.distributions",
        "description": "torch.distributions",
        "isExtraImport": true,
        "detail": "torch.distributions",
        "documentation": {}
    },
    {
        "label": "Normal",
        "importPath": "torch.distributions",
        "description": "torch.distributions",
        "isExtraImport": true,
        "detail": "torch.distributions",
        "documentation": {}
    },
    {
        "label": "Categorical",
        "importPath": "torch.distributions",
        "description": "torch.distributions",
        "isExtraImport": true,
        "detail": "torch.distributions",
        "documentation": {}
    },
    {
        "label": "RunDisabled",
        "importPath": "wandb.sdk.lib",
        "description": "wandb.sdk.lib",
        "isExtraImport": true,
        "detail": "wandb.sdk.lib",
        "documentation": {}
    },
    {
        "label": "Run",
        "importPath": "wandb.sdk.wandb_run",
        "description": "wandb.sdk.wandb_run",
        "isExtraImport": true,
        "detail": "wandb.sdk.wandb_run",
        "documentation": {}
    },
    {
        "label": "SurrogateModel",
        "importPath": "carbs.model",
        "description": "carbs.model",
        "isExtraImport": true,
        "detail": "carbs.model",
        "documentation": {}
    },
    {
        "label": "CARBSParams",
        "importPath": "carbs.utils",
        "description": "carbs.utils",
        "isExtraImport": true,
        "detail": "carbs.utils",
        "documentation": {}
    },
    {
        "label": "load_latest_checkpoint_from_wandb_run",
        "importPath": "carbs.utils",
        "description": "carbs.utils",
        "isExtraImport": true,
        "detail": "carbs.utils",
        "documentation": {}
    },
    {
        "label": "CARBS_CHECKPOINT_PREFIX",
        "importPath": "carbs.utils",
        "description": "carbs.utils",
        "isExtraImport": true,
        "detail": "carbs.utils",
        "documentation": {}
    },
    {
        "label": "CARBS_CHECKPOINT_SUFFIX",
        "importPath": "carbs.utils",
        "description": "carbs.utils",
        "isExtraImport": true,
        "detail": "carbs.utils",
        "documentation": {}
    },
    {
        "label": "ObservationGroup",
        "importPath": "carbs.utils",
        "description": "carbs.utils",
        "isExtraImport": true,
        "detail": "carbs.utils",
        "documentation": {}
    },
    {
        "label": "ObservationInBasic",
        "importPath": "carbs.utils",
        "description": "carbs.utils",
        "isExtraImport": true,
        "detail": "carbs.utils",
        "documentation": {}
    },
    {
        "label": "ObservationInParam",
        "importPath": "carbs.utils",
        "description": "carbs.utils",
        "isExtraImport": true,
        "detail": "carbs.utils",
        "documentation": {}
    },
    {
        "label": "ObserveOutput",
        "importPath": "carbs.utils",
        "description": "carbs.utils",
        "isExtraImport": true,
        "detail": "carbs.utils",
        "documentation": {}
    },
    {
        "label": "Param",
        "importPath": "carbs.utils",
        "description": "carbs.utils",
        "isExtraImport": true,
        "detail": "carbs.utils",
        "documentation": {}
    },
    {
        "label": "ParamDictType",
        "importPath": "carbs.utils",
        "description": "carbs.utils",
        "isExtraImport": true,
        "detail": "carbs.utils",
        "documentation": {}
    },
    {
        "label": "RealNumberSpace",
        "importPath": "carbs.utils",
        "description": "carbs.utils",
        "isExtraImport": true,
        "detail": "carbs.utils",
        "documentation": {}
    },
    {
        "label": "SUGGESTION_ID_DICT_KEY",
        "importPath": "carbs.utils",
        "description": "carbs.utils",
        "isExtraImport": true,
        "detail": "carbs.utils",
        "documentation": {}
    },
    {
        "label": "SuggestOutput",
        "importPath": "carbs.utils",
        "description": "carbs.utils",
        "isExtraImport": true,
        "detail": "carbs.utils",
        "documentation": {}
    },
    {
        "label": "SuggestionInBasic",
        "importPath": "carbs.utils",
        "description": "carbs.utils",
        "isExtraImport": true,
        "detail": "carbs.utils",
        "documentation": {}
    },
    {
        "label": "SurrogateModelParams",
        "importPath": "carbs.utils",
        "description": "carbs.utils",
        "isExtraImport": true,
        "detail": "carbs.utils",
        "documentation": {}
    },
    {
        "label": "add_dict_key_prefix",
        "importPath": "carbs.utils",
        "description": "carbs.utils",
        "isExtraImport": true,
        "detail": "carbs.utils",
        "documentation": {}
    },
    {
        "label": "aggregate_logical_and_across_dim",
        "importPath": "carbs.utils",
        "description": "carbs.utils",
        "isExtraImport": true,
        "detail": "carbs.utils",
        "documentation": {}
    },
    {
        "label": "assert_empty",
        "importPath": "carbs.utils",
        "description": "carbs.utils",
        "isExtraImport": true,
        "detail": "carbs.utils",
        "documentation": {}
    },
    {
        "label": "expected_improvement",
        "importPath": "carbs.utils",
        "description": "carbs.utils",
        "isExtraImport": true,
        "detail": "carbs.utils",
        "documentation": {}
    },
    {
        "label": "get_pareto_curve_plot",
        "importPath": "carbs.utils",
        "description": "carbs.utils",
        "isExtraImport": true,
        "detail": "carbs.utils",
        "documentation": {}
    },
    {
        "label": "get_pareto_groups",
        "importPath": "carbs.utils",
        "description": "carbs.utils",
        "isExtraImport": true,
        "detail": "carbs.utils",
        "documentation": {}
    },
    {
        "label": "get_pareto_groups_conservative",
        "importPath": "carbs.utils",
        "description": "carbs.utils",
        "isExtraImport": true,
        "detail": "carbs.utils",
        "documentation": {}
    },
    {
        "label": "group_observations",
        "importPath": "carbs.utils",
        "description": "carbs.utils",
        "isExtraImport": true,
        "detail": "carbs.utils",
        "documentation": {}
    },
    {
        "label": "observation_group_cost",
        "importPath": "carbs.utils",
        "description": "carbs.utils",
        "isExtraImport": true,
        "detail": "carbs.utils",
        "documentation": {}
    },
    {
        "label": "observation_group_output",
        "importPath": "carbs.utils",
        "description": "carbs.utils",
        "isExtraImport": true,
        "detail": "carbs.utils",
        "documentation": {}
    },
    {
        "label": "ordered_dict_index",
        "importPath": "carbs.utils",
        "description": "carbs.utils",
        "isExtraImport": true,
        "detail": "carbs.utils",
        "documentation": {}
    },
    {
        "label": "pareto_area_from_groups",
        "importPath": "carbs.utils",
        "description": "carbs.utils",
        "isExtraImport": true,
        "detail": "carbs.utils",
        "documentation": {}
    },
    {
        "label": "ObservationInBasic",
        "importPath": "carbs.utils",
        "description": "carbs.utils",
        "isExtraImport": true,
        "detail": "carbs.utils",
        "documentation": {}
    },
    {
        "label": "OutstandingSuggestionEstimatorEnum",
        "importPath": "carbs.utils",
        "description": "carbs.utils",
        "isExtraImport": true,
        "detail": "carbs.utils",
        "documentation": {}
    },
    {
        "label": "SuggestionInBasic",
        "importPath": "carbs.utils",
        "description": "carbs.utils",
        "isExtraImport": true,
        "detail": "carbs.utils",
        "documentation": {}
    },
    {
        "label": "SurrogateModelParams",
        "importPath": "carbs.utils",
        "description": "carbs.utils",
        "isExtraImport": true,
        "detail": "carbs.utils",
        "documentation": {}
    },
    {
        "label": "CARBSParams",
        "importPath": "carbs.utils",
        "description": "carbs.utils",
        "isExtraImport": true,
        "detail": "carbs.utils",
        "documentation": {}
    },
    {
        "label": "LinearSpace",
        "importPath": "carbs.utils",
        "description": "carbs.utils",
        "isExtraImport": true,
        "detail": "carbs.utils",
        "documentation": {}
    },
    {
        "label": "LogSpace",
        "importPath": "carbs.utils",
        "description": "carbs.utils",
        "isExtraImport": true,
        "detail": "carbs.utils",
        "documentation": {}
    },
    {
        "label": "Param",
        "importPath": "carbs.utils",
        "description": "carbs.utils",
        "isExtraImport": true,
        "detail": "carbs.utils",
        "documentation": {}
    },
    {
        "label": "pyro",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pyro",
        "description": "pyro",
        "detail": "pyro",
        "documentation": {}
    },
    {
        "label": "gp",
        "importPath": "pyro.contrib",
        "description": "pyro.contrib",
        "isExtraImport": true,
        "detail": "pyro.contrib",
        "documentation": {}
    },
    {
        "label": "Kernel",
        "importPath": "pyro.contrib.gp.kernels",
        "description": "pyro.contrib.gp.kernels",
        "isExtraImport": true,
        "detail": "pyro.contrib.gp.kernels",
        "documentation": {}
    },
    {
        "label": "GPRegression",
        "importPath": "pyro.contrib.gp.models",
        "description": "pyro.contrib.gp.models",
        "isExtraImport": true,
        "detail": "pyro.contrib.gp.models",
        "documentation": {}
    },
    {
        "label": "MinMaxScaler",
        "importPath": "sklearn.preprocessing",
        "description": "sklearn.preprocessing",
        "isExtraImport": true,
        "detail": "sklearn.preprocessing",
        "documentation": {}
    },
    {
        "label": "QuantileTransformer",
        "importPath": "sklearn.preprocessing",
        "description": "sklearn.preprocessing",
        "isExtraImport": true,
        "detail": "sklearn.preprocessing",
        "documentation": {}
    },
    {
        "label": "multiprocessing",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "multiprocessing",
        "description": "multiprocessing",
        "detail": "multiprocessing",
        "documentation": {}
    },
    {
        "label": "Process",
        "importPath": "multiprocessing",
        "description": "multiprocessing",
        "isExtraImport": true,
        "detail": "multiprocessing",
        "documentation": {}
    },
    {
        "label": "Pipe",
        "importPath": "multiprocessing",
        "description": "multiprocessing",
        "isExtraImport": true,
        "detail": "multiprocessing",
        "documentation": {}
    },
    {
        "label": "Process",
        "importPath": "multiprocessing",
        "description": "multiprocessing",
        "isExtraImport": true,
        "detail": "multiprocessing",
        "documentation": {}
    },
    {
        "label": "Pipe",
        "importPath": "multiprocessing",
        "description": "multiprocessing",
        "isExtraImport": true,
        "detail": "multiprocessing",
        "documentation": {}
    },
    {
        "label": "Array",
        "importPath": "multiprocessing",
        "description": "multiprocessing",
        "isExtraImport": true,
        "detail": "multiprocessing",
        "documentation": {}
    },
    {
        "label": "Process",
        "importPath": "multiprocessing",
        "description": "multiprocessing",
        "isExtraImport": true,
        "detail": "multiprocessing",
        "documentation": {}
    },
    {
        "label": "Process",
        "importPath": "multiprocessing",
        "description": "multiprocessing",
        "isExtraImport": true,
        "detail": "multiprocessing",
        "documentation": {}
    },
    {
        "label": "contextlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "contextlib",
        "description": "contextlib",
        "detail": "contextlib",
        "documentation": {}
    },
    {
        "label": "contextmanager",
        "importPath": "contextlib",
        "description": "contextlib",
        "isExtraImport": true,
        "detail": "contextlib",
        "documentation": {}
    },
    {
        "label": "redirect_stdout",
        "importPath": "contextlib",
        "description": "contextlib",
        "isExtraImport": true,
        "detail": "contextlib",
        "documentation": {}
    },
    {
        "label": "redirect_stderr",
        "importPath": "contextlib",
        "description": "contextlib",
        "isExtraImport": true,
        "detail": "contextlib",
        "documentation": {}
    },
    {
        "label": "contextmanager",
        "importPath": "contextlib",
        "description": "contextlib",
        "isExtraImport": true,
        "detail": "contextlib",
        "documentation": {}
    },
    {
        "label": "copy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "copy",
        "description": "copy",
        "detail": "copy",
        "documentation": {}
    },
    {
        "label": "deepcopy",
        "importPath": "copy",
        "description": "copy",
        "isExtraImport": true,
        "detail": "copy",
        "documentation": {}
    },
    {
        "label": "datetime",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "datetime",
        "description": "datetime",
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "pytest",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pytest",
        "description": "pytest",
        "detail": "pytest",
        "documentation": {}
    },
    {
        "label": "LogitSpace",
        "importPath": "carbs",
        "description": "carbs",
        "isExtraImport": true,
        "detail": "carbs",
        "documentation": {}
    },
    {
        "label": "ObservationInParam",
        "importPath": "carbs",
        "description": "carbs",
        "isExtraImport": true,
        "detail": "carbs",
        "documentation": {}
    },
    {
        "label": "CARBS",
        "importPath": "carbs",
        "description": "carbs",
        "isExtraImport": true,
        "detail": "carbs",
        "documentation": {}
    },
    {
        "label": "CARBSParams",
        "importPath": "carbs",
        "description": "carbs",
        "isExtraImport": true,
        "detail": "carbs",
        "documentation": {}
    },
    {
        "label": "LinearSpace",
        "importPath": "carbs",
        "description": "carbs",
        "isExtraImport": true,
        "detail": "carbs",
        "documentation": {}
    },
    {
        "label": "LogSpace",
        "importPath": "carbs",
        "description": "carbs",
        "isExtraImport": true,
        "detail": "carbs",
        "documentation": {}
    },
    {
        "label": "LogitSpace",
        "importPath": "carbs",
        "description": "carbs",
        "isExtraImport": true,
        "detail": "carbs",
        "documentation": {}
    },
    {
        "label": "ObservationInParam",
        "importPath": "carbs",
        "description": "carbs",
        "isExtraImport": true,
        "detail": "carbs",
        "documentation": {}
    },
    {
        "label": "ParamDictType",
        "importPath": "carbs",
        "description": "carbs",
        "isExtraImport": true,
        "detail": "carbs",
        "documentation": {}
    },
    {
        "label": "Param",
        "importPath": "carbs",
        "description": "carbs",
        "isExtraImport": true,
        "detail": "carbs",
        "documentation": {}
    },
    {
        "label": "CARBS",
        "importPath": "carbs",
        "description": "carbs",
        "isExtraImport": true,
        "detail": "carbs",
        "documentation": {}
    },
    {
        "label": "CARBSParams",
        "importPath": "carbs",
        "description": "carbs",
        "isExtraImport": true,
        "detail": "carbs",
        "documentation": {}
    },
    {
        "label": "LinearSpace",
        "importPath": "carbs",
        "description": "carbs",
        "isExtraImport": true,
        "detail": "carbs",
        "documentation": {}
    },
    {
        "label": "LogitSpace",
        "importPath": "carbs",
        "description": "carbs",
        "isExtraImport": true,
        "detail": "carbs",
        "documentation": {}
    },
    {
        "label": "LogSpace",
        "importPath": "carbs",
        "description": "carbs",
        "isExtraImport": true,
        "detail": "carbs",
        "documentation": {}
    },
    {
        "label": "ObservationInParam",
        "importPath": "carbs",
        "description": "carbs",
        "isExtraImport": true,
        "detail": "carbs",
        "documentation": {}
    },
    {
        "label": "Param",
        "importPath": "carbs",
        "description": "carbs",
        "isExtraImport": true,
        "detail": "carbs",
        "documentation": {}
    },
    {
        "label": "CARBS",
        "importPath": "carbs.carbs",
        "description": "carbs.carbs",
        "isExtraImport": true,
        "detail": "carbs.carbs",
        "documentation": {}
    },
    {
        "label": "seaborn",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "seaborn",
        "description": "seaborn",
        "detail": "seaborn",
        "documentation": {}
    },
    {
        "label": "pyplot",
        "importPath": "matplotlib",
        "description": "matplotlib",
        "isExtraImport": true,
        "detail": "matplotlib",
        "documentation": {}
    },
    {
        "label": "wofz",
        "importPath": "scipy.special",
        "description": "scipy.special",
        "isExtraImport": true,
        "detail": "scipy.special",
        "documentation": {}
    },
    {
        "label": "Serializable",
        "importPath": "carbs.serialization",
        "description": "carbs.serialization",
        "isExtraImport": true,
        "detail": "carbs.serialization",
        "documentation": {}
    },
    {
        "label": "setup",
        "importPath": "distutils.core",
        "description": "distutils.core",
        "isExtraImport": true,
        "detail": "distutils.core",
        "documentation": {}
    },
    {
        "label": "cythonize",
        "importPath": "Cython.Build",
        "description": "Cython.Build",
        "isExtraImport": true,
        "detail": "Cython.Build",
        "documentation": {}
    },
    {
        "label": "cythonize",
        "importPath": "Cython.Build",
        "description": "Cython.Build",
        "isExtraImport": true,
        "detail": "Cython.Build",
        "documentation": {}
    },
    {
        "label": "cythonize",
        "importPath": "Cython.Build",
        "description": "Cython.Build",
        "isExtraImport": true,
        "detail": "Cython.Build",
        "documentation": {}
    },
    {
        "label": "cythonize",
        "importPath": "Cython.Build",
        "description": "Cython.Build",
        "isExtraImport": true,
        "detail": "Cython.Build",
        "documentation": {}
    },
    {
        "label": "setuptools",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "setuptools",
        "description": "setuptools",
        "detail": "setuptools",
        "documentation": {}
    },
    {
        "label": "Extension",
        "importPath": "setuptools",
        "description": "setuptools",
        "isExtraImport": true,
        "detail": "setuptools",
        "documentation": {}
    },
    {
        "label": "find_packages",
        "importPath": "setuptools",
        "description": "setuptools",
        "isExtraImport": true,
        "detail": "setuptools",
        "documentation": {}
    },
    {
        "label": "setup",
        "importPath": "setuptools",
        "description": "setuptools",
        "isExtraImport": true,
        "detail": "setuptools",
        "documentation": {}
    },
    {
        "label": "Extension",
        "importPath": "setuptools",
        "description": "setuptools",
        "isExtraImport": true,
        "detail": "setuptools",
        "documentation": {}
    },
    {
        "label": "setup",
        "importPath": "setuptools",
        "description": "setuptools",
        "isExtraImport": true,
        "detail": "setuptools",
        "documentation": {}
    },
    {
        "label": "find_packages",
        "importPath": "setuptools",
        "description": "setuptools",
        "isExtraImport": true,
        "detail": "setuptools",
        "documentation": {}
    },
    {
        "label": "Command",
        "importPath": "setuptools",
        "description": "setuptools",
        "isExtraImport": true,
        "detail": "setuptools",
        "documentation": {}
    },
    {
        "label": "setup",
        "importPath": "setuptools",
        "description": "setuptools",
        "isExtraImport": true,
        "detail": "setuptools",
        "documentation": {}
    },
    {
        "label": "Extension",
        "importPath": "setuptools",
        "description": "setuptools",
        "isExtraImport": true,
        "detail": "setuptools",
        "documentation": {}
    },
    {
        "label": "find_packages",
        "importPath": "setuptools",
        "description": "setuptools",
        "isExtraImport": true,
        "detail": "setuptools",
        "documentation": {}
    },
    {
        "label": "find_packages",
        "importPath": "setuptools",
        "description": "setuptools",
        "isExtraImport": true,
        "detail": "setuptools",
        "documentation": {}
    },
    {
        "label": "setup",
        "importPath": "setuptools",
        "description": "setuptools",
        "isExtraImport": true,
        "detail": "setuptools",
        "documentation": {}
    },
    {
        "label": "Extension",
        "importPath": "setuptools",
        "description": "setuptools",
        "isExtraImport": true,
        "detail": "setuptools",
        "documentation": {}
    },
    {
        "label": "Extension",
        "importPath": "setuptools",
        "description": "setuptools",
        "isExtraImport": true,
        "detail": "setuptools",
        "documentation": {}
    },
    {
        "label": "setup",
        "importPath": "setuptools",
        "description": "setuptools",
        "isExtraImport": true,
        "detail": "setuptools",
        "documentation": {}
    },
    {
        "label": "setup",
        "importPath": "setuptools",
        "description": "setuptools",
        "isExtraImport": true,
        "detail": "setuptools",
        "documentation": {}
    },
    {
        "label": "yaml",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "yaml",
        "description": "yaml",
        "detail": "yaml",
        "documentation": {}
    },
    {
        "label": "sys",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sys",
        "description": "sys",
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "argv",
        "importPath": "sys",
        "description": "sys",
        "isExtraImport": true,
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "platform",
        "importPath": "sys",
        "description": "sys",
        "isExtraImport": true,
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "pyray",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pyray",
        "description": "pyray",
        "detail": "pyray",
        "documentation": {}
    },
    {
        "label": "FFI",
        "importPath": "cffi",
        "description": "cffi",
        "isExtraImport": true,
        "detail": "cffi",
        "documentation": {}
    },
    {
        "label": "FFI",
        "importPath": "cffi",
        "description": "cffi",
        "isExtraImport": true,
        "detail": "cffi",
        "documentation": {}
    },
    {
        "label": "colors",
        "importPath": "raylib",
        "description": "raylib",
        "isExtraImport": true,
        "detail": "raylib",
        "documentation": {}
    },
    {
        "label": "rl",
        "importPath": "raylib",
        "description": "raylib",
        "isExtraImport": true,
        "detail": "raylib",
        "documentation": {}
    },
    {
        "label": "rl",
        "importPath": "raylib",
        "description": "raylib",
        "isExtraImport": true,
        "detail": "raylib",
        "documentation": {}
    },
    {
        "label": "colors",
        "importPath": "raylib",
        "description": "raylib",
        "isExtraImport": true,
        "detail": "raylib",
        "documentation": {}
    },
    {
        "label": "rl",
        "importPath": "raylib",
        "description": "raylib",
        "isExtraImport": true,
        "detail": "raylib",
        "documentation": {}
    },
    {
        "label": "rl",
        "importPath": "raylib",
        "description": "raylib",
        "isExtraImport": true,
        "detail": "raylib",
        "documentation": {}
    },
    {
        "label": "rl",
        "importPath": "raylib",
        "description": "raylib",
        "isExtraImport": true,
        "detail": "raylib",
        "documentation": {}
    },
    {
        "label": "rl",
        "importPath": "raylib",
        "description": "raylib",
        "isExtraImport": true,
        "detail": "raylib",
        "documentation": {}
    },
    {
        "label": "rl",
        "importPath": "raylib",
        "description": "raylib",
        "isExtraImport": true,
        "detail": "raylib",
        "documentation": {}
    },
    {
        "label": "colors",
        "importPath": "raylib",
        "description": "raylib",
        "isExtraImport": true,
        "detail": "raylib",
        "documentation": {}
    },
    {
        "label": "types",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "types",
        "description": "types",
        "detail": "types",
        "documentation": {}
    },
    {
        "label": "SimpleNamespace",
        "importPath": "types",
        "description": "types",
        "isExtraImport": true,
        "detail": "types",
        "documentation": {}
    },
    {
        "label": "SimpleNamespace",
        "importPath": "types",
        "description": "types",
        "isExtraImport": true,
        "detail": "types",
        "documentation": {}
    },
    {
        "label": "SimpleNamespace",
        "importPath": "types",
        "description": "types",
        "isExtraImport": true,
        "detail": "types",
        "documentation": {}
    },
    {
        "label": "SimpleNamespace",
        "importPath": "types",
        "description": "types",
        "isExtraImport": true,
        "detail": "types",
        "documentation": {}
    },
    {
        "label": "SimpleNamespace",
        "importPath": "types",
        "description": "types",
        "isExtraImport": true,
        "detail": "types",
        "documentation": {}
    },
    {
        "label": "pufferlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pufferlib",
        "description": "pufferlib",
        "detail": "pufferlib",
        "documentation": {}
    },
    {
        "label": "namespace",
        "importPath": "pufferlib",
        "description": "pufferlib",
        "isExtraImport": true,
        "detail": "pufferlib",
        "documentation": {}
    },
    {
        "label": "namespace",
        "importPath": "pufferlib",
        "description": "pufferlib",
        "isExtraImport": true,
        "detail": "pufferlib",
        "documentation": {}
    },
    {
        "label": "namespace",
        "importPath": "pufferlib",
        "description": "pufferlib",
        "isExtraImport": true,
        "detail": "pufferlib",
        "documentation": {}
    },
    {
        "label": "namespace",
        "importPath": "pufferlib",
        "description": "pufferlib",
        "isExtraImport": true,
        "detail": "pufferlib",
        "documentation": {}
    },
    {
        "label": "namespace",
        "importPath": "pufferlib",
        "description": "pufferlib",
        "isExtraImport": true,
        "detail": "pufferlib",
        "documentation": {}
    },
    {
        "label": "spaces",
        "importPath": "pufferlib",
        "description": "pufferlib",
        "isExtraImport": true,
        "detail": "pufferlib",
        "documentation": {}
    },
    {
        "label": "utils",
        "importPath": "pufferlib",
        "description": "pufferlib",
        "isExtraImport": true,
        "detail": "pufferlib",
        "documentation": {}
    },
    {
        "label": "exceptions",
        "importPath": "pufferlib",
        "description": "pufferlib",
        "isExtraImport": true,
        "detail": "pufferlib",
        "documentation": {}
    },
    {
        "label": "namespace",
        "importPath": "pufferlib",
        "description": "pufferlib",
        "isExtraImport": true,
        "detail": "pufferlib",
        "documentation": {}
    },
    {
        "label": "namespace",
        "importPath": "pufferlib",
        "description": "pufferlib",
        "isExtraImport": true,
        "detail": "pufferlib",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "pufferlib",
        "description": "pufferlib",
        "isExtraImport": true,
        "detail": "pufferlib",
        "documentation": {}
    },
    {
        "label": "namespace",
        "importPath": "pufferlib",
        "description": "pufferlib",
        "isExtraImport": true,
        "detail": "pufferlib",
        "documentation": {}
    },
    {
        "label": "MettaGridGameBuilder",
        "importPath": "mettagrid.config.game_builder",
        "description": "mettagrid.config.game_builder",
        "isExtraImport": true,
        "detail": "mettagrid.config.game_builder",
        "documentation": {}
    },
    {
        "label": "sample_config",
        "importPath": "mettagrid.config.sample_config",
        "description": "mettagrid.config.sample_config",
        "isExtraImport": true,
        "detail": "mettagrid.config.sample_config",
        "documentation": {}
    },
    {
        "label": "MettaGrid",
        "importPath": "mettagrid.mettagrid_c",
        "description": "mettagrid.mettagrid_c",
        "isExtraImport": true,
        "detail": "mettagrid.mettagrid_c",
        "documentation": {}
    },
    {
        "label": "li",
        "importPath": "sympy",
        "description": "sympy",
        "isExtraImport": true,
        "detail": "sympy",
        "documentation": {}
    },
    {
        "label": "N",
        "importPath": "sympy",
        "description": "sympy",
        "isExtraImport": true,
        "detail": "sympy",
        "documentation": {}
    },
    {
        "label": "subprocess",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "subprocess",
        "description": "subprocess",
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "PIPE",
        "importPath": "subprocess",
        "description": "subprocess",
        "isExtraImport": true,
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "Popen",
        "importPath": "subprocess",
        "description": "subprocess",
        "isExtraImport": true,
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "PIPE",
        "importPath": "subprocess",
        "description": "subprocess",
        "isExtraImport": true,
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "Popen",
        "importPath": "subprocess",
        "description": "subprocess",
        "isExtraImport": true,
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "PIPE",
        "importPath": "subprocess",
        "description": "subprocess",
        "isExtraImport": true,
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "Popen",
        "importPath": "subprocess",
        "description": "subprocess",
        "isExtraImport": true,
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "SubprocessError",
        "importPath": "subprocess",
        "description": "subprocess",
        "isExtraImport": true,
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "check_output",
        "importPath": "subprocess",
        "description": "subprocess",
        "isExtraImport": true,
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "run",
        "importPath": "subprocess",
        "description": "subprocess",
        "isExtraImport": true,
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "time",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "time",
        "description": "time",
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "sleep",
        "importPath": "time",
        "description": "time",
        "isExtraImport": true,
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "sleep",
        "importPath": "time",
        "description": "time",
        "isExtraImport": true,
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "tqdm",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "tqdm",
        "description": "tqdm",
        "detail": "tqdm",
        "documentation": {}
    },
    {
        "label": "tqdm",
        "importPath": "tqdm",
        "description": "tqdm",
        "isExtraImport": true,
        "detail": "tqdm",
        "documentation": {}
    },
    {
        "label": "tqdm",
        "importPath": "tqdm",
        "description": "tqdm",
        "isExtraImport": true,
        "detail": "tqdm",
        "documentation": {}
    },
    {
        "label": "tqdm",
        "importPath": "tqdm",
        "description": "tqdm",
        "isExtraImport": true,
        "detail": "tqdm",
        "documentation": {}
    },
    {
        "label": "pandas",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pandas",
        "description": "pandas",
        "detail": "pandas",
        "documentation": {}
    },
    {
        "label": "pufferlib.environment",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pufferlib.environment",
        "description": "pufferlib.environment",
        "detail": "pufferlib.environment",
        "documentation": {}
    },
    {
        "label": "PufferEnv",
        "importPath": "pufferlib.environment",
        "description": "pufferlib.environment",
        "isExtraImport": true,
        "detail": "pufferlib.environment",
        "documentation": {}
    },
    {
        "label": "PufferEnv",
        "importPath": "pufferlib.environment",
        "description": "pufferlib.environment",
        "isExtraImport": true,
        "detail": "pufferlib.environment",
        "documentation": {}
    },
    {
        "label": "PufferEnv",
        "importPath": "pufferlib.environment",
        "description": "pufferlib.environment",
        "isExtraImport": true,
        "detail": "pufferlib.environment",
        "documentation": {}
    },
    {
        "label": "build_ext",
        "importPath": "setuptools.command.build_ext",
        "description": "setuptools.command.build_ext",
        "isExtraImport": true,
        "detail": "setuptools.command.build_ext",
        "documentation": {}
    },
    {
        "label": "build_ext",
        "importPath": "setuptools.command.build_ext",
        "description": "setuptools.command.build_ext",
        "isExtraImport": true,
        "detail": "setuptools.command.build_ext",
        "documentation": {}
    },
    {
        "label": "argparse",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "argparse",
        "description": "argparse",
        "detail": "argparse",
        "documentation": {}
    },
    {
        "label": "ArgumentParser",
        "importPath": "argparse",
        "description": "argparse",
        "isExtraImport": true,
        "detail": "argparse",
        "documentation": {}
    },
    {
        "label": "importlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "importlib",
        "description": "importlib",
        "detail": "importlib",
        "documentation": {}
    },
    {
        "label": "pstats",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pstats",
        "description": "pstats",
        "detail": "pstats",
        "documentation": {}
    },
    {
        "label": "SortKey",
        "importPath": "pstats",
        "description": "pstats",
        "isExtraImport": true,
        "detail": "pstats",
        "documentation": {}
    },
    {
        "label": "run",
        "importPath": "cProfile",
        "description": "cProfile",
        "isExtraImport": true,
        "detail": "cProfile",
        "documentation": {}
    },
    {
        "label": "rich",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "rich",
        "description": "rich",
        "detail": "rich",
        "documentation": {}
    },
    {
        "label": "print",
        "importPath": "rich",
        "description": "rich",
        "isExtraImport": true,
        "detail": "rich",
        "documentation": {}
    },
    {
        "label": "traceback",
        "importPath": "rich",
        "description": "rich",
        "isExtraImport": true,
        "detail": "rich",
        "documentation": {}
    },
    {
        "label": "traceback",
        "importPath": "rich",
        "description": "rich",
        "isExtraImport": true,
        "detail": "rich",
        "documentation": {}
    },
    {
        "label": "pufferlib.environments",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pufferlib.environments",
        "description": "pufferlib.environments",
        "detail": "pufferlib.environments",
        "documentation": {}
    },
    {
        "label": "minihack",
        "importPath": "pufferlib.environments",
        "description": "pufferlib.environments",
        "isExtraImport": true,
        "detail": "pufferlib.environments",
        "documentation": {}
    },
    {
        "label": "try_import",
        "importPath": "pufferlib.environments",
        "description": "pufferlib.environments",
        "isExtraImport": true,
        "detail": "pufferlib.environments",
        "documentation": {}
    },
    {
        "label": "pokemon_red",
        "importPath": "pufferlib.environments",
        "description": "pufferlib.environments",
        "isExtraImport": true,
        "detail": "pufferlib.environments",
        "documentation": {}
    },
    {
        "label": "test",
        "importPath": "pufferlib.environments",
        "description": "pufferlib.environments",
        "isExtraImport": true,
        "detail": "pufferlib.environments",
        "documentation": {}
    },
    {
        "label": "test",
        "importPath": "pufferlib.environments",
        "description": "pufferlib.environments",
        "isExtraImport": true,
        "detail": "pufferlib.environments",
        "documentation": {}
    },
    {
        "label": "atari",
        "importPath": "pufferlib.environments",
        "description": "pufferlib.environments",
        "isExtraImport": true,
        "detail": "pufferlib.environments",
        "documentation": {}
    },
    {
        "label": "ocean",
        "importPath": "pufferlib.environments",
        "description": "pufferlib.environments",
        "isExtraImport": true,
        "detail": "pufferlib.environments",
        "documentation": {}
    },
    {
        "label": "ocean",
        "importPath": "pufferlib.environments",
        "description": "pufferlib.environments",
        "isExtraImport": true,
        "detail": "pufferlib.environments",
        "documentation": {}
    },
    {
        "label": "atari",
        "importPath": "pufferlib.environments",
        "description": "pufferlib.environments",
        "isExtraImport": true,
        "detail": "pufferlib.environments",
        "documentation": {}
    },
    {
        "label": "pufferlib.emulation",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pufferlib.emulation",
        "description": "pufferlib.emulation",
        "detail": "pufferlib.emulation",
        "documentation": {}
    },
    {
        "label": "GymnasiumPufferEnv",
        "importPath": "pufferlib.emulation",
        "description": "pufferlib.emulation",
        "isExtraImport": true,
        "detail": "pufferlib.emulation",
        "documentation": {}
    },
    {
        "label": "PettingZooPufferEnv",
        "importPath": "pufferlib.emulation",
        "description": "pufferlib.emulation",
        "isExtraImport": true,
        "detail": "pufferlib.emulation",
        "documentation": {}
    },
    {
        "label": "flatten_structure",
        "importPath": "pufferlib.emulation",
        "description": "pufferlib.emulation",
        "isExtraImport": true,
        "detail": "pufferlib.emulation",
        "documentation": {}
    },
    {
        "label": "flatten_space",
        "importPath": "pufferlib.emulation",
        "description": "pufferlib.emulation",
        "isExtraImport": true,
        "detail": "pufferlib.emulation",
        "documentation": {}
    },
    {
        "label": "flatten",
        "importPath": "pufferlib.emulation",
        "description": "pufferlib.emulation",
        "isExtraImport": true,
        "detail": "pufferlib.emulation",
        "documentation": {}
    },
    {
        "label": "unflatten",
        "importPath": "pufferlib.emulation",
        "description": "pufferlib.emulation",
        "isExtraImport": true,
        "detail": "pufferlib.emulation",
        "documentation": {}
    },
    {
        "label": "concatenate",
        "importPath": "pufferlib.emulation",
        "description": "pufferlib.emulation",
        "isExtraImport": true,
        "detail": "pufferlib.emulation",
        "documentation": {}
    },
    {
        "label": "split",
        "importPath": "pufferlib.emulation",
        "description": "pufferlib.emulation",
        "isExtraImport": true,
        "detail": "pufferlib.emulation",
        "documentation": {}
    },
    {
        "label": "flatten_structure",
        "importPath": "pufferlib.emulation",
        "description": "pufferlib.emulation",
        "isExtraImport": true,
        "detail": "pufferlib.emulation",
        "documentation": {}
    },
    {
        "label": "flatten",
        "importPath": "pufferlib.emulation",
        "description": "pufferlib.emulation",
        "isExtraImport": true,
        "detail": "pufferlib.emulation",
        "documentation": {}
    },
    {
        "label": "PettingZooPufferEnv",
        "importPath": "pufferlib.emulation",
        "description": "pufferlib.emulation",
        "isExtraImport": true,
        "detail": "pufferlib.emulation",
        "documentation": {}
    },
    {
        "label": "pufferlib.vector",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pufferlib.vector",
        "description": "pufferlib.vector",
        "detail": "pufferlib.vector",
        "documentation": {}
    },
    {
        "label": "Multiprocessing",
        "importPath": "pufferlib.vector",
        "description": "pufferlib.vector",
        "isExtraImport": true,
        "detail": "pufferlib.vector",
        "documentation": {}
    },
    {
        "label": "Serial",
        "importPath": "pufferlib.vector",
        "description": "pufferlib.vector",
        "isExtraImport": true,
        "detail": "pufferlib.vector",
        "documentation": {}
    },
    {
        "label": "Ray",
        "importPath": "pufferlib.vector",
        "description": "pufferlib.vector",
        "isExtraImport": true,
        "detail": "pufferlib.vector",
        "documentation": {}
    },
    {
        "label": "make",
        "importPath": "pufferlib.vector",
        "description": "pufferlib.vector",
        "isExtraImport": true,
        "detail": "pufferlib.vector",
        "documentation": {}
    },
    {
        "label": "autotune",
        "importPath": "pufferlib.vector",
        "description": "pufferlib.vector",
        "isExtraImport": true,
        "detail": "pufferlib.vector",
        "documentation": {}
    },
    {
        "label": "dataclasses",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "dataclasses",
        "description": "dataclasses",
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "gymnasium",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "gymnasium",
        "description": "gymnasium",
        "detail": "gymnasium",
        "documentation": {}
    },
    {
        "label": "Wrapper",
        "importPath": "gymnasium",
        "description": "gymnasium",
        "isExtraImport": true,
        "detail": "gymnasium",
        "documentation": {}
    },
    {
        "label": "spaces",
        "importPath": "gymnasium",
        "description": "gymnasium",
        "isExtraImport": true,
        "detail": "gymnasium",
        "documentation": {}
    },
    {
        "label": "spaces",
        "importPath": "gymnasium",
        "description": "gymnasium",
        "isExtraImport": true,
        "detail": "gymnasium",
        "documentation": {}
    },
    {
        "label": "ObservationWrapper",
        "importPath": "gymnasium",
        "description": "gymnasium",
        "isExtraImport": true,
        "detail": "gymnasium",
        "documentation": {}
    },
    {
        "label": "RewardWrapper",
        "importPath": "gymnasium",
        "description": "gymnasium",
        "isExtraImport": true,
        "detail": "gymnasium",
        "documentation": {}
    },
    {
        "label": "spaces",
        "importPath": "gymnasium",
        "description": "gymnasium",
        "isExtraImport": true,
        "detail": "gymnasium",
        "documentation": {}
    },
    {
        "label": "spaces",
        "importPath": "gymnasium",
        "description": "gymnasium",
        "isExtraImport": true,
        "detail": "gymnasium",
        "documentation": {}
    },
    {
        "label": "spaces",
        "importPath": "gymnasium",
        "description": "gymnasium",
        "isExtraImport": true,
        "detail": "gymnasium",
        "documentation": {}
    },
    {
        "label": "torch.optim",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "torch.optim",
        "description": "torch.optim",
        "detail": "torch.optim",
        "documentation": {}
    },
    {
        "label": "Optimizer",
        "importPath": "torch.optim",
        "description": "torch.optim",
        "isExtraImport": true,
        "detail": "torch.optim",
        "documentation": {}
    },
    {
        "label": "tyro",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "tyro",
        "description": "tyro",
        "detail": "tyro",
        "documentation": {}
    },
    {
        "label": "Categorical",
        "importPath": "torch.distributions.categorical",
        "description": "torch.distributions.categorical",
        "isExtraImport": true,
        "detail": "torch.distributions.categorical",
        "documentation": {}
    },
    {
        "label": "Categorical",
        "importPath": "torch.distributions.categorical",
        "description": "torch.distributions.categorical",
        "isExtraImport": true,
        "detail": "torch.distributions.categorical",
        "documentation": {}
    },
    {
        "label": "Categorical",
        "importPath": "torch.distributions.categorical",
        "description": "torch.distributions.categorical",
        "isExtraImport": true,
        "detail": "torch.distributions.categorical",
        "documentation": {}
    },
    {
        "label": "Categorical",
        "importPath": "torch.distributions.categorical",
        "description": "torch.distributions.categorical",
        "isExtraImport": true,
        "detail": "torch.distributions.categorical",
        "documentation": {}
    },
    {
        "label": "Categorical",
        "importPath": "torch.distributions.categorical",
        "description": "torch.distributions.categorical",
        "isExtraImport": true,
        "detail": "torch.distributions.categorical",
        "documentation": {}
    },
    {
        "label": "Categorical",
        "importPath": "torch.distributions.categorical",
        "description": "torch.distributions.categorical",
        "isExtraImport": true,
        "detail": "torch.distributions.categorical",
        "documentation": {}
    },
    {
        "label": "Categorical",
        "importPath": "torch.distributions.categorical",
        "description": "torch.distributions.categorical",
        "isExtraImport": true,
        "detail": "torch.distributions.categorical",
        "documentation": {}
    },
    {
        "label": "Categorical",
        "importPath": "torch.distributions.categorical",
        "description": "torch.distributions.categorical",
        "isExtraImport": true,
        "detail": "torch.distributions.categorical",
        "documentation": {}
    },
    {
        "label": "Categorical",
        "importPath": "torch.distributions.categorical",
        "description": "torch.distributions.categorical",
        "isExtraImport": true,
        "detail": "torch.distributions.categorical",
        "documentation": {}
    },
    {
        "label": "Categorical",
        "importPath": "torch.distributions.categorical",
        "description": "torch.distributions.categorical",
        "isExtraImport": true,
        "detail": "torch.distributions.categorical",
        "documentation": {}
    },
    {
        "label": "Categorical",
        "importPath": "torch.distributions.categorical",
        "description": "torch.distributions.categorical",
        "isExtraImport": true,
        "detail": "torch.distributions.categorical",
        "documentation": {}
    },
    {
        "label": "SummaryWriter",
        "importPath": "torch.utils.tensorboard",
        "description": "torch.utils.tensorboard",
        "isExtraImport": true,
        "detail": "torch.utils.tensorboard",
        "documentation": {}
    },
    {
        "label": "SummaryWriter",
        "importPath": "torch.utils.tensorboard",
        "description": "torch.utils.tensorboard",
        "isExtraImport": true,
        "detail": "torch.utils.tensorboard",
        "documentation": {}
    },
    {
        "label": "SummaryWriter",
        "importPath": "torch.utils.tensorboard",
        "description": "torch.utils.tensorboard",
        "isExtraImport": true,
        "detail": "torch.utils.tensorboard",
        "documentation": {}
    },
    {
        "label": "SummaryWriter",
        "importPath": "torch.utils.tensorboard",
        "description": "torch.utils.tensorboard",
        "isExtraImport": true,
        "detail": "torch.utils.tensorboard",
        "documentation": {}
    },
    {
        "label": "SummaryWriter",
        "importPath": "torch.utils.tensorboard",
        "description": "torch.utils.tensorboard",
        "isExtraImport": true,
        "detail": "torch.utils.tensorboard",
        "documentation": {}
    },
    {
        "label": "SummaryWriter",
        "importPath": "torch.utils.tensorboard",
        "description": "torch.utils.tensorboard",
        "isExtraImport": true,
        "detail": "torch.utils.tensorboard",
        "documentation": {}
    },
    {
        "label": "SummaryWriter",
        "importPath": "torch.utils.tensorboard",
        "description": "torch.utils.tensorboard",
        "isExtraImport": true,
        "detail": "torch.utils.tensorboard",
        "documentation": {}
    },
    {
        "label": "SummaryWriter",
        "importPath": "torch.utils.tensorboard",
        "description": "torch.utils.tensorboard",
        "isExtraImport": true,
        "detail": "torch.utils.tensorboard",
        "documentation": {}
    },
    {
        "label": "SummaryWriter",
        "importPath": "torch.utils.tensorboard",
        "description": "torch.utils.tensorboard",
        "isExtraImport": true,
        "detail": "torch.utils.tensorboard",
        "documentation": {}
    },
    {
        "label": "SummaryWriter",
        "importPath": "torch.utils.tensorboard",
        "description": "torch.utils.tensorboard",
        "isExtraImport": true,
        "detail": "torch.utils.tensorboard",
        "documentation": {}
    },
    {
        "label": "SummaryWriter",
        "importPath": "torch.utils.tensorboard",
        "description": "torch.utils.tensorboard",
        "isExtraImport": true,
        "detail": "torch.utils.tensorboard",
        "documentation": {}
    },
    {
        "label": "# isort:skip\n    ClipRewardEnv",
        "importPath": "stable_baselines3.common.atari_wrappers",
        "description": "stable_baselines3.common.atari_wrappers",
        "isExtraImport": true,
        "detail": "stable_baselines3.common.atari_wrappers",
        "documentation": {}
    },
    {
        "label": "EpisodicLifeEnv",
        "importPath": "stable_baselines3.common.atari_wrappers",
        "description": "stable_baselines3.common.atari_wrappers",
        "isExtraImport": true,
        "detail": "stable_baselines3.common.atari_wrappers",
        "documentation": {}
    },
    {
        "label": "FireResetEnv",
        "importPath": "stable_baselines3.common.atari_wrappers",
        "description": "stable_baselines3.common.atari_wrappers",
        "isExtraImport": true,
        "detail": "stable_baselines3.common.atari_wrappers",
        "documentation": {}
    },
    {
        "label": "MaxAndSkipEnv",
        "importPath": "stable_baselines3.common.atari_wrappers",
        "description": "stable_baselines3.common.atari_wrappers",
        "isExtraImport": true,
        "detail": "stable_baselines3.common.atari_wrappers",
        "documentation": {}
    },
    {
        "label": "NoopResetEnv",
        "importPath": "stable_baselines3.common.atari_wrappers",
        "description": "stable_baselines3.common.atari_wrappers",
        "isExtraImport": true,
        "detail": "stable_baselines3.common.atari_wrappers",
        "documentation": {}
    },
    {
        "label": "# isort:skip\n    ClipRewardEnv",
        "importPath": "stable_baselines3.common.atari_wrappers",
        "description": "stable_baselines3.common.atari_wrappers",
        "isExtraImport": true,
        "detail": "stable_baselines3.common.atari_wrappers",
        "documentation": {}
    },
    {
        "label": "EpisodicLifeEnv",
        "importPath": "stable_baselines3.common.atari_wrappers",
        "description": "stable_baselines3.common.atari_wrappers",
        "isExtraImport": true,
        "detail": "stable_baselines3.common.atari_wrappers",
        "documentation": {}
    },
    {
        "label": "FireResetEnv",
        "importPath": "stable_baselines3.common.atari_wrappers",
        "description": "stable_baselines3.common.atari_wrappers",
        "isExtraImport": true,
        "detail": "stable_baselines3.common.atari_wrappers",
        "documentation": {}
    },
    {
        "label": "MaxAndSkipEnv",
        "importPath": "stable_baselines3.common.atari_wrappers",
        "description": "stable_baselines3.common.atari_wrappers",
        "isExtraImport": true,
        "detail": "stable_baselines3.common.atari_wrappers",
        "documentation": {}
    },
    {
        "label": "NoopResetEnv",
        "importPath": "stable_baselines3.common.atari_wrappers",
        "description": "stable_baselines3.common.atari_wrappers",
        "isExtraImport": true,
        "detail": "stable_baselines3.common.atari_wrappers",
        "documentation": {}
    },
    {
        "label": "# isort:skip\n    ClipRewardEnv",
        "importPath": "stable_baselines3.common.atari_wrappers",
        "description": "stable_baselines3.common.atari_wrappers",
        "isExtraImport": true,
        "detail": "stable_baselines3.common.atari_wrappers",
        "documentation": {}
    },
    {
        "label": "EpisodicLifeEnv",
        "importPath": "stable_baselines3.common.atari_wrappers",
        "description": "stable_baselines3.common.atari_wrappers",
        "isExtraImport": true,
        "detail": "stable_baselines3.common.atari_wrappers",
        "documentation": {}
    },
    {
        "label": "FireResetEnv",
        "importPath": "stable_baselines3.common.atari_wrappers",
        "description": "stable_baselines3.common.atari_wrappers",
        "isExtraImport": true,
        "detail": "stable_baselines3.common.atari_wrappers",
        "documentation": {}
    },
    {
        "label": "MaxAndSkipEnv",
        "importPath": "stable_baselines3.common.atari_wrappers",
        "description": "stable_baselines3.common.atari_wrappers",
        "isExtraImport": true,
        "detail": "stable_baselines3.common.atari_wrappers",
        "documentation": {}
    },
    {
        "label": "NoopResetEnv",
        "importPath": "stable_baselines3.common.atari_wrappers",
        "description": "stable_baselines3.common.atari_wrappers",
        "isExtraImport": true,
        "detail": "stable_baselines3.common.atari_wrappers",
        "documentation": {}
    },
    {
        "label": "# isort:skip\n    ClipRewardEnv",
        "importPath": "stable_baselines3.common.atari_wrappers",
        "description": "stable_baselines3.common.atari_wrappers",
        "isExtraImport": true,
        "detail": "stable_baselines3.common.atari_wrappers",
        "documentation": {}
    },
    {
        "label": "EpisodicLifeEnv",
        "importPath": "stable_baselines3.common.atari_wrappers",
        "description": "stable_baselines3.common.atari_wrappers",
        "isExtraImport": true,
        "detail": "stable_baselines3.common.atari_wrappers",
        "documentation": {}
    },
    {
        "label": "FireResetEnv",
        "importPath": "stable_baselines3.common.atari_wrappers",
        "description": "stable_baselines3.common.atari_wrappers",
        "isExtraImport": true,
        "detail": "stable_baselines3.common.atari_wrappers",
        "documentation": {}
    },
    {
        "label": "MaxAndSkipEnv",
        "importPath": "stable_baselines3.common.atari_wrappers",
        "description": "stable_baselines3.common.atari_wrappers",
        "isExtraImport": true,
        "detail": "stable_baselines3.common.atari_wrappers",
        "documentation": {}
    },
    {
        "label": "NoopResetEnv",
        "importPath": "stable_baselines3.common.atari_wrappers",
        "description": "stable_baselines3.common.atari_wrappers",
        "isExtraImport": true,
        "detail": "stable_baselines3.common.atari_wrappers",
        "documentation": {}
    },
    {
        "label": "# isort:skip\n    ClipRewardEnv",
        "importPath": "stable_baselines3.common.atari_wrappers",
        "description": "stable_baselines3.common.atari_wrappers",
        "isExtraImport": true,
        "detail": "stable_baselines3.common.atari_wrappers",
        "documentation": {}
    },
    {
        "label": "EpisodicLifeEnv",
        "importPath": "stable_baselines3.common.atari_wrappers",
        "description": "stable_baselines3.common.atari_wrappers",
        "isExtraImport": true,
        "detail": "stable_baselines3.common.atari_wrappers",
        "documentation": {}
    },
    {
        "label": "FireResetEnv",
        "importPath": "stable_baselines3.common.atari_wrappers",
        "description": "stable_baselines3.common.atari_wrappers",
        "isExtraImport": true,
        "detail": "stable_baselines3.common.atari_wrappers",
        "documentation": {}
    },
    {
        "label": "MaxAndSkipEnv",
        "importPath": "stable_baselines3.common.atari_wrappers",
        "description": "stable_baselines3.common.atari_wrappers",
        "isExtraImport": true,
        "detail": "stable_baselines3.common.atari_wrappers",
        "documentation": {}
    },
    {
        "label": "NoopResetEnv",
        "importPath": "stable_baselines3.common.atari_wrappers",
        "description": "stable_baselines3.common.atari_wrappers",
        "isExtraImport": true,
        "detail": "stable_baselines3.common.atari_wrappers",
        "documentation": {}
    },
    {
        "label": "MaxAndSkipEnv",
        "importPath": "stable_baselines3.common.atari_wrappers",
        "description": "stable_baselines3.common.atari_wrappers",
        "isExtraImport": true,
        "detail": "stable_baselines3.common.atari_wrappers",
        "documentation": {}
    },
    {
        "label": "# isort:skip\n    ClipRewardEnv",
        "importPath": "stable_baselines3.common.atari_wrappers",
        "description": "stable_baselines3.common.atari_wrappers",
        "isExtraImport": true,
        "detail": "stable_baselines3.common.atari_wrappers",
        "documentation": {}
    },
    {
        "label": "EpisodicLifeEnv",
        "importPath": "stable_baselines3.common.atari_wrappers",
        "description": "stable_baselines3.common.atari_wrappers",
        "isExtraImport": true,
        "detail": "stable_baselines3.common.atari_wrappers",
        "documentation": {}
    },
    {
        "label": "FireResetEnv",
        "importPath": "stable_baselines3.common.atari_wrappers",
        "description": "stable_baselines3.common.atari_wrappers",
        "isExtraImport": true,
        "detail": "stable_baselines3.common.atari_wrappers",
        "documentation": {}
    },
    {
        "label": "MaxAndSkipEnv",
        "importPath": "stable_baselines3.common.atari_wrappers",
        "description": "stable_baselines3.common.atari_wrappers",
        "isExtraImport": true,
        "detail": "stable_baselines3.common.atari_wrappers",
        "documentation": {}
    },
    {
        "label": "NoopResetEnv",
        "importPath": "stable_baselines3.common.atari_wrappers",
        "description": "stable_baselines3.common.atari_wrappers",
        "isExtraImport": true,
        "detail": "stable_baselines3.common.atari_wrappers",
        "documentation": {}
    },
    {
        "label": "envpool",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "envpool",
        "description": "envpool",
        "detail": "envpool",
        "documentation": {}
    },
    {
        "label": "gym",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "gym",
        "description": "gym",
        "detail": "gym",
        "documentation": {}
    },
    {
        "label": "minihack",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "minihack",
        "description": "minihack",
        "detail": "minihack",
        "documentation": {}
    },
    {
        "label": "shimmy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "shimmy",
        "description": "shimmy",
        "detail": "shimmy",
        "documentation": {}
    },
    {
        "label": "pufferlib.pytorch",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pufferlib.pytorch",
        "description": "pufferlib.pytorch",
        "detail": "pufferlib.pytorch",
        "documentation": {}
    },
    {
        "label": "LSTM",
        "importPath": "pufferlib.pytorch",
        "description": "pufferlib.pytorch",
        "isExtraImport": true,
        "detail": "pufferlib.pytorch",
        "documentation": {}
    },
    {
        "label": "layer_init",
        "importPath": "pufferlib.pytorch",
        "description": "pufferlib.pytorch",
        "isExtraImport": true,
        "detail": "pufferlib.pytorch",
        "documentation": {}
    },
    {
        "label": "layer_init",
        "importPath": "pufferlib.pytorch",
        "description": "pufferlib.pytorch",
        "isExtraImport": true,
        "detail": "pufferlib.pytorch",
        "documentation": {}
    },
    {
        "label": "NativeDType",
        "importPath": "pufferlib.pytorch",
        "description": "pufferlib.pytorch",
        "isExtraImport": true,
        "detail": "pufferlib.pytorch",
        "documentation": {}
    },
    {
        "label": "nativize_dtype",
        "importPath": "pufferlib.pytorch",
        "description": "pufferlib.pytorch",
        "isExtraImport": true,
        "detail": "pufferlib.pytorch",
        "documentation": {}
    },
    {
        "label": "nativize_tensor",
        "importPath": "pufferlib.pytorch",
        "description": "pufferlib.pytorch",
        "isExtraImport": true,
        "detail": "pufferlib.pytorch",
        "documentation": {}
    },
    {
        "label": "pufferlib.environments.minihack",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pufferlib.environments.minihack",
        "description": "pufferlib.environments.minihack",
        "detail": "pufferlib.environments.minihack",
        "documentation": {}
    },
    {
        "label": "set_trace",
        "importPath": "pdb",
        "description": "pdb",
        "isExtraImport": true,
        "detail": "pdb",
        "documentation": {}
    },
    {
        "label": "set_trace",
        "importPath": "pdb",
        "description": "pdb",
        "isExtraImport": true,
        "detail": "pdb",
        "documentation": {}
    },
    {
        "label": "set_trace",
        "importPath": "pdb",
        "description": "pdb",
        "isExtraImport": true,
        "detail": "pdb",
        "documentation": {}
    },
    {
        "label": "set_trace",
        "importPath": "pdb",
        "description": "pdb",
        "isExtraImport": true,
        "detail": "pdb",
        "documentation": {}
    },
    {
        "label": "set_trace",
        "importPath": "pdb",
        "description": "pdb",
        "isExtraImport": true,
        "detail": "pdb",
        "documentation": {}
    },
    {
        "label": "set_trace",
        "importPath": "pdb",
        "description": "pdb",
        "isExtraImport": true,
        "detail": "pdb",
        "documentation": {}
    },
    {
        "label": "set_trace",
        "importPath": "pdb",
        "description": "pdb",
        "isExtraImport": true,
        "detail": "pdb",
        "documentation": {}
    },
    {
        "label": "set_trace",
        "importPath": "pdb",
        "description": "pdb",
        "isExtraImport": true,
        "detail": "pdb",
        "documentation": {}
    },
    {
        "label": "set_trace",
        "importPath": "pdb",
        "description": "pdb",
        "isExtraImport": true,
        "detail": "pdb",
        "documentation": {}
    },
    {
        "label": "set_trace",
        "importPath": "pdb",
        "description": "pdb",
        "isExtraImport": true,
        "detail": "pdb",
        "documentation": {}
    },
    {
        "label": "set_trace",
        "importPath": "pdb",
        "description": "pdb",
        "isExtraImport": true,
        "detail": "pdb",
        "documentation": {}
    },
    {
        "label": "set_trace",
        "importPath": "pdb",
        "description": "pdb",
        "isExtraImport": true,
        "detail": "pdb",
        "documentation": {}
    },
    {
        "label": "set_trace",
        "importPath": "pdb",
        "description": "pdb",
        "isExtraImport": true,
        "detail": "pdb",
        "documentation": {}
    },
    {
        "label": "set_trace",
        "importPath": "pdb",
        "description": "pdb",
        "isExtraImport": true,
        "detail": "pdb",
        "documentation": {}
    },
    {
        "label": "set_trace",
        "importPath": "pdb",
        "description": "pdb",
        "isExtraImport": true,
        "detail": "pdb",
        "documentation": {}
    },
    {
        "label": "set_trace",
        "importPath": "pdb",
        "description": "pdb",
        "isExtraImport": true,
        "detail": "pdb",
        "documentation": {}
    },
    {
        "label": "set_trace",
        "importPath": "pdb",
        "description": "pdb",
        "isExtraImport": true,
        "detail": "pdb",
        "documentation": {}
    },
    {
        "label": "set_trace",
        "importPath": "pdb",
        "description": "pdb",
        "isExtraImport": true,
        "detail": "pdb",
        "documentation": {}
    },
    {
        "label": "set_trace",
        "importPath": "pdb",
        "description": "pdb",
        "isExtraImport": true,
        "detail": "pdb",
        "documentation": {}
    },
    {
        "label": "set_trace",
        "importPath": "pdb",
        "description": "pdb",
        "isExtraImport": true,
        "detail": "pdb",
        "documentation": {}
    },
    {
        "label": "set_trace",
        "importPath": "pdb",
        "description": "pdb",
        "isExtraImport": true,
        "detail": "pdb",
        "documentation": {}
    },
    {
        "label": "set_trace",
        "importPath": "pdb",
        "description": "pdb",
        "isExtraImport": true,
        "detail": "pdb",
        "documentation": {}
    },
    {
        "label": "set_trace",
        "importPath": "pdb",
        "description": "pdb",
        "isExtraImport": true,
        "detail": "pdb",
        "documentation": {}
    },
    {
        "label": "set_trace",
        "importPath": "pdb",
        "description": "pdb",
        "isExtraImport": true,
        "detail": "pdb",
        "documentation": {}
    },
    {
        "label": "set_trace",
        "importPath": "pdb",
        "description": "pdb",
        "isExtraImport": true,
        "detail": "pdb",
        "documentation": {}
    },
    {
        "label": "set_trace",
        "importPath": "pdb",
        "description": "pdb",
        "isExtraImport": true,
        "detail": "pdb",
        "documentation": {}
    },
    {
        "label": "set_trace",
        "importPath": "pdb",
        "description": "pdb",
        "isExtraImport": true,
        "detail": "pdb",
        "documentation": {}
    },
    {
        "label": "set_trace",
        "importPath": "pdb",
        "description": "pdb",
        "isExtraImport": true,
        "detail": "pdb",
        "documentation": {}
    },
    {
        "label": "set_trace",
        "importPath": "pdb",
        "description": "pdb",
        "isExtraImport": true,
        "detail": "pdb",
        "documentation": {}
    },
    {
        "label": "set_trace",
        "importPath": "pdb",
        "description": "pdb",
        "isExtraImport": true,
        "detail": "pdb",
        "documentation": {}
    },
    {
        "label": "set_trace",
        "importPath": "pdb",
        "description": "pdb",
        "isExtraImport": true,
        "detail": "pdb",
        "documentation": {}
    },
    {
        "label": "set_trace",
        "importPath": "pdb",
        "description": "pdb",
        "isExtraImport": true,
        "detail": "pdb",
        "documentation": {}
    },
    {
        "label": "set_trace",
        "importPath": "pdb",
        "description": "pdb",
        "isExtraImport": true,
        "detail": "pdb",
        "documentation": {}
    },
    {
        "label": "set_trace",
        "importPath": "pdb",
        "description": "pdb",
        "isExtraImport": true,
        "detail": "pdb",
        "documentation": {}
    },
    {
        "label": "set_trace",
        "importPath": "pdb",
        "description": "pdb",
        "isExtraImport": true,
        "detail": "pdb",
        "documentation": {}
    },
    {
        "label": "set_trace",
        "importPath": "pdb",
        "description": "pdb",
        "isExtraImport": true,
        "detail": "pdb",
        "documentation": {}
    },
    {
        "label": "set_trace",
        "importPath": "pdb",
        "description": "pdb",
        "isExtraImport": true,
        "detail": "pdb",
        "documentation": {}
    },
    {
        "label": "set_trace",
        "importPath": "pdb",
        "description": "pdb",
        "isExtraImport": true,
        "detail": "pdb",
        "documentation": {}
    },
    {
        "label": "set_trace",
        "importPath": "pdb",
        "description": "pdb",
        "isExtraImport": true,
        "detail": "pdb",
        "documentation": {}
    },
    {
        "label": "set_trace",
        "importPath": "pdb",
        "description": "pdb",
        "isExtraImport": true,
        "detail": "pdb",
        "documentation": {}
    },
    {
        "label": "set_trace",
        "importPath": "pdb",
        "description": "pdb",
        "isExtraImport": true,
        "detail": "pdb",
        "documentation": {}
    },
    {
        "label": "set_trace",
        "importPath": "pdb",
        "description": "pdb",
        "isExtraImport": true,
        "detail": "pdb",
        "documentation": {}
    },
    {
        "label": "set_trace",
        "importPath": "pdb",
        "description": "pdb",
        "isExtraImport": true,
        "detail": "pdb",
        "documentation": {}
    },
    {
        "label": "set_trace",
        "importPath": "pdb",
        "description": "pdb",
        "isExtraImport": true,
        "detail": "pdb",
        "documentation": {}
    },
    {
        "label": "set_trace",
        "importPath": "pdb",
        "description": "pdb",
        "isExtraImport": true,
        "detail": "pdb",
        "documentation": {}
    },
    {
        "label": "set_trace",
        "importPath": "pdb",
        "description": "pdb",
        "isExtraImport": true,
        "detail": "pdb",
        "documentation": {}
    },
    {
        "label": "set_trace",
        "importPath": "pdb",
        "description": "pdb",
        "isExtraImport": true,
        "detail": "pdb",
        "documentation": {}
    },
    {
        "label": "set_trace",
        "importPath": "pdb",
        "description": "pdb",
        "isExtraImport": true,
        "detail": "pdb",
        "documentation": {}
    },
    {
        "label": "set_trace",
        "importPath": "pdb",
        "description": "pdb",
        "isExtraImport": true,
        "detail": "pdb",
        "documentation": {}
    },
    {
        "label": "set_trace",
        "importPath": "pdb",
        "description": "pdb",
        "isExtraImport": true,
        "detail": "pdb",
        "documentation": {}
    },
    {
        "label": "set_trace",
        "importPath": "pdb",
        "description": "pdb",
        "isExtraImport": true,
        "detail": "pdb",
        "documentation": {}
    },
    {
        "label": "set_trace",
        "importPath": "pdb",
        "description": "pdb",
        "isExtraImport": true,
        "detail": "pdb",
        "documentation": {}
    },
    {
        "label": "set_trace",
        "importPath": "pdb",
        "description": "pdb",
        "isExtraImport": true,
        "detail": "pdb",
        "documentation": {}
    },
    {
        "label": "set_trace",
        "importPath": "pdb",
        "description": "pdb",
        "isExtraImport": true,
        "detail": "pdb",
        "documentation": {}
    },
    {
        "label": "set_trace",
        "importPath": "pdb",
        "description": "pdb",
        "isExtraImport": true,
        "detail": "pdb",
        "documentation": {}
    },
    {
        "label": "set_trace",
        "importPath": "pdb",
        "description": "pdb",
        "isExtraImport": true,
        "detail": "pdb",
        "documentation": {}
    },
    {
        "label": "set_trace",
        "importPath": "pdb",
        "description": "pdb",
        "isExtraImport": true,
        "detail": "pdb",
        "documentation": {}
    },
    {
        "label": "set_trace",
        "importPath": "pdb",
        "description": "pdb",
        "isExtraImport": true,
        "detail": "pdb",
        "documentation": {}
    },
    {
        "label": "set_trace",
        "importPath": "pdb",
        "description": "pdb",
        "isExtraImport": true,
        "detail": "pdb",
        "documentation": {}
    },
    {
        "label": "set_trace",
        "importPath": "pdb",
        "description": "pdb",
        "isExtraImport": true,
        "detail": "pdb",
        "documentation": {}
    },
    {
        "label": "set_trace",
        "importPath": "pdb",
        "description": "pdb",
        "isExtraImport": true,
        "detail": "pdb",
        "documentation": {}
    },
    {
        "label": "set_trace",
        "importPath": "pdb",
        "description": "pdb",
        "isExtraImport": true,
        "detail": "pdb",
        "documentation": {}
    },
    {
        "label": "set_trace",
        "importPath": "pdb",
        "description": "pdb",
        "isExtraImport": true,
        "detail": "pdb",
        "documentation": {}
    },
    {
        "label": "set_trace",
        "importPath": "pdb",
        "description": "pdb",
        "isExtraImport": true,
        "detail": "pdb",
        "documentation": {}
    },
    {
        "label": "set_trace",
        "importPath": "pdb",
        "description": "pdb",
        "isExtraImport": true,
        "detail": "pdb",
        "documentation": {}
    },
    {
        "label": "set_trace",
        "importPath": "pdb",
        "description": "pdb",
        "isExtraImport": true,
        "detail": "pdb",
        "documentation": {}
    },
    {
        "label": "set_trace",
        "importPath": "pdb",
        "description": "pdb",
        "isExtraImport": true,
        "detail": "pdb",
        "documentation": {}
    },
    {
        "label": "set_trace",
        "importPath": "pdb",
        "description": "pdb",
        "isExtraImport": true,
        "detail": "pdb",
        "documentation": {}
    },
    {
        "label": "set_trace",
        "importPath": "pdb",
        "description": "pdb",
        "isExtraImport": true,
        "detail": "pdb",
        "documentation": {}
    },
    {
        "label": "functools",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "functools",
        "description": "functools",
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "partial",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "partial",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "partial",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "partial",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "partial",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "partial",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "wraps",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "wraps",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "partial",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "wraps",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "wraps",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "lru_cache",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "lru_cache",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "lru_cache",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "lru_cache",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "lru_cache",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "lru_cache",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "pufferlib.utils",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pufferlib.utils",
        "description": "pufferlib.utils",
        "detail": "pufferlib.utils",
        "documentation": {}
    },
    {
        "label": "pufferlib.postprocess",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pufferlib.postprocess",
        "description": "pufferlib.postprocess",
        "detail": "pufferlib.postprocess",
        "documentation": {}
    },
    {
        "label": "pufferlib.models",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pufferlib.models",
        "description": "pufferlib.models",
        "detail": "pufferlib.models",
        "documentation": {}
    },
    {
        "label": "Default",
        "importPath": "pufferlib.models",
        "description": "pufferlib.models",
        "isExtraImport": true,
        "detail": "pufferlib.models",
        "documentation": {}
    },
    {
        "label": "Default",
        "importPath": "pufferlib.models",
        "description": "pufferlib.models",
        "isExtraImport": true,
        "detail": "pufferlib.models",
        "documentation": {}
    },
    {
        "label": "Default",
        "importPath": "pufferlib.models",
        "description": "pufferlib.models",
        "isExtraImport": true,
        "detail": "pufferlib.models",
        "documentation": {}
    },
    {
        "label": "Default",
        "importPath": "pufferlib.models",
        "description": "pufferlib.models",
        "isExtraImport": true,
        "detail": "pufferlib.models",
        "documentation": {}
    },
    {
        "label": "Default",
        "importPath": "pufferlib.models",
        "description": "pufferlib.models",
        "isExtraImport": true,
        "detail": "pufferlib.models",
        "documentation": {}
    },
    {
        "label": "Default",
        "importPath": "pufferlib.models",
        "description": "pufferlib.models",
        "isExtraImport": true,
        "detail": "pufferlib.models",
        "documentation": {}
    },
    {
        "label": "Default",
        "importPath": "pufferlib.models",
        "description": "pufferlib.models",
        "isExtraImport": true,
        "detail": "pufferlib.models",
        "documentation": {}
    },
    {
        "label": "Default",
        "importPath": "pufferlib.models",
        "description": "pufferlib.models",
        "isExtraImport": true,
        "detail": "pufferlib.models",
        "documentation": {}
    },
    {
        "label": "Default",
        "importPath": "pufferlib.models",
        "description": "pufferlib.models",
        "isExtraImport": true,
        "detail": "pufferlib.models",
        "documentation": {}
    },
    {
        "label": "Policy",
        "importPath": "pufferlib.models",
        "description": "pufferlib.models",
        "isExtraImport": true,
        "detail": "pufferlib.models",
        "documentation": {}
    },
    {
        "label": "Default",
        "importPath": "pufferlib.models",
        "description": "pufferlib.models",
        "isExtraImport": true,
        "detail": "pufferlib.models",
        "documentation": {}
    },
    {
        "label": "Default",
        "importPath": "pufferlib.models",
        "description": "pufferlib.models",
        "isExtraImport": true,
        "detail": "pufferlib.models",
        "documentation": {}
    },
    {
        "label": "pufferlib.wrappers",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pufferlib.wrappers",
        "description": "pufferlib.wrappers",
        "detail": "pufferlib.wrappers",
        "documentation": {}
    },
    {
        "label": "bsuite",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "bsuite",
        "description": "bsuite",
        "detail": "bsuite",
        "documentation": {}
    },
    {
        "label": "gym_wrapper",
        "importPath": "bsuite.utils",
        "description": "bsuite.utils",
        "isExtraImport": true,
        "detail": "bsuite.utils",
        "documentation": {}
    },
    {
        "label": "aec_to_parallel_wrapper",
        "importPath": "pettingzoo.utils.conversions",
        "description": "pettingzoo.utils.conversions",
        "isExtraImport": true,
        "detail": "pettingzoo.utils.conversions",
        "documentation": {}
    },
    {
        "label": "aec_to_parallel_wrapper",
        "importPath": "pettingzoo.utils.conversions",
        "description": "pettingzoo.utils.conversions",
        "isExtraImport": true,
        "detail": "pettingzoo.utils.conversions",
        "documentation": {}
    },
    {
        "label": "classic_control",
        "importPath": "gymnasium.envs",
        "description": "gymnasium.envs",
        "isExtraImport": true,
        "detail": "gymnasium.envs",
        "documentation": {}
    },
    {
        "label": "EnvConfig",
        "importPath": "pygpudrive.env.config",
        "description": "pygpudrive.env.config",
        "isExtraImport": true,
        "detail": "pygpudrive.env.config",
        "documentation": {}
    },
    {
        "label": "RenderConfig",
        "importPath": "pygpudrive.env.config",
        "description": "pygpudrive.env.config",
        "isExtraImport": true,
        "detail": "pygpudrive.env.config",
        "documentation": {}
    },
    {
        "label": "SceneConfig",
        "importPath": "pygpudrive.env.config",
        "description": "pygpudrive.env.config",
        "isExtraImport": true,
        "detail": "pygpudrive.env.config",
        "documentation": {}
    },
    {
        "label": "SelectionDiscipline",
        "importPath": "pygpudrive.env.config",
        "description": "pygpudrive.env.config",
        "isExtraImport": true,
        "detail": "pygpudrive.env.config",
        "documentation": {}
    },
    {
        "label": "GPUDriveTorchEnv",
        "importPath": "pygpudrive.env.env_torch",
        "description": "pygpudrive.env.env_torch",
        "isExtraImport": true,
        "detail": "pygpudrive.env.env_torch",
        "documentation": {}
    },
    {
        "label": "LinksAwakenV1",
        "importPath": "links_awaken",
        "description": "links_awaken",
        "isExtraImport": true,
        "detail": "links_awaken",
        "documentation": {}
    },
    {
        "label": "warnings",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "warnings",
        "description": "warnings",
        "detail": "warnings",
        "documentation": {}
    },
    {
        "label": "Policy",
        "importPath": "pufferlib.environments.nethack",
        "description": "pufferlib.environments.nethack",
        "isExtraImport": true,
        "detail": "pufferlib.environments.nethack",
        "documentation": {}
    },
    {
        "label": "configparser",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "configparser",
        "description": "configparser",
        "detail": "configparser",
        "documentation": {}
    },
    {
        "label": "ast",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "ast",
        "description": "ast",
        "detail": "ast",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "ast",
        "description": "ast",
        "isExtraImport": true,
        "detail": "ast",
        "documentation": {}
    },
    {
        "label": "pufferlib.frameworks.cleanrl",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pufferlib.frameworks.cleanrl",
        "description": "pufferlib.frameworks.cleanrl",
        "detail": "pufferlib.frameworks.cleanrl",
        "documentation": {}
    },
    {
        "label": "cleanrl_env_creator",
        "importPath": "pufferlib.environments.mujoco.environment",
        "description": "pufferlib.environments.mujoco.environment",
        "isExtraImport": true,
        "detail": "pufferlib.environments.mujoco.environment",
        "documentation": {}
    },
    {
        "label": "CleanRLPolicy",
        "importPath": "pufferlib.environments.mujoco.policy",
        "description": "pufferlib.environments.mujoco.policy",
        "isExtraImport": true,
        "detail": "pufferlib.environments.mujoco.policy",
        "documentation": {}
    },
    {
        "label": "Policy",
        "importPath": "pufferlib.environments.mujoco.policy",
        "description": "pufferlib.environments.mujoco.policy",
        "isExtraImport": true,
        "detail": "pufferlib.environments.mujoco.policy",
        "documentation": {}
    },
    {
        "label": "cv2",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "cv2",
        "description": "cv2",
        "detail": "cv2",
        "documentation": {}
    },
    {
        "label": "exp",
        "importPath": "cv2",
        "description": "cv2",
        "isExtraImport": true,
        "detail": "cv2",
        "documentation": {}
    },
    {
        "label": "njit",
        "importPath": "numba",
        "description": "numba",
        "isExtraImport": true,
        "detail": "numba",
        "documentation": {}
    },
    {
        "label": "njit",
        "importPath": "numba",
        "description": "numba",
        "isExtraImport": true,
        "detail": "numba",
        "documentation": {}
    },
    {
        "label": "nle",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "nle",
        "description": "nle",
        "detail": "nle",
        "documentation": {}
    },
    {
        "label": "nethack",
        "importPath": "nle",
        "description": "nle",
        "isExtraImport": true,
        "detail": "nle",
        "documentation": {}
    },
    {
        "label": "nethack",
        "importPath": "nle",
        "description": "nle",
        "isExtraImport": true,
        "detail": "nle",
        "documentation": {}
    },
    {
        "label": "nethack",
        "importPath": "nle",
        "description": "nle",
        "isExtraImport": true,
        "detail": "nle",
        "documentation": {}
    },
    {
        "label": "nethack",
        "importPath": "nle",
        "description": "nle",
        "isExtraImport": true,
        "detail": "nle",
        "documentation": {}
    },
    {
        "label": "Image",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "ImageDraw",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "ImageFont",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "Image",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "Image",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "Image",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "Image",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "ImageDraw",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "ImageFont",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "EntityState",
        "importPath": "nmmo.entity.entity",
        "description": "nmmo.entity.entity",
        "isExtraImport": true,
        "detail": "nmmo.entity.entity",
        "documentation": {}
    },
    {
        "label": "PuffEnv",
        "importPath": "nmmo3",
        "description": "nmmo3",
        "isExtraImport": true,
        "detail": "nmmo3",
        "documentation": {}
    },
    {
        "label": "render",
        "importPath": "pufferlib.environments.ocean",
        "description": "pufferlib.environments.ocean",
        "isExtraImport": true,
        "detail": "pufferlib.environments.ocean",
        "documentation": {}
    },
    {
        "label": "render",
        "importPath": "pufferlib.environments.ocean",
        "description": "pufferlib.environments.ocean",
        "isExtraImport": true,
        "detail": "pufferlib.environments.ocean",
        "documentation": {}
    },
    {
        "label": "render",
        "importPath": "pufferlib.environments.ocean",
        "description": "pufferlib.environments.ocean",
        "isExtraImport": true,
        "detail": "pufferlib.environments.ocean",
        "documentation": {}
    },
    {
        "label": "render",
        "importPath": "pufferlib.environments.ocean",
        "description": "pufferlib.environments.ocean",
        "isExtraImport": true,
        "detail": "pufferlib.environments.ocean",
        "documentation": {}
    },
    {
        "label": "env_creator",
        "importPath": "pufferlib.environments.ocean",
        "description": "pufferlib.environments.ocean",
        "isExtraImport": true,
        "detail": "pufferlib.environments.ocean",
        "documentation": {}
    },
    {
        "label": "Environment",
        "importPath": "pufferlib.environments.ocean.grid.c_grid",
        "description": "pufferlib.environments.ocean.grid.c_grid",
        "isExtraImport": true,
        "detail": "pufferlib.environments.ocean.grid.c_grid",
        "documentation": {}
    },
    {
        "label": "precompute_pathing",
        "importPath": "c_precompute_pathing",
        "description": "c_precompute_pathing",
        "isExtraImport": true,
        "detail": "c_precompute_pathing",
        "documentation": {}
    },
    {
        "label": "precompute_pathing",
        "importPath": "c_precompute_pathing",
        "description": "c_precompute_pathing",
        "isExtraImport": true,
        "detail": "c_precompute_pathing",
        "documentation": {}
    },
    {
        "label": "pettingzoo",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pettingzoo",
        "description": "pettingzoo",
        "detail": "pettingzoo",
        "documentation": {}
    },
    {
        "label": "Environment",
        "importPath": "pufferlib.environments.ocean.moba.cy_moba",
        "description": "pufferlib.environments.ocean.moba.cy_moba",
        "isExtraImport": true,
        "detail": "pufferlib.environments.ocean.moba.cy_moba",
        "documentation": {}
    },
    {
        "label": "entity_dtype",
        "importPath": "pufferlib.environments.ocean.moba.cy_moba",
        "description": "pufferlib.environments.ocean.moba.cy_moba",
        "isExtraImport": true,
        "detail": "pufferlib.environments.ocean.moba.cy_moba",
        "documentation": {}
    },
    {
        "label": "reward_dtype",
        "importPath": "pufferlib.environments.ocean.moba.cy_moba",
        "description": "pufferlib.environments.ocean.moba.cy_moba",
        "isExtraImport": true,
        "detail": "pufferlib.environments.ocean.moba.cy_moba",
        "documentation": {}
    },
    {
        "label": "step_all",
        "importPath": "pufferlib.environments.ocean.moba.cy_moba",
        "description": "pufferlib.environments.ocean.moba.cy_moba",
        "isExtraImport": true,
        "detail": "pufferlib.environments.ocean.moba.cy_moba",
        "documentation": {}
    },
    {
        "label": "precompute_pathing",
        "importPath": "pufferlib.environments.ocean.moba.c_precompute_pathing",
        "description": "pufferlib.environments.ocean.moba.c_precompute_pathing",
        "isExtraImport": true,
        "detail": "pufferlib.environments.ocean.moba.c_precompute_pathing",
        "documentation": {}
    },
    {
        "label": "pyximport",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pyximport",
        "description": "pyximport",
        "detail": "pyximport",
        "documentation": {}
    },
    {
        "label": "GridRender",
        "importPath": "pufferlib.environments.ocean.render",
        "description": "pufferlib.environments.ocean.render",
        "isExtraImport": true,
        "detail": "pufferlib.environments.ocean.render",
        "documentation": {}
    },
    {
        "label": "cdata_to_numpy",
        "importPath": "pufferlib.environments.ocean.render",
        "description": "pufferlib.environments.ocean.render",
        "isExtraImport": true,
        "detail": "pufferlib.environments.ocean.render",
        "documentation": {}
    },
    {
        "label": "player_dtype",
        "importPath": "c_test",
        "description": "c_test",
        "isExtraImport": true,
        "detail": "c_test",
        "documentation": {}
    },
    {
        "label": "test_struct",
        "importPath": "c_test",
        "description": "c_test",
        "isExtraImport": true,
        "detail": "c_test",
        "documentation": {}
    },
    {
        "label": "test_struct_view",
        "importPath": "c_test",
        "description": "c_test",
        "isExtraImport": true,
        "detail": "c_test",
        "documentation": {}
    },
    {
        "label": "CPong",
        "importPath": "pufferlib.environments.ocean.pong.cy_pong",
        "description": "pufferlib.environments.ocean.pong.cy_pong",
        "isExtraImport": true,
        "detail": "pufferlib.environments.ocean.pong.cy_pong",
        "documentation": {}
    },
    {
        "label": "Snake",
        "importPath": "cysnake",
        "description": "cysnake",
        "isExtraImport": true,
        "detail": "cysnake",
        "documentation": {}
    },
    {
        "label": "CSnake",
        "importPath": "pufferlib.environments.ocean.snake.c_snake",
        "description": "pufferlib.environments.ocean.snake.c_snake",
        "isExtraImport": true,
        "detail": "pufferlib.environments.ocean.snake.c_snake",
        "documentation": {}
    },
    {
        "label": "step_all",
        "importPath": "pufferlib.environments.ocean.snake.c_snake",
        "description": "pufferlib.environments.ocean.snake.c_snake",
        "isExtraImport": true,
        "detail": "pufferlib.environments.ocean.snake.c_snake",
        "documentation": {}
    },
    {
        "label": "mcts",
        "importPath": "open_spiel.python.algorithms",
        "description": "open_spiel.python.algorithms",
        "isExtraImport": true,
        "detail": "open_spiel.python.algorithms",
        "documentation": {}
    },
    {
        "label": "solve_chance_nodes",
        "importPath": "pufferlib.environments.open_spiel.utils",
        "description": "pufferlib.environments.open_spiel.utils",
        "isExtraImport": true,
        "detail": "pufferlib.environments.open_spiel.utils",
        "documentation": {}
    },
    {
        "label": "get_obs_and_infos",
        "importPath": "pufferlib.environments.open_spiel.utils",
        "description": "pufferlib.environments.open_spiel.utils",
        "isExtraImport": true,
        "detail": "pufferlib.environments.open_spiel.utils",
        "documentation": {}
    },
    {
        "label": "observation_space",
        "importPath": "pufferlib.environments.open_spiel.utils",
        "description": "pufferlib.environments.open_spiel.utils",
        "isExtraImport": true,
        "detail": "pufferlib.environments.open_spiel.utils",
        "documentation": {}
    },
    {
        "label": "action_space",
        "importPath": "pufferlib.environments.open_spiel.utils",
        "description": "pufferlib.environments.open_spiel.utils",
        "isExtraImport": true,
        "detail": "pufferlib.environments.open_spiel.utils",
        "documentation": {}
    },
    {
        "label": "init",
        "importPath": "pufferlib.environments.open_spiel.utils",
        "description": "pufferlib.environments.open_spiel.utils",
        "isExtraImport": true,
        "detail": "pufferlib.environments.open_spiel.utils",
        "documentation": {}
    },
    {
        "label": "render",
        "importPath": "pufferlib.environments.open_spiel.utils",
        "description": "pufferlib.environments.open_spiel.utils",
        "isExtraImport": true,
        "detail": "pufferlib.environments.open_spiel.utils",
        "documentation": {}
    },
    {
        "label": "close",
        "importPath": "pufferlib.environments.open_spiel.utils",
        "description": "pufferlib.environments.open_spiel.utils",
        "isExtraImport": true,
        "detail": "pufferlib.environments.open_spiel.utils",
        "documentation": {}
    },
    {
        "label": "solve_chance_nodes",
        "importPath": "pufferlib.environments.open_spiel.utils",
        "description": "pufferlib.environments.open_spiel.utils",
        "isExtraImport": true,
        "detail": "pufferlib.environments.open_spiel.utils",
        "documentation": {}
    },
    {
        "label": "get_obs_and_infos",
        "importPath": "pufferlib.environments.open_spiel.utils",
        "description": "pufferlib.environments.open_spiel.utils",
        "isExtraImport": true,
        "detail": "pufferlib.environments.open_spiel.utils",
        "documentation": {}
    },
    {
        "label": "observation_space",
        "importPath": "pufferlib.environments.open_spiel.utils",
        "description": "pufferlib.environments.open_spiel.utils",
        "isExtraImport": true,
        "detail": "pufferlib.environments.open_spiel.utils",
        "documentation": {}
    },
    {
        "label": "action_space",
        "importPath": "pufferlib.environments.open_spiel.utils",
        "description": "pufferlib.environments.open_spiel.utils",
        "isExtraImport": true,
        "detail": "pufferlib.environments.open_spiel.utils",
        "documentation": {}
    },
    {
        "label": "init",
        "importPath": "pufferlib.environments.open_spiel.utils",
        "description": "pufferlib.environments.open_spiel.utils",
        "isExtraImport": true,
        "detail": "pufferlib.environments.open_spiel.utils",
        "documentation": {}
    },
    {
        "label": "render",
        "importPath": "pufferlib.environments.open_spiel.utils",
        "description": "pufferlib.environments.open_spiel.utils",
        "isExtraImport": true,
        "detail": "pufferlib.environments.open_spiel.utils",
        "documentation": {}
    },
    {
        "label": "close",
        "importPath": "pufferlib.environments.open_spiel.utils",
        "description": "pufferlib.environments.open_spiel.utils",
        "isExtraImport": true,
        "detail": "pufferlib.environments.open_spiel.utils",
        "documentation": {}
    },
    {
        "label": "Environment",
        "importPath": "pokegym",
        "description": "pokegym",
        "isExtraImport": true,
        "detail": "pokegym",
        "documentation": {}
    },
    {
        "label": "Box",
        "importPath": "gymnasium.spaces",
        "description": "gymnasium.spaces",
        "isExtraImport": true,
        "detail": "gymnasium.spaces",
        "documentation": {}
    },
    {
        "label": "Discrete",
        "importPath": "gymnasium.spaces",
        "description": "gymnasium.spaces",
        "isExtraImport": true,
        "detail": "gymnasium.spaces",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "gymnasium.spaces",
        "description": "gymnasium.spaces",
        "isExtraImport": true,
        "detail": "gymnasium.spaces",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "gymnasium.spaces",
        "description": "gymnasium.spaces",
        "isExtraImport": true,
        "detail": "gymnasium.spaces",
        "documentation": {}
    },
    {
        "label": "Box",
        "importPath": "gymnasium.spaces",
        "description": "gymnasium.spaces",
        "isExtraImport": true,
        "detail": "gymnasium.spaces",
        "documentation": {}
    },
    {
        "label": "Discrete",
        "importPath": "gymnasium.spaces",
        "description": "gymnasium.spaces",
        "isExtraImport": true,
        "detail": "gymnasium.spaces",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "gymnasium.spaces",
        "description": "gymnasium.spaces",
        "isExtraImport": true,
        "detail": "gymnasium.spaces",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "gymnasium.spaces",
        "description": "gymnasium.spaces",
        "isExtraImport": true,
        "detail": "gymnasium.spaces",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "gymnasium.spaces",
        "description": "gymnasium.spaces",
        "isExtraImport": true,
        "detail": "gymnasium.spaces",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "gymnasium.spaces",
        "description": "gymnasium.spaces",
        "isExtraImport": true,
        "detail": "gymnasium.spaces",
        "documentation": {}
    },
    {
        "label": "Box",
        "importPath": "gymnasium.spaces",
        "description": "gymnasium.spaces",
        "isExtraImport": true,
        "detail": "gymnasium.spaces",
        "documentation": {}
    },
    {
        "label": "Discrete",
        "importPath": "gymnasium.spaces",
        "description": "gymnasium.spaces",
        "isExtraImport": true,
        "detail": "gymnasium.spaces",
        "documentation": {}
    },
    {
        "label": "Box",
        "importPath": "gymnasium.spaces",
        "description": "gymnasium.spaces",
        "isExtraImport": true,
        "detail": "gymnasium.spaces",
        "documentation": {}
    },
    {
        "label": "Discrete",
        "importPath": "gymnasium.spaces",
        "description": "gymnasium.spaces",
        "isExtraImport": true,
        "detail": "gymnasium.spaces",
        "documentation": {}
    },
    {
        "label": "Discrete",
        "importPath": "gymnasium.spaces",
        "description": "gymnasium.spaces",
        "isExtraImport": true,
        "detail": "gymnasium.spaces",
        "documentation": {}
    },
    {
        "label": "Box",
        "importPath": "gymnasium.spaces",
        "description": "gymnasium.spaces",
        "isExtraImport": true,
        "detail": "gymnasium.spaces",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "gymnasium.spaces",
        "description": "gymnasium.spaces",
        "isExtraImport": true,
        "detail": "gymnasium.spaces",
        "documentation": {}
    },
    {
        "label": "ParallelEnv",
        "importPath": "pettingzoo.utils.env",
        "description": "pettingzoo.utils.env",
        "isExtraImport": true,
        "detail": "pettingzoo.utils.env",
        "documentation": {}
    },
    {
        "label": "ParallelEnv",
        "importPath": "pettingzoo.utils.env",
        "description": "pettingzoo.utils.env",
        "isExtraImport": true,
        "detail": "pettingzoo.utils.env",
        "documentation": {}
    },
    {
        "label": "logits_to_probs",
        "importPath": "torch.distributions.utils",
        "description": "torch.distributions.utils",
        "isExtraImport": true,
        "detail": "torch.distributions.utils",
        "documentation": {}
    },
    {
        "label": "RLPredictor",
        "importPath": "ray.train.rl.rl_predictor",
        "description": "ray.train.rl.rl_predictor",
        "isExtraImport": true,
        "detail": "ray.train.rl.rl_predictor",
        "documentation": {}
    },
    {
        "label": "RLCheckpoint",
        "importPath": "ray.train.rl",
        "description": "ray.train.rl",
        "isExtraImport": true,
        "detail": "ray.train.rl",
        "documentation": {}
    },
    {
        "label": "register_env",
        "importPath": "ray.tune.registry",
        "description": "ray.tune.registry",
        "isExtraImport": true,
        "detail": "ray.tune.registry",
        "documentation": {}
    },
    {
        "label": "register_env",
        "importPath": "ray.tune.registry",
        "description": "ray.tune.registry",
        "isExtraImport": true,
        "detail": "ray.tune.registry",
        "documentation": {}
    },
    {
        "label": "RecurrentNetwork",
        "importPath": "ray.rllib.models.torch.recurrent_net",
        "description": "ray.rllib.models.torch.recurrent_net",
        "isExtraImport": true,
        "detail": "ray.rllib.models.torch.recurrent_net",
        "documentation": {}
    },
    {
        "label": "TorchModelV2",
        "importPath": "ray.rllib.models.torch.torch_modelv2",
        "description": "ray.rllib.models.torch.torch_modelv2",
        "isExtraImport": true,
        "detail": "ray.rllib.models.torch.torch_modelv2",
        "documentation": {}
    },
    {
        "label": "TorchModelV2",
        "importPath": "ray.rllib.models.torch.torch_modelv2",
        "description": "ray.rllib.models.torch.torch_modelv2",
        "isExtraImport": true,
        "detail": "ray.rllib.models.torch.torch_modelv2",
        "documentation": {}
    },
    {
        "label": "DefaultCallbacks",
        "importPath": "ray.rllib.algorithms.callbacks",
        "description": "ray.rllib.algorithms.callbacks",
        "isExtraImport": true,
        "detail": "ray.rllib.algorithms.callbacks",
        "documentation": {}
    },
    {
        "label": "PolicySpec",
        "importPath": "ray.rllib.policy.policy",
        "description": "ray.rllib.policy.policy",
        "isExtraImport": true,
        "detail": "ray.rllib.policy.policy",
        "documentation": {}
    },
    {
        "label": "ParallelPettingZooEnv",
        "importPath": "ray.rllib.env",
        "description": "ray.rllib.env",
        "isExtraImport": true,
        "detail": "ray.rllib.env",
        "documentation": {}
    },
    {
        "label": "inspect",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "inspect",
        "description": "inspect",
        "detail": "inspect",
        "documentation": {}
    },
    {
        "label": "signature",
        "importPath": "inspect",
        "description": "inspect",
        "isExtraImport": true,
        "detail": "inspect",
        "documentation": {}
    },
    {
        "label": "pufferlib.spaces",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pufferlib.spaces",
        "description": "pufferlib.spaces",
        "detail": "pufferlib.spaces",
        "documentation": {}
    },
    {
        "label": "Discrete",
        "importPath": "pufferlib.spaces",
        "description": "pufferlib.spaces",
        "isExtraImport": true,
        "detail": "pufferlib.spaces",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "pufferlib.spaces",
        "description": "pufferlib.spaces",
        "isExtraImport": true,
        "detail": "pufferlib.spaces",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "pufferlib.spaces",
        "description": "pufferlib.spaces",
        "isExtraImport": true,
        "detail": "pufferlib.spaces",
        "documentation": {}
    },
    {
        "label": "Mapping",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Mapping",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "pufferlib.exceptions",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pufferlib.exceptions",
        "description": "pufferlib.exceptions",
        "detail": "pufferlib.exceptions",
        "documentation": {}
    },
    {
        "label": "APIUsageError",
        "importPath": "pufferlib.exceptions",
        "description": "pufferlib.exceptions",
        "isExtraImport": true,
        "detail": "pufferlib.exceptions",
        "documentation": {}
    },
    {
        "label": "APIUsageError",
        "importPath": "pufferlib.exceptions",
        "description": "pufferlib.exceptions",
        "isExtraImport": true,
        "detail": "pufferlib.exceptions",
        "documentation": {}
    },
    {
        "label": "InvalidAgentError",
        "importPath": "pufferlib.exceptions",
        "description": "pufferlib.exceptions",
        "isExtraImport": true,
        "detail": "pufferlib.exceptions",
        "documentation": {}
    },
    {
        "label": "sqlite3",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sqlite3",
        "description": "sqlite3",
        "detail": "sqlite3",
        "documentation": {}
    },
    {
        "label": "mmap",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "mmap",
        "description": "mmap",
        "detail": "mmap",
        "documentation": {}
    },
    {
        "label": "errno",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "errno",
        "description": "errno",
        "detail": "errno",
        "documentation": {}
    },
    {
        "label": "struct",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "struct",
        "description": "struct",
        "detail": "struct",
        "documentation": {}
    },
    {
        "label": "secrets",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "secrets",
        "description": "secrets",
        "detail": "secrets",
        "documentation": {}
    },
    {
        "label": "pickle",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pickle",
        "description": "pickle",
        "detail": "pickle",
        "documentation": {}
    },
    {
        "label": "psutil",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "psutil",
        "description": "psutil",
        "detail": "psutil",
        "documentation": {}
    },
    {
        "label": "Namespace",
        "importPath": "pufferlib.namespace",
        "description": "pufferlib.namespace",
        "isExtraImport": true,
        "detail": "pufferlib.namespace",
        "documentation": {}
    },
    {
        "label": "plotly.graph_objects",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "plotly.graph_objects",
        "description": "plotly.graph_objects",
        "detail": "plotly.graph_objects",
        "documentation": {}
    },
    {
        "label": "selectors",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "selectors",
        "description": "selectors",
        "detail": "selectors",
        "documentation": {}
    },
    {
        "label": "pufferlib.vectorization",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pufferlib.vectorization",
        "description": "pufferlib.vectorization",
        "detail": "pufferlib.vectorization",
        "documentation": {}
    },
    {
        "label": "Serial",
        "importPath": "pufferlib.vectorization",
        "description": "pufferlib.vectorization",
        "isExtraImport": true,
        "detail": "pufferlib.vectorization",
        "documentation": {}
    },
    {
        "label": "Multiprocessing",
        "importPath": "pufferlib.vectorization",
        "description": "pufferlib.vectorization",
        "isExtraImport": true,
        "detail": "pufferlib.vectorization",
        "documentation": {}
    },
    {
        "label": "Ray",
        "importPath": "pufferlib.vectorization",
        "description": "pufferlib.vectorization",
        "isExtraImport": true,
        "detail": "pufferlib.vectorization",
        "documentation": {}
    },
    {
        "label": "Multiprocessing",
        "importPath": "pufferlib.vectorization",
        "description": "pufferlib.vectorization",
        "isExtraImport": true,
        "detail": "pufferlib.vectorization",
        "documentation": {}
    },
    {
        "label": "pufferlib.environments.classic_control",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pufferlib.environments.classic_control",
        "description": "pufferlib.environments.classic_control",
        "detail": "pufferlib.environments.classic_control",
        "documentation": {}
    },
    {
        "label": "nle,",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "nle.",
        "description": "nle.",
        "detail": "nle.",
        "documentation": {}
    },
    {
        "label": "pufferlib.environments.nmmo",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pufferlib.environments.nmmo",
        "description": "pufferlib.environments.nmmo",
        "detail": "pufferlib.environments.nmmo",
        "documentation": {}
    },
    {
        "label": "timeit",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "timeit",
        "description": "timeit",
        "detail": "timeit",
        "documentation": {}
    },
    {
        "label": "pufferlib.extensions",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pufferlib.extensions",
        "description": "pufferlib.extensions",
        "detail": "pufferlib.extensions",
        "documentation": {}
    },
    {
        "label": "env_creator",
        "importPath": "pufferlib.environments.pokemon_red",
        "description": "pufferlib.environments.pokemon_red",
        "isExtraImport": true,
        "detail": "pufferlib.environments.pokemon_red",
        "documentation": {}
    },
    {
        "label": "unittest",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "unittest",
        "description": "unittest",
        "detail": "unittest",
        "documentation": {}
    },
    {
        "label": "pufferlib.policy_pool",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pufferlib.policy_pool",
        "description": "pufferlib.policy_pool",
        "detail": "pufferlib.policy_pool",
        "documentation": {}
    },
    {
        "label": "GPUtil",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "GPUtil",
        "description": "GPUtil",
        "detail": "GPUtil",
        "documentation": {}
    },
    {
        "label": "Console",
        "importPath": "rich.console",
        "description": "rich.console",
        "isExtraImport": true,
        "detail": "rich.console",
        "documentation": {}
    },
    {
        "label": "Console",
        "importPath": "rich.console",
        "description": "rich.console",
        "isExtraImport": true,
        "detail": "rich.console",
        "documentation": {}
    },
    {
        "label": "Console",
        "importPath": "rich.console",
        "description": "rich.console",
        "isExtraImport": true,
        "detail": "rich.console",
        "documentation": {}
    },
    {
        "label": "Console",
        "importPath": "rich.console",
        "description": "rich.console",
        "isExtraImport": true,
        "detail": "rich.console",
        "documentation": {}
    },
    {
        "label": "Console",
        "importPath": "rich.console",
        "description": "rich.console",
        "isExtraImport": true,
        "detail": "rich.console",
        "documentation": {}
    },
    {
        "label": "Console",
        "importPath": "rich.console",
        "description": "rich.console",
        "isExtraImport": true,
        "detail": "rich.console",
        "documentation": {}
    },
    {
        "label": "Console",
        "importPath": "rich.console",
        "description": "rich.console",
        "isExtraImport": true,
        "detail": "rich.console",
        "documentation": {}
    },
    {
        "label": "Console",
        "importPath": "rich.console",
        "description": "rich.console",
        "isExtraImport": true,
        "detail": "rich.console",
        "documentation": {}
    },
    {
        "label": "Layout",
        "importPath": "rich.layout",
        "description": "rich.layout",
        "isExtraImport": true,
        "detail": "rich.layout",
        "documentation": {}
    },
    {
        "label": "Live",
        "importPath": "rich.live",
        "description": "rich.live",
        "isExtraImport": true,
        "detail": "rich.live",
        "documentation": {}
    },
    {
        "label": "Table",
        "importPath": "rich.table",
        "description": "rich.table",
        "isExtraImport": true,
        "detail": "rich.table",
        "documentation": {}
    },
    {
        "label": "Table",
        "importPath": "rich.table",
        "description": "rich.table",
        "isExtraImport": true,
        "detail": "rich.table",
        "documentation": {}
    },
    {
        "label": "Table",
        "importPath": "rich.table",
        "description": "rich.table",
        "isExtraImport": true,
        "detail": "rich.table",
        "documentation": {}
    },
    {
        "label": "Table",
        "importPath": "rich.table",
        "description": "rich.table",
        "isExtraImport": true,
        "detail": "rich.table",
        "documentation": {}
    },
    {
        "label": "Table",
        "importPath": "rich.table",
        "description": "rich.table",
        "isExtraImport": true,
        "detail": "rich.table",
        "documentation": {}
    },
    {
        "label": "Panel",
        "importPath": "rich.panel",
        "description": "rich.panel",
        "isExtraImport": true,
        "detail": "rich.panel",
        "documentation": {}
    },
    {
        "label": "Progress",
        "importPath": "rich.progress",
        "description": "rich.progress",
        "isExtraImport": true,
        "detail": "rich.progress",
        "documentation": {}
    },
    {
        "label": "BarColumn",
        "importPath": "rich.progress",
        "description": "rich.progress",
        "isExtraImport": true,
        "detail": "rich.progress",
        "documentation": {}
    },
    {
        "label": "TextColumn",
        "importPath": "rich.progress",
        "description": "rich.progress",
        "isExtraImport": true,
        "detail": "rich.progress",
        "documentation": {}
    },
    {
        "label": "MofNCompleteColumn",
        "importPath": "rich.progress",
        "description": "rich.progress",
        "isExtraImport": true,
        "detail": "rich.progress",
        "documentation": {}
    },
    {
        "label": "compute_gae",
        "importPath": "c_gae",
        "description": "c_gae",
        "isExtraImport": true,
        "detail": "c_gae",
        "documentation": {}
    },
    {
        "label": "shutil",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "shutil",
        "description": "shutil",
        "detail": "shutil",
        "documentation": {}
    },
    {
        "label": "glob",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "glob",
        "description": "glob",
        "detail": "glob",
        "documentation": {}
    },
    {
        "label": "RichHelpFormatter",
        "importPath": "rich_argparse",
        "description": "rich_argparse",
        "isExtraImport": true,
        "detail": "rich_argparse",
        "documentation": {}
    },
    {
        "label": "RichHelpFormatter",
        "importPath": "rich_argparse",
        "description": "rich_argparse",
        "isExtraImport": true,
        "detail": "rich_argparse",
        "documentation": {}
    },
    {
        "label": "install",
        "importPath": "rich.traceback",
        "description": "rich.traceback",
        "isExtraImport": true,
        "detail": "rich.traceback",
        "documentation": {}
    },
    {
        "label": "install",
        "importPath": "rich.traceback",
        "description": "rich.traceback",
        "isExtraImport": true,
        "detail": "rich.traceback",
        "documentation": {}
    },
    {
        "label": "signal",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "signal",
        "description": "signal",
        "detail": "signal",
        "documentation": {}
    },
    {
        "label": "clean_pufferl",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "clean_pufferl",
        "description": "clean_pufferl",
        "detail": "clean_pufferl",
        "documentation": {}
    },
    {
        "label": "update_elos",
        "importPath": "pufferlib.policy_ranker",
        "description": "pufferlib.policy_ranker",
        "isExtraImport": true,
        "detail": "pufferlib.policy_ranker",
        "documentation": {}
    },
    {
        "label": "env_creator",
        "importPath": "pufferlib.environments.ocean.environment",
        "description": "pufferlib.environments.ocean.environment",
        "isExtraImport": true,
        "detail": "pufferlib.environments.ocean.environment",
        "documentation": {}
    },
    {
        "label": "MOBA",
        "importPath": "pufferlib.environments.ocean.torch",
        "description": "pufferlib.environments.ocean.torch",
        "isExtraImport": true,
        "detail": "pufferlib.environments.ocean.torch",
        "documentation": {}
    },
    {
        "label": "Recurrent",
        "importPath": "pufferlib.environments.ocean.torch",
        "description": "pufferlib.environments.ocean.torch",
        "isExtraImport": true,
        "detail": "pufferlib.environments.ocean.torch",
        "documentation": {}
    },
    {
        "label": "ray",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "ray",
        "description": "ray",
        "detail": "ray",
        "documentation": {}
    },
    {
        "label": "CheckpointConfig",
        "importPath": "ray.air",
        "description": "ray.air",
        "isExtraImport": true,
        "detail": "ray.air",
        "documentation": {}
    },
    {
        "label": "RunConfig",
        "importPath": "ray.air.config",
        "description": "ray.air.config",
        "isExtraImport": true,
        "detail": "ray.air.config",
        "documentation": {}
    },
    {
        "label": "ScalingConfig",
        "importPath": "ray.air.config",
        "description": "ray.air.config",
        "isExtraImport": true,
        "detail": "ray.air.config",
        "documentation": {}
    },
    {
        "label": "Tuner",
        "importPath": "ray.tune.tuner",
        "description": "ray.tune.tuner",
        "isExtraImport": true,
        "detail": "ray.tune.tuner",
        "documentation": {}
    },
    {
        "label": "WandbLoggerCallback",
        "importPath": "ray.tune.integration.wandb",
        "description": "ray.tune.integration.wandb",
        "isExtraImport": true,
        "detail": "ray.tune.integration.wandb",
        "documentation": {}
    },
    {
        "label": "RLTrainer",
        "importPath": "ray.train.rl.rl_trainer",
        "description": "ray.train.rl.rl_trainer",
        "isExtraImport": true,
        "detail": "ray.train.rl.rl_trainer",
        "documentation": {}
    },
    {
        "label": "ModelCatalog",
        "importPath": "ray.rllib.models",
        "description": "ray.rllib.models",
        "isExtraImport": true,
        "detail": "ray.rllib.models",
        "documentation": {}
    },
    {
        "label": "make_multi_agent",
        "importPath": "ray.rllib.env.multi_agent_env",
        "description": "ray.rllib.env.multi_agent_env",
        "isExtraImport": true,
        "detail": "ray.rllib.env.multi_agent_env",
        "documentation": {}
    },
    {
        "label": "pufferlib.registry",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pufferlib.registry",
        "description": "pufferlib.registry",
        "detail": "pufferlib.registry",
        "documentation": {}
    },
    {
        "label": "pufferlib.frameworks.rllib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pufferlib.frameworks.rllib",
        "description": "pufferlib.frameworks.rllib",
        "detail": "pufferlib.frameworks.rllib",
        "documentation": {}
    },
    {
        "label": "PPO",
        "importPath": "stable_baselines3",
        "description": "stable_baselines3",
        "isExtraImport": true,
        "detail": "stable_baselines3",
        "documentation": {}
    },
    {
        "label": "DummyVecEnv",
        "importPath": "stable_baselines3.common.vec_env",
        "description": "stable_baselines3.common.vec_env",
        "isExtraImport": true,
        "detail": "stable_baselines3.common.vec_env",
        "documentation": {}
    },
    {
        "label": "SubprocVecEnv",
        "importPath": "stable_baselines3.common.vec_env",
        "description": "stable_baselines3.common.vec_env",
        "isExtraImport": true,
        "detail": "stable_baselines3.common.vec_env",
        "documentation": {}
    },
    {
        "label": "make_vec_env",
        "importPath": "stable_baselines3.common.env_util",
        "description": "stable_baselines3.common.env_util",
        "isExtraImport": true,
        "detail": "stable_baselines3.common.env_util",
        "documentation": {}
    },
    {
        "label": "PufferCPUDrive",
        "importPath": "pufferlib.environments.gpudrive.environment",
        "description": "pufferlib.environments.gpudrive.environment",
        "isExtraImport": true,
        "detail": "pufferlib.environments.gpudrive.environment",
        "documentation": {}
    },
    {
        "label": "puffernet",
        "importPath": "pufferlib.environments.ocean.moba",
        "description": "pufferlib.environments.ocean.moba",
        "isExtraImport": true,
        "detail": "pufferlib.environments.ocean.moba",
        "documentation": {}
    },
    {
        "label": "signal_slot.signal_slot",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "signal_slot.signal_slot",
        "description": "signal_slot.signal_slot",
        "detail": "signal_slot.signal_slot",
        "documentation": {}
    },
    {
        "label": "EventLoop",
        "importPath": "signal_slot.signal_slot",
        "description": "signal_slot.signal_slot",
        "isExtraImport": true,
        "detail": "signal_slot.signal_slot",
        "documentation": {}
    },
    {
        "label": "signal",
        "importPath": "signal_slot.signal_slot",
        "description": "signal_slot.signal_slot",
        "isExtraImport": true,
        "detail": "signal_slot.signal_slot",
        "documentation": {}
    },
    {
        "label": "EventLoop",
        "importPath": "signal_slot.signal_slot",
        "description": "signal_slot.signal_slot",
        "isExtraImport": true,
        "detail": "signal_slot.signal_slot",
        "documentation": {}
    },
    {
        "label": "Timer",
        "importPath": "signal_slot.signal_slot",
        "description": "signal_slot.signal_slot",
        "isExtraImport": true,
        "detail": "signal_slot.signal_slot",
        "documentation": {}
    },
    {
        "label": "signal",
        "importPath": "signal_slot.signal_slot",
        "description": "signal_slot.signal_slot",
        "isExtraImport": true,
        "detail": "signal_slot.signal_slot",
        "documentation": {}
    },
    {
        "label": "EventLoop",
        "importPath": "signal_slot.signal_slot",
        "description": "signal_slot.signal_slot",
        "isExtraImport": true,
        "detail": "signal_slot.signal_slot",
        "documentation": {}
    },
    {
        "label": "EventLoopObject",
        "importPath": "signal_slot.signal_slot",
        "description": "signal_slot.signal_slot",
        "isExtraImport": true,
        "detail": "signal_slot.signal_slot",
        "documentation": {}
    },
    {
        "label": "EventLoopStatus",
        "importPath": "signal_slot.signal_slot",
        "description": "signal_slot.signal_slot",
        "isExtraImport": true,
        "detail": "signal_slot.signal_slot",
        "documentation": {}
    },
    {
        "label": "Timer",
        "importPath": "signal_slot.signal_slot",
        "description": "signal_slot.signal_slot",
        "isExtraImport": true,
        "detail": "signal_slot.signal_slot",
        "documentation": {}
    },
    {
        "label": "process_name",
        "importPath": "signal_slot.signal_slot",
        "description": "signal_slot.signal_slot",
        "isExtraImport": true,
        "detail": "signal_slot.signal_slot",
        "documentation": {}
    },
    {
        "label": "signal",
        "importPath": "signal_slot.signal_slot",
        "description": "signal_slot.signal_slot",
        "isExtraImport": true,
        "detail": "signal_slot.signal_slot",
        "documentation": {}
    },
    {
        "label": "EventLoop",
        "importPath": "signal_slot.signal_slot",
        "description": "signal_slot.signal_slot",
        "isExtraImport": true,
        "detail": "signal_slot.signal_slot",
        "documentation": {}
    },
    {
        "label": "EventLoopProcess",
        "importPath": "signal_slot.signal_slot",
        "description": "signal_slot.signal_slot",
        "isExtraImport": true,
        "detail": "signal_slot.signal_slot",
        "documentation": {}
    },
    {
        "label": "EventLoop",
        "importPath": "signal_slot.signal_slot",
        "description": "signal_slot.signal_slot",
        "isExtraImport": true,
        "detail": "signal_slot.signal_slot",
        "documentation": {}
    },
    {
        "label": "EventLoopObject",
        "importPath": "signal_slot.signal_slot",
        "description": "signal_slot.signal_slot",
        "isExtraImport": true,
        "detail": "signal_slot.signal_slot",
        "documentation": {}
    },
    {
        "label": "EventLoopStatus",
        "importPath": "signal_slot.signal_slot",
        "description": "signal_slot.signal_slot",
        "isExtraImport": true,
        "detail": "signal_slot.signal_slot",
        "documentation": {}
    },
    {
        "label": "signal",
        "importPath": "signal_slot.signal_slot",
        "description": "signal_slot.signal_slot",
        "isExtraImport": true,
        "detail": "signal_slot.signal_slot",
        "documentation": {}
    },
    {
        "label": "TightLoop",
        "importPath": "signal_slot.signal_slot",
        "description": "signal_slot.signal_slot",
        "isExtraImport": true,
        "detail": "signal_slot.signal_slot",
        "documentation": {}
    },
    {
        "label": "Timer",
        "importPath": "signal_slot.signal_slot",
        "description": "signal_slot.signal_slot",
        "isExtraImport": true,
        "detail": "signal_slot.signal_slot",
        "documentation": {}
    },
    {
        "label": "signal",
        "importPath": "signal_slot.signal_slot",
        "description": "signal_slot.signal_slot",
        "isExtraImport": true,
        "detail": "signal_slot.signal_slot",
        "documentation": {}
    },
    {
        "label": "signal",
        "importPath": "signal_slot.signal_slot",
        "description": "signal_slot.signal_slot",
        "isExtraImport": true,
        "detail": "signal_slot.signal_slot",
        "documentation": {}
    },
    {
        "label": "BoundMethod",
        "importPath": "signal_slot.signal_slot",
        "description": "signal_slot.signal_slot",
        "isExtraImport": true,
        "detail": "signal_slot.signal_slot",
        "documentation": {}
    },
    {
        "label": "EventLoop",
        "importPath": "signal_slot.signal_slot",
        "description": "signal_slot.signal_slot",
        "isExtraImport": true,
        "detail": "signal_slot.signal_slot",
        "documentation": {}
    },
    {
        "label": "EventLoopObject",
        "importPath": "signal_slot.signal_slot",
        "description": "signal_slot.signal_slot",
        "isExtraImport": true,
        "detail": "signal_slot.signal_slot",
        "documentation": {}
    },
    {
        "label": "EventLoopProcess",
        "importPath": "signal_slot.signal_slot",
        "description": "signal_slot.signal_slot",
        "isExtraImport": true,
        "detail": "signal_slot.signal_slot",
        "documentation": {}
    },
    {
        "label": "signal",
        "importPath": "signal_slot.signal_slot",
        "description": "signal_slot.signal_slot",
        "isExtraImport": true,
        "detail": "signal_slot.signal_slot",
        "documentation": {}
    },
    {
        "label": "EventLoop",
        "importPath": "signal_slot.signal_slot",
        "description": "signal_slot.signal_slot",
        "isExtraImport": true,
        "detail": "signal_slot.signal_slot",
        "documentation": {}
    },
    {
        "label": "EventLoopObject",
        "importPath": "signal_slot.signal_slot",
        "description": "signal_slot.signal_slot",
        "isExtraImport": true,
        "detail": "signal_slot.signal_slot",
        "documentation": {}
    },
    {
        "label": "Timer",
        "importPath": "signal_slot.signal_slot",
        "description": "signal_slot.signal_slot",
        "isExtraImport": true,
        "detail": "signal_slot.signal_slot",
        "documentation": {}
    },
    {
        "label": "process_name",
        "importPath": "signal_slot.signal_slot",
        "description": "signal_slot.signal_slot",
        "isExtraImport": true,
        "detail": "signal_slot.signal_slot",
        "documentation": {}
    },
    {
        "label": "signal",
        "importPath": "signal_slot.signal_slot",
        "description": "signal_slot.signal_slot",
        "isExtraImport": true,
        "detail": "signal_slot.signal_slot",
        "documentation": {}
    },
    {
        "label": "EventLoopObject",
        "importPath": "signal_slot.signal_slot",
        "description": "signal_slot.signal_slot",
        "isExtraImport": true,
        "detail": "signal_slot.signal_slot",
        "documentation": {}
    },
    {
        "label": "StatusCode",
        "importPath": "signal_slot.signal_slot",
        "description": "signal_slot.signal_slot",
        "isExtraImport": true,
        "detail": "signal_slot.signal_slot",
        "documentation": {}
    },
    {
        "label": "StatusCode",
        "importPath": "signal_slot.signal_slot",
        "description": "signal_slot.signal_slot",
        "isExtraImport": true,
        "detail": "signal_slot.signal_slot",
        "documentation": {}
    },
    {
        "label": "EnvInfo",
        "importPath": "sample_factory.algo.utils.env_info",
        "description": "sample_factory.algo.utils.env_info",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.env_info",
        "documentation": {}
    },
    {
        "label": "EnvInfo",
        "importPath": "sample_factory.algo.utils.env_info",
        "description": "sample_factory.algo.utils.env_info",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.env_info",
        "documentation": {}
    },
    {
        "label": "EnvInfo",
        "importPath": "sample_factory.algo.utils.env_info",
        "description": "sample_factory.algo.utils.env_info",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.env_info",
        "documentation": {}
    },
    {
        "label": "EnvInfo",
        "importPath": "sample_factory.algo.utils.env_info",
        "description": "sample_factory.algo.utils.env_info",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.env_info",
        "documentation": {}
    },
    {
        "label": "obtain_env_info_in_a_separate_process",
        "importPath": "sample_factory.algo.utils.env_info",
        "description": "sample_factory.algo.utils.env_info",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.env_info",
        "documentation": {}
    },
    {
        "label": "EnvInfo",
        "importPath": "sample_factory.algo.utils.env_info",
        "description": "sample_factory.algo.utils.env_info",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.env_info",
        "documentation": {}
    },
    {
        "label": "check_env_info",
        "importPath": "sample_factory.algo.utils.env_info",
        "description": "sample_factory.algo.utils.env_info",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.env_info",
        "documentation": {}
    },
    {
        "label": "EnvInfo",
        "importPath": "sample_factory.algo.utils.env_info",
        "description": "sample_factory.algo.utils.env_info",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.env_info",
        "documentation": {}
    },
    {
        "label": "EnvInfo",
        "importPath": "sample_factory.algo.utils.env_info",
        "description": "sample_factory.algo.utils.env_info",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.env_info",
        "documentation": {}
    },
    {
        "label": "EnvInfo",
        "importPath": "sample_factory.algo.utils.env_info",
        "description": "sample_factory.algo.utils.env_info",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.env_info",
        "documentation": {}
    },
    {
        "label": "check_env_info",
        "importPath": "sample_factory.algo.utils.env_info",
        "description": "sample_factory.algo.utils.env_info",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.env_info",
        "documentation": {}
    },
    {
        "label": "EnvInfo",
        "importPath": "sample_factory.algo.utils.env_info",
        "description": "sample_factory.algo.utils.env_info",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.env_info",
        "documentation": {}
    },
    {
        "label": "EnvInfo",
        "importPath": "sample_factory.algo.utils.env_info",
        "description": "sample_factory.algo.utils.env_info",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.env_info",
        "documentation": {}
    },
    {
        "label": "EnvInfo",
        "importPath": "sample_factory.algo.utils.env_info",
        "description": "sample_factory.algo.utils.env_info",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.env_info",
        "documentation": {}
    },
    {
        "label": "EnvInfo",
        "importPath": "sample_factory.algo.utils.env_info",
        "description": "sample_factory.algo.utils.env_info",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.env_info",
        "documentation": {}
    },
    {
        "label": "EnvInfo",
        "importPath": "sample_factory.algo.utils.env_info",
        "description": "sample_factory.algo.utils.env_info",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.env_info",
        "documentation": {}
    },
    {
        "label": "EnvInfo",
        "importPath": "sample_factory.algo.utils.env_info",
        "description": "sample_factory.algo.utils.env_info",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.env_info",
        "documentation": {}
    },
    {
        "label": "EnvInfo",
        "importPath": "sample_factory.algo.utils.env_info",
        "description": "sample_factory.algo.utils.env_info",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.env_info",
        "documentation": {}
    },
    {
        "label": "EnvInfo",
        "importPath": "sample_factory.algo.utils.env_info",
        "description": "sample_factory.algo.utils.env_info",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.env_info",
        "documentation": {}
    },
    {
        "label": "EnvInfo",
        "importPath": "sample_factory.algo.utils.env_info",
        "description": "sample_factory.algo.utils.env_info",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.env_info",
        "documentation": {}
    },
    {
        "label": "extract_env_info",
        "importPath": "sample_factory.algo.utils.env_info",
        "description": "sample_factory.algo.utils.env_info",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.env_info",
        "documentation": {}
    },
    {
        "label": "EnvInfo",
        "importPath": "sample_factory.algo.utils.env_info",
        "description": "sample_factory.algo.utils.env_info",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.env_info",
        "documentation": {}
    },
    {
        "label": "obtain_env_info_in_a_separate_process",
        "importPath": "sample_factory.algo.utils.env_info",
        "description": "sample_factory.algo.utils.env_info",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.env_info",
        "documentation": {}
    },
    {
        "label": "EnvInfo",
        "importPath": "sample_factory.algo.utils.env_info",
        "description": "sample_factory.algo.utils.env_info",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.env_info",
        "documentation": {}
    },
    {
        "label": "obtain_env_info_in_a_separate_process",
        "importPath": "sample_factory.algo.utils.env_info",
        "description": "sample_factory.algo.utils.env_info",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.env_info",
        "documentation": {}
    },
    {
        "label": "extract_env_info",
        "importPath": "sample_factory.algo.utils.env_info",
        "description": "sample_factory.algo.utils.env_info",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.env_info",
        "documentation": {}
    },
    {
        "label": "extract_env_info",
        "importPath": "sample_factory.algo.utils.env_info",
        "description": "sample_factory.algo.utils.env_info",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.env_info",
        "documentation": {}
    },
    {
        "label": "HeartbeatStoppableEventLoopObject",
        "importPath": "sample_factory.algo.utils.heartbeat",
        "description": "sample_factory.algo.utils.heartbeat",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.heartbeat",
        "documentation": {}
    },
    {
        "label": "HeartbeatStoppableEventLoopObject",
        "importPath": "sample_factory.algo.utils.heartbeat",
        "description": "sample_factory.algo.utils.heartbeat",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.heartbeat",
        "documentation": {}
    },
    {
        "label": "HeartbeatStoppableEventLoopObject",
        "importPath": "sample_factory.algo.utils.heartbeat",
        "description": "sample_factory.algo.utils.heartbeat",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.heartbeat",
        "documentation": {}
    },
    {
        "label": "HeartbeatStoppableEventLoopObject",
        "importPath": "sample_factory.algo.utils.heartbeat",
        "description": "sample_factory.algo.utils.heartbeat",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.heartbeat",
        "documentation": {}
    },
    {
        "label": "HeartbeatStoppableEventLoopObject",
        "importPath": "sample_factory.algo.utils.heartbeat",
        "description": "sample_factory.algo.utils.heartbeat",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.heartbeat",
        "documentation": {}
    },
    {
        "label": "HeartbeatStoppableEventLoopObject",
        "importPath": "sample_factory.algo.utils.heartbeat",
        "description": "sample_factory.algo.utils.heartbeat",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.heartbeat",
        "documentation": {}
    },
    {
        "label": "BufferMgr",
        "importPath": "sample_factory.algo.utils.shared_buffers",
        "description": "sample_factory.algo.utils.shared_buffers",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.shared_buffers",
        "documentation": {}
    },
    {
        "label": "alloc_trajectory_tensors",
        "importPath": "sample_factory.algo.utils.shared_buffers",
        "description": "sample_factory.algo.utils.shared_buffers",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.shared_buffers",
        "documentation": {}
    },
    {
        "label": "policy_device",
        "importPath": "sample_factory.algo.utils.shared_buffers",
        "description": "sample_factory.algo.utils.shared_buffers",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.shared_buffers",
        "documentation": {}
    },
    {
        "label": "policy_device",
        "importPath": "sample_factory.algo.utils.shared_buffers",
        "description": "sample_factory.algo.utils.shared_buffers",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.shared_buffers",
        "documentation": {}
    },
    {
        "label": "BufferMgr",
        "importPath": "sample_factory.algo.utils.shared_buffers",
        "description": "sample_factory.algo.utils.shared_buffers",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.shared_buffers",
        "documentation": {}
    },
    {
        "label": "BufferMgr",
        "importPath": "sample_factory.algo.utils.shared_buffers",
        "description": "sample_factory.algo.utils.shared_buffers",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.shared_buffers",
        "documentation": {}
    },
    {
        "label": "BufferMgr",
        "importPath": "sample_factory.algo.utils.shared_buffers",
        "description": "sample_factory.algo.utils.shared_buffers",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.shared_buffers",
        "documentation": {}
    },
    {
        "label": "policy_device",
        "importPath": "sample_factory.algo.utils.shared_buffers",
        "description": "sample_factory.algo.utils.shared_buffers",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.shared_buffers",
        "documentation": {}
    },
    {
        "label": "BufferMgr",
        "importPath": "sample_factory.algo.utils.shared_buffers",
        "description": "sample_factory.algo.utils.shared_buffers",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.shared_buffers",
        "documentation": {}
    },
    {
        "label": "BufferMgr",
        "importPath": "sample_factory.algo.utils.shared_buffers",
        "description": "sample_factory.algo.utils.shared_buffers",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.shared_buffers",
        "documentation": {}
    },
    {
        "label": "BufferMgr",
        "importPath": "sample_factory.algo.utils.shared_buffers",
        "description": "sample_factory.algo.utils.shared_buffers",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.shared_buffers",
        "documentation": {}
    },
    {
        "label": "TensorDict",
        "importPath": "sample_factory.algo.utils.tensor_dict",
        "description": "sample_factory.algo.utils.tensor_dict",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.tensor_dict",
        "documentation": {}
    },
    {
        "label": "TensorDict",
        "importPath": "sample_factory.algo.utils.tensor_dict",
        "description": "sample_factory.algo.utils.tensor_dict",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.tensor_dict",
        "documentation": {}
    },
    {
        "label": "shallow_recursive_copy",
        "importPath": "sample_factory.algo.utils.tensor_dict",
        "description": "sample_factory.algo.utils.tensor_dict",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.tensor_dict",
        "documentation": {}
    },
    {
        "label": "TensorDict",
        "importPath": "sample_factory.algo.utils.tensor_dict",
        "description": "sample_factory.algo.utils.tensor_dict",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.tensor_dict",
        "documentation": {}
    },
    {
        "label": "TensorDict",
        "importPath": "sample_factory.algo.utils.tensor_dict",
        "description": "sample_factory.algo.utils.tensor_dict",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.tensor_dict",
        "documentation": {}
    },
    {
        "label": "TensorDict",
        "importPath": "sample_factory.algo.utils.tensor_dict",
        "description": "sample_factory.algo.utils.tensor_dict",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.tensor_dict",
        "documentation": {}
    },
    {
        "label": "to_numpy",
        "importPath": "sample_factory.algo.utils.tensor_dict",
        "description": "sample_factory.algo.utils.tensor_dict",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.tensor_dict",
        "documentation": {}
    },
    {
        "label": "TensorDict",
        "importPath": "sample_factory.algo.utils.tensor_dict",
        "description": "sample_factory.algo.utils.tensor_dict",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.tensor_dict",
        "documentation": {}
    },
    {
        "label": "to_numpy",
        "importPath": "sample_factory.algo.utils.tensor_dict",
        "description": "sample_factory.algo.utils.tensor_dict",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.tensor_dict",
        "documentation": {}
    },
    {
        "label": "TensorDict",
        "importPath": "sample_factory.algo.utils.tensor_dict",
        "description": "sample_factory.algo.utils.tensor_dict",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.tensor_dict",
        "documentation": {}
    },
    {
        "label": "clone_tensordict",
        "importPath": "sample_factory.algo.utils.tensor_dict",
        "description": "sample_factory.algo.utils.tensor_dict",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.tensor_dict",
        "documentation": {}
    },
    {
        "label": "TensorDict",
        "importPath": "sample_factory.algo.utils.tensor_dict",
        "description": "sample_factory.algo.utils.tensor_dict",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.tensor_dict",
        "documentation": {}
    },
    {
        "label": "TensorDict",
        "importPath": "sample_factory.algo.utils.tensor_dict",
        "description": "sample_factory.algo.utils.tensor_dict",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.tensor_dict",
        "documentation": {}
    },
    {
        "label": "TensorDict",
        "importPath": "sample_factory.algo.utils.tensor_dict",
        "description": "sample_factory.algo.utils.tensor_dict",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.tensor_dict",
        "documentation": {}
    },
    {
        "label": "cat_tensordicts",
        "importPath": "sample_factory.algo.utils.tensor_dict",
        "description": "sample_factory.algo.utils.tensor_dict",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.tensor_dict",
        "documentation": {}
    },
    {
        "label": "TensorDict",
        "importPath": "sample_factory.algo.utils.tensor_dict",
        "description": "sample_factory.algo.utils.tensor_dict",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.tensor_dict",
        "documentation": {}
    },
    {
        "label": "cat_tensordicts",
        "importPath": "sample_factory.algo.utils.tensor_dict",
        "description": "sample_factory.algo.utils.tensor_dict",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.tensor_dict",
        "documentation": {}
    },
    {
        "label": "get_rnn_size",
        "importPath": "sample_factory.model.model_utils",
        "description": "sample_factory.model.model_utils",
        "isExtraImport": true,
        "detail": "sample_factory.model.model_utils",
        "documentation": {}
    },
    {
        "label": "get_rnn_size",
        "importPath": "sample_factory.model.model_utils",
        "description": "sample_factory.model.model_utils",
        "isExtraImport": true,
        "detail": "sample_factory.model.model_utils",
        "documentation": {}
    },
    {
        "label": "model_device",
        "importPath": "sample_factory.model.model_utils",
        "description": "sample_factory.model.model_utils",
        "isExtraImport": true,
        "detail": "sample_factory.model.model_utils",
        "documentation": {}
    },
    {
        "label": "ModelModule",
        "importPath": "sample_factory.model.model_utils",
        "description": "sample_factory.model.model_utils",
        "isExtraImport": true,
        "detail": "sample_factory.model.model_utils",
        "documentation": {}
    },
    {
        "label": "ModelModule",
        "importPath": "sample_factory.model.model_utils",
        "description": "sample_factory.model.model_utils",
        "isExtraImport": true,
        "detail": "sample_factory.model.model_utils",
        "documentation": {}
    },
    {
        "label": "create_mlp",
        "importPath": "sample_factory.model.model_utils",
        "description": "sample_factory.model.model_utils",
        "isExtraImport": true,
        "detail": "sample_factory.model.model_utils",
        "documentation": {}
    },
    {
        "label": "nonlinearity",
        "importPath": "sample_factory.model.model_utils",
        "description": "sample_factory.model.model_utils",
        "isExtraImport": true,
        "detail": "sample_factory.model.model_utils",
        "documentation": {}
    },
    {
        "label": "ModelModule",
        "importPath": "sample_factory.model.model_utils",
        "description": "sample_factory.model.model_utils",
        "isExtraImport": true,
        "detail": "sample_factory.model.model_utils",
        "documentation": {}
    },
    {
        "label": "create_mlp",
        "importPath": "sample_factory.model.model_utils",
        "description": "sample_factory.model.model_utils",
        "isExtraImport": true,
        "detail": "sample_factory.model.model_utils",
        "documentation": {}
    },
    {
        "label": "model_device",
        "importPath": "sample_factory.model.model_utils",
        "description": "sample_factory.model.model_utils",
        "isExtraImport": true,
        "detail": "sample_factory.model.model_utils",
        "documentation": {}
    },
    {
        "label": "nonlinearity",
        "importPath": "sample_factory.model.model_utils",
        "description": "sample_factory.model.model_utils",
        "isExtraImport": true,
        "detail": "sample_factory.model.model_utils",
        "documentation": {}
    },
    {
        "label": "get_rnn_size",
        "importPath": "sample_factory.model.model_utils",
        "description": "sample_factory.model.model_utils",
        "isExtraImport": true,
        "detail": "sample_factory.model.model_utils",
        "documentation": {}
    },
    {
        "label": "model_device",
        "importPath": "sample_factory.model.model_utils",
        "description": "sample_factory.model.model_utils",
        "isExtraImport": true,
        "detail": "sample_factory.model.model_utils",
        "documentation": {}
    },
    {
        "label": "nonlinearity",
        "importPath": "sample_factory.model.model_utils",
        "description": "sample_factory.model.model_utils",
        "isExtraImport": true,
        "detail": "sample_factory.model.model_utils",
        "documentation": {}
    },
    {
        "label": "nonlinearity",
        "importPath": "sample_factory.model.model_utils",
        "description": "sample_factory.model.model_utils",
        "isExtraImport": true,
        "detail": "sample_factory.model.model_utils",
        "documentation": {}
    },
    {
        "label": "get_rnn_size",
        "importPath": "sample_factory.model.model_utils",
        "description": "sample_factory.model.model_utils",
        "isExtraImport": true,
        "detail": "sample_factory.model.model_utils",
        "documentation": {}
    },
    {
        "label": "Timing",
        "importPath": "sample_factory.utils.timing",
        "description": "sample_factory.utils.timing",
        "isExtraImport": true,
        "detail": "sample_factory.utils.timing",
        "documentation": {}
    },
    {
        "label": "Timing",
        "importPath": "sample_factory.utils.timing",
        "description": "sample_factory.utils.timing",
        "isExtraImport": true,
        "detail": "sample_factory.utils.timing",
        "documentation": {}
    },
    {
        "label": "Timing",
        "importPath": "sample_factory.utils.timing",
        "description": "sample_factory.utils.timing",
        "isExtraImport": true,
        "detail": "sample_factory.utils.timing",
        "documentation": {}
    },
    {
        "label": "Timing",
        "importPath": "sample_factory.utils.timing",
        "description": "sample_factory.utils.timing",
        "isExtraImport": true,
        "detail": "sample_factory.utils.timing",
        "documentation": {}
    },
    {
        "label": "Timing",
        "importPath": "sample_factory.utils.timing",
        "description": "sample_factory.utils.timing",
        "isExtraImport": true,
        "detail": "sample_factory.utils.timing",
        "documentation": {}
    },
    {
        "label": "Timing",
        "importPath": "sample_factory.utils.timing",
        "description": "sample_factory.utils.timing",
        "isExtraImport": true,
        "detail": "sample_factory.utils.timing",
        "documentation": {}
    },
    {
        "label": "Timing",
        "importPath": "sample_factory.utils.timing",
        "description": "sample_factory.utils.timing",
        "isExtraImport": true,
        "detail": "sample_factory.utils.timing",
        "documentation": {}
    },
    {
        "label": "Timing",
        "importPath": "sample_factory.utils.timing",
        "description": "sample_factory.utils.timing",
        "isExtraImport": true,
        "detail": "sample_factory.utils.timing",
        "documentation": {}
    },
    {
        "label": "Timing",
        "importPath": "sample_factory.utils.timing",
        "description": "sample_factory.utils.timing",
        "isExtraImport": true,
        "detail": "sample_factory.utils.timing",
        "documentation": {}
    },
    {
        "label": "Timing",
        "importPath": "sample_factory.utils.timing",
        "description": "sample_factory.utils.timing",
        "isExtraImport": true,
        "detail": "sample_factory.utils.timing",
        "documentation": {}
    },
    {
        "label": "Timing",
        "importPath": "sample_factory.utils.timing",
        "description": "sample_factory.utils.timing",
        "isExtraImport": true,
        "detail": "sample_factory.utils.timing",
        "documentation": {}
    },
    {
        "label": "Timing",
        "importPath": "sample_factory.utils.timing",
        "description": "sample_factory.utils.timing",
        "isExtraImport": true,
        "detail": "sample_factory.utils.timing",
        "documentation": {}
    },
    {
        "label": "debug_log_every_n",
        "importPath": "sample_factory.utils.utils",
        "description": "sample_factory.utils.utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "log",
        "importPath": "sample_factory.utils.utils",
        "description": "sample_factory.utils.utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "ensure_dir_exists",
        "importPath": "sample_factory.utils.utils",
        "description": "sample_factory.utils.utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "experiment_dir",
        "importPath": "sample_factory.utils.utils",
        "description": "sample_factory.utils.utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "log",
        "importPath": "sample_factory.utils.utils",
        "description": "sample_factory.utils.utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "init_file_logger",
        "importPath": "sample_factory.utils.utils",
        "description": "sample_factory.utils.utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "log",
        "importPath": "sample_factory.utils.utils",
        "description": "sample_factory.utils.utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "log",
        "importPath": "sample_factory.utils.utils",
        "description": "sample_factory.utils.utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "cfg_file",
        "importPath": "sample_factory.utils.utils",
        "description": "sample_factory.utils.utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "debug_log_every_n",
        "importPath": "sample_factory.utils.utils",
        "description": "sample_factory.utils.utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "ensure_dir_exists",
        "importPath": "sample_factory.utils.utils",
        "description": "sample_factory.utils.utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "experiment_dir",
        "importPath": "sample_factory.utils.utils",
        "description": "sample_factory.utils.utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "init_file_logger",
        "importPath": "sample_factory.utils.utils",
        "description": "sample_factory.utils.utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "log",
        "importPath": "sample_factory.utils.utils",
        "description": "sample_factory.utils.utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "memory_consumption_mb",
        "importPath": "sample_factory.utils.utils",
        "description": "sample_factory.utils.utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "save_git_diff",
        "importPath": "sample_factory.utils.utils",
        "description": "sample_factory.utils.utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "summaries_dir",
        "importPath": "sample_factory.utils.utils",
        "description": "sample_factory.utils.utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "log",
        "importPath": "sample_factory.utils.utils",
        "description": "sample_factory.utils.utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "log",
        "importPath": "sample_factory.utils.utils",
        "description": "sample_factory.utils.utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "log",
        "importPath": "sample_factory.utils.utils",
        "description": "sample_factory.utils.utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "debug_log_every_n",
        "importPath": "sample_factory.utils.utils",
        "description": "sample_factory.utils.utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "init_file_logger",
        "importPath": "sample_factory.utils.utils",
        "description": "sample_factory.utils.utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "log",
        "importPath": "sample_factory.utils.utils",
        "description": "sample_factory.utils.utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "debug_log_every_n",
        "importPath": "sample_factory.utils.utils",
        "description": "sample_factory.utils.utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "log",
        "importPath": "sample_factory.utils.utils",
        "description": "sample_factory.utils.utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "set_attr_if_exists",
        "importPath": "sample_factory.utils.utils",
        "description": "sample_factory.utils.utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "cores_for_worker_process",
        "importPath": "sample_factory.utils.utils",
        "description": "sample_factory.utils.utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "debug_log_every_n",
        "importPath": "sample_factory.utils.utils",
        "description": "sample_factory.utils.utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "init_file_logger",
        "importPath": "sample_factory.utils.utils",
        "description": "sample_factory.utils.utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "log",
        "importPath": "sample_factory.utils.utils",
        "description": "sample_factory.utils.utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "set_process_cpu_affinity",
        "importPath": "sample_factory.utils.utils",
        "description": "sample_factory.utils.utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "log",
        "importPath": "sample_factory.utils.utils",
        "description": "sample_factory.utils.utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "log",
        "importPath": "sample_factory.utils.utils",
        "description": "sample_factory.utils.utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "log",
        "importPath": "sample_factory.utils.utils",
        "description": "sample_factory.utils.utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "log",
        "importPath": "sample_factory.utils.utils",
        "description": "sample_factory.utils.utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "project_tmp_dir",
        "importPath": "sample_factory.utils.utils",
        "description": "sample_factory.utils.utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "log",
        "importPath": "sample_factory.utils.utils",
        "description": "sample_factory.utils.utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "log",
        "importPath": "sample_factory.utils.utils",
        "description": "sample_factory.utils.utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "memory_consumption_mb",
        "importPath": "sample_factory.utils.utils",
        "description": "sample_factory.utils.utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "log",
        "importPath": "sample_factory.utils.utils",
        "description": "sample_factory.utils.utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "static_vars",
        "importPath": "sample_factory.utils.utils",
        "description": "sample_factory.utils.utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "log",
        "importPath": "sample_factory.utils.utils",
        "description": "sample_factory.utils.utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "log",
        "importPath": "sample_factory.utils.utils",
        "description": "sample_factory.utils.utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "log",
        "importPath": "sample_factory.utils.utils",
        "description": "sample_factory.utils.utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "cfg_file",
        "importPath": "sample_factory.utils.utils",
        "description": "sample_factory.utils.utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "cfg_file_old",
        "importPath": "sample_factory.utils.utils",
        "description": "sample_factory.utils.utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "get_git_commit_hash",
        "importPath": "sample_factory.utils.utils",
        "description": "sample_factory.utils.utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "log",
        "importPath": "sample_factory.utils.utils",
        "description": "sample_factory.utils.utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "str2bool",
        "importPath": "sample_factory.utils.utils",
        "description": "sample_factory.utils.utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "log",
        "importPath": "sample_factory.utils.utils",
        "description": "sample_factory.utils.utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "is_module_available",
        "importPath": "sample_factory.utils.utils",
        "description": "sample_factory.utils.utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "log",
        "importPath": "sample_factory.utils.utils",
        "description": "sample_factory.utils.utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "ensure_dir_exists",
        "importPath": "sample_factory.utils.utils",
        "description": "sample_factory.utils.utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "log",
        "importPath": "sample_factory.utils.utils",
        "description": "sample_factory.utils.utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "log",
        "importPath": "sample_factory.utils.utils",
        "description": "sample_factory.utils.utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "project_tmp_dir",
        "importPath": "sample_factory.utils.utils",
        "description": "sample_factory.utils.utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "log",
        "importPath": "sample_factory.utils.utils",
        "description": "sample_factory.utils.utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "log",
        "importPath": "sample_factory.utils.utils",
        "description": "sample_factory.utils.utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "log",
        "importPath": "sample_factory.utils.utils",
        "description": "sample_factory.utils.utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "str2bool",
        "importPath": "sample_factory.utils.utils",
        "description": "sample_factory.utils.utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "ensure_dir_exists",
        "importPath": "sample_factory.utils.utils",
        "description": "sample_factory.utils.utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "log",
        "importPath": "sample_factory.utils.utils",
        "description": "sample_factory.utils.utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "log",
        "importPath": "sample_factory.utils.utils",
        "description": "sample_factory.utils.utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "str2bool",
        "importPath": "sample_factory.utils.utils",
        "description": "sample_factory.utils.utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "log",
        "importPath": "sample_factory.utils.utils",
        "description": "sample_factory.utils.utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "log",
        "importPath": "sample_factory.utils.utils",
        "description": "sample_factory.utils.utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "experiment_dir",
        "importPath": "sample_factory.utils.utils",
        "description": "sample_factory.utils.utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "log",
        "importPath": "sample_factory.utils.utils",
        "description": "sample_factory.utils.utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "log",
        "importPath": "sample_factory.utils.utils",
        "description": "sample_factory.utils.utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "log",
        "importPath": "sample_factory.utils.utils",
        "description": "sample_factory.utils.utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "kill",
        "importPath": "sample_factory.utils.utils",
        "description": "sample_factory.utils.utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "log",
        "importPath": "sample_factory.utils.utils",
        "description": "sample_factory.utils.utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "log",
        "importPath": "sample_factory.utils.utils",
        "description": "sample_factory.utils.utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "retry",
        "importPath": "sample_factory.utils.utils",
        "description": "sample_factory.utils.utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "debug_log_every_n",
        "importPath": "sample_factory.utils.utils",
        "description": "sample_factory.utils.utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "experiment_dir",
        "importPath": "sample_factory.utils.utils",
        "description": "sample_factory.utils.utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "log",
        "importPath": "sample_factory.utils.utils",
        "description": "sample_factory.utils.utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "experiment_dir",
        "importPath": "sample_factory.utils.utils",
        "description": "sample_factory.utils.utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "log",
        "importPath": "sample_factory.utils.utils",
        "description": "sample_factory.utils.utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "log",
        "importPath": "sample_factory.utils.utils",
        "description": "sample_factory.utils.utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "str2bool",
        "importPath": "sample_factory.utils.utils",
        "description": "sample_factory.utils.utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "log",
        "importPath": "sample_factory.utils.utils",
        "description": "sample_factory.utils.utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "static_vars",
        "importPath": "sample_factory.utils.utils",
        "description": "sample_factory.utils.utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "ensure_dir_exists",
        "importPath": "sample_factory.utils.utils",
        "description": "sample_factory.utils.utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "log",
        "importPath": "sample_factory.utils.utils",
        "description": "sample_factory.utils.utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "ensure_dir_exists",
        "importPath": "sample_factory.utils.utils",
        "description": "sample_factory.utils.utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "log",
        "importPath": "sample_factory.utils.utils",
        "description": "sample_factory.utils.utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "safe_ensure_dir_exists",
        "importPath": "sample_factory.utils.utils",
        "description": "sample_factory.utils.utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "log",
        "importPath": "sample_factory.utils.utils",
        "description": "sample_factory.utils.utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "str2bool",
        "importPath": "sample_factory.utils.utils",
        "description": "sample_factory.utils.utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "is_module_available",
        "importPath": "sample_factory.utils.utils",
        "description": "sample_factory.utils.utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "experiment_dir",
        "importPath": "sample_factory.utils.utils",
        "description": "sample_factory.utils.utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "log",
        "importPath": "sample_factory.utils.utils",
        "description": "sample_factory.utils.utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "log",
        "importPath": "sample_factory.utils.utils",
        "description": "sample_factory.utils.utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "is_module_available",
        "importPath": "sample_factory.utils.utils",
        "description": "sample_factory.utils.utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "str2bool",
        "importPath": "sample_factory.utils.utils",
        "description": "sample_factory.utils.utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "is_module_available",
        "importPath": "sample_factory.utils.utils",
        "description": "sample_factory.utils.utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "log",
        "importPath": "sample_factory.utils.utils",
        "description": "sample_factory.utils.utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "str2bool",
        "importPath": "sample_factory.utils.utils",
        "description": "sample_factory.utils.utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "log",
        "importPath": "sample_factory.utils.utils",
        "description": "sample_factory.utils.utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "log",
        "importPath": "sample_factory.utils.utils",
        "description": "sample_factory.utils.utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "log",
        "importPath": "sample_factory.utils.utils",
        "description": "sample_factory.utils.utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "log",
        "importPath": "sample_factory.utils.utils",
        "description": "sample_factory.utils.utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "log",
        "importPath": "sample_factory.utils.utils",
        "description": "sample_factory.utils.utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "log",
        "importPath": "sample_factory.utils.utils",
        "description": "sample_factory.utils.utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "project_tmp_dir",
        "importPath": "sample_factory.utils.utils",
        "description": "sample_factory.utils.utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "log",
        "importPath": "sample_factory.utils.utils",
        "description": "sample_factory.utils.utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "str2bool",
        "importPath": "sample_factory.utils.utils",
        "description": "sample_factory.utils.utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "log",
        "importPath": "sample_factory.utils.utils",
        "description": "sample_factory.utils.utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "debug_log_every_n",
        "importPath": "sample_factory.utils.utils",
        "description": "sample_factory.utils.utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "log",
        "importPath": "sample_factory.utils.utils",
        "description": "sample_factory.utils.utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "log",
        "importPath": "sample_factory.utils.utils",
        "description": "sample_factory.utils.utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "log",
        "importPath": "sample_factory.utils.utils",
        "description": "sample_factory.utils.utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "log",
        "importPath": "sample_factory.utils.utils",
        "description": "sample_factory.utils.utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "log",
        "importPath": "sample_factory.utils.utils",
        "description": "sample_factory.utils.utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "log",
        "importPath": "sample_factory.utils.utils",
        "description": "sample_factory.utils.utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "log",
        "importPath": "sample_factory.utils.utils",
        "description": "sample_factory.utils.utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "debug_log_every_n",
        "importPath": "sample_factory.utils.utils",
        "description": "sample_factory.utils.utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "log",
        "importPath": "sample_factory.utils.utils",
        "description": "sample_factory.utils.utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "log",
        "importPath": "sample_factory.utils.utils",
        "description": "sample_factory.utils.utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "experiment_dir",
        "importPath": "sample_factory.utils.utils",
        "description": "sample_factory.utils.utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "log",
        "importPath": "sample_factory.utils.utils",
        "description": "sample_factory.utils.utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "ensure_dir_exists",
        "importPath": "sample_factory.utils.utils",
        "description": "sample_factory.utils.utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "project_tmp_dir",
        "importPath": "sample_factory.utils.utils",
        "description": "sample_factory.utils.utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "cores_for_worker_process",
        "importPath": "sample_factory.utils.utils",
        "description": "sample_factory.utils.utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "log",
        "importPath": "sample_factory.utils.utils",
        "description": "sample_factory.utils.utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "experiment_dir",
        "importPath": "sample_factory.utils.utils",
        "description": "sample_factory.utils.utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "log",
        "importPath": "sample_factory.utils.utils",
        "description": "sample_factory.utils.utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "project_tmp_dir",
        "importPath": "sample_factory.utils.utils",
        "description": "sample_factory.utils.utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "log",
        "importPath": "sample_factory.utils.utils",
        "description": "sample_factory.utils.utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "project_tmp_dir",
        "importPath": "sample_factory.utils.utils",
        "description": "sample_factory.utils.utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "ABC",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "abstractmethod",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "ABC",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "ABC",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "ABC",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "os.path",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os.path",
        "description": "os.path",
        "detail": "os.path",
        "documentation": {}
    },
    {
        "label": "join",
        "importPath": "os.path",
        "description": "os.path",
        "isExtraImport": true,
        "detail": "os.path",
        "documentation": {}
    },
    {
        "label": "isdir",
        "importPath": "os.path",
        "description": "os.path",
        "isExtraImport": true,
        "detail": "os.path",
        "documentation": {}
    },
    {
        "label": "join",
        "importPath": "os.path",
        "description": "os.path",
        "isExtraImport": true,
        "detail": "os.path",
        "documentation": {}
    },
    {
        "label": "join",
        "importPath": "os.path",
        "description": "os.path",
        "isExtraImport": true,
        "detail": "os.path",
        "documentation": {}
    },
    {
        "label": "join",
        "importPath": "os.path",
        "description": "os.path",
        "isExtraImport": true,
        "detail": "os.path",
        "documentation": {}
    },
    {
        "label": "join",
        "importPath": "os.path",
        "description": "os.path",
        "isExtraImport": true,
        "detail": "os.path",
        "documentation": {}
    },
    {
        "label": "join",
        "importPath": "os.path",
        "description": "os.path",
        "isExtraImport": true,
        "detail": "os.path",
        "documentation": {}
    },
    {
        "label": "join",
        "importPath": "os.path",
        "description": "os.path",
        "isExtraImport": true,
        "detail": "os.path",
        "documentation": {}
    },
    {
        "label": "join",
        "importPath": "os.path",
        "description": "os.path",
        "isExtraImport": true,
        "detail": "os.path",
        "documentation": {}
    },
    {
        "label": "join",
        "importPath": "os.path",
        "description": "os.path",
        "isExtraImport": true,
        "detail": "os.path",
        "documentation": {}
    },
    {
        "label": "join",
        "importPath": "os.path",
        "description": "os.path",
        "isExtraImport": true,
        "detail": "os.path",
        "documentation": {}
    },
    {
        "label": "join",
        "importPath": "os.path",
        "description": "os.path",
        "isExtraImport": true,
        "detail": "os.path",
        "documentation": {}
    },
    {
        "label": "join",
        "importPath": "os.path",
        "description": "os.path",
        "isExtraImport": true,
        "detail": "os.path",
        "documentation": {}
    },
    {
        "label": "join",
        "importPath": "os.path",
        "description": "os.path",
        "isExtraImport": true,
        "detail": "os.path",
        "documentation": {}
    },
    {
        "label": "join",
        "importPath": "os.path",
        "description": "os.path",
        "isExtraImport": true,
        "detail": "os.path",
        "documentation": {}
    },
    {
        "label": "join",
        "importPath": "os.path",
        "description": "os.path",
        "isExtraImport": true,
        "detail": "os.path",
        "documentation": {}
    },
    {
        "label": "join",
        "importPath": "os.path",
        "description": "os.path",
        "isExtraImport": true,
        "detail": "os.path",
        "documentation": {}
    },
    {
        "label": "join",
        "importPath": "os.path",
        "description": "os.path",
        "isExtraImport": true,
        "detail": "os.path",
        "documentation": {}
    },
    {
        "label": "join",
        "importPath": "os.path",
        "description": "os.path",
        "isExtraImport": true,
        "detail": "os.path",
        "documentation": {}
    },
    {
        "label": "join",
        "importPath": "os.path",
        "description": "os.path",
        "isExtraImport": true,
        "detail": "os.path",
        "documentation": {}
    },
    {
        "label": "join",
        "importPath": "os.path",
        "description": "os.path",
        "isExtraImport": true,
        "detail": "os.path",
        "documentation": {}
    },
    {
        "label": "isdir",
        "importPath": "os.path",
        "description": "os.path",
        "isExtraImport": true,
        "detail": "os.path",
        "documentation": {}
    },
    {
        "label": "isdir",
        "importPath": "os.path",
        "description": "os.path",
        "isExtraImport": true,
        "detail": "os.path",
        "documentation": {}
    },
    {
        "label": "isdir",
        "importPath": "os.path",
        "description": "os.path",
        "isExtraImport": true,
        "detail": "os.path",
        "documentation": {}
    },
    {
        "label": "isdir",
        "importPath": "os.path",
        "description": "os.path",
        "isExtraImport": true,
        "detail": "os.path",
        "documentation": {}
    },
    {
        "label": "isdir",
        "importPath": "os.path",
        "description": "os.path",
        "isExtraImport": true,
        "detail": "os.path",
        "documentation": {}
    },
    {
        "label": "join",
        "importPath": "os.path",
        "description": "os.path",
        "isExtraImport": true,
        "detail": "os.path",
        "documentation": {}
    },
    {
        "label": "split",
        "importPath": "os.path",
        "description": "os.path",
        "isExtraImport": true,
        "detail": "os.path",
        "documentation": {}
    },
    {
        "label": "isdir",
        "importPath": "os.path",
        "description": "os.path",
        "isExtraImport": true,
        "detail": "os.path",
        "documentation": {}
    },
    {
        "label": "build_core_out_from_seq",
        "importPath": "sample_factory.algo.learning.rnn_utils",
        "description": "sample_factory.algo.learning.rnn_utils",
        "isExtraImport": true,
        "detail": "sample_factory.algo.learning.rnn_utils",
        "documentation": {}
    },
    {
        "label": "build_rnn_inputs",
        "importPath": "sample_factory.algo.learning.rnn_utils",
        "description": "sample_factory.algo.learning.rnn_utils",
        "isExtraImport": true,
        "detail": "sample_factory.algo.learning.rnn_utils",
        "documentation": {}
    },
    {
        "label": "build_core_out_from_seq",
        "importPath": "sample_factory.algo.learning.rnn_utils",
        "description": "sample_factory.algo.learning.rnn_utils",
        "isExtraImport": true,
        "detail": "sample_factory.algo.learning.rnn_utils",
        "documentation": {}
    },
    {
        "label": "build_rnn_inputs",
        "importPath": "sample_factory.algo.learning.rnn_utils",
        "description": "sample_factory.algo.learning.rnn_utils",
        "isExtraImport": true,
        "detail": "sample_factory.algo.learning.rnn_utils",
        "documentation": {}
    },
    {
        "label": "LEARNER_ENV_STEPS",
        "importPath": "sample_factory.algo.utils.misc",
        "description": "sample_factory.algo.utils.misc",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.misc",
        "documentation": {}
    },
    {
        "label": "POLICY_ID_KEY",
        "importPath": "sample_factory.algo.utils.misc",
        "description": "sample_factory.algo.utils.misc",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.misc",
        "documentation": {}
    },
    {
        "label": "STATS_KEY",
        "importPath": "sample_factory.algo.utils.misc",
        "description": "sample_factory.algo.utils.misc",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.misc",
        "documentation": {}
    },
    {
        "label": "TRAIN_STATS",
        "importPath": "sample_factory.algo.utils.misc",
        "description": "sample_factory.algo.utils.misc",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.misc",
        "documentation": {}
    },
    {
        "label": "memory_stats",
        "importPath": "sample_factory.algo.utils.misc",
        "description": "sample_factory.algo.utils.misc",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.misc",
        "documentation": {}
    },
    {
        "label": "LEARNER_ENV_STEPS",
        "importPath": "sample_factory.algo.utils.misc",
        "description": "sample_factory.algo.utils.misc",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.misc",
        "documentation": {}
    },
    {
        "label": "POLICY_ID_KEY",
        "importPath": "sample_factory.algo.utils.misc",
        "description": "sample_factory.algo.utils.misc",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.misc",
        "documentation": {}
    },
    {
        "label": "EPISODIC",
        "importPath": "sample_factory.algo.utils.misc",
        "description": "sample_factory.algo.utils.misc",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.misc",
        "documentation": {}
    },
    {
        "label": "LEARNER_ENV_STEPS",
        "importPath": "sample_factory.algo.utils.misc",
        "description": "sample_factory.algo.utils.misc",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.misc",
        "documentation": {}
    },
    {
        "label": "SAMPLES_COLLECTED",
        "importPath": "sample_factory.algo.utils.misc",
        "description": "sample_factory.algo.utils.misc",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.misc",
        "documentation": {}
    },
    {
        "label": "STATS_KEY",
        "importPath": "sample_factory.algo.utils.misc",
        "description": "sample_factory.algo.utils.misc",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.misc",
        "documentation": {}
    },
    {
        "label": "TIMING_STATS",
        "importPath": "sample_factory.algo.utils.misc",
        "description": "sample_factory.algo.utils.misc",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.misc",
        "documentation": {}
    },
    {
        "label": "TRAIN_STATS",
        "importPath": "sample_factory.algo.utils.misc",
        "description": "sample_factory.algo.utils.misc",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.misc",
        "documentation": {}
    },
    {
        "label": "ExperimentStatus",
        "importPath": "sample_factory.algo.utils.misc",
        "description": "sample_factory.algo.utils.misc",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.misc",
        "documentation": {}
    },
    {
        "label": "ExperimentStatus",
        "importPath": "sample_factory.algo.utils.misc",
        "description": "sample_factory.algo.utils.misc",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.misc",
        "documentation": {}
    },
    {
        "label": "ExperimentStatus",
        "importPath": "sample_factory.algo.utils.misc",
        "description": "sample_factory.algo.utils.misc",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.misc",
        "documentation": {}
    },
    {
        "label": "EPISODIC",
        "importPath": "sample_factory.algo.utils.misc",
        "description": "sample_factory.algo.utils.misc",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.misc",
        "documentation": {}
    },
    {
        "label": "POLICY_ID_KEY",
        "importPath": "sample_factory.algo.utils.misc",
        "description": "sample_factory.algo.utils.misc",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.misc",
        "documentation": {}
    },
    {
        "label": "EPISODIC",
        "importPath": "sample_factory.algo.utils.misc",
        "description": "sample_factory.algo.utils.misc",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.misc",
        "documentation": {}
    },
    {
        "label": "SAMPLES_COLLECTED",
        "importPath": "sample_factory.algo.utils.misc",
        "description": "sample_factory.algo.utils.misc",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.misc",
        "documentation": {}
    },
    {
        "label": "STATS_KEY",
        "importPath": "sample_factory.algo.utils.misc",
        "description": "sample_factory.algo.utils.misc",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.misc",
        "documentation": {}
    },
    {
        "label": "TIMING_STATS",
        "importPath": "sample_factory.algo.utils.misc",
        "description": "sample_factory.algo.utils.misc",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.misc",
        "documentation": {}
    },
    {
        "label": "ExperimentStatus",
        "importPath": "sample_factory.algo.utils.misc",
        "description": "sample_factory.algo.utils.misc",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.misc",
        "documentation": {}
    },
    {
        "label": "POLICY_ID_KEY",
        "importPath": "sample_factory.algo.utils.misc",
        "description": "sample_factory.algo.utils.misc",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.misc",
        "documentation": {}
    },
    {
        "label": "SAMPLES_COLLECTED",
        "importPath": "sample_factory.algo.utils.misc",
        "description": "sample_factory.algo.utils.misc",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.misc",
        "documentation": {}
    },
    {
        "label": "STATS_KEY",
        "importPath": "sample_factory.algo.utils.misc",
        "description": "sample_factory.algo.utils.misc",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.misc",
        "documentation": {}
    },
    {
        "label": "TIMING_STATS",
        "importPath": "sample_factory.algo.utils.misc",
        "description": "sample_factory.algo.utils.misc",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.misc",
        "documentation": {}
    },
    {
        "label": "advance_rollouts_signal",
        "importPath": "sample_factory.algo.utils.misc",
        "description": "sample_factory.algo.utils.misc",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.misc",
        "documentation": {}
    },
    {
        "label": "memory_stats",
        "importPath": "sample_factory.algo.utils.misc",
        "description": "sample_factory.algo.utils.misc",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.misc",
        "documentation": {}
    },
    {
        "label": "EPISODIC",
        "importPath": "sample_factory.algo.utils.misc",
        "description": "sample_factory.algo.utils.misc",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.misc",
        "documentation": {}
    },
    {
        "label": "POLICY_ID_KEY",
        "importPath": "sample_factory.algo.utils.misc",
        "description": "sample_factory.algo.utils.misc",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.misc",
        "documentation": {}
    },
    {
        "label": "advance_rollouts_signal",
        "importPath": "sample_factory.algo.utils.misc",
        "description": "sample_factory.algo.utils.misc",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.misc",
        "documentation": {}
    },
    {
        "label": "new_trajectories_signal",
        "importPath": "sample_factory.algo.utils.misc",
        "description": "sample_factory.algo.utils.misc",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.misc",
        "documentation": {}
    },
    {
        "label": "advance_rollouts_signal",
        "importPath": "sample_factory.algo.utils.misc",
        "description": "sample_factory.algo.utils.misc",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.misc",
        "documentation": {}
    },
    {
        "label": "new_trajectories_signal",
        "importPath": "sample_factory.algo.utils.misc",
        "description": "sample_factory.algo.utils.misc",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.misc",
        "documentation": {}
    },
    {
        "label": "SAMPLES_COLLECTED",
        "importPath": "sample_factory.algo.utils.misc",
        "description": "sample_factory.algo.utils.misc",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.misc",
        "documentation": {}
    },
    {
        "label": "MAGIC_FLOAT",
        "importPath": "sample_factory.algo.utils.misc",
        "description": "sample_factory.algo.utils.misc",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.misc",
        "documentation": {}
    },
    {
        "label": "MAGIC_INT",
        "importPath": "sample_factory.algo.utils.misc",
        "description": "sample_factory.algo.utils.misc",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.misc",
        "documentation": {}
    },
    {
        "label": "MAGIC_FLOAT",
        "importPath": "sample_factory.algo.utils.misc",
        "description": "sample_factory.algo.utils.misc",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.misc",
        "documentation": {}
    },
    {
        "label": "MAGIC_INT",
        "importPath": "sample_factory.algo.utils.misc",
        "description": "sample_factory.algo.utils.misc",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.misc",
        "documentation": {}
    },
    {
        "label": "ExperimentStatus",
        "importPath": "sample_factory.algo.utils.misc",
        "description": "sample_factory.algo.utils.misc",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.misc",
        "documentation": {}
    },
    {
        "label": "EPS",
        "importPath": "sample_factory.algo.utils.misc",
        "description": "sample_factory.algo.utils.misc",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.misc",
        "documentation": {}
    },
    {
        "label": "EPS",
        "importPath": "sample_factory.algo.utils.misc",
        "description": "sample_factory.algo.utils.misc",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.misc",
        "documentation": {}
    },
    {
        "label": "EPS",
        "importPath": "sample_factory.algo.utils.misc",
        "description": "sample_factory.algo.utils.misc",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.misc",
        "documentation": {}
    },
    {
        "label": "ExperimentStatus",
        "importPath": "sample_factory.algo.utils.misc",
        "description": "sample_factory.algo.utils.misc",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.misc",
        "documentation": {}
    },
    {
        "label": "ExperimentStatus",
        "importPath": "sample_factory.algo.utils.misc",
        "description": "sample_factory.algo.utils.misc",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.misc",
        "documentation": {}
    },
    {
        "label": "EPISODIC",
        "importPath": "sample_factory.algo.utils.misc",
        "description": "sample_factory.algo.utils.misc",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.misc",
        "documentation": {}
    },
    {
        "label": "ExperimentStatus",
        "importPath": "sample_factory.algo.utils.misc",
        "description": "sample_factory.algo.utils.misc",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.misc",
        "documentation": {}
    },
    {
        "label": "EPS",
        "importPath": "sample_factory.algo.utils.misc",
        "description": "sample_factory.algo.utils.misc",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.misc",
        "documentation": {}
    },
    {
        "label": "EPS",
        "importPath": "sample_factory.algo.utils.misc",
        "description": "sample_factory.algo.utils.misc",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.misc",
        "documentation": {}
    },
    {
        "label": "ExperimentStatus",
        "importPath": "sample_factory.algo.utils.misc",
        "description": "sample_factory.algo.utils.misc",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.misc",
        "documentation": {}
    },
    {
        "label": "ExperimentStatus",
        "importPath": "sample_factory.algo.utils.misc",
        "description": "sample_factory.algo.utils.misc",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.misc",
        "documentation": {}
    },
    {
        "label": "ExperimentStatus",
        "importPath": "sample_factory.algo.utils.misc",
        "description": "sample_factory.algo.utils.misc",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.misc",
        "documentation": {}
    },
    {
        "label": "ExperimentStatus",
        "importPath": "sample_factory.algo.utils.misc",
        "description": "sample_factory.algo.utils.misc",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.misc",
        "documentation": {}
    },
    {
        "label": "EPS",
        "importPath": "sample_factory.algo.utils.misc",
        "description": "sample_factory.algo.utils.misc",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.misc",
        "documentation": {}
    },
    {
        "label": "ExperimentStatus",
        "importPath": "sample_factory.algo.utils.misc",
        "description": "sample_factory.algo.utils.misc",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.misc",
        "documentation": {}
    },
    {
        "label": "ExperimentStatus",
        "importPath": "sample_factory.algo.utils.misc",
        "description": "sample_factory.algo.utils.misc",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.misc",
        "documentation": {}
    },
    {
        "label": "ParameterServer",
        "importPath": "sample_factory.algo.utils.model_sharing",
        "description": "sample_factory.algo.utils.model_sharing",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.model_sharing",
        "documentation": {}
    },
    {
        "label": "ParameterServer",
        "importPath": "sample_factory.algo.utils.model_sharing",
        "description": "sample_factory.algo.utils.model_sharing",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.model_sharing",
        "documentation": {}
    },
    {
        "label": "ParameterServer",
        "importPath": "sample_factory.algo.utils.model_sharing",
        "description": "sample_factory.algo.utils.model_sharing",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.model_sharing",
        "documentation": {}
    },
    {
        "label": "ParameterServer",
        "importPath": "sample_factory.algo.utils.model_sharing",
        "description": "sample_factory.algo.utils.model_sharing",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.model_sharing",
        "documentation": {}
    },
    {
        "label": "make_parameter_client",
        "importPath": "sample_factory.algo.utils.model_sharing",
        "description": "sample_factory.algo.utils.model_sharing",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.model_sharing",
        "documentation": {}
    },
    {
        "label": "ParameterServer",
        "importPath": "sample_factory.algo.utils.model_sharing",
        "description": "sample_factory.algo.utils.model_sharing",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.model_sharing",
        "documentation": {}
    },
    {
        "label": "ParameterServer",
        "importPath": "sample_factory.algo.utils.model_sharing",
        "description": "sample_factory.algo.utils.model_sharing",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.model_sharing",
        "documentation": {}
    },
    {
        "label": "ParameterServer",
        "importPath": "sample_factory.algo.utils.model_sharing",
        "description": "sample_factory.algo.utils.model_sharing",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.model_sharing",
        "documentation": {}
    },
    {
        "label": "Lamb",
        "importPath": "sample_factory.algo.utils.optimizers",
        "description": "sample_factory.algo.utils.optimizers",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.optimizers",
        "documentation": {}
    },
    {
        "label": "gae_advantages",
        "importPath": "sample_factory.algo.utils.rl_utils",
        "description": "sample_factory.algo.utils.rl_utils",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.rl_utils",
        "documentation": {}
    },
    {
        "label": "prepare_and_normalize_obs",
        "importPath": "sample_factory.algo.utils.rl_utils",
        "description": "sample_factory.algo.utils.rl_utils",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.rl_utils",
        "documentation": {}
    },
    {
        "label": "samples_per_trajectory",
        "importPath": "sample_factory.algo.utils.rl_utils",
        "description": "sample_factory.algo.utils.rl_utils",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.rl_utils",
        "documentation": {}
    },
    {
        "label": "prepare_and_normalize_obs",
        "importPath": "sample_factory.algo.utils.rl_utils",
        "description": "sample_factory.algo.utils.rl_utils",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.rl_utils",
        "documentation": {}
    },
    {
        "label": "total_num_agents",
        "importPath": "sample_factory.algo.utils.rl_utils",
        "description": "sample_factory.algo.utils.rl_utils",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.rl_utils",
        "documentation": {}
    },
    {
        "label": "trajectories_per_training_iteration",
        "importPath": "sample_factory.algo.utils.rl_utils",
        "description": "sample_factory.algo.utils.rl_utils",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.rl_utils",
        "documentation": {}
    },
    {
        "label": "total_num_envs",
        "importPath": "sample_factory.algo.utils.rl_utils",
        "description": "sample_factory.algo.utils.rl_utils",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.rl_utils",
        "documentation": {}
    },
    {
        "label": "trajectories_per_training_iteration",
        "importPath": "sample_factory.algo.utils.rl_utils",
        "description": "sample_factory.algo.utils.rl_utils",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.rl_utils",
        "documentation": {}
    },
    {
        "label": "total_num_agents",
        "importPath": "sample_factory.algo.utils.rl_utils",
        "description": "sample_factory.algo.utils.rl_utils",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.rl_utils",
        "documentation": {}
    },
    {
        "label": "make_dones",
        "importPath": "sample_factory.algo.utils.rl_utils",
        "description": "sample_factory.algo.utils.rl_utils",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.rl_utils",
        "documentation": {}
    },
    {
        "label": "prepare_and_normalize_obs",
        "importPath": "sample_factory.algo.utils.rl_utils",
        "description": "sample_factory.algo.utils.rl_utils",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.rl_utils",
        "documentation": {}
    },
    {
        "label": "make_dones",
        "importPath": "sample_factory.algo.utils.rl_utils",
        "description": "sample_factory.algo.utils.rl_utils",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.rl_utils",
        "documentation": {}
    },
    {
        "label": "samples_per_trajectory",
        "importPath": "sample_factory.algo.utils.rl_utils",
        "description": "sample_factory.algo.utils.rl_utils",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.rl_utils",
        "documentation": {}
    },
    {
        "label": "make_dones",
        "importPath": "sample_factory.algo.utils.rl_utils",
        "description": "sample_factory.algo.utils.rl_utils",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.rl_utils",
        "documentation": {}
    },
    {
        "label": "make_dones",
        "importPath": "sample_factory.algo.utils.rl_utils",
        "description": "sample_factory.algo.utils.rl_utils",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.rl_utils",
        "documentation": {}
    },
    {
        "label": "make_dones",
        "importPath": "sample_factory.algo.utils.rl_utils",
        "description": "sample_factory.algo.utils.rl_utils",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.rl_utils",
        "documentation": {}
    },
    {
        "label": "samples_per_trajectory",
        "importPath": "sample_factory.algo.utils.rl_utils",
        "description": "sample_factory.algo.utils.rl_utils",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.rl_utils",
        "documentation": {}
    },
    {
        "label": "make_dones",
        "importPath": "sample_factory.algo.utils.rl_utils",
        "description": "sample_factory.algo.utils.rl_utils",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.rl_utils",
        "documentation": {}
    },
    {
        "label": "masked_select",
        "importPath": "sample_factory.algo.utils.torch_utils",
        "description": "sample_factory.algo.utils.torch_utils",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "synchronize",
        "importPath": "sample_factory.algo.utils.torch_utils",
        "description": "sample_factory.algo.utils.torch_utils",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "to_scalar",
        "importPath": "sample_factory.algo.utils.torch_utils",
        "description": "sample_factory.algo.utils.torch_utils",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "init_torch_runtime",
        "importPath": "sample_factory.algo.utils.torch_utils",
        "description": "sample_factory.algo.utils.torch_utils",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "init_torch_runtime",
        "importPath": "sample_factory.algo.utils.torch_utils",
        "description": "sample_factory.algo.utils.torch_utils",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "synchronize",
        "importPath": "sample_factory.algo.utils.torch_utils",
        "description": "sample_factory.algo.utils.torch_utils",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "inference_context",
        "importPath": "sample_factory.algo.utils.torch_utils",
        "description": "sample_factory.algo.utils.torch_utils",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "init_torch_runtime",
        "importPath": "sample_factory.algo.utils.torch_utils",
        "description": "sample_factory.algo.utils.torch_utils",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "synchronize",
        "importPath": "sample_factory.algo.utils.torch_utils",
        "description": "sample_factory.algo.utils.torch_utils",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "inference_context",
        "importPath": "sample_factory.algo.utils.torch_utils",
        "description": "sample_factory.algo.utils.torch_utils",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "to_torch_dtype",
        "importPath": "sample_factory.algo.utils.torch_utils",
        "description": "sample_factory.algo.utils.torch_utils",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "calc_num_elements",
        "importPath": "sample_factory.algo.utils.torch_utils",
        "description": "sample_factory.algo.utils.torch_utils",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "calc_num_elements",
        "importPath": "sample_factory.algo.utils.torch_utils",
        "description": "sample_factory.algo.utils.torch_utils",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "calc_num_elements",
        "importPath": "sample_factory.algo.utils.torch_utils",
        "description": "sample_factory.algo.utils.torch_utils",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "calc_num_elements",
        "importPath": "sample_factory.algo.utils.torch_utils",
        "description": "sample_factory.algo.utils.torch_utils",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "calc_num_elements",
        "importPath": "sample_factory.algo.utils.torch_utils",
        "description": "sample_factory.algo.utils.torch_utils",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "Configurable",
        "importPath": "sample_factory.cfg.configurable",
        "description": "sample_factory.cfg.configurable",
        "isExtraImport": true,
        "detail": "sample_factory.cfg.configurable",
        "documentation": {}
    },
    {
        "label": "Configurable",
        "importPath": "sample_factory.cfg.configurable",
        "description": "sample_factory.cfg.configurable",
        "isExtraImport": true,
        "detail": "sample_factory.cfg.configurable",
        "documentation": {}
    },
    {
        "label": "Configurable",
        "importPath": "sample_factory.cfg.configurable",
        "description": "sample_factory.cfg.configurable",
        "isExtraImport": true,
        "detail": "sample_factory.cfg.configurable",
        "documentation": {}
    },
    {
        "label": "Configurable",
        "importPath": "sample_factory.cfg.configurable",
        "description": "sample_factory.cfg.configurable",
        "isExtraImport": true,
        "detail": "sample_factory.cfg.configurable",
        "documentation": {}
    },
    {
        "label": "Configurable",
        "importPath": "sample_factory.cfg.configurable",
        "description": "sample_factory.cfg.configurable",
        "isExtraImport": true,
        "detail": "sample_factory.cfg.configurable",
        "documentation": {}
    },
    {
        "label": "Configurable",
        "importPath": "sample_factory.cfg.configurable",
        "description": "sample_factory.cfg.configurable",
        "isExtraImport": true,
        "detail": "sample_factory.cfg.configurable",
        "documentation": {}
    },
    {
        "label": "Configurable",
        "importPath": "sample_factory.cfg.configurable",
        "description": "sample_factory.cfg.configurable",
        "isExtraImport": true,
        "detail": "sample_factory.cfg.configurable",
        "documentation": {}
    },
    {
        "label": "Configurable",
        "importPath": "sample_factory.cfg.configurable",
        "description": "sample_factory.cfg.configurable",
        "isExtraImport": true,
        "detail": "sample_factory.cfg.configurable",
        "documentation": {}
    },
    {
        "label": "Configurable",
        "importPath": "sample_factory.cfg.configurable",
        "description": "sample_factory.cfg.configurable",
        "isExtraImport": true,
        "detail": "sample_factory.cfg.configurable",
        "documentation": {}
    },
    {
        "label": "Configurable",
        "importPath": "sample_factory.cfg.configurable",
        "description": "sample_factory.cfg.configurable",
        "isExtraImport": true,
        "detail": "sample_factory.cfg.configurable",
        "documentation": {}
    },
    {
        "label": "Configurable",
        "importPath": "sample_factory.cfg.configurable",
        "description": "sample_factory.cfg.configurable",
        "isExtraImport": true,
        "detail": "sample_factory.cfg.configurable",
        "documentation": {}
    },
    {
        "label": "ActorCritic",
        "importPath": "sample_factory.model.actor_critic",
        "description": "sample_factory.model.actor_critic",
        "isExtraImport": true,
        "detail": "sample_factory.model.actor_critic",
        "documentation": {}
    },
    {
        "label": "create_actor_critic",
        "importPath": "sample_factory.model.actor_critic",
        "description": "sample_factory.model.actor_critic",
        "isExtraImport": true,
        "detail": "sample_factory.model.actor_critic",
        "documentation": {}
    },
    {
        "label": "create_actor_critic",
        "importPath": "sample_factory.model.actor_critic",
        "description": "sample_factory.model.actor_critic",
        "isExtraImport": true,
        "detail": "sample_factory.model.actor_critic",
        "documentation": {}
    },
    {
        "label": "ActorCritic",
        "importPath": "sample_factory.model.actor_critic",
        "description": "sample_factory.model.actor_critic",
        "isExtraImport": true,
        "detail": "sample_factory.model.actor_critic",
        "documentation": {}
    },
    {
        "label": "default_make_actor_critic_func",
        "importPath": "sample_factory.model.actor_critic",
        "description": "sample_factory.model.actor_critic",
        "isExtraImport": true,
        "detail": "sample_factory.model.actor_critic",
        "documentation": {}
    },
    {
        "label": "create_actor_critic",
        "importPath": "sample_factory.model.actor_critic",
        "description": "sample_factory.model.actor_critic",
        "isExtraImport": true,
        "detail": "sample_factory.model.actor_critic",
        "documentation": {}
    },
    {
        "label": "create_actor_critic",
        "importPath": "sample_factory.model.actor_critic",
        "description": "sample_factory.model.actor_critic",
        "isExtraImport": true,
        "detail": "sample_factory.model.actor_critic",
        "documentation": {}
    },
    {
        "label": "LinearDecay",
        "importPath": "sample_factory.utils.decay",
        "description": "sample_factory.utils.decay",
        "isExtraImport": true,
        "detail": "sample_factory.utils.decay",
        "documentation": {}
    },
    {
        "label": "iterate_recursively",
        "importPath": "sample_factory.utils.dicts",
        "description": "sample_factory.utils.dicts",
        "isExtraImport": true,
        "detail": "sample_factory.utils.dicts",
        "documentation": {}
    },
    {
        "label": "iterate_recursively",
        "importPath": "sample_factory.utils.dicts",
        "description": "sample_factory.utils.dicts",
        "isExtraImport": true,
        "detail": "sample_factory.utils.dicts",
        "documentation": {}
    },
    {
        "label": "iterate_recursively_with_prefix",
        "importPath": "sample_factory.utils.dicts",
        "description": "sample_factory.utils.dicts",
        "isExtraImport": true,
        "detail": "sample_factory.utils.dicts",
        "documentation": {}
    },
    {
        "label": "iterate_recursively",
        "importPath": "sample_factory.utils.dicts",
        "description": "sample_factory.utils.dicts",
        "isExtraImport": true,
        "detail": "sample_factory.utils.dicts",
        "documentation": {}
    },
    {
        "label": "dict_of_lists_append_idx",
        "importPath": "sample_factory.utils.dicts",
        "description": "sample_factory.utils.dicts",
        "isExtraImport": true,
        "detail": "sample_factory.utils.dicts",
        "documentation": {}
    },
    {
        "label": "dict_of_lists_append",
        "importPath": "sample_factory.utils.dicts",
        "description": "sample_factory.utils.dicts",
        "isExtraImport": true,
        "detail": "sample_factory.utils.dicts",
        "documentation": {}
    },
    {
        "label": "list_of_dicts_to_dict_of_lists",
        "importPath": "sample_factory.utils.dicts",
        "description": "sample_factory.utils.dicts",
        "isExtraImport": true,
        "detail": "sample_factory.utils.dicts",
        "documentation": {}
    },
    {
        "label": "copy_dict_structure",
        "importPath": "sample_factory.utils.dicts",
        "description": "sample_factory.utils.dicts",
        "isExtraImport": true,
        "detail": "sample_factory.utils.dicts",
        "documentation": {}
    },
    {
        "label": "iter_dicts_recursively",
        "importPath": "sample_factory.utils.dicts",
        "description": "sample_factory.utils.dicts",
        "isExtraImport": true,
        "detail": "sample_factory.utils.dicts",
        "documentation": {}
    },
    {
        "label": "iterate_recursively",
        "importPath": "sample_factory.utils.dicts",
        "description": "sample_factory.utils.dicts",
        "isExtraImport": true,
        "detail": "sample_factory.utils.dicts",
        "documentation": {}
    },
    {
        "label": "list_of_dicts_to_dict_of_lists",
        "importPath": "sample_factory.utils.dicts",
        "description": "sample_factory.utils.dicts",
        "isExtraImport": true,
        "detail": "sample_factory.utils.dicts",
        "documentation": {}
    },
    {
        "label": "iter_dicts_recursively",
        "importPath": "sample_factory.utils.dicts",
        "description": "sample_factory.utils.dicts",
        "isExtraImport": true,
        "detail": "sample_factory.utils.dicts",
        "documentation": {}
    },
    {
        "label": "iterate_recursively",
        "importPath": "sample_factory.utils.dicts",
        "description": "sample_factory.utils.dicts",
        "isExtraImport": true,
        "detail": "sample_factory.utils.dicts",
        "documentation": {}
    },
    {
        "label": "copy_dict_structure",
        "importPath": "sample_factory.utils.dicts",
        "description": "sample_factory.utils.dicts",
        "isExtraImport": true,
        "detail": "sample_factory.utils.dicts",
        "documentation": {}
    },
    {
        "label": "iter_dicts_recursively",
        "importPath": "sample_factory.utils.dicts",
        "description": "sample_factory.utils.dicts",
        "isExtraImport": true,
        "detail": "sample_factory.utils.dicts",
        "documentation": {}
    },
    {
        "label": "iterate_recursively",
        "importPath": "sample_factory.utils.dicts",
        "description": "sample_factory.utils.dicts",
        "isExtraImport": true,
        "detail": "sample_factory.utils.dicts",
        "documentation": {}
    },
    {
        "label": "list_of_dicts_to_dict_of_lists",
        "importPath": "sample_factory.utils.dicts",
        "description": "sample_factory.utils.dicts",
        "isExtraImport": true,
        "detail": "sample_factory.utils.dicts",
        "documentation": {}
    },
    {
        "label": "Batcher",
        "importPath": "sample_factory.algo.learning.batcher",
        "description": "sample_factory.algo.learning.batcher",
        "isExtraImport": true,
        "detail": "sample_factory.algo.learning.batcher",
        "documentation": {}
    },
    {
        "label": "Batcher",
        "importPath": "sample_factory.algo.learning.batcher",
        "description": "sample_factory.algo.learning.batcher",
        "isExtraImport": true,
        "detail": "sample_factory.algo.learning.batcher",
        "documentation": {}
    },
    {
        "label": "Learner",
        "importPath": "sample_factory.algo.learning.learner",
        "description": "sample_factory.algo.learning.learner",
        "isExtraImport": true,
        "detail": "sample_factory.algo.learning.learner",
        "documentation": {}
    },
    {
        "label": "Learner",
        "importPath": "sample_factory.algo.learning.learner",
        "description": "sample_factory.algo.learning.learner",
        "isExtraImport": true,
        "detail": "sample_factory.algo.learning.learner",
        "documentation": {}
    },
    {
        "label": "Learner",
        "importPath": "sample_factory.algo.learning.learner",
        "description": "sample_factory.algo.learning.learner",
        "isExtraImport": true,
        "detail": "sample_factory.algo.learning.learner",
        "documentation": {}
    },
    {
        "label": "Learner",
        "importPath": "sample_factory.algo.learning.learner",
        "description": "sample_factory.algo.learning.learner",
        "isExtraImport": true,
        "detail": "sample_factory.algo.learning.learner",
        "documentation": {}
    },
    {
        "label": "SampleFactoryContext",
        "importPath": "sample_factory.algo.utils.context",
        "description": "sample_factory.algo.utils.context",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.context",
        "documentation": {}
    },
    {
        "label": "set_global_context",
        "importPath": "sample_factory.algo.utils.context",
        "description": "sample_factory.algo.utils.context",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.context",
        "documentation": {}
    },
    {
        "label": "sf_global_context",
        "importPath": "sample_factory.algo.utils.context",
        "description": "sample_factory.algo.utils.context",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.context",
        "documentation": {}
    },
    {
        "label": "SampleFactoryContext",
        "importPath": "sample_factory.algo.utils.context",
        "description": "sample_factory.algo.utils.context",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.context",
        "documentation": {}
    },
    {
        "label": "set_global_context",
        "importPath": "sample_factory.algo.utils.context",
        "description": "sample_factory.algo.utils.context",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.context",
        "documentation": {}
    },
    {
        "label": "SampleFactoryContext",
        "importPath": "sample_factory.algo.utils.context",
        "description": "sample_factory.algo.utils.context",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.context",
        "documentation": {}
    },
    {
        "label": "set_global_context",
        "importPath": "sample_factory.algo.utils.context",
        "description": "sample_factory.algo.utils.context",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.context",
        "documentation": {}
    },
    {
        "label": "sf_global_context",
        "importPath": "sample_factory.algo.utils.context",
        "description": "sample_factory.algo.utils.context",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.context",
        "documentation": {}
    },
    {
        "label": "set_global_context",
        "importPath": "sample_factory.algo.utils.context",
        "description": "sample_factory.algo.utils.context",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.context",
        "documentation": {}
    },
    {
        "label": "sf_global_context",
        "importPath": "sample_factory.algo.utils.context",
        "description": "sample_factory.algo.utils.context",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.context",
        "documentation": {}
    },
    {
        "label": "global_env_registry",
        "importPath": "sample_factory.algo.utils.context",
        "description": "sample_factory.algo.utils.context",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.context",
        "documentation": {}
    },
    {
        "label": "global_env_registry",
        "importPath": "sample_factory.algo.utils.context",
        "description": "sample_factory.algo.utils.context",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.context",
        "documentation": {}
    },
    {
        "label": "global_model_factory",
        "importPath": "sample_factory.algo.utils.context",
        "description": "sample_factory.algo.utils.context",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.context",
        "documentation": {}
    },
    {
        "label": "global_model_factory",
        "importPath": "sample_factory.algo.utils.context",
        "description": "sample_factory.algo.utils.context",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.context",
        "documentation": {}
    },
    {
        "label": "global_model_factory",
        "importPath": "sample_factory.algo.utils.context",
        "description": "sample_factory.algo.utils.context",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.context",
        "documentation": {}
    },
    {
        "label": "global_model_factory",
        "importPath": "sample_factory.algo.utils.context",
        "description": "sample_factory.algo.utils.context",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.context",
        "documentation": {}
    },
    {
        "label": "global_model_factory",
        "importPath": "sample_factory.algo.utils.context",
        "description": "sample_factory.algo.utils.context",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.context",
        "documentation": {}
    },
    {
        "label": "reset_global_context",
        "importPath": "sample_factory.algo.utils.context",
        "description": "sample_factory.algo.utils.context",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.context",
        "documentation": {}
    },
    {
        "label": "reset_global_context",
        "importPath": "sample_factory.algo.utils.context",
        "description": "sample_factory.algo.utils.context",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.context",
        "documentation": {}
    },
    {
        "label": "reset_global_context",
        "importPath": "sample_factory.algo.utils.context",
        "description": "sample_factory.algo.utils.context",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.context",
        "documentation": {}
    },
    {
        "label": "reset_global_context",
        "importPath": "sample_factory.algo.utils.context",
        "description": "sample_factory.algo.utils.context",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.context",
        "documentation": {}
    },
    {
        "label": "SampleFactoryContext",
        "importPath": "sample_factory.algo.utils.context",
        "description": "sample_factory.algo.utils.context",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.context",
        "documentation": {}
    },
    {
        "label": "cuda_envvars_for_policy",
        "importPath": "sample_factory.utils.gpu_utils",
        "description": "sample_factory.utils.gpu_utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.gpu_utils",
        "documentation": {}
    },
    {
        "label": "set_global_cuda_envvars",
        "importPath": "sample_factory.utils.gpu_utils",
        "description": "sample_factory.utils.gpu_utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.gpu_utils",
        "documentation": {}
    },
    {
        "label": "set_global_cuda_envvars",
        "importPath": "sample_factory.utils.gpu_utils",
        "description": "sample_factory.utils.gpu_utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.gpu_utils",
        "documentation": {}
    },
    {
        "label": "cuda_envvars_for_policy",
        "importPath": "sample_factory.utils.gpu_utils",
        "description": "sample_factory.utils.gpu_utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.gpu_utils",
        "documentation": {}
    },
    {
        "label": "set_gpus_for_process",
        "importPath": "sample_factory.utils.gpu_utils",
        "description": "sample_factory.utils.gpu_utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.gpu_utils",
        "documentation": {}
    },
    {
        "label": "gpus_for_process",
        "importPath": "sample_factory.utils.gpu_utils",
        "description": "sample_factory.utils.gpu_utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.gpu_utils",
        "documentation": {}
    },
    {
        "label": "gpus_for_process",
        "importPath": "sample_factory.utils.gpu_utils",
        "description": "sample_factory.utils.gpu_utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.gpu_utils",
        "documentation": {}
    },
    {
        "label": "PackedSequence",
        "importPath": "torch.nn.utils.rnn",
        "description": "torch.nn.utils.rnn",
        "isExtraImport": true,
        "detail": "torch.nn.utils.rnn",
        "documentation": {}
    },
    {
        "label": "invert_permutation",
        "importPath": "torch.nn.utils.rnn",
        "description": "torch.nn.utils.rnn",
        "isExtraImport": true,
        "detail": "torch.nn.utils.rnn",
        "documentation": {}
    },
    {
        "label": "PackedSequence",
        "importPath": "torch.nn.utils.rnn",
        "description": "torch.nn.utils.rnn",
        "isExtraImport": true,
        "detail": "torch.nn.utils.rnn",
        "documentation": {}
    },
    {
        "label": "pack_padded_sequence",
        "importPath": "torch.nn.utils.rnn",
        "description": "torch.nn.utils.rnn",
        "isExtraImport": true,
        "detail": "torch.nn.utils.rnn",
        "documentation": {}
    },
    {
        "label": "pad_packed_sequence",
        "importPath": "torch.nn.utils.rnn",
        "description": "torch.nn.utils.rnn",
        "isExtraImport": true,
        "detail": "torch.nn.utils.rnn",
        "documentation": {}
    },
    {
        "label": "json",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "json",
        "description": "json",
        "detail": "json",
        "documentation": {}
    },
    {
        "label": "load",
        "importPath": "json",
        "description": "json",
        "isExtraImport": true,
        "detail": "json",
        "documentation": {}
    },
    {
        "label": "SummaryWriter",
        "importPath": "tensorboardX",
        "description": "tensorboardX",
        "isExtraImport": true,
        "detail": "tensorboardX",
        "documentation": {}
    },
    {
        "label": "SummaryWriter",
        "importPath": "tensorboardX",
        "description": "tensorboardX",
        "isExtraImport": true,
        "detail": "tensorboardX",
        "documentation": {}
    },
    {
        "label": "SummaryWriter",
        "importPath": "tensorboardX",
        "description": "tensorboardX",
        "isExtraImport": true,
        "detail": "tensorboardX",
        "documentation": {}
    },
    {
        "label": "SummaryWriter",
        "importPath": "tensorboardX",
        "description": "tensorboardX",
        "isExtraImport": true,
        "detail": "tensorboardX",
        "documentation": {}
    },
    {
        "label": "LearnerWorker",
        "importPath": "sample_factory.algo.learning.learner_worker",
        "description": "sample_factory.algo.learning.learner_worker",
        "isExtraImport": true,
        "detail": "sample_factory.algo.learning.learner_worker",
        "documentation": {}
    },
    {
        "label": "init_learner_process",
        "importPath": "sample_factory.algo.learning.learner_worker",
        "description": "sample_factory.algo.learning.learner_worker",
        "isExtraImport": true,
        "detail": "sample_factory.algo.learning.learner_worker",
        "documentation": {}
    },
    {
        "label": "AbstractSampler",
        "importPath": "sample_factory.algo.sampling.sampler",
        "description": "sample_factory.algo.sampling.sampler",
        "isExtraImport": true,
        "detail": "sample_factory.algo.sampling.sampler",
        "documentation": {}
    },
    {
        "label": "ParallelSampler",
        "importPath": "sample_factory.algo.sampling.sampler",
        "description": "sample_factory.algo.sampling.sampler",
        "isExtraImport": true,
        "detail": "sample_factory.algo.sampling.sampler",
        "documentation": {}
    },
    {
        "label": "SerialSampler",
        "importPath": "sample_factory.algo.sampling.sampler",
        "description": "sample_factory.algo.sampling.sampler",
        "isExtraImport": true,
        "detail": "sample_factory.algo.sampling.sampler",
        "documentation": {}
    },
    {
        "label": "AbstractSampler",
        "importPath": "sample_factory.algo.sampling.sampler",
        "description": "sample_factory.algo.sampling.sampler",
        "isExtraImport": true,
        "detail": "sample_factory.algo.sampling.sampler",
        "documentation": {}
    },
    {
        "label": "ParallelSampler",
        "importPath": "sample_factory.algo.sampling.sampler",
        "description": "sample_factory.algo.sampling.sampler",
        "isExtraImport": true,
        "detail": "sample_factory.algo.sampling.sampler",
        "documentation": {}
    },
    {
        "label": "SerialSampler",
        "importPath": "sample_factory.algo.sampling.sampler",
        "description": "sample_factory.algo.sampling.sampler",
        "isExtraImport": true,
        "detail": "sample_factory.algo.sampling.sampler",
        "documentation": {}
    },
    {
        "label": "SerialSampler",
        "importPath": "sample_factory.algo.sampling.sampler",
        "description": "sample_factory.algo.sampling.sampler",
        "isExtraImport": true,
        "detail": "sample_factory.algo.sampling.sampler",
        "documentation": {}
    },
    {
        "label": "samples_stats_handler",
        "importPath": "sample_factory.algo.sampling.stats",
        "description": "sample_factory.algo.sampling.stats",
        "isExtraImport": true,
        "detail": "sample_factory.algo.sampling.stats",
        "documentation": {}
    },
    {
        "label": "stats_msg_handler",
        "importPath": "sample_factory.algo.sampling.stats",
        "description": "sample_factory.algo.sampling.stats",
        "isExtraImport": true,
        "detail": "sample_factory.algo.sampling.stats",
        "documentation": {}
    },
    {
        "label": "timing_msg_handler",
        "importPath": "sample_factory.algo.sampling.stats",
        "description": "sample_factory.algo.sampling.stats",
        "isExtraImport": true,
        "detail": "sample_factory.algo.sampling.stats",
        "documentation": {}
    },
    {
        "label": "samples_stats_handler",
        "importPath": "sample_factory.algo.sampling.stats",
        "description": "sample_factory.algo.sampling.stats",
        "isExtraImport": true,
        "detail": "sample_factory.algo.sampling.stats",
        "documentation": {}
    },
    {
        "label": "stats_msg_handler",
        "importPath": "sample_factory.algo.sampling.stats",
        "description": "sample_factory.algo.sampling.stats",
        "isExtraImport": true,
        "detail": "sample_factory.algo.sampling.stats",
        "documentation": {}
    },
    {
        "label": "timing_msg_handler",
        "importPath": "sample_factory.algo.sampling.stats",
        "description": "sample_factory.algo.sampling.stats",
        "isExtraImport": true,
        "detail": "sample_factory.algo.sampling.stats",
        "documentation": {}
    },
    {
        "label": "cfg_dict",
        "importPath": "sample_factory.cfg.arguments",
        "description": "sample_factory.cfg.arguments",
        "isExtraImport": true,
        "detail": "sample_factory.cfg.arguments",
        "documentation": {}
    },
    {
        "label": "cfg_str",
        "importPath": "sample_factory.cfg.arguments",
        "description": "sample_factory.cfg.arguments",
        "isExtraImport": true,
        "detail": "sample_factory.cfg.arguments",
        "documentation": {}
    },
    {
        "label": "preprocess_cfg",
        "importPath": "sample_factory.cfg.arguments",
        "description": "sample_factory.cfg.arguments",
        "isExtraImport": true,
        "detail": "sample_factory.cfg.arguments",
        "documentation": {}
    },
    {
        "label": "cfg_dict",
        "importPath": "sample_factory.cfg.arguments",
        "description": "sample_factory.cfg.arguments",
        "isExtraImport": true,
        "detail": "sample_factory.cfg.arguments",
        "documentation": {}
    },
    {
        "label": "load_from_checkpoint",
        "importPath": "sample_factory.cfg.arguments",
        "description": "sample_factory.cfg.arguments",
        "isExtraImport": true,
        "detail": "sample_factory.cfg.arguments",
        "documentation": {}
    },
    {
        "label": "maybe_load_from_checkpoint",
        "importPath": "sample_factory.cfg.arguments",
        "description": "sample_factory.cfg.arguments",
        "isExtraImport": true,
        "detail": "sample_factory.cfg.arguments",
        "documentation": {}
    },
    {
        "label": "parse_full_cfg",
        "importPath": "sample_factory.cfg.arguments",
        "description": "sample_factory.cfg.arguments",
        "isExtraImport": true,
        "detail": "sample_factory.cfg.arguments",
        "documentation": {}
    },
    {
        "label": "parse_sf_args",
        "importPath": "sample_factory.cfg.arguments",
        "description": "sample_factory.cfg.arguments",
        "isExtraImport": true,
        "detail": "sample_factory.cfg.arguments",
        "documentation": {}
    },
    {
        "label": "parse_full_cfg",
        "importPath": "sample_factory.cfg.arguments",
        "description": "sample_factory.cfg.arguments",
        "isExtraImport": true,
        "detail": "sample_factory.cfg.arguments",
        "documentation": {}
    },
    {
        "label": "parse_sf_args",
        "importPath": "sample_factory.cfg.arguments",
        "description": "sample_factory.cfg.arguments",
        "isExtraImport": true,
        "detail": "sample_factory.cfg.arguments",
        "documentation": {}
    },
    {
        "label": "parse_full_cfg",
        "importPath": "sample_factory.cfg.arguments",
        "description": "sample_factory.cfg.arguments",
        "isExtraImport": true,
        "detail": "sample_factory.cfg.arguments",
        "documentation": {}
    },
    {
        "label": "parse_sf_args",
        "importPath": "sample_factory.cfg.arguments",
        "description": "sample_factory.cfg.arguments",
        "isExtraImport": true,
        "detail": "sample_factory.cfg.arguments",
        "documentation": {}
    },
    {
        "label": "parse_full_cfg",
        "importPath": "sample_factory.cfg.arguments",
        "description": "sample_factory.cfg.arguments",
        "isExtraImport": true,
        "detail": "sample_factory.cfg.arguments",
        "documentation": {}
    },
    {
        "label": "parse_sf_args",
        "importPath": "sample_factory.cfg.arguments",
        "description": "sample_factory.cfg.arguments",
        "isExtraImport": true,
        "detail": "sample_factory.cfg.arguments",
        "documentation": {}
    },
    {
        "label": "parse_full_cfg",
        "importPath": "sample_factory.cfg.arguments",
        "description": "sample_factory.cfg.arguments",
        "isExtraImport": true,
        "detail": "sample_factory.cfg.arguments",
        "documentation": {}
    },
    {
        "label": "parse_sf_args",
        "importPath": "sample_factory.cfg.arguments",
        "description": "sample_factory.cfg.arguments",
        "isExtraImport": true,
        "detail": "sample_factory.cfg.arguments",
        "documentation": {}
    },
    {
        "label": "parse_full_cfg",
        "importPath": "sample_factory.cfg.arguments",
        "description": "sample_factory.cfg.arguments",
        "isExtraImport": true,
        "detail": "sample_factory.cfg.arguments",
        "documentation": {}
    },
    {
        "label": "parse_sf_args",
        "importPath": "sample_factory.cfg.arguments",
        "description": "sample_factory.cfg.arguments",
        "isExtraImport": true,
        "detail": "sample_factory.cfg.arguments",
        "documentation": {}
    },
    {
        "label": "checkpoint_override_defaults",
        "importPath": "sample_factory.cfg.arguments",
        "description": "sample_factory.cfg.arguments",
        "isExtraImport": true,
        "detail": "sample_factory.cfg.arguments",
        "documentation": {}
    },
    {
        "label": "parse_full_cfg",
        "importPath": "sample_factory.cfg.arguments",
        "description": "sample_factory.cfg.arguments",
        "isExtraImport": true,
        "detail": "sample_factory.cfg.arguments",
        "documentation": {}
    },
    {
        "label": "parse_sf_args",
        "importPath": "sample_factory.cfg.arguments",
        "description": "sample_factory.cfg.arguments",
        "isExtraImport": true,
        "detail": "sample_factory.cfg.arguments",
        "documentation": {}
    },
    {
        "label": "parse_full_cfg",
        "importPath": "sample_factory.cfg.arguments",
        "description": "sample_factory.cfg.arguments",
        "isExtraImport": true,
        "detail": "sample_factory.cfg.arguments",
        "documentation": {}
    },
    {
        "label": "parse_sf_args",
        "importPath": "sample_factory.cfg.arguments",
        "description": "sample_factory.cfg.arguments",
        "isExtraImport": true,
        "detail": "sample_factory.cfg.arguments",
        "documentation": {}
    },
    {
        "label": "parse_full_cfg",
        "importPath": "sample_factory.cfg.arguments",
        "description": "sample_factory.cfg.arguments",
        "isExtraImport": true,
        "detail": "sample_factory.cfg.arguments",
        "documentation": {}
    },
    {
        "label": "parse_sf_args",
        "importPath": "sample_factory.cfg.arguments",
        "description": "sample_factory.cfg.arguments",
        "isExtraImport": true,
        "detail": "sample_factory.cfg.arguments",
        "documentation": {}
    },
    {
        "label": "checkpoint_override_defaults",
        "importPath": "sample_factory.cfg.arguments",
        "description": "sample_factory.cfg.arguments",
        "isExtraImport": true,
        "detail": "sample_factory.cfg.arguments",
        "documentation": {}
    },
    {
        "label": "parse_full_cfg",
        "importPath": "sample_factory.cfg.arguments",
        "description": "sample_factory.cfg.arguments",
        "isExtraImport": true,
        "detail": "sample_factory.cfg.arguments",
        "documentation": {}
    },
    {
        "label": "parse_sf_args",
        "importPath": "sample_factory.cfg.arguments",
        "description": "sample_factory.cfg.arguments",
        "isExtraImport": true,
        "detail": "sample_factory.cfg.arguments",
        "documentation": {}
    },
    {
        "label": "parse_full_cfg",
        "importPath": "sample_factory.cfg.arguments",
        "description": "sample_factory.cfg.arguments",
        "isExtraImport": true,
        "detail": "sample_factory.cfg.arguments",
        "documentation": {}
    },
    {
        "label": "parse_sf_args",
        "importPath": "sample_factory.cfg.arguments",
        "description": "sample_factory.cfg.arguments",
        "isExtraImport": true,
        "detail": "sample_factory.cfg.arguments",
        "documentation": {}
    },
    {
        "label": "parse_full_cfg",
        "importPath": "sample_factory.cfg.arguments",
        "description": "sample_factory.cfg.arguments",
        "isExtraImport": true,
        "detail": "sample_factory.cfg.arguments",
        "documentation": {}
    },
    {
        "label": "parse_sf_args",
        "importPath": "sample_factory.cfg.arguments",
        "description": "sample_factory.cfg.arguments",
        "isExtraImport": true,
        "detail": "sample_factory.cfg.arguments",
        "documentation": {}
    },
    {
        "label": "default_cfg",
        "importPath": "sample_factory.cfg.arguments",
        "description": "sample_factory.cfg.arguments",
        "isExtraImport": true,
        "detail": "sample_factory.cfg.arguments",
        "documentation": {}
    },
    {
        "label": "default_cfg",
        "importPath": "sample_factory.cfg.arguments",
        "description": "sample_factory.cfg.arguments",
        "isExtraImport": true,
        "detail": "sample_factory.cfg.arguments",
        "documentation": {}
    },
    {
        "label": "parse_full_cfg",
        "importPath": "sample_factory.cfg.arguments",
        "description": "sample_factory.cfg.arguments",
        "isExtraImport": true,
        "detail": "sample_factory.cfg.arguments",
        "documentation": {}
    },
    {
        "label": "parse_sf_args",
        "importPath": "sample_factory.cfg.arguments",
        "description": "sample_factory.cfg.arguments",
        "isExtraImport": true,
        "detail": "sample_factory.cfg.arguments",
        "documentation": {}
    },
    {
        "label": "parse_full_cfg",
        "importPath": "sample_factory.cfg.arguments",
        "description": "sample_factory.cfg.arguments",
        "isExtraImport": true,
        "detail": "sample_factory.cfg.arguments",
        "documentation": {}
    },
    {
        "label": "parse_sf_args",
        "importPath": "sample_factory.cfg.arguments",
        "description": "sample_factory.cfg.arguments",
        "isExtraImport": true,
        "detail": "sample_factory.cfg.arguments",
        "documentation": {}
    },
    {
        "label": "parse_full_cfg",
        "importPath": "sample_factory.cfg.arguments",
        "description": "sample_factory.cfg.arguments",
        "isExtraImport": true,
        "detail": "sample_factory.cfg.arguments",
        "documentation": {}
    },
    {
        "label": "parse_sf_args",
        "importPath": "sample_factory.cfg.arguments",
        "description": "sample_factory.cfg.arguments",
        "isExtraImport": true,
        "detail": "sample_factory.cfg.arguments",
        "documentation": {}
    },
    {
        "label": "parse_full_cfg",
        "importPath": "sample_factory.cfg.arguments",
        "description": "sample_factory.cfg.arguments",
        "isExtraImport": true,
        "detail": "sample_factory.cfg.arguments",
        "documentation": {}
    },
    {
        "label": "parse_sf_args",
        "importPath": "sample_factory.cfg.arguments",
        "description": "sample_factory.cfg.arguments",
        "isExtraImport": true,
        "detail": "sample_factory.cfg.arguments",
        "documentation": {}
    },
    {
        "label": "parse_full_cfg",
        "importPath": "sample_factory.cfg.arguments",
        "description": "sample_factory.cfg.arguments",
        "isExtraImport": true,
        "detail": "sample_factory.cfg.arguments",
        "documentation": {}
    },
    {
        "label": "parse_sf_args",
        "importPath": "sample_factory.cfg.arguments",
        "description": "sample_factory.cfg.arguments",
        "isExtraImport": true,
        "detail": "sample_factory.cfg.arguments",
        "documentation": {}
    },
    {
        "label": "parse_full_cfg",
        "importPath": "sample_factory.cfg.arguments",
        "description": "sample_factory.cfg.arguments",
        "isExtraImport": true,
        "detail": "sample_factory.cfg.arguments",
        "documentation": {}
    },
    {
        "label": "parse_sf_args",
        "importPath": "sample_factory.cfg.arguments",
        "description": "sample_factory.cfg.arguments",
        "isExtraImport": true,
        "detail": "sample_factory.cfg.arguments",
        "documentation": {}
    },
    {
        "label": "parse_full_cfg",
        "importPath": "sample_factory.cfg.arguments",
        "description": "sample_factory.cfg.arguments",
        "isExtraImport": true,
        "detail": "sample_factory.cfg.arguments",
        "documentation": {}
    },
    {
        "label": "parse_sf_args",
        "importPath": "sample_factory.cfg.arguments",
        "description": "sample_factory.cfg.arguments",
        "isExtraImport": true,
        "detail": "sample_factory.cfg.arguments",
        "documentation": {}
    },
    {
        "label": "verify_cfg",
        "importPath": "sample_factory.cfg.arguments",
        "description": "sample_factory.cfg.arguments",
        "isExtraImport": true,
        "detail": "sample_factory.cfg.arguments",
        "documentation": {}
    },
    {
        "label": "default_cfg",
        "importPath": "sample_factory.cfg.arguments",
        "description": "sample_factory.cfg.arguments",
        "isExtraImport": true,
        "detail": "sample_factory.cfg.arguments",
        "documentation": {}
    },
    {
        "label": "parse_sf_args",
        "importPath": "sample_factory.cfg.arguments",
        "description": "sample_factory.cfg.arguments",
        "isExtraImport": true,
        "detail": "sample_factory.cfg.arguments",
        "documentation": {}
    },
    {
        "label": "parse_full_cfg",
        "importPath": "sample_factory.cfg.arguments",
        "description": "sample_factory.cfg.arguments",
        "isExtraImport": true,
        "detail": "sample_factory.cfg.arguments",
        "documentation": {}
    },
    {
        "label": "parse_sf_args",
        "importPath": "sample_factory.cfg.arguments",
        "description": "sample_factory.cfg.arguments",
        "isExtraImport": true,
        "detail": "sample_factory.cfg.arguments",
        "documentation": {}
    },
    {
        "label": "parse_full_cfg",
        "importPath": "sample_factory.cfg.arguments",
        "description": "sample_factory.cfg.arguments",
        "isExtraImport": true,
        "detail": "sample_factory.cfg.arguments",
        "documentation": {}
    },
    {
        "label": "parse_sf_args",
        "importPath": "sample_factory.cfg.arguments",
        "description": "sample_factory.cfg.arguments",
        "isExtraImport": true,
        "detail": "sample_factory.cfg.arguments",
        "documentation": {}
    },
    {
        "label": "parse_full_cfg",
        "importPath": "sample_factory.cfg.arguments",
        "description": "sample_factory.cfg.arguments",
        "isExtraImport": true,
        "detail": "sample_factory.cfg.arguments",
        "documentation": {}
    },
    {
        "label": "parse_sf_args",
        "importPath": "sample_factory.cfg.arguments",
        "description": "sample_factory.cfg.arguments",
        "isExtraImport": true,
        "detail": "sample_factory.cfg.arguments",
        "documentation": {}
    },
    {
        "label": "parse_full_cfg",
        "importPath": "sample_factory.cfg.arguments",
        "description": "sample_factory.cfg.arguments",
        "isExtraImport": true,
        "detail": "sample_factory.cfg.arguments",
        "documentation": {}
    },
    {
        "label": "parse_sf_args",
        "importPath": "sample_factory.cfg.arguments",
        "description": "sample_factory.cfg.arguments",
        "isExtraImport": true,
        "detail": "sample_factory.cfg.arguments",
        "documentation": {}
    },
    {
        "label": "init_wandb",
        "importPath": "sample_factory.utils.wandb_utils",
        "description": "sample_factory.utils.wandb_utils",
        "isExtraImport": true,
        "detail": "sample_factory.utils.wandb_utils",
        "documentation": {}
    },
    {
        "label": "Runner",
        "importPath": "sample_factory.algo.runners.runner",
        "description": "sample_factory.algo.runners.runner",
        "isExtraImport": true,
        "detail": "sample_factory.algo.runners.runner",
        "documentation": {}
    },
    {
        "label": "Runner",
        "importPath": "sample_factory.algo.runners.runner",
        "description": "sample_factory.algo.runners.runner",
        "isExtraImport": true,
        "detail": "sample_factory.algo.runners.runner",
        "documentation": {}
    },
    {
        "label": "MsgHandler",
        "importPath": "sample_factory.algo.runners.runner",
        "description": "sample_factory.algo.runners.runner",
        "isExtraImport": true,
        "detail": "sample_factory.algo.runners.runner",
        "documentation": {}
    },
    {
        "label": "PolicyMsgHandler",
        "importPath": "sample_factory.algo.runners.runner",
        "description": "sample_factory.algo.runners.runner",
        "isExtraImport": true,
        "detail": "sample_factory.algo.runners.runner",
        "documentation": {}
    },
    {
        "label": "AlgoObserver",
        "importPath": "sample_factory.algo.runners.runner",
        "description": "sample_factory.algo.runners.runner",
        "isExtraImport": true,
        "detail": "sample_factory.algo.runners.runner",
        "documentation": {}
    },
    {
        "label": "Runner",
        "importPath": "sample_factory.algo.runners.runner",
        "description": "sample_factory.algo.runners.runner",
        "isExtraImport": true,
        "detail": "sample_factory.algo.runners.runner",
        "documentation": {}
    },
    {
        "label": "Runner",
        "importPath": "sample_factory.algo.runners.runner",
        "description": "sample_factory.algo.runners.runner",
        "isExtraImport": true,
        "detail": "sample_factory.algo.runners.runner",
        "documentation": {}
    },
    {
        "label": "Runner",
        "importPath": "sample_factory.algo.runners.runner",
        "description": "sample_factory.algo.runners.runner",
        "isExtraImport": true,
        "detail": "sample_factory.algo.runners.runner",
        "documentation": {}
    },
    {
        "label": "AlgoObserver",
        "importPath": "sample_factory.algo.runners.runner",
        "description": "sample_factory.algo.runners.runner",
        "isExtraImport": true,
        "detail": "sample_factory.algo.runners.runner",
        "documentation": {}
    },
    {
        "label": "Runner",
        "importPath": "sample_factory.algo.runners.runner",
        "description": "sample_factory.algo.runners.runner",
        "isExtraImport": true,
        "detail": "sample_factory.algo.runners.runner",
        "documentation": {}
    },
    {
        "label": "get_mp_ctx",
        "importPath": "sample_factory.algo.utils.multiprocessing_utils",
        "description": "sample_factory.algo.utils.multiprocessing_utils",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.multiprocessing_utils",
        "documentation": {}
    },
    {
        "label": "get_mp_ctx",
        "importPath": "sample_factory.algo.utils.multiprocessing_utils",
        "description": "sample_factory.algo.utils.multiprocessing_utils",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.multiprocessing_utils",
        "documentation": {}
    },
    {
        "label": "get_lock",
        "importPath": "sample_factory.algo.utils.multiprocessing_utils",
        "description": "sample_factory.algo.utils.multiprocessing_utils",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.multiprocessing_utils",
        "documentation": {}
    },
    {
        "label": "get_mp_ctx",
        "importPath": "sample_factory.algo.utils.multiprocessing_utils",
        "description": "sample_factory.algo.utils.multiprocessing_utils",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.multiprocessing_utils",
        "documentation": {}
    },
    {
        "label": "get_mp_lock",
        "importPath": "sample_factory.algo.utils.multiprocessing_utils",
        "description": "sample_factory.algo.utils.multiprocessing_utils",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.multiprocessing_utils",
        "documentation": {}
    },
    {
        "label": "get_mp_ctx",
        "importPath": "sample_factory.algo.utils.multiprocessing_utils",
        "description": "sample_factory.algo.utils.multiprocessing_utils",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.multiprocessing_utils",
        "documentation": {}
    },
    {
        "label": "numbers",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "numbers",
        "description": "numbers",
        "detail": "numbers",
        "documentation": {}
    },
    {
        "label": "Empty",
        "importPath": "queue",
        "description": "queue",
        "isExtraImport": true,
        "detail": "queue",
        "documentation": {}
    },
    {
        "label": "Empty",
        "importPath": "queue",
        "description": "queue",
        "isExtraImport": true,
        "detail": "queue",
        "documentation": {}
    },
    {
        "label": "Empty",
        "importPath": "queue",
        "description": "queue",
        "isExtraImport": true,
        "detail": "queue",
        "documentation": {}
    },
    {
        "label": "Empty",
        "importPath": "queue",
        "description": "queue",
        "isExtraImport": true,
        "detail": "queue",
        "documentation": {}
    },
    {
        "label": "Full",
        "importPath": "queue",
        "description": "queue",
        "isExtraImport": true,
        "detail": "queue",
        "documentation": {}
    },
    {
        "label": "Queue",
        "importPath": "queue",
        "description": "queue",
        "isExtraImport": true,
        "detail": "queue",
        "documentation": {}
    },
    {
        "label": "Full",
        "importPath": "queue",
        "description": "queue",
        "isExtraImport": true,
        "detail": "queue",
        "documentation": {}
    },
    {
        "label": "Empty",
        "importPath": "queue",
        "description": "queue",
        "isExtraImport": true,
        "detail": "queue",
        "documentation": {}
    },
    {
        "label": "Queue",
        "importPath": "queue",
        "description": "queue",
        "isExtraImport": true,
        "detail": "queue",
        "documentation": {}
    },
    {
        "label": "VectorEnvRunner",
        "importPath": "sample_factory.algo.sampling.sampling_utils",
        "description": "sample_factory.algo.sampling.sampling_utils",
        "isExtraImport": true,
        "detail": "sample_factory.algo.sampling.sampling_utils",
        "documentation": {}
    },
    {
        "label": "record_episode_statistics_wrapper_stats",
        "importPath": "sample_factory.algo.sampling.sampling_utils",
        "description": "sample_factory.algo.sampling.sampling_utils",
        "isExtraImport": true,
        "detail": "sample_factory.algo.sampling.sampling_utils",
        "documentation": {}
    },
    {
        "label": "VectorEnvRunner",
        "importPath": "sample_factory.algo.sampling.sampling_utils",
        "description": "sample_factory.algo.sampling.sampling_utils",
        "isExtraImport": true,
        "detail": "sample_factory.algo.sampling.sampling_utils",
        "documentation": {}
    },
    {
        "label": "record_episode_statistics_wrapper_stats",
        "importPath": "sample_factory.algo.sampling.sampling_utils",
        "description": "sample_factory.algo.sampling.sampling_utils",
        "isExtraImport": true,
        "detail": "sample_factory.algo.sampling.sampling_utils",
        "documentation": {}
    },
    {
        "label": "VectorEnvRunner",
        "importPath": "sample_factory.algo.sampling.sampling_utils",
        "description": "sample_factory.algo.sampling.sampling_utils",
        "isExtraImport": true,
        "detail": "sample_factory.algo.sampling.sampling_utils",
        "documentation": {}
    },
    {
        "label": "rollout_worker_device",
        "importPath": "sample_factory.algo.sampling.sampling_utils",
        "description": "sample_factory.algo.sampling.sampling_utils",
        "isExtraImport": true,
        "detail": "sample_factory.algo.sampling.sampling_utils",
        "documentation": {}
    },
    {
        "label": "rollout_worker_device",
        "importPath": "sample_factory.algo.sampling.sampling_utils",
        "description": "sample_factory.algo.sampling.sampling_utils",
        "isExtraImport": true,
        "detail": "sample_factory.algo.sampling.sampling_utils",
        "documentation": {}
    },
    {
        "label": "BatchedVecEnv",
        "importPath": "sample_factory.algo.utils.make_env",
        "description": "sample_factory.algo.utils.make_env",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.make_env",
        "documentation": {}
    },
    {
        "label": "SequentialVectorizeWrapper",
        "importPath": "sample_factory.algo.utils.make_env",
        "description": "sample_factory.algo.utils.make_env",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.make_env",
        "documentation": {}
    },
    {
        "label": "make_env_func_batched",
        "importPath": "sample_factory.algo.utils.make_env",
        "description": "sample_factory.algo.utils.make_env",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.make_env",
        "documentation": {}
    },
    {
        "label": "make_env_func_non_batched",
        "importPath": "sample_factory.algo.utils.make_env",
        "description": "sample_factory.algo.utils.make_env",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.make_env",
        "documentation": {}
    },
    {
        "label": "BatchedVecEnv",
        "importPath": "sample_factory.algo.utils.make_env",
        "description": "sample_factory.algo.utils.make_env",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.make_env",
        "documentation": {}
    },
    {
        "label": "NonBatchedVecEnv",
        "importPath": "sample_factory.algo.utils.make_env",
        "description": "sample_factory.algo.utils.make_env",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.make_env",
        "documentation": {}
    },
    {
        "label": "make_env_func_batched",
        "importPath": "sample_factory.algo.utils.make_env",
        "description": "sample_factory.algo.utils.make_env",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.make_env",
        "documentation": {}
    },
    {
        "label": "make_env_func_batched",
        "importPath": "sample_factory.algo.utils.make_env",
        "description": "sample_factory.algo.utils.make_env",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.make_env",
        "documentation": {}
    },
    {
        "label": "make_env_func_batched",
        "importPath": "sample_factory.algo.utils.make_env",
        "description": "sample_factory.algo.utils.make_env",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.make_env",
        "documentation": {}
    },
    {
        "label": "make_env_func_batched",
        "importPath": "sample_factory.algo.utils.make_env",
        "description": "sample_factory.algo.utils.make_env",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.make_env",
        "documentation": {}
    },
    {
        "label": "SequentialVectorizeWrapper",
        "importPath": "sample_factory.algo.utils.make_env",
        "description": "sample_factory.algo.utils.make_env",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.make_env",
        "documentation": {}
    },
    {
        "label": "make_env_func_batched",
        "importPath": "sample_factory.algo.utils.make_env",
        "description": "sample_factory.algo.utils.make_env",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.make_env",
        "documentation": {}
    },
    {
        "label": "TrainingInfoInterface",
        "importPath": "sample_factory.envs.env_utils",
        "description": "sample_factory.envs.env_utils",
        "isExtraImport": true,
        "detail": "sample_factory.envs.env_utils",
        "documentation": {}
    },
    {
        "label": "find_training_info_interface",
        "importPath": "sample_factory.envs.env_utils",
        "description": "sample_factory.envs.env_utils",
        "isExtraImport": true,
        "detail": "sample_factory.envs.env_utils",
        "documentation": {}
    },
    {
        "label": "set_reward_shaping",
        "importPath": "sample_factory.envs.env_utils",
        "description": "sample_factory.envs.env_utils",
        "isExtraImport": true,
        "detail": "sample_factory.envs.env_utils",
        "documentation": {}
    },
    {
        "label": "set_training_info",
        "importPath": "sample_factory.envs.env_utils",
        "description": "sample_factory.envs.env_utils",
        "isExtraImport": true,
        "detail": "sample_factory.envs.env_utils",
        "documentation": {}
    },
    {
        "label": "find_training_info_interface",
        "importPath": "sample_factory.envs.env_utils",
        "description": "sample_factory.envs.env_utils",
        "isExtraImport": true,
        "detail": "sample_factory.envs.env_utils",
        "documentation": {}
    },
    {
        "label": "set_reward_shaping",
        "importPath": "sample_factory.envs.env_utils",
        "description": "sample_factory.envs.env_utils",
        "isExtraImport": true,
        "detail": "sample_factory.envs.env_utils",
        "documentation": {}
    },
    {
        "label": "set_training_info",
        "importPath": "sample_factory.envs.env_utils",
        "description": "sample_factory.envs.env_utils",
        "isExtraImport": true,
        "detail": "sample_factory.envs.env_utils",
        "documentation": {}
    },
    {
        "label": "get_default_reward_shaping",
        "importPath": "sample_factory.envs.env_utils",
        "description": "sample_factory.envs.env_utils",
        "isExtraImport": true,
        "detail": "sample_factory.envs.env_utils",
        "documentation": {}
    },
    {
        "label": "RewardShapingInterface",
        "importPath": "sample_factory.envs.env_utils",
        "description": "sample_factory.envs.env_utils",
        "isExtraImport": true,
        "detail": "sample_factory.envs.env_utils",
        "documentation": {}
    },
    {
        "label": "TrainingInfoInterface",
        "importPath": "sample_factory.envs.env_utils",
        "description": "sample_factory.envs.env_utils",
        "isExtraImport": true,
        "detail": "sample_factory.envs.env_utils",
        "documentation": {}
    },
    {
        "label": "find_training_info_interface",
        "importPath": "sample_factory.envs.env_utils",
        "description": "sample_factory.envs.env_utils",
        "isExtraImport": true,
        "detail": "sample_factory.envs.env_utils",
        "documentation": {}
    },
    {
        "label": "find_wrapper_interface",
        "importPath": "sample_factory.envs.env_utils",
        "description": "sample_factory.envs.env_utils",
        "isExtraImport": true,
        "detail": "sample_factory.envs.env_utils",
        "documentation": {}
    },
    {
        "label": "num_env_steps",
        "importPath": "sample_factory.envs.env_utils",
        "description": "sample_factory.envs.env_utils",
        "isExtraImport": true,
        "detail": "sample_factory.envs.env_utils",
        "documentation": {}
    },
    {
        "label": "register_env",
        "importPath": "sample_factory.envs.env_utils",
        "description": "sample_factory.envs.env_utils",
        "isExtraImport": true,
        "detail": "sample_factory.envs.env_utils",
        "documentation": {}
    },
    {
        "label": "register_env",
        "importPath": "sample_factory.envs.env_utils",
        "description": "sample_factory.envs.env_utils",
        "isExtraImport": true,
        "detail": "sample_factory.envs.env_utils",
        "documentation": {}
    },
    {
        "label": "register_env",
        "importPath": "sample_factory.envs.env_utils",
        "description": "sample_factory.envs.env_utils",
        "isExtraImport": true,
        "detail": "sample_factory.envs.env_utils",
        "documentation": {}
    },
    {
        "label": "register_env",
        "importPath": "sample_factory.envs.env_utils",
        "description": "sample_factory.envs.env_utils",
        "isExtraImport": true,
        "detail": "sample_factory.envs.env_utils",
        "documentation": {}
    },
    {
        "label": "register_env",
        "importPath": "sample_factory.envs.env_utils",
        "description": "sample_factory.envs.env_utils",
        "isExtraImport": true,
        "detail": "sample_factory.envs.env_utils",
        "documentation": {}
    },
    {
        "label": "register_env",
        "importPath": "sample_factory.envs.env_utils",
        "description": "sample_factory.envs.env_utils",
        "isExtraImport": true,
        "detail": "sample_factory.envs.env_utils",
        "documentation": {}
    },
    {
        "label": "register_env",
        "importPath": "sample_factory.envs.env_utils",
        "description": "sample_factory.envs.env_utils",
        "isExtraImport": true,
        "detail": "sample_factory.envs.env_utils",
        "documentation": {}
    },
    {
        "label": "register_env",
        "importPath": "sample_factory.envs.env_utils",
        "description": "sample_factory.envs.env_utils",
        "isExtraImport": true,
        "detail": "sample_factory.envs.env_utils",
        "documentation": {}
    },
    {
        "label": "RewardShapingInterface",
        "importPath": "sample_factory.envs.env_utils",
        "description": "sample_factory.envs.env_utils",
        "isExtraImport": true,
        "detail": "sample_factory.envs.env_utils",
        "documentation": {}
    },
    {
        "label": "get_default_reward_shaping",
        "importPath": "sample_factory.envs.env_utils",
        "description": "sample_factory.envs.env_utils",
        "isExtraImport": true,
        "detail": "sample_factory.envs.env_utils",
        "documentation": {}
    },
    {
        "label": "RewardShapingInterface",
        "importPath": "sample_factory.envs.env_utils",
        "description": "sample_factory.envs.env_utils",
        "isExtraImport": true,
        "detail": "sample_factory.envs.env_utils",
        "documentation": {}
    },
    {
        "label": "register_env",
        "importPath": "sample_factory.envs.env_utils",
        "description": "sample_factory.envs.env_utils",
        "isExtraImport": true,
        "detail": "sample_factory.envs.env_utils",
        "documentation": {}
    },
    {
        "label": "register_env",
        "importPath": "sample_factory.envs.env_utils",
        "description": "sample_factory.envs.env_utils",
        "isExtraImport": true,
        "detail": "sample_factory.envs.env_utils",
        "documentation": {}
    },
    {
        "label": "RewardShapingInterface",
        "importPath": "sample_factory.envs.env_utils",
        "description": "sample_factory.envs.env_utils",
        "isExtraImport": true,
        "detail": "sample_factory.envs.env_utils",
        "documentation": {}
    },
    {
        "label": "TrainingInfoInterface",
        "importPath": "sample_factory.envs.env_utils",
        "description": "sample_factory.envs.env_utils",
        "isExtraImport": true,
        "detail": "sample_factory.envs.env_utils",
        "documentation": {}
    },
    {
        "label": "register_env",
        "importPath": "sample_factory.envs.env_utils",
        "description": "sample_factory.envs.env_utils",
        "isExtraImport": true,
        "detail": "sample_factory.envs.env_utils",
        "documentation": {}
    },
    {
        "label": "RewardShapingInterface",
        "importPath": "sample_factory.envs.env_utils",
        "description": "sample_factory.envs.env_utils",
        "isExtraImport": true,
        "detail": "sample_factory.envs.env_utils",
        "documentation": {}
    },
    {
        "label": "TrainingInfoInterface",
        "importPath": "sample_factory.envs.env_utils",
        "description": "sample_factory.envs.env_utils",
        "isExtraImport": true,
        "detail": "sample_factory.envs.env_utils",
        "documentation": {}
    },
    {
        "label": "register_env",
        "importPath": "sample_factory.envs.env_utils",
        "description": "sample_factory.envs.env_utils",
        "isExtraImport": true,
        "detail": "sample_factory.envs.env_utils",
        "documentation": {}
    },
    {
        "label": "register_env",
        "importPath": "sample_factory.envs.env_utils",
        "description": "sample_factory.envs.env_utils",
        "isExtraImport": true,
        "detail": "sample_factory.envs.env_utils",
        "documentation": {}
    },
    {
        "label": "register_env",
        "importPath": "sample_factory.envs.env_utils",
        "description": "sample_factory.envs.env_utils",
        "isExtraImport": true,
        "detail": "sample_factory.envs.env_utils",
        "documentation": {}
    },
    {
        "label": "register_env",
        "importPath": "sample_factory.envs.env_utils",
        "description": "sample_factory.envs.env_utils",
        "isExtraImport": true,
        "detail": "sample_factory.envs.env_utils",
        "documentation": {}
    },
    {
        "label": "register_env",
        "importPath": "sample_factory.envs.env_utils",
        "description": "sample_factory.envs.env_utils",
        "isExtraImport": true,
        "detail": "sample_factory.envs.env_utils",
        "documentation": {}
    },
    {
        "label": "register_env",
        "importPath": "sample_factory.envs.env_utils",
        "description": "sample_factory.envs.env_utils",
        "isExtraImport": true,
        "detail": "sample_factory.envs.env_utils",
        "documentation": {}
    },
    {
        "label": "vizdoom_available",
        "importPath": "sample_factory.envs.env_utils",
        "description": "sample_factory.envs.env_utils",
        "isExtraImport": true,
        "detail": "sample_factory.envs.env_utils",
        "documentation": {}
    },
    {
        "label": "vizdoom_available",
        "importPath": "sample_factory.envs.env_utils",
        "description": "sample_factory.envs.env_utils",
        "isExtraImport": true,
        "detail": "sample_factory.envs.env_utils",
        "documentation": {}
    },
    {
        "label": "num_env_steps",
        "importPath": "sample_factory.envs.env_utils",
        "description": "sample_factory.envs.env_utils",
        "isExtraImport": true,
        "detail": "sample_factory.envs.env_utils",
        "documentation": {}
    },
    {
        "label": "RewardShapingInterface",
        "importPath": "sample_factory.envs.env_utils",
        "description": "sample_factory.envs.env_utils",
        "isExtraImport": true,
        "detail": "sample_factory.envs.env_utils",
        "documentation": {}
    },
    {
        "label": "TrainingInfoInterface",
        "importPath": "sample_factory.envs.env_utils",
        "description": "sample_factory.envs.env_utils",
        "isExtraImport": true,
        "detail": "sample_factory.envs.env_utils",
        "documentation": {}
    },
    {
        "label": "find_training_info_interface",
        "importPath": "sample_factory.envs.env_utils",
        "description": "sample_factory.envs.env_utils",
        "isExtraImport": true,
        "detail": "sample_factory.envs.env_utils",
        "documentation": {}
    },
    {
        "label": "find_wrapper_interface",
        "importPath": "sample_factory.envs.env_utils",
        "description": "sample_factory.envs.env_utils",
        "isExtraImport": true,
        "detail": "sample_factory.envs.env_utils",
        "documentation": {}
    },
    {
        "label": "cat_tensors",
        "importPath": "sample_factory.algo.utils.tensor_utils",
        "description": "sample_factory.algo.utils.tensor_utils",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.tensor_utils",
        "documentation": {}
    },
    {
        "label": "dict_of_lists_cat",
        "importPath": "sample_factory.algo.utils.tensor_utils",
        "description": "sample_factory.algo.utils.tensor_utils",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.tensor_utils",
        "documentation": {}
    },
    {
        "label": "ensure_torch_tensor",
        "importPath": "sample_factory.algo.utils.tensor_utils",
        "description": "sample_factory.algo.utils.tensor_utils",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.tensor_utils",
        "documentation": {}
    },
    {
        "label": "clone_tensor",
        "importPath": "sample_factory.algo.utils.tensor_utils",
        "description": "sample_factory.algo.utils.tensor_utils",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.tensor_utils",
        "documentation": {}
    },
    {
        "label": "ensure_numpy_array",
        "importPath": "sample_factory.algo.utils.tensor_utils",
        "description": "sample_factory.algo.utils.tensor_utils",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.tensor_utils",
        "documentation": {}
    },
    {
        "label": "dict_of_lists_cat",
        "importPath": "sample_factory.algo.utils.tensor_utils",
        "description": "sample_factory.algo.utils.tensor_utils",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.tensor_utils",
        "documentation": {}
    },
    {
        "label": "ensure_torch_tensor",
        "importPath": "sample_factory.algo.utils.tensor_utils",
        "description": "sample_factory.algo.utils.tensor_utils",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.tensor_utils",
        "documentation": {}
    },
    {
        "label": "unsqueeze_tensor",
        "importPath": "sample_factory.algo.utils.tensor_utils",
        "description": "sample_factory.algo.utils.tensor_utils",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.tensor_utils",
        "documentation": {}
    },
    {
        "label": "AgentPolicyMapping",
        "importPath": "sample_factory.algo.utils.agent_policy_mapping",
        "description": "sample_factory.algo.utils.agent_policy_mapping",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.agent_policy_mapping",
        "documentation": {}
    },
    {
        "label": "BatchedVectorEnvRunner",
        "importPath": "sample_factory.algo.sampling.batched_sampling",
        "description": "sample_factory.algo.sampling.batched_sampling",
        "isExtraImport": true,
        "detail": "sample_factory.algo.sampling.batched_sampling",
        "documentation": {}
    },
    {
        "label": "preprocess_actions",
        "importPath": "sample_factory.algo.sampling.batched_sampling",
        "description": "sample_factory.algo.sampling.batched_sampling",
        "isExtraImport": true,
        "detail": "sample_factory.algo.sampling.batched_sampling",
        "documentation": {}
    },
    {
        "label": "BatchedVectorEnvRunner",
        "importPath": "sample_factory.algo.sampling.batched_sampling",
        "description": "sample_factory.algo.sampling.batched_sampling",
        "isExtraImport": true,
        "detail": "sample_factory.algo.sampling.batched_sampling",
        "documentation": {}
    },
    {
        "label": "NonBatchedVectorEnvRunner",
        "importPath": "sample_factory.algo.sampling.non_batched_sampling",
        "description": "sample_factory.algo.sampling.non_batched_sampling",
        "isExtraImport": true,
        "detail": "sample_factory.algo.sampling.non_batched_sampling",
        "documentation": {}
    },
    {
        "label": "NonBatchedVectorEnvRunner",
        "importPath": "sample_factory.algo.sampling.non_batched_sampling",
        "description": "sample_factory.algo.sampling.non_batched_sampling",
        "isExtraImport": true,
        "detail": "sample_factory.algo.sampling.non_batched_sampling",
        "documentation": {}
    },
    {
        "label": "get_queue",
        "importPath": "signal_slot.queue_utils",
        "description": "signal_slot.queue_utils",
        "isExtraImport": true,
        "detail": "signal_slot.queue_utils",
        "documentation": {}
    },
    {
        "label": "get_queue",
        "importPath": "signal_slot.queue_utils",
        "description": "signal_slot.queue_utils",
        "isExtraImport": true,
        "detail": "signal_slot.queue_utils",
        "documentation": {}
    },
    {
        "label": "InferenceWorker",
        "importPath": "sample_factory.algo.sampling.inference_worker",
        "description": "sample_factory.algo.sampling.inference_worker",
        "isExtraImport": true,
        "detail": "sample_factory.algo.sampling.inference_worker",
        "documentation": {}
    },
    {
        "label": "init_inference_process",
        "importPath": "sample_factory.algo.sampling.inference_worker",
        "description": "sample_factory.algo.sampling.inference_worker",
        "isExtraImport": true,
        "detail": "sample_factory.algo.sampling.inference_worker",
        "documentation": {}
    },
    {
        "label": "RolloutWorker",
        "importPath": "sample_factory.algo.sampling.rollout_worker",
        "description": "sample_factory.algo.sampling.rollout_worker",
        "isExtraImport": true,
        "detail": "sample_factory.algo.sampling.rollout_worker",
        "documentation": {}
    },
    {
        "label": "init_rollout_worker_process",
        "importPath": "sample_factory.algo.sampling.rollout_worker",
        "description": "sample_factory.algo.sampling.rollout_worker",
        "isExtraImport": true,
        "detail": "sample_factory.algo.sampling.rollout_worker",
        "documentation": {}
    },
    {
        "label": "SamplingLoop",
        "importPath": "sample_factory.algo.sampling.evaluation_sampling_api",
        "description": "sample_factory.algo.sampling.evaluation_sampling_api",
        "isExtraImport": true,
        "detail": "sample_factory.algo.sampling.evaluation_sampling_api",
        "documentation": {}
    },
    {
        "label": "EvalSamplingAPI",
        "importPath": "sample_factory.algo.sampling.evaluation_sampling_api",
        "description": "sample_factory.algo.sampling.evaluation_sampling_api",
        "isExtraImport": true,
        "detail": "sample_factory.algo.sampling.evaluation_sampling_api",
        "documentation": {}
    },
    {
        "label": "ModelFactory",
        "importPath": "sample_factory.model.model_factory",
        "description": "sample_factory.model.model_factory",
        "isExtraImport": true,
        "detail": "sample_factory.model.model_factory",
        "documentation": {}
    },
    {
        "label": "ActType",
        "importPath": "gymnasium.core",
        "description": "gymnasium.core",
        "isExtraImport": true,
        "detail": "gymnasium.core",
        "documentation": {}
    },
    {
        "label": "ObsType",
        "importPath": "gymnasium.core",
        "description": "gymnasium.core",
        "isExtraImport": true,
        "detail": "gymnasium.core",
        "documentation": {}
    },
    {
        "label": "RenderFrame",
        "importPath": "gymnasium.core",
        "description": "gymnasium.core",
        "isExtraImport": true,
        "detail": "gymnasium.core",
        "documentation": {}
    },
    {
        "label": "ObsType",
        "importPath": "gymnasium.core",
        "description": "gymnasium.core",
        "isExtraImport": true,
        "detail": "gymnasium.core",
        "documentation": {}
    },
    {
        "label": "create_env",
        "importPath": "sample_factory.envs.create_env",
        "description": "sample_factory.envs.create_env",
        "isExtraImport": true,
        "detail": "sample_factory.envs.create_env",
        "documentation": {}
    },
    {
        "label": "create_env",
        "importPath": "sample_factory.envs.create_env",
        "description": "sample_factory.envs.create_env",
        "isExtraImport": true,
        "detail": "sample_factory.envs.create_env",
        "documentation": {}
    },
    {
        "label": "create_env",
        "importPath": "sample_factory.envs.create_env",
        "description": "sample_factory.envs.create_env",
        "isExtraImport": true,
        "detail": "sample_factory.envs.create_env",
        "documentation": {}
    },
    {
        "label": "BaseContext",
        "importPath": "multiprocessing.context",
        "description": "multiprocessing.context",
        "isExtraImport": true,
        "detail": "multiprocessing.context",
        "documentation": {}
    },
    {
        "label": "BaseContext",
        "importPath": "multiprocessing.context",
        "description": "multiprocessing.context",
        "isExtraImport": true,
        "detail": "multiprocessing.context",
        "documentation": {}
    },
    {
        "label": "BaseContext",
        "importPath": "multiprocessing.context",
        "description": "multiprocessing.context",
        "isExtraImport": true,
        "detail": "multiprocessing.context",
        "documentation": {}
    },
    {
        "label": "RecursiveScriptModule",
        "importPath": "torch.jit",
        "description": "torch.jit",
        "isExtraImport": true,
        "detail": "torch.jit",
        "documentation": {}
    },
    {
        "label": "ScriptModule",
        "importPath": "torch.jit",
        "description": "torch.jit",
        "isExtraImport": true,
        "detail": "torch.jit",
        "documentation": {}
    },
    {
        "label": "add_basic_cli_args",
        "importPath": "sample_factory.cfg.cfg",
        "description": "sample_factory.cfg.cfg",
        "isExtraImport": true,
        "detail": "sample_factory.cfg.cfg",
        "documentation": {}
    },
    {
        "label": "add_default_env_args",
        "importPath": "sample_factory.cfg.cfg",
        "description": "sample_factory.cfg.cfg",
        "isExtraImport": true,
        "detail": "sample_factory.cfg.cfg",
        "documentation": {}
    },
    {
        "label": "add_eval_args",
        "importPath": "sample_factory.cfg.cfg",
        "description": "sample_factory.cfg.cfg",
        "isExtraImport": true,
        "detail": "sample_factory.cfg.cfg",
        "documentation": {}
    },
    {
        "label": "add_model_args",
        "importPath": "sample_factory.cfg.cfg",
        "description": "sample_factory.cfg.cfg",
        "isExtraImport": true,
        "detail": "sample_factory.cfg.cfg",
        "documentation": {}
    },
    {
        "label": "add_pbt_args",
        "importPath": "sample_factory.cfg.cfg",
        "description": "sample_factory.cfg.cfg",
        "isExtraImport": true,
        "detail": "sample_factory.cfg.cfg",
        "documentation": {}
    },
    {
        "label": "add_rl_args",
        "importPath": "sample_factory.cfg.cfg",
        "description": "sample_factory.cfg.cfg",
        "isExtraImport": true,
        "detail": "sample_factory.cfg.cfg",
        "documentation": {}
    },
    {
        "label": "add_wandb_args",
        "importPath": "sample_factory.cfg.cfg",
        "description": "sample_factory.cfg.cfg",
        "isExtraImport": true,
        "detail": "sample_factory.cfg.cfg",
        "documentation": {}
    },
    {
        "label": "patch_non_gymnasium_env",
        "importPath": "sample_factory.algo.utils.gymnasium_utils",
        "description": "sample_factory.algo.utils.gymnasium_utils",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.gymnasium_utils",
        "documentation": {}
    },
    {
        "label": "convert_space",
        "importPath": "sample_factory.algo.utils.gymnasium_utils",
        "description": "sample_factory.algo.utils.gymnasium_utils",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.gymnasium_utils",
        "documentation": {}
    },
    {
        "label": "convert_space",
        "importPath": "sample_factory.algo.utils.gymnasium_utils",
        "description": "sample_factory.algo.utils.gymnasium_utils",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.gymnasium_utils",
        "documentation": {}
    },
    {
        "label": "patch_non_gymnasium_env",
        "importPath": "sample_factory.algo.utils.gymnasium_utils",
        "description": "sample_factory.algo.utils.gymnasium_utils",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.gymnasium_utils",
        "documentation": {}
    },
    {
        "label": "EpisodeCounterWrapper",
        "importPath": "sample_factory.envs.env_wrappers",
        "description": "sample_factory.envs.env_wrappers",
        "isExtraImport": true,
        "detail": "sample_factory.envs.env_wrappers",
        "documentation": {}
    },
    {
        "label": "ClipRewardEnv",
        "importPath": "sample_factory.envs.env_wrappers",
        "description": "sample_factory.envs.env_wrappers",
        "isExtraImport": true,
        "detail": "sample_factory.envs.env_wrappers",
        "documentation": {}
    },
    {
        "label": "EpisodicLifeEnv",
        "importPath": "sample_factory.envs.env_wrappers",
        "description": "sample_factory.envs.env_wrappers",
        "isExtraImport": true,
        "detail": "sample_factory.envs.env_wrappers",
        "documentation": {}
    },
    {
        "label": "FireResetEnv",
        "importPath": "sample_factory.envs.env_wrappers",
        "description": "sample_factory.envs.env_wrappers",
        "isExtraImport": true,
        "detail": "sample_factory.envs.env_wrappers",
        "documentation": {}
    },
    {
        "label": "MaxAndSkipEnv",
        "importPath": "sample_factory.envs.env_wrappers",
        "description": "sample_factory.envs.env_wrappers",
        "isExtraImport": true,
        "detail": "sample_factory.envs.env_wrappers",
        "documentation": {}
    },
    {
        "label": "NoopResetEnv",
        "importPath": "sample_factory.envs.env_wrappers",
        "description": "sample_factory.envs.env_wrappers",
        "isExtraImport": true,
        "detail": "sample_factory.envs.env_wrappers",
        "documentation": {}
    },
    {
        "label": "NumpyObsWrapper",
        "importPath": "sample_factory.envs.env_wrappers",
        "description": "sample_factory.envs.env_wrappers",
        "isExtraImport": true,
        "detail": "sample_factory.envs.env_wrappers",
        "documentation": {}
    },
    {
        "label": "PixelFormatChwWrapper",
        "importPath": "sample_factory.envs.env_wrappers",
        "description": "sample_factory.envs.env_wrappers",
        "isExtraImport": true,
        "detail": "sample_factory.envs.env_wrappers",
        "documentation": {}
    },
    {
        "label": "RecordingWrapper",
        "importPath": "sample_factory.envs.env_wrappers",
        "description": "sample_factory.envs.env_wrappers",
        "isExtraImport": true,
        "detail": "sample_factory.envs.env_wrappers",
        "documentation": {}
    },
    {
        "label": "PixelFormatChwWrapper",
        "importPath": "sample_factory.envs.env_wrappers",
        "description": "sample_factory.envs.env_wrappers",
        "isExtraImport": true,
        "detail": "sample_factory.envs.env_wrappers",
        "documentation": {}
    },
    {
        "label": "RecordingWrapper",
        "importPath": "sample_factory.envs.env_wrappers",
        "description": "sample_factory.envs.env_wrappers",
        "isExtraImport": true,
        "detail": "sample_factory.envs.env_wrappers",
        "documentation": {}
    },
    {
        "label": "ResizeWrapper",
        "importPath": "sample_factory.envs.env_wrappers",
        "description": "sample_factory.envs.env_wrappers",
        "isExtraImport": true,
        "detail": "sample_factory.envs.env_wrappers",
        "documentation": {}
    },
    {
        "label": "RewardScalingWrapper",
        "importPath": "sample_factory.envs.env_wrappers",
        "description": "sample_factory.envs.env_wrappers",
        "isExtraImport": true,
        "detail": "sample_factory.envs.env_wrappers",
        "documentation": {}
    },
    {
        "label": "TimeLimitWrapper",
        "importPath": "sample_factory.envs.env_wrappers",
        "description": "sample_factory.envs.env_wrappers",
        "isExtraImport": true,
        "detail": "sample_factory.envs.env_wrappers",
        "documentation": {}
    },
    {
        "label": "HfApi",
        "importPath": "huggingface_hub",
        "description": "huggingface_hub",
        "isExtraImport": true,
        "detail": "huggingface_hub",
        "documentation": {}
    },
    {
        "label": "Repository",
        "importPath": "huggingface_hub",
        "description": "huggingface_hub",
        "isExtraImport": true,
        "detail": "huggingface_hub",
        "documentation": {}
    },
    {
        "label": "repocard",
        "importPath": "huggingface_hub",
        "description": "huggingface_hub",
        "isExtraImport": true,
        "detail": "huggingface_hub",
        "documentation": {}
    },
    {
        "label": "upload_folder",
        "importPath": "huggingface_hub",
        "description": "huggingface_hub",
        "isExtraImport": true,
        "detail": "huggingface_hub",
        "documentation": {}
    },
    {
        "label": "HfApi",
        "importPath": "huggingface_hub",
        "description": "huggingface_hub",
        "isExtraImport": true,
        "detail": "huggingface_hub",
        "documentation": {}
    },
    {
        "label": "Repository",
        "importPath": "huggingface_hub",
        "description": "huggingface_hub",
        "isExtraImport": true,
        "detail": "huggingface_hub",
        "documentation": {}
    },
    {
        "label": "repocard",
        "importPath": "huggingface_hub",
        "description": "huggingface_hub",
        "isExtraImport": true,
        "detail": "huggingface_hub",
        "documentation": {}
    },
    {
        "label": "upload_folder",
        "importPath": "huggingface_hub",
        "description": "huggingface_hub",
        "isExtraImport": true,
        "detail": "huggingface_hub",
        "documentation": {}
    },
    {
        "label": "imageio",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "imageio",
        "description": "imageio",
        "detail": "imageio",
        "documentation": {}
    },
    {
        "label": "load_from_hf",
        "importPath": "sample_factory.huggingface.huggingface_utils",
        "description": "sample_factory.huggingface.huggingface_utils",
        "isExtraImport": true,
        "detail": "sample_factory.huggingface.huggingface_utils",
        "documentation": {}
    },
    {
        "label": "generate_model_card",
        "importPath": "sample_factory.huggingface.huggingface_utils",
        "description": "sample_factory.huggingface.huggingface_utils",
        "isExtraImport": true,
        "detail": "sample_factory.huggingface.huggingface_utils",
        "documentation": {}
    },
    {
        "label": "push_to_hf",
        "importPath": "sample_factory.huggingface.huggingface_utils",
        "description": "sample_factory.huggingface.huggingface_utils",
        "isExtraImport": true,
        "detail": "sample_factory.huggingface.huggingface_utils",
        "documentation": {}
    },
    {
        "label": "generate_model_card",
        "importPath": "sample_factory.huggingface.huggingface_utils",
        "description": "sample_factory.huggingface.huggingface_utils",
        "isExtraImport": true,
        "detail": "sample_factory.huggingface.huggingface_utils",
        "documentation": {}
    },
    {
        "label": "generate_replay_video",
        "importPath": "sample_factory.huggingface.huggingface_utils",
        "description": "sample_factory.huggingface.huggingface_utils",
        "isExtraImport": true,
        "detail": "sample_factory.huggingface.huggingface_utils",
        "documentation": {}
    },
    {
        "label": "push_to_hf",
        "importPath": "sample_factory.huggingface.huggingface_utils",
        "description": "sample_factory.huggingface.huggingface_utils",
        "isExtraImport": true,
        "detail": "sample_factory.huggingface.huggingface_utils",
        "documentation": {}
    },
    {
        "label": "add_ngc_args",
        "importPath": "sample_factory.launcher.run_ngc",
        "description": "sample_factory.launcher.run_ngc",
        "isExtraImport": true,
        "detail": "sample_factory.launcher.run_ngc",
        "documentation": {}
    },
    {
        "label": "run_ngc",
        "importPath": "sample_factory.launcher.run_ngc",
        "description": "sample_factory.launcher.run_ngc",
        "isExtraImport": true,
        "detail": "sample_factory.launcher.run_ngc",
        "documentation": {}
    },
    {
        "label": "add_os_parallelism_args",
        "importPath": "sample_factory.launcher.run_processes",
        "description": "sample_factory.launcher.run_processes",
        "isExtraImport": true,
        "detail": "sample_factory.launcher.run_processes",
        "documentation": {}
    },
    {
        "label": "run",
        "importPath": "sample_factory.launcher.run_processes",
        "description": "sample_factory.launcher.run_processes",
        "isExtraImport": true,
        "detail": "sample_factory.launcher.run_processes",
        "documentation": {}
    },
    {
        "label": "run",
        "importPath": "sample_factory.launcher.run_processes",
        "description": "sample_factory.launcher.run_processes",
        "isExtraImport": true,
        "detail": "sample_factory.launcher.run_processes",
        "documentation": {}
    },
    {
        "label": "add_slurm_args",
        "importPath": "sample_factory.launcher.run_slurm",
        "description": "sample_factory.launcher.run_slurm",
        "isExtraImport": true,
        "detail": "sample_factory.launcher.run_slurm",
        "documentation": {}
    },
    {
        "label": "run_slurm",
        "importPath": "sample_factory.launcher.run_slurm",
        "description": "sample_factory.launcher.run_slurm",
        "isExtraImport": true,
        "detail": "sample_factory.launcher.run_slurm",
        "documentation": {}
    },
    {
        "label": "re",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "re",
        "description": "re",
        "detail": "re",
        "documentation": {}
    },
    {
        "label": "ThreadPool",
        "importPath": "multiprocessing.pool",
        "description": "multiprocessing.pool",
        "isExtraImport": true,
        "detail": "multiprocessing.pool",
        "documentation": {}
    },
    {
        "label": "Template",
        "importPath": "string",
        "description": "string",
        "isExtraImport": true,
        "detail": "string",
        "documentation": {}
    },
    {
        "label": "ObservationNormalizer",
        "importPath": "sample_factory.utils.normalize",
        "description": "sample_factory.utils.normalize",
        "isExtraImport": true,
        "detail": "sample_factory.utils.normalize",
        "documentation": {}
    },
    {
        "label": "Encoder",
        "importPath": "sample_factory.model.encoder",
        "description": "sample_factory.model.encoder",
        "isExtraImport": true,
        "detail": "sample_factory.model.encoder",
        "documentation": {}
    },
    {
        "label": "default_make_encoder_func",
        "importPath": "sample_factory.model.encoder",
        "description": "sample_factory.model.encoder",
        "isExtraImport": true,
        "detail": "sample_factory.model.encoder",
        "documentation": {}
    },
    {
        "label": "Encoder",
        "importPath": "sample_factory.model.encoder",
        "description": "sample_factory.model.encoder",
        "isExtraImport": true,
        "detail": "sample_factory.model.encoder",
        "documentation": {}
    },
    {
        "label": "make_img_encoder",
        "importPath": "sample_factory.model.encoder",
        "description": "sample_factory.model.encoder",
        "isExtraImport": true,
        "detail": "sample_factory.model.encoder",
        "documentation": {}
    },
    {
        "label": "Encoder",
        "importPath": "sample_factory.model.encoder",
        "description": "sample_factory.model.encoder",
        "isExtraImport": true,
        "detail": "sample_factory.model.encoder",
        "documentation": {}
    },
    {
        "label": "Encoder",
        "importPath": "sample_factory.model.encoder",
        "description": "sample_factory.model.encoder",
        "isExtraImport": true,
        "detail": "sample_factory.model.encoder",
        "documentation": {}
    },
    {
        "label": "Encoder",
        "importPath": "sample_factory.model.encoder",
        "description": "sample_factory.model.encoder",
        "isExtraImport": true,
        "detail": "sample_factory.model.encoder",
        "documentation": {}
    },
    {
        "label": "make_img_encoder",
        "importPath": "sample_factory.model.encoder",
        "description": "sample_factory.model.encoder",
        "isExtraImport": true,
        "detail": "sample_factory.model.encoder",
        "documentation": {}
    },
    {
        "label": "Encoder",
        "importPath": "sample_factory.model.encoder",
        "description": "sample_factory.model.encoder",
        "isExtraImport": true,
        "detail": "sample_factory.model.encoder",
        "documentation": {}
    },
    {
        "label": "default_make_encoder_func",
        "importPath": "sample_factory.model.encoder",
        "description": "sample_factory.model.encoder",
        "isExtraImport": true,
        "detail": "sample_factory.model.encoder",
        "documentation": {}
    },
    {
        "label": "Encoder",
        "importPath": "sample_factory.model.encoder",
        "description": "sample_factory.model.encoder",
        "isExtraImport": true,
        "detail": "sample_factory.model.encoder",
        "documentation": {}
    },
    {
        "label": "spectral_norm",
        "importPath": "torch.nn.utils",
        "description": "torch.nn.utils",
        "isExtraImport": true,
        "detail": "torch.nn.utils",
        "documentation": {}
    },
    {
        "label": "get_gpus_without_triggering_pytorch_cuda_initialization",
        "importPath": "sample_factory.utils.get_available_gpus",
        "description": "sample_factory.utils.get_available_gpus",
        "isExtraImport": true,
        "detail": "sample_factory.utils.get_available_gpus",
        "documentation": {}
    },
    {
        "label": "socket",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "socket",
        "description": "socket",
        "detail": "socket",
        "documentation": {}
    },
    {
        "label": "logging",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "logging",
        "description": "logging",
        "detail": "logging",
        "documentation": {}
    },
    {
        "label": "operator",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "operator",
        "description": "operator",
        "detail": "operator",
        "documentation": {}
    },
    {
        "label": "pwd",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pwd",
        "description": "pwd",
        "detail": "pwd",
        "documentation": {}
    },
    {
        "label": "tempfile",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "tempfile",
        "description": "tempfile",
        "detail": "tempfile",
        "documentation": {}
    },
    {
        "label": "col",
        "importPath": "pyparsing",
        "description": "pyparsing",
        "isExtraImport": true,
        "detail": "pyparsing",
        "documentation": {}
    },
    {
        "label": "Empty",
        "importPath": "_queue",
        "description": "_queue",
        "isExtraImport": true,
        "detail": "_queue",
        "documentation": {}
    },
    {
        "label": "ColoredFormatter",
        "importPath": "colorlog",
        "description": "colorlog",
        "isExtraImport": true,
        "detail": "colorlog",
        "documentation": {}
    },
    {
        "label": "ParallelRunner",
        "importPath": "sample_factory.algo.runners.runner_parallel",
        "description": "sample_factory.algo.runners.runner_parallel",
        "isExtraImport": true,
        "detail": "sample_factory.algo.runners.runner_parallel",
        "documentation": {}
    },
    {
        "label": "SerialRunner",
        "importPath": "sample_factory.algo.runners.runner_serial",
        "description": "sample_factory.algo.runners.runner_serial",
        "isExtraImport": true,
        "detail": "sample_factory.algo.runners.runner_serial",
        "documentation": {}
    },
    {
        "label": "PopulationBasedTraining",
        "importPath": "sample_factory.pbt.population_based_training",
        "description": "sample_factory.pbt.population_based_training",
        "isExtraImport": true,
        "detail": "sample_factory.pbt.population_based_training",
        "documentation": {}
    },
    {
        "label": "Experiment",
        "importPath": "sample_factory.launcher.run_description",
        "description": "sample_factory.launcher.run_description",
        "isExtraImport": true,
        "detail": "sample_factory.launcher.run_description",
        "documentation": {}
    },
    {
        "label": "ParamGrid",
        "importPath": "sample_factory.launcher.run_description",
        "description": "sample_factory.launcher.run_description",
        "isExtraImport": true,
        "detail": "sample_factory.launcher.run_description",
        "documentation": {}
    },
    {
        "label": "RunDescription",
        "importPath": "sample_factory.launcher.run_description",
        "description": "sample_factory.launcher.run_description",
        "isExtraImport": true,
        "detail": "sample_factory.launcher.run_description",
        "documentation": {}
    },
    {
        "label": "Experiment",
        "importPath": "sample_factory.launcher.run_description",
        "description": "sample_factory.launcher.run_description",
        "isExtraImport": true,
        "detail": "sample_factory.launcher.run_description",
        "documentation": {}
    },
    {
        "label": "ParamGrid",
        "importPath": "sample_factory.launcher.run_description",
        "description": "sample_factory.launcher.run_description",
        "isExtraImport": true,
        "detail": "sample_factory.launcher.run_description",
        "documentation": {}
    },
    {
        "label": "RunDescription",
        "importPath": "sample_factory.launcher.run_description",
        "description": "sample_factory.launcher.run_description",
        "isExtraImport": true,
        "detail": "sample_factory.launcher.run_description",
        "documentation": {}
    },
    {
        "label": "Experiment",
        "importPath": "sample_factory.launcher.run_description",
        "description": "sample_factory.launcher.run_description",
        "isExtraImport": true,
        "detail": "sample_factory.launcher.run_description",
        "documentation": {}
    },
    {
        "label": "ParamGrid",
        "importPath": "sample_factory.launcher.run_description",
        "description": "sample_factory.launcher.run_description",
        "isExtraImport": true,
        "detail": "sample_factory.launcher.run_description",
        "documentation": {}
    },
    {
        "label": "RunDescription",
        "importPath": "sample_factory.launcher.run_description",
        "description": "sample_factory.launcher.run_description",
        "isExtraImport": true,
        "detail": "sample_factory.launcher.run_description",
        "documentation": {}
    },
    {
        "label": "Experiment",
        "importPath": "sample_factory.launcher.run_description",
        "description": "sample_factory.launcher.run_description",
        "isExtraImport": true,
        "detail": "sample_factory.launcher.run_description",
        "documentation": {}
    },
    {
        "label": "ParamGrid",
        "importPath": "sample_factory.launcher.run_description",
        "description": "sample_factory.launcher.run_description",
        "isExtraImport": true,
        "detail": "sample_factory.launcher.run_description",
        "documentation": {}
    },
    {
        "label": "RunDescription",
        "importPath": "sample_factory.launcher.run_description",
        "description": "sample_factory.launcher.run_description",
        "isExtraImport": true,
        "detail": "sample_factory.launcher.run_description",
        "documentation": {}
    },
    {
        "label": "Experiment",
        "importPath": "sample_factory.launcher.run_description",
        "description": "sample_factory.launcher.run_description",
        "isExtraImport": true,
        "detail": "sample_factory.launcher.run_description",
        "documentation": {}
    },
    {
        "label": "ParamGrid",
        "importPath": "sample_factory.launcher.run_description",
        "description": "sample_factory.launcher.run_description",
        "isExtraImport": true,
        "detail": "sample_factory.launcher.run_description",
        "documentation": {}
    },
    {
        "label": "RunDescription",
        "importPath": "sample_factory.launcher.run_description",
        "description": "sample_factory.launcher.run_description",
        "isExtraImport": true,
        "detail": "sample_factory.launcher.run_description",
        "documentation": {}
    },
    {
        "label": "Experiment",
        "importPath": "sample_factory.launcher.run_description",
        "description": "sample_factory.launcher.run_description",
        "isExtraImport": true,
        "detail": "sample_factory.launcher.run_description",
        "documentation": {}
    },
    {
        "label": "ParamGrid",
        "importPath": "sample_factory.launcher.run_description",
        "description": "sample_factory.launcher.run_description",
        "isExtraImport": true,
        "detail": "sample_factory.launcher.run_description",
        "documentation": {}
    },
    {
        "label": "RunDescription",
        "importPath": "sample_factory.launcher.run_description",
        "description": "sample_factory.launcher.run_description",
        "isExtraImport": true,
        "detail": "sample_factory.launcher.run_description",
        "documentation": {}
    },
    {
        "label": "Experiment",
        "importPath": "sample_factory.launcher.run_description",
        "description": "sample_factory.launcher.run_description",
        "isExtraImport": true,
        "detail": "sample_factory.launcher.run_description",
        "documentation": {}
    },
    {
        "label": "ParamGrid",
        "importPath": "sample_factory.launcher.run_description",
        "description": "sample_factory.launcher.run_description",
        "isExtraImport": true,
        "detail": "sample_factory.launcher.run_description",
        "documentation": {}
    },
    {
        "label": "RunDescription",
        "importPath": "sample_factory.launcher.run_description",
        "description": "sample_factory.launcher.run_description",
        "isExtraImport": true,
        "detail": "sample_factory.launcher.run_description",
        "documentation": {}
    },
    {
        "label": "Experiment",
        "importPath": "sample_factory.launcher.run_description",
        "description": "sample_factory.launcher.run_description",
        "isExtraImport": true,
        "detail": "sample_factory.launcher.run_description",
        "documentation": {}
    },
    {
        "label": "ParamGrid",
        "importPath": "sample_factory.launcher.run_description",
        "description": "sample_factory.launcher.run_description",
        "isExtraImport": true,
        "detail": "sample_factory.launcher.run_description",
        "documentation": {}
    },
    {
        "label": "RunDescription",
        "importPath": "sample_factory.launcher.run_description",
        "description": "sample_factory.launcher.run_description",
        "isExtraImport": true,
        "detail": "sample_factory.launcher.run_description",
        "documentation": {}
    },
    {
        "label": "Experiment",
        "importPath": "sample_factory.launcher.run_description",
        "description": "sample_factory.launcher.run_description",
        "isExtraImport": true,
        "detail": "sample_factory.launcher.run_description",
        "documentation": {}
    },
    {
        "label": "ParamGrid",
        "importPath": "sample_factory.launcher.run_description",
        "description": "sample_factory.launcher.run_description",
        "isExtraImport": true,
        "detail": "sample_factory.launcher.run_description",
        "documentation": {}
    },
    {
        "label": "RunDescription",
        "importPath": "sample_factory.launcher.run_description",
        "description": "sample_factory.launcher.run_description",
        "isExtraImport": true,
        "detail": "sample_factory.launcher.run_description",
        "documentation": {}
    },
    {
        "label": "Experiment",
        "importPath": "sample_factory.launcher.run_description",
        "description": "sample_factory.launcher.run_description",
        "isExtraImport": true,
        "detail": "sample_factory.launcher.run_description",
        "documentation": {}
    },
    {
        "label": "ParamGrid",
        "importPath": "sample_factory.launcher.run_description",
        "description": "sample_factory.launcher.run_description",
        "isExtraImport": true,
        "detail": "sample_factory.launcher.run_description",
        "documentation": {}
    },
    {
        "label": "RunDescription",
        "importPath": "sample_factory.launcher.run_description",
        "description": "sample_factory.launcher.run_description",
        "isExtraImport": true,
        "detail": "sample_factory.launcher.run_description",
        "documentation": {}
    },
    {
        "label": "Experiment",
        "importPath": "sample_factory.launcher.run_description",
        "description": "sample_factory.launcher.run_description",
        "isExtraImport": true,
        "detail": "sample_factory.launcher.run_description",
        "documentation": {}
    },
    {
        "label": "ParamGrid",
        "importPath": "sample_factory.launcher.run_description",
        "description": "sample_factory.launcher.run_description",
        "isExtraImport": true,
        "detail": "sample_factory.launcher.run_description",
        "documentation": {}
    },
    {
        "label": "RunDescription",
        "importPath": "sample_factory.launcher.run_description",
        "description": "sample_factory.launcher.run_description",
        "isExtraImport": true,
        "detail": "sample_factory.launcher.run_description",
        "documentation": {}
    },
    {
        "label": "Experiment",
        "importPath": "sample_factory.launcher.run_description",
        "description": "sample_factory.launcher.run_description",
        "isExtraImport": true,
        "detail": "sample_factory.launcher.run_description",
        "documentation": {}
    },
    {
        "label": "ParamGrid",
        "importPath": "sample_factory.launcher.run_description",
        "description": "sample_factory.launcher.run_description",
        "isExtraImport": true,
        "detail": "sample_factory.launcher.run_description",
        "documentation": {}
    },
    {
        "label": "RunDescription",
        "importPath": "sample_factory.launcher.run_description",
        "description": "sample_factory.launcher.run_description",
        "isExtraImport": true,
        "detail": "sample_factory.launcher.run_description",
        "documentation": {}
    },
    {
        "label": "Experiment",
        "importPath": "sample_factory.launcher.run_description",
        "description": "sample_factory.launcher.run_description",
        "isExtraImport": true,
        "detail": "sample_factory.launcher.run_description",
        "documentation": {}
    },
    {
        "label": "ParamGrid",
        "importPath": "sample_factory.launcher.run_description",
        "description": "sample_factory.launcher.run_description",
        "isExtraImport": true,
        "detail": "sample_factory.launcher.run_description",
        "documentation": {}
    },
    {
        "label": "RunDescription",
        "importPath": "sample_factory.launcher.run_description",
        "description": "sample_factory.launcher.run_description",
        "isExtraImport": true,
        "detail": "sample_factory.launcher.run_description",
        "documentation": {}
    },
    {
        "label": "Experiment",
        "importPath": "sample_factory.launcher.run_description",
        "description": "sample_factory.launcher.run_description",
        "isExtraImport": true,
        "detail": "sample_factory.launcher.run_description",
        "documentation": {}
    },
    {
        "label": "ParamGrid",
        "importPath": "sample_factory.launcher.run_description",
        "description": "sample_factory.launcher.run_description",
        "isExtraImport": true,
        "detail": "sample_factory.launcher.run_description",
        "documentation": {}
    },
    {
        "label": "RunDescription",
        "importPath": "sample_factory.launcher.run_description",
        "description": "sample_factory.launcher.run_description",
        "isExtraImport": true,
        "detail": "sample_factory.launcher.run_description",
        "documentation": {}
    },
    {
        "label": "Experiment",
        "importPath": "sample_factory.launcher.run_description",
        "description": "sample_factory.launcher.run_description",
        "isExtraImport": true,
        "detail": "sample_factory.launcher.run_description",
        "documentation": {}
    },
    {
        "label": "ParamGrid",
        "importPath": "sample_factory.launcher.run_description",
        "description": "sample_factory.launcher.run_description",
        "isExtraImport": true,
        "detail": "sample_factory.launcher.run_description",
        "documentation": {}
    },
    {
        "label": "RunDescription",
        "importPath": "sample_factory.launcher.run_description",
        "description": "sample_factory.launcher.run_description",
        "isExtraImport": true,
        "detail": "sample_factory.launcher.run_description",
        "documentation": {}
    },
    {
        "label": "Experiment",
        "importPath": "sample_factory.launcher.run_description",
        "description": "sample_factory.launcher.run_description",
        "isExtraImport": true,
        "detail": "sample_factory.launcher.run_description",
        "documentation": {}
    },
    {
        "label": "ParamGrid",
        "importPath": "sample_factory.launcher.run_description",
        "description": "sample_factory.launcher.run_description",
        "isExtraImport": true,
        "detail": "sample_factory.launcher.run_description",
        "documentation": {}
    },
    {
        "label": "RunDescription",
        "importPath": "sample_factory.launcher.run_description",
        "description": "sample_factory.launcher.run_description",
        "isExtraImport": true,
        "detail": "sample_factory.launcher.run_description",
        "documentation": {}
    },
    {
        "label": "Experiment",
        "importPath": "sample_factory.launcher.run_description",
        "description": "sample_factory.launcher.run_description",
        "isExtraImport": true,
        "detail": "sample_factory.launcher.run_description",
        "documentation": {}
    },
    {
        "label": "ParamGrid",
        "importPath": "sample_factory.launcher.run_description",
        "description": "sample_factory.launcher.run_description",
        "isExtraImport": true,
        "detail": "sample_factory.launcher.run_description",
        "documentation": {}
    },
    {
        "label": "RunDescription",
        "importPath": "sample_factory.launcher.run_description",
        "description": "sample_factory.launcher.run_description",
        "isExtraImport": true,
        "detail": "sample_factory.launcher.run_description",
        "documentation": {}
    },
    {
        "label": "Experiment",
        "importPath": "sample_factory.launcher.run_description",
        "description": "sample_factory.launcher.run_description",
        "isExtraImport": true,
        "detail": "sample_factory.launcher.run_description",
        "documentation": {}
    },
    {
        "label": "ParamGrid",
        "importPath": "sample_factory.launcher.run_description",
        "description": "sample_factory.launcher.run_description",
        "isExtraImport": true,
        "detail": "sample_factory.launcher.run_description",
        "documentation": {}
    },
    {
        "label": "RunDescription",
        "importPath": "sample_factory.launcher.run_description",
        "description": "sample_factory.launcher.run_description",
        "isExtraImport": true,
        "detail": "sample_factory.launcher.run_description",
        "documentation": {}
    },
    {
        "label": "Experiment",
        "importPath": "sample_factory.launcher.run_description",
        "description": "sample_factory.launcher.run_description",
        "isExtraImport": true,
        "detail": "sample_factory.launcher.run_description",
        "documentation": {}
    },
    {
        "label": "ParamGrid",
        "importPath": "sample_factory.launcher.run_description",
        "description": "sample_factory.launcher.run_description",
        "isExtraImport": true,
        "detail": "sample_factory.launcher.run_description",
        "documentation": {}
    },
    {
        "label": "RunDescription",
        "importPath": "sample_factory.launcher.run_description",
        "description": "sample_factory.launcher.run_description",
        "isExtraImport": true,
        "detail": "sample_factory.launcher.run_description",
        "documentation": {}
    },
    {
        "label": "Experiment",
        "importPath": "sample_factory.launcher.run_description",
        "description": "sample_factory.launcher.run_description",
        "isExtraImport": true,
        "detail": "sample_factory.launcher.run_description",
        "documentation": {}
    },
    {
        "label": "ParamGrid",
        "importPath": "sample_factory.launcher.run_description",
        "description": "sample_factory.launcher.run_description",
        "isExtraImport": true,
        "detail": "sample_factory.launcher.run_description",
        "documentation": {}
    },
    {
        "label": "RunDescription",
        "importPath": "sample_factory.launcher.run_description",
        "description": "sample_factory.launcher.run_description",
        "isExtraImport": true,
        "detail": "sample_factory.launcher.run_description",
        "documentation": {}
    },
    {
        "label": "Experiment",
        "importPath": "sample_factory.launcher.run_description",
        "description": "sample_factory.launcher.run_description",
        "isExtraImport": true,
        "detail": "sample_factory.launcher.run_description",
        "documentation": {}
    },
    {
        "label": "ParamGrid",
        "importPath": "sample_factory.launcher.run_description",
        "description": "sample_factory.launcher.run_description",
        "isExtraImport": true,
        "detail": "sample_factory.launcher.run_description",
        "documentation": {}
    },
    {
        "label": "RunDescription",
        "importPath": "sample_factory.launcher.run_description",
        "description": "sample_factory.launcher.run_description",
        "isExtraImport": true,
        "detail": "sample_factory.launcher.run_description",
        "documentation": {}
    },
    {
        "label": "Experiment",
        "importPath": "sample_factory.launcher.run_description",
        "description": "sample_factory.launcher.run_description",
        "isExtraImport": true,
        "detail": "sample_factory.launcher.run_description",
        "documentation": {}
    },
    {
        "label": "ParamGrid",
        "importPath": "sample_factory.launcher.run_description",
        "description": "sample_factory.launcher.run_description",
        "isExtraImport": true,
        "detail": "sample_factory.launcher.run_description",
        "documentation": {}
    },
    {
        "label": "RunDescription",
        "importPath": "sample_factory.launcher.run_description",
        "description": "sample_factory.launcher.run_description",
        "isExtraImport": true,
        "detail": "sample_factory.launcher.run_description",
        "documentation": {}
    },
    {
        "label": "Experiment",
        "importPath": "sample_factory.launcher.run_description",
        "description": "sample_factory.launcher.run_description",
        "isExtraImport": true,
        "detail": "sample_factory.launcher.run_description",
        "documentation": {}
    },
    {
        "label": "RunDescription",
        "importPath": "sample_factory.launcher.run_description",
        "description": "sample_factory.launcher.run_description",
        "isExtraImport": true,
        "detail": "sample_factory.launcher.run_description",
        "documentation": {}
    },
    {
        "label": "Experiment",
        "importPath": "sample_factory.launcher.run_description",
        "description": "sample_factory.launcher.run_description",
        "isExtraImport": true,
        "detail": "sample_factory.launcher.run_description",
        "documentation": {}
    },
    {
        "label": "RunDescription",
        "importPath": "sample_factory.launcher.run_description",
        "description": "sample_factory.launcher.run_description",
        "isExtraImport": true,
        "detail": "sample_factory.launcher.run_description",
        "documentation": {}
    },
    {
        "label": "Experiment",
        "importPath": "sample_factory.launcher.run_description",
        "description": "sample_factory.launcher.run_description",
        "isExtraImport": true,
        "detail": "sample_factory.launcher.run_description",
        "documentation": {}
    },
    {
        "label": "ParamGrid",
        "importPath": "sample_factory.launcher.run_description",
        "description": "sample_factory.launcher.run_description",
        "isExtraImport": true,
        "detail": "sample_factory.launcher.run_description",
        "documentation": {}
    },
    {
        "label": "RunDescription",
        "importPath": "sample_factory.launcher.run_description",
        "description": "sample_factory.launcher.run_description",
        "isExtraImport": true,
        "detail": "sample_factory.launcher.run_description",
        "documentation": {}
    },
    {
        "label": "Experiment",
        "importPath": "sample_factory.launcher.run_description",
        "description": "sample_factory.launcher.run_description",
        "isExtraImport": true,
        "detail": "sample_factory.launcher.run_description",
        "documentation": {}
    },
    {
        "label": "ParamGrid",
        "importPath": "sample_factory.launcher.run_description",
        "description": "sample_factory.launcher.run_description",
        "isExtraImport": true,
        "detail": "sample_factory.launcher.run_description",
        "documentation": {}
    },
    {
        "label": "RunDescription",
        "importPath": "sample_factory.launcher.run_description",
        "description": "sample_factory.launcher.run_description",
        "isExtraImport": true,
        "detail": "sample_factory.launcher.run_description",
        "documentation": {}
    },
    {
        "label": "Experiment",
        "importPath": "sample_factory.launcher.run_description",
        "description": "sample_factory.launcher.run_description",
        "isExtraImport": true,
        "detail": "sample_factory.launcher.run_description",
        "documentation": {}
    },
    {
        "label": "ParamGrid",
        "importPath": "sample_factory.launcher.run_description",
        "description": "sample_factory.launcher.run_description",
        "isExtraImport": true,
        "detail": "sample_factory.launcher.run_description",
        "documentation": {}
    },
    {
        "label": "ParamList",
        "importPath": "sample_factory.launcher.run_description",
        "description": "sample_factory.launcher.run_description",
        "isExtraImport": true,
        "detail": "sample_factory.launcher.run_description",
        "documentation": {}
    },
    {
        "label": "RunDescription",
        "importPath": "sample_factory.launcher.run_description",
        "description": "sample_factory.launcher.run_description",
        "isExtraImport": true,
        "detail": "sample_factory.launcher.run_description",
        "documentation": {}
    },
    {
        "label": "enjoy",
        "importPath": "sample_factory.enjoy",
        "description": "sample_factory.enjoy",
        "isExtraImport": true,
        "detail": "sample_factory.enjoy",
        "documentation": {}
    },
    {
        "label": "enjoy",
        "importPath": "sample_factory.enjoy",
        "description": "sample_factory.enjoy",
        "isExtraImport": true,
        "detail": "sample_factory.enjoy",
        "documentation": {}
    },
    {
        "label": "enjoy",
        "importPath": "sample_factory.enjoy",
        "description": "sample_factory.enjoy",
        "isExtraImport": true,
        "detail": "sample_factory.enjoy",
        "documentation": {}
    },
    {
        "label": "enjoy",
        "importPath": "sample_factory.enjoy",
        "description": "sample_factory.enjoy",
        "isExtraImport": true,
        "detail": "sample_factory.enjoy",
        "documentation": {}
    },
    {
        "label": "enjoy",
        "importPath": "sample_factory.enjoy",
        "description": "sample_factory.enjoy",
        "isExtraImport": true,
        "detail": "sample_factory.enjoy",
        "documentation": {}
    },
    {
        "label": "enjoy",
        "importPath": "sample_factory.enjoy",
        "description": "sample_factory.enjoy",
        "isExtraImport": true,
        "detail": "sample_factory.enjoy",
        "documentation": {}
    },
    {
        "label": "enjoy",
        "importPath": "sample_factory.enjoy",
        "description": "sample_factory.enjoy",
        "isExtraImport": true,
        "detail": "sample_factory.enjoy",
        "documentation": {}
    },
    {
        "label": "enjoy",
        "importPath": "sample_factory.enjoy",
        "description": "sample_factory.enjoy",
        "isExtraImport": true,
        "detail": "sample_factory.enjoy",
        "documentation": {}
    },
    {
        "label": "enjoy",
        "importPath": "sample_factory.enjoy",
        "description": "sample_factory.enjoy",
        "isExtraImport": true,
        "detail": "sample_factory.enjoy",
        "documentation": {}
    },
    {
        "label": "enjoy",
        "importPath": "sample_factory.enjoy",
        "description": "sample_factory.enjoy",
        "isExtraImport": true,
        "detail": "sample_factory.enjoy",
        "documentation": {}
    },
    {
        "label": "enjoy",
        "importPath": "sample_factory.enjoy",
        "description": "sample_factory.enjoy",
        "isExtraImport": true,
        "detail": "sample_factory.enjoy",
        "documentation": {}
    },
    {
        "label": "enjoy",
        "importPath": "sample_factory.enjoy",
        "description": "sample_factory.enjoy",
        "isExtraImport": true,
        "detail": "sample_factory.enjoy",
        "documentation": {}
    },
    {
        "label": "enjoy",
        "importPath": "sample_factory.enjoy",
        "description": "sample_factory.enjoy",
        "isExtraImport": true,
        "detail": "sample_factory.enjoy",
        "documentation": {}
    },
    {
        "label": "enjoy",
        "importPath": "sample_factory.enjoy",
        "description": "sample_factory.enjoy",
        "isExtraImport": true,
        "detail": "sample_factory.enjoy",
        "documentation": {}
    },
    {
        "label": "parse_atari_args",
        "importPath": "sf_examples.atari.train_atari",
        "description": "sf_examples.atari.train_atari",
        "isExtraImport": true,
        "detail": "sf_examples.atari.train_atari",
        "documentation": {}
    },
    {
        "label": "register_atari_components",
        "importPath": "sf_examples.atari.train_atari",
        "description": "sf_examples.atari.train_atari",
        "isExtraImport": true,
        "detail": "sf_examples.atari.train_atari",
        "documentation": {}
    },
    {
        "label": "parse_atari_args",
        "importPath": "sf_examples.atari.train_atari",
        "description": "sf_examples.atari.train_atari",
        "isExtraImport": true,
        "detail": "sf_examples.atari.train_atari",
        "documentation": {}
    },
    {
        "label": "register_atari_components",
        "importPath": "sf_examples.atari.train_atari",
        "description": "sf_examples.atari.train_atari",
        "isExtraImport": true,
        "detail": "sf_examples.atari.train_atari",
        "documentation": {}
    },
    {
        "label": "parse_atari_args",
        "importPath": "sf_examples.atari.train_atari",
        "description": "sf_examples.atari.train_atari",
        "isExtraImport": true,
        "detail": "sf_examples.atari.train_atari",
        "documentation": {}
    },
    {
        "label": "register_atari_components",
        "importPath": "sf_examples.atari.train_atari",
        "description": "sf_examples.atari.train_atari",
        "isExtraImport": true,
        "detail": "sf_examples.atari.train_atari",
        "documentation": {}
    },
    {
        "label": "parse_atari_args",
        "importPath": "sf_examples.atari.train_atari",
        "description": "sf_examples.atari.train_atari",
        "isExtraImport": true,
        "detail": "sf_examples.atari.train_atari",
        "documentation": {}
    },
    {
        "label": "run_rl",
        "importPath": "sample_factory.train",
        "description": "sample_factory.train",
        "isExtraImport": true,
        "detail": "sample_factory.train",
        "documentation": {}
    },
    {
        "label": "run_rl",
        "importPath": "sample_factory.train",
        "description": "sample_factory.train",
        "isExtraImport": true,
        "detail": "sample_factory.train",
        "documentation": {}
    },
    {
        "label": "make_runner",
        "importPath": "sample_factory.train",
        "description": "sample_factory.train",
        "isExtraImport": true,
        "detail": "sample_factory.train",
        "documentation": {}
    },
    {
        "label": "run_rl",
        "importPath": "sample_factory.train",
        "description": "sample_factory.train",
        "isExtraImport": true,
        "detail": "sample_factory.train",
        "documentation": {}
    },
    {
        "label": "run_rl",
        "importPath": "sample_factory.train",
        "description": "sample_factory.train",
        "isExtraImport": true,
        "detail": "sample_factory.train",
        "documentation": {}
    },
    {
        "label": "run_rl",
        "importPath": "sample_factory.train",
        "description": "sample_factory.train",
        "isExtraImport": true,
        "detail": "sample_factory.train",
        "documentation": {}
    },
    {
        "label": "run_rl",
        "importPath": "sample_factory.train",
        "description": "sample_factory.train",
        "isExtraImport": true,
        "detail": "sample_factory.train",
        "documentation": {}
    },
    {
        "label": "run_rl",
        "importPath": "sample_factory.train",
        "description": "sample_factory.train",
        "isExtraImport": true,
        "detail": "sample_factory.train",
        "documentation": {}
    },
    {
        "label": "run_rl",
        "importPath": "sample_factory.train",
        "description": "sample_factory.train",
        "isExtraImport": true,
        "detail": "sample_factory.train",
        "documentation": {}
    },
    {
        "label": "run_rl",
        "importPath": "sample_factory.train",
        "description": "sample_factory.train",
        "isExtraImport": true,
        "detail": "sample_factory.train",
        "documentation": {}
    },
    {
        "label": "run_rl",
        "importPath": "sample_factory.train",
        "description": "sample_factory.train",
        "isExtraImport": true,
        "detail": "sample_factory.train",
        "documentation": {}
    },
    {
        "label": "run_rl",
        "importPath": "sample_factory.train",
        "description": "sample_factory.train",
        "isExtraImport": true,
        "detail": "sample_factory.train",
        "documentation": {}
    },
    {
        "label": "run_rl",
        "importPath": "sample_factory.train",
        "description": "sample_factory.train",
        "isExtraImport": true,
        "detail": "sample_factory.train",
        "documentation": {}
    },
    {
        "label": "run_rl",
        "importPath": "sample_factory.train",
        "description": "sample_factory.train",
        "isExtraImport": true,
        "detail": "sample_factory.train",
        "documentation": {}
    },
    {
        "label": "run_rl",
        "importPath": "sample_factory.train",
        "description": "sample_factory.train",
        "isExtraImport": true,
        "detail": "sample_factory.train",
        "documentation": {}
    },
    {
        "label": "make_runner",
        "importPath": "sample_factory.train",
        "description": "sample_factory.train",
        "isExtraImport": true,
        "detail": "sample_factory.train",
        "documentation": {}
    },
    {
        "label": "make_runner",
        "importPath": "sample_factory.train",
        "description": "sample_factory.train",
        "isExtraImport": true,
        "detail": "sample_factory.train",
        "documentation": {}
    },
    {
        "label": "run_rl",
        "importPath": "sample_factory.train",
        "description": "sample_factory.train",
        "isExtraImport": true,
        "detail": "sample_factory.train",
        "documentation": {}
    },
    {
        "label": "run_rl",
        "importPath": "sample_factory.train",
        "description": "sample_factory.train",
        "isExtraImport": true,
        "detail": "sample_factory.train",
        "documentation": {}
    },
    {
        "label": "run_rl",
        "importPath": "sample_factory.train",
        "description": "sample_factory.train",
        "isExtraImport": true,
        "detail": "sample_factory.train",
        "documentation": {}
    },
    {
        "label": "run_rl",
        "importPath": "sample_factory.train",
        "description": "sample_factory.train",
        "isExtraImport": true,
        "detail": "sample_factory.train",
        "documentation": {}
    },
    {
        "label": "make_runner",
        "importPath": "sample_factory.train",
        "description": "sample_factory.train",
        "isExtraImport": true,
        "detail": "sample_factory.train",
        "documentation": {}
    },
    {
        "label": "atari_override_defaults",
        "importPath": "sf_examples.atari.atari_params",
        "description": "sf_examples.atari.atari_params",
        "isExtraImport": true,
        "detail": "sf_examples.atari.atari_params",
        "documentation": {}
    },
    {
        "label": "ATARI_ENVS",
        "importPath": "sf_examples.atari.atari_utils",
        "description": "sf_examples.atari.atari_utils",
        "isExtraImport": true,
        "detail": "sf_examples.atari.atari_utils",
        "documentation": {}
    },
    {
        "label": "make_atari_env",
        "importPath": "sf_examples.atari.atari_utils",
        "description": "sf_examples.atari.atari_utils",
        "isExtraImport": true,
        "detail": "sf_examples.atari.atari_utils",
        "documentation": {}
    },
    {
        "label": "ATARI_ENVS",
        "importPath": "sf_examples.atari.atari_utils",
        "description": "sf_examples.atari.atari_utils",
        "isExtraImport": true,
        "detail": "sf_examples.atari.atari_utils",
        "documentation": {}
    },
    {
        "label": "AtariSpec",
        "importPath": "sf_examples.atari.atari_utils",
        "description": "sf_examples.atari.atari_utils",
        "isExtraImport": true,
        "detail": "sf_examples.atari.atari_utils",
        "documentation": {}
    },
    {
        "label": "seeds",
        "importPath": "sample_factory.launcher.launcher_utils",
        "description": "sample_factory.launcher.launcher_utils",
        "isExtraImport": true,
        "detail": "sample_factory.launcher.launcher_utils",
        "documentation": {}
    },
    {
        "label": "seeds",
        "importPath": "sample_factory.launcher.launcher_utils",
        "description": "sample_factory.launcher.launcher_utils",
        "isExtraImport": true,
        "detail": "sample_factory.launcher.launcher_utils",
        "documentation": {}
    },
    {
        "label": "seeds",
        "importPath": "sample_factory.launcher.launcher_utils",
        "description": "sample_factory.launcher.launcher_utils",
        "isExtraImport": true,
        "detail": "sample_factory.launcher.launcher_utils",
        "documentation": {}
    },
    {
        "label": "seeds",
        "importPath": "sample_factory.launcher.launcher_utils",
        "description": "sample_factory.launcher.launcher_utils",
        "isExtraImport": true,
        "detail": "sample_factory.launcher.launcher_utils",
        "documentation": {}
    },
    {
        "label": "seeds",
        "importPath": "sample_factory.launcher.launcher_utils",
        "description": "sample_factory.launcher.launcher_utils",
        "isExtraImport": true,
        "detail": "sample_factory.launcher.launcher_utils",
        "documentation": {}
    },
    {
        "label": "ALGO_VERSION",
        "importPath": "sample_factory.utils.algo_version",
        "description": "sample_factory.utils.algo_version",
        "isExtraImport": true,
        "detail": "sample_factory.utils.algo_version",
        "documentation": {}
    },
    {
        "label": "ALGO_VERSION",
        "importPath": "sample_factory.utils.algo_version",
        "description": "sample_factory.utils.algo_version",
        "isExtraImport": true,
        "detail": "sample_factory.utils.algo_version",
        "documentation": {}
    },
    {
        "label": "ALGO_VERSION",
        "importPath": "sample_factory.utils.algo_version",
        "description": "sample_factory.utils.algo_version",
        "isExtraImport": true,
        "detail": "sample_factory.utils.algo_version",
        "documentation": {}
    },
    {
        "label": "brax",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "brax",
        "description": "brax",
        "detail": "brax",
        "documentation": {}
    },
    {
        "label": "math",
        "importPath": "brax",
        "description": "brax",
        "isExtraImport": true,
        "detail": "brax",
        "documentation": {}
    },
    {
        "label": "_BASIC",
        "importPath": "brax.io.image",
        "description": "brax.io.image",
        "isExtraImport": true,
        "detail": "brax.io.image",
        "documentation": {}
    },
    {
        "label": "_GROUND",
        "importPath": "brax.io.image",
        "description": "brax.io.image",
        "isExtraImport": true,
        "detail": "brax.io.image",
        "documentation": {}
    },
    {
        "label": "_TARGET",
        "importPath": "brax.io.image",
        "description": "brax.io.image",
        "isExtraImport": true,
        "detail": "brax.io.image",
        "documentation": {}
    },
    {
        "label": "_eye",
        "importPath": "brax.io.image",
        "description": "brax.io.image",
        "isExtraImport": true,
        "detail": "brax.io.image",
        "documentation": {}
    },
    {
        "label": "_up",
        "importPath": "brax.io.image",
        "description": "brax.io.image",
        "isExtraImport": true,
        "detail": "brax.io.image",
        "documentation": {}
    },
    {
        "label": "vec_to_arr",
        "importPath": "brax.physics.base",
        "description": "brax.physics.base",
        "isExtraImport": true,
        "detail": "brax.physics.base",
        "documentation": {}
    },
    {
        "label": "TinyRenderCamera",
        "importPath": "pytinyrenderer",
        "description": "pytinyrenderer",
        "isExtraImport": true,
        "detail": "pytinyrenderer",
        "documentation": {}
    },
    {
        "label": "TinyRenderLight",
        "importPath": "pytinyrenderer",
        "description": "pytinyrenderer",
        "isExtraImport": true,
        "detail": "pytinyrenderer",
        "documentation": {}
    },
    {
        "label": "TinySceneRenderer",
        "importPath": "pytinyrenderer",
        "description": "pytinyrenderer",
        "isExtraImport": true,
        "detail": "pytinyrenderer",
        "documentation": {}
    },
    {
        "label": "parse_brax_cfg",
        "importPath": "sf_examples.brax.train_brax",
        "description": "sf_examples.brax.train_brax",
        "isExtraImport": true,
        "detail": "sf_examples.brax.train_brax",
        "documentation": {}
    },
    {
        "label": "register_brax_custom_components",
        "importPath": "sf_examples.brax.train_brax",
        "description": "sf_examples.brax.train_brax",
        "isExtraImport": true,
        "detail": "sf_examples.brax.train_brax",
        "documentation": {}
    },
    {
        "label": "torch.utils.dlpack",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "torch.utils.dlpack",
        "description": "torch.utils.dlpack",
        "detail": "torch.utils.dlpack",
        "documentation": {}
    },
    {
        "label": "DMLAB30_LEVELS",
        "importPath": "sf_examples.dmlab.dmlab30",
        "description": "sf_examples.dmlab.dmlab30",
        "isExtraImport": true,
        "detail": "sf_examples.dmlab.dmlab30",
        "documentation": {}
    },
    {
        "label": "DMLAB30_LEVELS_THAT_USE_LEVEL_CACHE",
        "importPath": "sf_examples.dmlab.dmlab30",
        "description": "sf_examples.dmlab.dmlab30",
        "isExtraImport": true,
        "detail": "sf_examples.dmlab.dmlab30",
        "documentation": {}
    },
    {
        "label": "HUMAN_SCORES",
        "importPath": "sf_examples.dmlab.dmlab30",
        "description": "sf_examples.dmlab.dmlab30",
        "isExtraImport": true,
        "detail": "sf_examples.dmlab.dmlab30",
        "documentation": {}
    },
    {
        "label": "LEVEL_MAPPING",
        "importPath": "sf_examples.dmlab.dmlab30",
        "description": "sf_examples.dmlab.dmlab30",
        "isExtraImport": true,
        "detail": "sf_examples.dmlab.dmlab30",
        "documentation": {}
    },
    {
        "label": "RANDOM_SCORES",
        "importPath": "sf_examples.dmlab.dmlab30",
        "description": "sf_examples.dmlab.dmlab30",
        "isExtraImport": true,
        "detail": "sf_examples.dmlab.dmlab30",
        "documentation": {}
    },
    {
        "label": "dmlab30_level_name_to_level",
        "importPath": "sf_examples.dmlab.dmlab30",
        "description": "sf_examples.dmlab.dmlab30",
        "isExtraImport": true,
        "detail": "sf_examples.dmlab.dmlab30",
        "documentation": {}
    },
    {
        "label": "DMLAB_INSTRUCTIONS",
        "importPath": "sf_examples.dmlab.dmlab30",
        "description": "sf_examples.dmlab.dmlab30",
        "isExtraImport": true,
        "detail": "sf_examples.dmlab.dmlab30",
        "documentation": {}
    },
    {
        "label": "DMLAB_MAX_INSTRUCTION_LEN",
        "importPath": "sf_examples.dmlab.dmlab30",
        "description": "sf_examples.dmlab.dmlab30",
        "isExtraImport": true,
        "detail": "sf_examples.dmlab.dmlab30",
        "documentation": {}
    },
    {
        "label": "DMLAB_VOCABULARY_SIZE",
        "importPath": "sf_examples.dmlab.dmlab30",
        "description": "sf_examples.dmlab.dmlab30",
        "isExtraImport": true,
        "detail": "sf_examples.dmlab.dmlab30",
        "documentation": {}
    },
    {
        "label": "DMLAB_INSTRUCTIONS",
        "importPath": "sf_examples.dmlab.dmlab30",
        "description": "sf_examples.dmlab.dmlab30",
        "isExtraImport": true,
        "detail": "sf_examples.dmlab.dmlab30",
        "documentation": {}
    },
    {
        "label": "DMLAB_VOCABULARY_SIZE",
        "importPath": "sf_examples.dmlab.dmlab30",
        "description": "sf_examples.dmlab.dmlab30",
        "isExtraImport": true,
        "detail": "sf_examples.dmlab.dmlab30",
        "documentation": {}
    },
    {
        "label": "DmlabGymEnv",
        "importPath": "sf_examples.dmlab.dmlab_gym",
        "description": "sf_examples.dmlab.dmlab_gym",
        "isExtraImport": true,
        "detail": "sf_examples.dmlab.dmlab_gym",
        "documentation": {}
    },
    {
        "label": "dmlab_level_to_level_name",
        "importPath": "sf_examples.dmlab.dmlab_gym",
        "description": "sf_examples.dmlab.dmlab_gym",
        "isExtraImport": true,
        "detail": "sf_examples.dmlab.dmlab_gym",
        "documentation": {}
    },
    {
        "label": "DmlabLevelCache",
        "importPath": "sf_examples.dmlab.dmlab_level_cache",
        "description": "sf_examples.dmlab.dmlab_level_cache",
        "isExtraImport": true,
        "detail": "sf_examples.dmlab.dmlab_level_cache",
        "documentation": {}
    },
    {
        "label": "DmlabLevelCaches",
        "importPath": "sf_examples.dmlab.dmlab_level_cache",
        "description": "sf_examples.dmlab.dmlab_level_cache",
        "isExtraImport": true,
        "detail": "sf_examples.dmlab.dmlab_level_cache",
        "documentation": {}
    },
    {
        "label": "DmlabLevelCache",
        "importPath": "sf_examples.dmlab.dmlab_level_cache",
        "description": "sf_examples.dmlab.dmlab_level_cache",
        "isExtraImport": true,
        "detail": "sf_examples.dmlab.dmlab_level_cache",
        "documentation": {}
    },
    {
        "label": "DmlabLevelCaches",
        "importPath": "sf_examples.dmlab.dmlab_level_cache",
        "description": "sf_examples.dmlab.dmlab_level_cache",
        "isExtraImport": true,
        "detail": "sf_examples.dmlab.dmlab_level_cache",
        "documentation": {}
    },
    {
        "label": "make_dmlab_caches",
        "importPath": "sf_examples.dmlab.dmlab_level_cache",
        "description": "sf_examples.dmlab.dmlab_level_cache",
        "isExtraImport": true,
        "detail": "sf_examples.dmlab.dmlab_level_cache",
        "documentation": {}
    },
    {
        "label": "RAW_SCORE_SUMMARY_KEY_SUFFIX",
        "importPath": "sf_examples.dmlab.wrappers.reward_shaping",
        "description": "sf_examples.dmlab.wrappers.reward_shaping",
        "isExtraImport": true,
        "detail": "sf_examples.dmlab.wrappers.reward_shaping",
        "documentation": {}
    },
    {
        "label": "DmlabRewardShapingWrapper",
        "importPath": "sf_examples.dmlab.wrappers.reward_shaping",
        "description": "sf_examples.dmlab.wrappers.reward_shaping",
        "isExtraImport": true,
        "detail": "sf_examples.dmlab.wrappers.reward_shaping",
        "documentation": {}
    },
    {
        "label": "deepmind_lab",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "deepmind_lab",
        "description": "deepmind_lab",
        "detail": "deepmind_lab",
        "documentation": {}
    },
    {
        "label": "string_to_hash_bucket",
        "importPath": "sf_examples.dmlab.dmlab_utils",
        "description": "sf_examples.dmlab.dmlab_utils",
        "isExtraImport": true,
        "detail": "sf_examples.dmlab.dmlab_utils",
        "documentation": {}
    },
    {
        "label": "dmlab_available",
        "importPath": "sf_examples.dmlab.dmlab_utils",
        "description": "sf_examples.dmlab.dmlab_utils",
        "isExtraImport": true,
        "detail": "sf_examples.dmlab.dmlab_utils",
        "documentation": {}
    },
    {
        "label": "string_to_hash_bucket",
        "importPath": "sf_examples.dmlab.dmlab_utils",
        "description": "sf_examples.dmlab.dmlab_utils",
        "isExtraImport": true,
        "detail": "sf_examples.dmlab.dmlab_utils",
        "documentation": {}
    },
    {
        "label": "ctypes",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "ctypes",
        "description": "ctypes",
        "detail": "ctypes",
        "documentation": {}
    },
    {
        "label": "parse_dmlab_args",
        "importPath": "sf_examples.dmlab.train_dmlab",
        "description": "sf_examples.dmlab.train_dmlab",
        "isExtraImport": true,
        "detail": "sf_examples.dmlab.train_dmlab",
        "documentation": {}
    },
    {
        "label": "register_dmlab_components",
        "importPath": "sf_examples.dmlab.train_dmlab",
        "description": "sf_examples.dmlab.train_dmlab",
        "isExtraImport": true,
        "detail": "sf_examples.dmlab.train_dmlab",
        "documentation": {}
    },
    {
        "label": "DMLAB_ENVS",
        "importPath": "sf_examples.dmlab.dmlab_env",
        "description": "sf_examples.dmlab.dmlab_env",
        "isExtraImport": true,
        "detail": "sf_examples.dmlab.dmlab_env",
        "documentation": {}
    },
    {
        "label": "dmlab_extra_episodic_stats_processing",
        "importPath": "sf_examples.dmlab.dmlab_env",
        "description": "sf_examples.dmlab.dmlab_env",
        "isExtraImport": true,
        "detail": "sf_examples.dmlab.dmlab_env",
        "documentation": {}
    },
    {
        "label": "dmlab_extra_summaries",
        "importPath": "sf_examples.dmlab.dmlab_env",
        "description": "sf_examples.dmlab.dmlab_env",
        "isExtraImport": true,
        "detail": "sf_examples.dmlab.dmlab_env",
        "documentation": {}
    },
    {
        "label": "list_all_levels_for_experiment",
        "importPath": "sf_examples.dmlab.dmlab_env",
        "description": "sf_examples.dmlab.dmlab_env",
        "isExtraImport": true,
        "detail": "sf_examples.dmlab.dmlab_env",
        "documentation": {}
    },
    {
        "label": "make_dmlab_env",
        "importPath": "sf_examples.dmlab.dmlab_env",
        "description": "sf_examples.dmlab.dmlab_env",
        "isExtraImport": true,
        "detail": "sf_examples.dmlab.dmlab_env",
        "documentation": {}
    },
    {
        "label": "make_dmlab_encoder",
        "importPath": "sf_examples.dmlab.dmlab_model",
        "description": "sf_examples.dmlab.dmlab_model",
        "isExtraImport": true,
        "detail": "sf_examples.dmlab.dmlab_model",
        "documentation": {}
    },
    {
        "label": "add_dmlab_env_args",
        "importPath": "sf_examples.dmlab.dmlab_params",
        "description": "sf_examples.dmlab.dmlab_params",
        "isExtraImport": true,
        "detail": "sf_examples.dmlab.dmlab_params",
        "documentation": {}
    },
    {
        "label": "dmlab_override_defaults",
        "importPath": "sf_examples.dmlab.dmlab_params",
        "description": "sf_examples.dmlab.dmlab_params",
        "isExtraImport": true,
        "detail": "sf_examples.dmlab.dmlab_params",
        "documentation": {}
    },
    {
        "label": "BatchedRecordEpisodeStatistics",
        "importPath": "sf_examples.envpool.envpool_wrappers",
        "description": "sf_examples.envpool.envpool_wrappers",
        "isExtraImport": true,
        "detail": "sf_examples.envpool.envpool_wrappers",
        "documentation": {}
    },
    {
        "label": "EnvPoolResetFixWrapper",
        "importPath": "sf_examples.envpool.envpool_wrappers",
        "description": "sf_examples.envpool.envpool_wrappers",
        "isExtraImport": true,
        "detail": "sf_examples.envpool.envpool_wrappers",
        "documentation": {}
    },
    {
        "label": "EnvPoolResetFixWrapper",
        "importPath": "sf_examples.envpool.envpool_wrappers",
        "description": "sf_examples.envpool.envpool_wrappers",
        "isExtraImport": true,
        "detail": "sf_examples.envpool.envpool_wrappers",
        "documentation": {}
    },
    {
        "label": "add_atari_env_args",
        "importPath": "sf_examples.envpool.atari.envpool_atari_params",
        "description": "sf_examples.envpool.atari.envpool_atari_params",
        "isExtraImport": true,
        "detail": "sf_examples.envpool.atari.envpool_atari_params",
        "documentation": {}
    },
    {
        "label": "atari_override_defaults",
        "importPath": "sf_examples.envpool.atari.envpool_atari_params",
        "description": "sf_examples.envpool.atari.envpool_atari_params",
        "isExtraImport": true,
        "detail": "sf_examples.envpool.atari.envpool_atari_params",
        "documentation": {}
    },
    {
        "label": "ENVPOOL_ATARI_ENVS",
        "importPath": "sf_examples.envpool.atari.envpool_atari_utils",
        "description": "sf_examples.envpool.atari.envpool_atari_utils",
        "isExtraImport": true,
        "detail": "sf_examples.envpool.atari.envpool_atari_utils",
        "documentation": {}
    },
    {
        "label": "make_atari_env",
        "importPath": "sf_examples.envpool.atari.envpool_atari_utils",
        "description": "sf_examples.envpool.atari.envpool_atari_utils",
        "isExtraImport": true,
        "detail": "sf_examples.envpool.atari.envpool_atari_utils",
        "documentation": {}
    },
    {
        "label": "parse_mujoco_cfg",
        "importPath": "sf_examples.mujoco.train_mujoco",
        "description": "sf_examples.mujoco.train_mujoco",
        "isExtraImport": true,
        "detail": "sf_examples.mujoco.train_mujoco",
        "documentation": {}
    },
    {
        "label": "register_mujoco_components",
        "importPath": "sf_examples.mujoco.train_mujoco",
        "description": "sf_examples.mujoco.train_mujoco",
        "isExtraImport": true,
        "detail": "sf_examples.mujoco.train_mujoco",
        "documentation": {}
    },
    {
        "label": "parse_mujoco_cfg",
        "importPath": "sf_examples.mujoco.train_mujoco",
        "description": "sf_examples.mujoco.train_mujoco",
        "isExtraImport": true,
        "detail": "sf_examples.mujoco.train_mujoco",
        "documentation": {}
    },
    {
        "label": "register_mujoco_components",
        "importPath": "sf_examples.mujoco.train_mujoco",
        "description": "sf_examples.mujoco.train_mujoco",
        "isExtraImport": true,
        "detail": "sf_examples.mujoco.train_mujoco",
        "documentation": {}
    },
    {
        "label": "register_mujoco_components",
        "importPath": "sf_examples.mujoco.train_mujoco",
        "description": "sf_examples.mujoco.train_mujoco",
        "isExtraImport": true,
        "detail": "sf_examples.mujoco.train_mujoco",
        "documentation": {}
    },
    {
        "label": "parse_mujoco_cfg",
        "importPath": "sf_examples.mujoco.train_mujoco",
        "description": "sf_examples.mujoco.train_mujoco",
        "isExtraImport": true,
        "detail": "sf_examples.mujoco.train_mujoco",
        "documentation": {}
    },
    {
        "label": "register_mujoco_components",
        "importPath": "sf_examples.mujoco.train_mujoco",
        "description": "sf_examples.mujoco.train_mujoco",
        "isExtraImport": true,
        "detail": "sf_examples.mujoco.train_mujoco",
        "documentation": {}
    },
    {
        "label": "parse_mujoco_cfg",
        "importPath": "sf_examples.mujoco.train_mujoco",
        "description": "sf_examples.mujoco.train_mujoco",
        "isExtraImport": true,
        "detail": "sf_examples.mujoco.train_mujoco",
        "documentation": {}
    },
    {
        "label": "register_mujoco_components",
        "importPath": "sf_examples.mujoco.train_mujoco",
        "description": "sf_examples.mujoco.train_mujoco",
        "isExtraImport": true,
        "detail": "sf_examples.mujoco.train_mujoco",
        "documentation": {}
    },
    {
        "label": "parse_mujoco_cfg",
        "importPath": "sf_examples.mujoco.train_mujoco",
        "description": "sf_examples.mujoco.train_mujoco",
        "isExtraImport": true,
        "detail": "sf_examples.mujoco.train_mujoco",
        "documentation": {}
    },
    {
        "label": "register_mujoco_components",
        "importPath": "sf_examples.mujoco.train_mujoco",
        "description": "sf_examples.mujoco.train_mujoco",
        "isExtraImport": true,
        "detail": "sf_examples.mujoco.train_mujoco",
        "documentation": {}
    },
    {
        "label": "add_envpool_common_args",
        "importPath": "sf_examples.envpool.envpool_utils",
        "description": "sf_examples.envpool.envpool_utils",
        "isExtraImport": true,
        "detail": "sf_examples.envpool.envpool_utils",
        "documentation": {}
    },
    {
        "label": "envpool_available",
        "importPath": "sf_examples.envpool.envpool_utils",
        "description": "sf_examples.envpool.envpool_utils",
        "isExtraImport": true,
        "detail": "sf_examples.envpool.envpool_utils",
        "documentation": {}
    },
    {
        "label": "envpool_available",
        "importPath": "sf_examples.envpool.envpool_utils",
        "description": "sf_examples.envpool.envpool_utils",
        "isExtraImport": true,
        "detail": "sf_examples.envpool.envpool_utils",
        "documentation": {}
    },
    {
        "label": "MUJOCO_ENVS",
        "importPath": "sf_examples.mujoco.mujoco_utils",
        "description": "sf_examples.mujoco.mujoco_utils",
        "isExtraImport": true,
        "detail": "sf_examples.mujoco.mujoco_utils",
        "documentation": {}
    },
    {
        "label": "MUJOCO_ENVS",
        "importPath": "sf_examples.mujoco.mujoco_utils",
        "description": "sf_examples.mujoco.mujoco_utils",
        "isExtraImport": true,
        "detail": "sf_examples.mujoco.mujoco_utils",
        "documentation": {}
    },
    {
        "label": "MUJOCO_ENVS",
        "importPath": "sf_examples.mujoco.mujoco_utils",
        "description": "sf_examples.mujoco.mujoco_utils",
        "isExtraImport": true,
        "detail": "sf_examples.mujoco.mujoco_utils",
        "documentation": {}
    },
    {
        "label": "make_mujoco_env",
        "importPath": "sf_examples.mujoco.mujoco_utils",
        "description": "sf_examples.mujoco.mujoco_utils",
        "isExtraImport": true,
        "detail": "sf_examples.mujoco.mujoco_utils",
        "documentation": {}
    },
    {
        "label": "mujoco_available",
        "importPath": "sf_examples.mujoco.mujoco_utils",
        "description": "sf_examples.mujoco.mujoco_utils",
        "isExtraImport": true,
        "detail": "sf_examples.mujoco.mujoco_utils",
        "documentation": {}
    },
    {
        "label": "mujoco_available",
        "importPath": "sf_examples.mujoco.mujoco_utils",
        "description": "sf_examples.mujoco.mujoco_utils",
        "isExtraImport": true,
        "detail": "sf_examples.mujoco.mujoco_utils",
        "documentation": {}
    },
    {
        "label": "mujoco_available",
        "importPath": "sf_examples.mujoco.mujoco_utils",
        "description": "sf_examples.mujoco.mujoco_utils",
        "isExtraImport": true,
        "detail": "sf_examples.mujoco.mujoco_utils",
        "documentation": {}
    },
    {
        "label": "add_mujoco_envpool_env_args",
        "importPath": "sf_examples.envpool.mujoco.envpool_mujoco_params",
        "description": "sf_examples.envpool.mujoco.envpool_mujoco_params",
        "isExtraImport": true,
        "detail": "sf_examples.envpool.mujoco.envpool_mujoco_params",
        "documentation": {}
    },
    {
        "label": "mujoco_envpool_override_defaults",
        "importPath": "sf_examples.envpool.mujoco.envpool_mujoco_params",
        "description": "sf_examples.envpool.mujoco.envpool_mujoco_params",
        "isExtraImport": true,
        "detail": "sf_examples.envpool.mujoco.envpool_mujoco_params",
        "documentation": {}
    },
    {
        "label": "make_mujoco_env",
        "importPath": "sf_examples.envpool.mujoco.envpool_mujoco_utils",
        "description": "sf_examples.envpool.mujoco.envpool_mujoco_utils",
        "isExtraImport": true,
        "detail": "sf_examples.envpool.mujoco.envpool_mujoco_utils",
        "documentation": {}
    },
    {
        "label": "base_cli",
        "importPath": "sf_examples.isaacgym_examples.experiments.isaacgym_runs",
        "description": "sf_examples.isaacgym_examples.experiments.isaacgym_runs",
        "isExtraImport": true,
        "detail": "sf_examples.isaacgym_examples.experiments.isaacgym_runs",
        "documentation": {}
    },
    {
        "label": "vstr",
        "importPath": "sf_examples.isaacgym_examples.experiments.isaacgym_runs",
        "description": "sf_examples.isaacgym_examples.experiments.isaacgym_runs",
        "isExtraImport": true,
        "detail": "sf_examples.isaacgym_examples.experiments.isaacgym_runs",
        "documentation": {}
    },
    {
        "label": "base_cli",
        "importPath": "sf_examples.isaacgym_examples.experiments.isaacgym_runs",
        "description": "sf_examples.isaacgym_examples.experiments.isaacgym_runs",
        "isExtraImport": true,
        "detail": "sf_examples.isaacgym_examples.experiments.isaacgym_runs",
        "documentation": {}
    },
    {
        "label": "vstr",
        "importPath": "sf_examples.isaacgym_examples.experiments.isaacgym_runs",
        "description": "sf_examples.isaacgym_examples.experiments.isaacgym_runs",
        "isExtraImport": true,
        "detail": "sf_examples.isaacgym_examples.experiments.isaacgym_runs",
        "documentation": {}
    },
    {
        "label": "base_cli",
        "importPath": "sf_examples.isaacgym_examples.experiments.isaacgym_runs",
        "description": "sf_examples.isaacgym_examples.experiments.isaacgym_runs",
        "isExtraImport": true,
        "detail": "sf_examples.isaacgym_examples.experiments.isaacgym_runs",
        "documentation": {}
    },
    {
        "label": "vstr",
        "importPath": "sf_examples.isaacgym_examples.experiments.isaacgym_runs",
        "description": "sf_examples.isaacgym_examples.experiments.isaacgym_runs",
        "isExtraImport": true,
        "detail": "sf_examples.isaacgym_examples.experiments.isaacgym_runs",
        "documentation": {}
    },
    {
        "label": "base_cli",
        "importPath": "sf_examples.isaacgym_examples.experiments.isaacgym_runs",
        "description": "sf_examples.isaacgym_examples.experiments.isaacgym_runs",
        "isExtraImport": true,
        "detail": "sf_examples.isaacgym_examples.experiments.isaacgym_runs",
        "documentation": {}
    },
    {
        "label": "vstr",
        "importPath": "sf_examples.isaacgym_examples.experiments.isaacgym_runs",
        "description": "sf_examples.isaacgym_examples.experiments.isaacgym_runs",
        "isExtraImport": true,
        "detail": "sf_examples.isaacgym_examples.experiments.isaacgym_runs",
        "documentation": {}
    },
    {
        "label": "isaacgym",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "isaacgym",
        "description": "isaacgym",
        "detail": "isaacgym",
        "documentation": {}
    },
    {
        "label": "parse_isaacgym_cfg",
        "importPath": "sf_examples.isaacgym_examples.train_isaacgym",
        "description": "sf_examples.isaacgym_examples.train_isaacgym",
        "isExtraImport": true,
        "detail": "sf_examples.isaacgym_examples.train_isaacgym",
        "documentation": {}
    },
    {
        "label": "register_isaacgym_custom_components",
        "importPath": "sf_examples.isaacgym_examples.train_isaacgym",
        "description": "sf_examples.isaacgym_examples.train_isaacgym",
        "isExtraImport": true,
        "detail": "sf_examples.isaacgym_examples.train_isaacgym",
        "documentation": {}
    },
    {
        "label": "isaacgym_task_map",
        "importPath": "isaacgymenvs.tasks",
        "description": "isaacgymenvs.tasks",
        "isExtraImport": true,
        "detail": "isaacgymenvs.tasks",
        "documentation": {}
    },
    {
        "label": "omegaconf_to_dict",
        "importPath": "isaacgymenvs.utils.reformat",
        "description": "isaacgymenvs.utils.reformat",
        "isExtraImport": true,
        "detail": "isaacgymenvs.utils.reformat",
        "documentation": {}
    },
    {
        "label": "do_eval",
        "importPath": "sample_factory.eval",
        "description": "sample_factory.eval",
        "isExtraImport": true,
        "detail": "sample_factory.eval",
        "documentation": {}
    },
    {
        "label": "do_eval",
        "importPath": "sample_factory.eval",
        "description": "sample_factory.eval",
        "isExtraImport": true,
        "detail": "sample_factory.eval",
        "documentation": {}
    },
    {
        "label": "add_mujoco_env_args",
        "importPath": "sf_examples.mujoco.mujoco_params",
        "description": "sf_examples.mujoco.mujoco_params",
        "isExtraImport": true,
        "detail": "sf_examples.mujoco.mujoco_params",
        "documentation": {}
    },
    {
        "label": "mujoco_override_defaults",
        "importPath": "sf_examples.mujoco.mujoco_params",
        "description": "sf_examples.mujoco.mujoco_params",
        "isExtraImport": true,
        "detail": "sf_examples.mujoco.mujoco_params",
        "documentation": {}
    },
    {
        "label": "add_mujoco_env_args",
        "importPath": "sf_examples.mujoco.mujoco_params",
        "description": "sf_examples.mujoco.mujoco_params",
        "isExtraImport": true,
        "detail": "sf_examples.mujoco.mujoco_params",
        "documentation": {}
    },
    {
        "label": "mujoco_override_defaults",
        "importPath": "sf_examples.mujoco.mujoco_params",
        "description": "sf_examples.mujoco.mujoco_params",
        "isExtraImport": true,
        "detail": "sf_examples.mujoco.mujoco_params",
        "documentation": {}
    },
    {
        "label": "ThreadPoolExecutor",
        "importPath": "concurrent.futures",
        "description": "concurrent.futures",
        "isExtraImport": true,
        "detail": "concurrent.futures",
        "documentation": {}
    },
    {
        "label": "nethack_render_utils",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "nethack_render_utils",
        "description": "nethack_render_utils",
        "detail": "nethack_render_utils",
        "documentation": {}
    },
    {
        "label": "wrappers",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "wrappers",
        "description": "wrappers",
        "detail": "wrappers",
        "documentation": {}
    },
    {
        "label": "parse_nethack_args",
        "importPath": "sf_examples.nethack.train_nethack",
        "description": "sf_examples.nethack.train_nethack",
        "isExtraImport": true,
        "detail": "sf_examples.nethack.train_nethack",
        "documentation": {}
    },
    {
        "label": "register_nethack_components",
        "importPath": "sf_examples.nethack.train_nethack",
        "description": "sf_examples.nethack.train_nethack",
        "isExtraImport": true,
        "detail": "sf_examples.nethack.train_nethack",
        "documentation": {}
    },
    {
        "label": "register_nethack_components",
        "importPath": "sf_examples.nethack.train_nethack",
        "description": "sf_examples.nethack.train_nethack",
        "isExtraImport": true,
        "detail": "sf_examples.nethack.train_nethack",
        "documentation": {}
    },
    {
        "label": "register_nethack_components",
        "importPath": "sf_examples.nethack.train_nethack",
        "description": "sf_examples.nethack.train_nethack",
        "isExtraImport": true,
        "detail": "sf_examples.nethack.train_nethack",
        "documentation": {}
    },
    {
        "label": "EatingScore",
        "importPath": "sf_examples.nethack.utils.task_rewards",
        "description": "sf_examples.nethack.utils.task_rewards",
        "isExtraImport": true,
        "detail": "sf_examples.nethack.utils.task_rewards",
        "documentation": {}
    },
    {
        "label": "GoldScore",
        "importPath": "sf_examples.nethack.utils.task_rewards",
        "description": "sf_examples.nethack.utils.task_rewards",
        "isExtraImport": true,
        "detail": "sf_examples.nethack.utils.task_rewards",
        "documentation": {}
    },
    {
        "label": "ScoutScore",
        "importPath": "sf_examples.nethack.utils.task_rewards",
        "description": "sf_examples.nethack.utils.task_rewards",
        "isExtraImport": true,
        "detail": "sf_examples.nethack.utils.task_rewards",
        "documentation": {}
    },
    {
        "label": "SokobanfillpitScore",
        "importPath": "sf_examples.nethack.utils.task_rewards",
        "description": "sf_examples.nethack.utils.task_rewards",
        "isExtraImport": true,
        "detail": "sf_examples.nethack.utils.task_rewards",
        "documentation": {}
    },
    {
        "label": "SokobansolvedlevelsScore",
        "importPath": "sf_examples.nethack.utils.task_rewards",
        "description": "sf_examples.nethack.utils.task_rewards",
        "isExtraImport": true,
        "detail": "sf_examples.nethack.utils.task_rewards",
        "documentation": {}
    },
    {
        "label": "StaircasePetScore",
        "importPath": "sf_examples.nethack.utils.task_rewards",
        "description": "sf_examples.nethack.utils.task_rewards",
        "isExtraImport": true,
        "detail": "sf_examples.nethack.utils.task_rewards",
        "documentation": {}
    },
    {
        "label": "StaircaseScore",
        "importPath": "sf_examples.nethack.utils.task_rewards",
        "description": "sf_examples.nethack.utils.task_rewards",
        "isExtraImport": true,
        "detail": "sf_examples.nethack.utils.task_rewards",
        "documentation": {}
    },
    {
        "label": "add_extra_params_general",
        "importPath": "sf_examples.nethack.nethack_params",
        "description": "sf_examples.nethack.nethack_params",
        "isExtraImport": true,
        "detail": "sf_examples.nethack.nethack_params",
        "documentation": {}
    },
    {
        "label": "add_extra_params_model",
        "importPath": "sf_examples.nethack.nethack_params",
        "description": "sf_examples.nethack.nethack_params",
        "isExtraImport": true,
        "detail": "sf_examples.nethack.nethack_params",
        "documentation": {}
    },
    {
        "label": "add_extra_params_nethack_env",
        "importPath": "sf_examples.nethack.nethack_params",
        "description": "sf_examples.nethack.nethack_params",
        "isExtraImport": true,
        "detail": "sf_examples.nethack.nethack_params",
        "documentation": {}
    },
    {
        "label": "nethack_override_defaults",
        "importPath": "sf_examples.nethack.nethack_params",
        "description": "sf_examples.nethack.nethack_params",
        "isExtraImport": true,
        "detail": "sf_examples.nethack.nethack_params",
        "documentation": {}
    },
    {
        "label": "add_extra_params_general",
        "importPath": "sf_examples.nethack.nethack_params",
        "description": "sf_examples.nethack.nethack_params",
        "isExtraImport": true,
        "detail": "sf_examples.nethack.nethack_params",
        "documentation": {}
    },
    {
        "label": "add_extra_params_model",
        "importPath": "sf_examples.nethack.nethack_params",
        "description": "sf_examples.nethack.nethack_params",
        "isExtraImport": true,
        "detail": "sf_examples.nethack.nethack_params",
        "documentation": {}
    },
    {
        "label": "add_extra_params_nethack_env",
        "importPath": "sf_examples.nethack.nethack_params",
        "description": "sf_examples.nethack.nethack_params",
        "isExtraImport": true,
        "detail": "sf_examples.nethack.nethack_params",
        "documentation": {}
    },
    {
        "label": "nethack_override_defaults",
        "importPath": "sf_examples.nethack.nethack_params",
        "description": "sf_examples.nethack.nethack_params",
        "isExtraImport": true,
        "detail": "sf_examples.nethack.nethack_params",
        "documentation": {}
    },
    {
        "label": "add_extra_params_general",
        "importPath": "sf_examples.nethack.nethack_params",
        "description": "sf_examples.nethack.nethack_params",
        "isExtraImport": true,
        "detail": "sf_examples.nethack.nethack_params",
        "documentation": {}
    },
    {
        "label": "add_extra_params_model",
        "importPath": "sf_examples.nethack.nethack_params",
        "description": "sf_examples.nethack.nethack_params",
        "isExtraImport": true,
        "detail": "sf_examples.nethack.nethack_params",
        "documentation": {}
    },
    {
        "label": "add_extra_params_nethack_env",
        "importPath": "sf_examples.nethack.nethack_params",
        "description": "sf_examples.nethack.nethack_params",
        "isExtraImport": true,
        "detail": "sf_examples.nethack.nethack_params",
        "documentation": {}
    },
    {
        "label": "nethack_override_defaults",
        "importPath": "sf_examples.nethack.nethack_params",
        "description": "sf_examples.nethack.nethack_params",
        "isExtraImport": true,
        "detail": "sf_examples.nethack.nethack_params",
        "documentation": {}
    },
    {
        "label": "NetHackChallenge",
        "importPath": "nle.env.tasks",
        "description": "nle.env.tasks",
        "isExtraImport": true,
        "detail": "nle.env.tasks",
        "documentation": {}
    },
    {
        "label": "NetHackEat",
        "importPath": "nle.env.tasks",
        "description": "nle.env.tasks",
        "isExtraImport": true,
        "detail": "nle.env.tasks",
        "documentation": {}
    },
    {
        "label": "NetHackGold",
        "importPath": "nle.env.tasks",
        "description": "nle.env.tasks",
        "isExtraImport": true,
        "detail": "nle.env.tasks",
        "documentation": {}
    },
    {
        "label": "NetHackOracle",
        "importPath": "nle.env.tasks",
        "description": "nle.env.tasks",
        "isExtraImport": true,
        "detail": "nle.env.tasks",
        "documentation": {}
    },
    {
        "label": "NetHackScore",
        "importPath": "nle.env.tasks",
        "description": "nle.env.tasks",
        "isExtraImport": true,
        "detail": "nle.env.tasks",
        "documentation": {}
    },
    {
        "label": "NetHackScout",
        "importPath": "nle.env.tasks",
        "description": "nle.env.tasks",
        "isExtraImport": true,
        "detail": "nle.env.tasks",
        "documentation": {}
    },
    {
        "label": "NetHackStaircase",
        "importPath": "nle.env.tasks",
        "description": "nle.env.tasks",
        "isExtraImport": true,
        "detail": "nle.env.tasks",
        "documentation": {}
    },
    {
        "label": "NetHackStaircasePet",
        "importPath": "nle.env.tasks",
        "description": "nle.env.tasks",
        "isExtraImport": true,
        "detail": "nle.env.tasks",
        "documentation": {}
    },
    {
        "label": "BlstatsInfoWrapper",
        "importPath": "sf_examples.nethack.utils.wrappers",
        "description": "sf_examples.nethack.utils.wrappers",
        "isExtraImport": true,
        "detail": "sf_examples.nethack.utils.wrappers",
        "documentation": {}
    },
    {
        "label": "PrevActionsWrapper",
        "importPath": "sf_examples.nethack.utils.wrappers",
        "description": "sf_examples.nethack.utils.wrappers",
        "isExtraImport": true,
        "detail": "sf_examples.nethack.utils.wrappers",
        "documentation": {}
    },
    {
        "label": "RenderCharImagesWithNumpyWrapperV2",
        "importPath": "sf_examples.nethack.utils.wrappers",
        "description": "sf_examples.nethack.utils.wrappers",
        "isExtraImport": true,
        "detail": "sf_examples.nethack.utils.wrappers",
        "documentation": {}
    },
    {
        "label": "SeedActionSpaceWrapper",
        "importPath": "sf_examples.nethack.utils.wrappers",
        "description": "sf_examples.nethack.utils.wrappers",
        "isExtraImport": true,
        "detail": "sf_examples.nethack.utils.wrappers",
        "documentation": {}
    },
    {
        "label": "TaskRewardsInfoWrapper",
        "importPath": "sf_examples.nethack.utils.wrappers",
        "description": "sf_examples.nethack.utils.wrappers",
        "isExtraImport": true,
        "detail": "sf_examples.nethack.utils.wrappers",
        "documentation": {}
    },
    {
        "label": "MODELS_LOOKUP",
        "importPath": "sf_examples.nethack.models",
        "description": "sf_examples.nethack.models",
        "isExtraImport": true,
        "detail": "sf_examples.nethack.models",
        "documentation": {}
    },
    {
        "label": "NETHACK_ENVS",
        "importPath": "sf_examples.nethack.nethack_env",
        "description": "sf_examples.nethack.nethack_env",
        "isExtraImport": true,
        "detail": "sf_examples.nethack.nethack_env",
        "documentation": {}
    },
    {
        "label": "make_nethack_env",
        "importPath": "sf_examples.nethack.nethack_env",
        "description": "sf_examples.nethack.nethack_env",
        "isExtraImport": true,
        "detail": "sf_examples.nethack.nethack_env",
        "documentation": {}
    },
    {
        "label": "SyncSamplingAPI",
        "importPath": "sample_factory.algo.sampling.sync_sampling_api",
        "description": "sample_factory.algo.sampling.sync_sampling_api",
        "isExtraImport": true,
        "detail": "sample_factory.algo.sampling.sync_sampling_api",
        "documentation": {}
    },
    {
        "label": "SyncSamplingAPI",
        "importPath": "sample_factory.algo.sampling.sync_sampling_api",
        "description": "sample_factory.algo.sampling.sync_sampling_api",
        "isExtraImport": true,
        "detail": "sample_factory.algo.sampling.sync_sampling_api",
        "documentation": {}
    },
    {
        "label": "is_udp_port_available",
        "importPath": "sample_factory.utils.network",
        "description": "sample_factory.utils.network",
        "isExtraImport": true,
        "detail": "sample_factory.utils.network",
        "documentation": {}
    },
    {
        "label": "is_udp_port_available",
        "importPath": "sample_factory.utils.network",
        "description": "sample_factory.utils.network",
        "isExtraImport": true,
        "detail": "sample_factory.utils.network",
        "documentation": {}
    },
    {
        "label": "VizdoomEnv",
        "importPath": "sf_examples.vizdoom.doom.doom_gym",
        "description": "sf_examples.vizdoom.doom.doom_gym",
        "isExtraImport": true,
        "detail": "sf_examples.vizdoom.doom.doom_gym",
        "documentation": {}
    },
    {
        "label": "doom_lock_file",
        "importPath": "sf_examples.vizdoom.doom.doom_gym",
        "description": "sf_examples.vizdoom.doom.doom_gym",
        "isExtraImport": true,
        "detail": "sf_examples.vizdoom.doom.doom_gym",
        "documentation": {}
    },
    {
        "label": "VizdoomEnv",
        "importPath": "sf_examples.vizdoom.doom.doom_gym",
        "description": "sf_examples.vizdoom.doom.doom_gym",
        "isExtraImport": true,
        "detail": "sf_examples.vizdoom.doom.doom_gym",
        "documentation": {}
    },
    {
        "label": "VizdoomEnv",
        "importPath": "sf_examples.vizdoom.doom.doom_gym",
        "description": "sf_examples.vizdoom.doom.doom_gym",
        "isExtraImport": true,
        "detail": "sf_examples.vizdoom.doom.doom_gym",
        "documentation": {}
    },
    {
        "label": "faster_fifo",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "faster_fifo",
        "description": "faster_fifo",
        "detail": "faster_fifo",
        "documentation": {}
    },
    {
        "label": "filelock",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "filelock",
        "description": "filelock",
        "detail": "filelock",
        "documentation": {}
    },
    {
        "label": "FileLock",
        "importPath": "filelock",
        "description": "filelock",
        "isExtraImport": true,
        "detail": "filelock",
        "documentation": {}
    },
    {
        "label": "FileLock",
        "importPath": "filelock",
        "description": "filelock",
        "isExtraImport": true,
        "detail": "filelock",
        "documentation": {}
    },
    {
        "label": "Timeout",
        "importPath": "filelock",
        "description": "filelock",
        "isExtraImport": true,
        "detail": "filelock",
        "documentation": {}
    },
    {
        "label": "concat_grid",
        "importPath": "sf_examples.vizdoom.doom.doom_render",
        "description": "sf_examples.vizdoom.doom.doom_render",
        "isExtraImport": true,
        "detail": "sf_examples.vizdoom.doom.doom_render",
        "documentation": {}
    },
    {
        "label": "cvt_doom_obs",
        "importPath": "sf_examples.vizdoom.doom.doom_render",
        "description": "sf_examples.vizdoom.doom.doom_render",
        "isExtraImport": true,
        "detail": "sf_examples.vizdoom.doom.doom_render",
        "documentation": {}
    },
    {
        "label": "DEFAULT_UDP_PORT",
        "importPath": "sf_examples.vizdoom.doom.multiplayer.doom_multiagent",
        "description": "sf_examples.vizdoom.doom.multiplayer.doom_multiagent",
        "isExtraImport": true,
        "detail": "sf_examples.vizdoom.doom.multiplayer.doom_multiagent",
        "documentation": {}
    },
    {
        "label": "find_available_port",
        "importPath": "sf_examples.vizdoom.doom.multiplayer.doom_multiagent",
        "description": "sf_examples.vizdoom.doom.multiplayer.doom_multiagent",
        "isExtraImport": true,
        "detail": "sf_examples.vizdoom.doom.multiplayer.doom_multiagent",
        "documentation": {}
    },
    {
        "label": "NUM_WEAPONS",
        "importPath": "sf_examples.vizdoom.doom.wrappers.reward_shaping",
        "description": "sf_examples.vizdoom.doom.wrappers.reward_shaping",
        "isExtraImport": true,
        "detail": "sf_examples.vizdoom.doom.wrappers.reward_shaping",
        "documentation": {}
    },
    {
        "label": "REWARD_SHAPING_BATTLE",
        "importPath": "sf_examples.vizdoom.doom.wrappers.reward_shaping",
        "description": "sf_examples.vizdoom.doom.wrappers.reward_shaping",
        "isExtraImport": true,
        "detail": "sf_examples.vizdoom.doom.wrappers.reward_shaping",
        "documentation": {}
    },
    {
        "label": "REWARD_SHAPING_DEATHMATCH_V0",
        "importPath": "sf_examples.vizdoom.doom.wrappers.reward_shaping",
        "description": "sf_examples.vizdoom.doom.wrappers.reward_shaping",
        "isExtraImport": true,
        "detail": "sf_examples.vizdoom.doom.wrappers.reward_shaping",
        "documentation": {}
    },
    {
        "label": "REWARD_SHAPING_DEATHMATCH_V1",
        "importPath": "sf_examples.vizdoom.doom.wrappers.reward_shaping",
        "description": "sf_examples.vizdoom.doom.wrappers.reward_shaping",
        "isExtraImport": true,
        "detail": "sf_examples.vizdoom.doom.wrappers.reward_shaping",
        "documentation": {}
    },
    {
        "label": "DoomRewardShapingWrapper",
        "importPath": "sf_examples.vizdoom.doom.wrappers.reward_shaping",
        "description": "sf_examples.vizdoom.doom.wrappers.reward_shaping",
        "isExtraImport": true,
        "detail": "sf_examples.vizdoom.doom.wrappers.reward_shaping",
        "documentation": {}
    },
    {
        "label": "true_objective_frags",
        "importPath": "sf_examples.vizdoom.doom.wrappers.reward_shaping",
        "description": "sf_examples.vizdoom.doom.wrappers.reward_shaping",
        "isExtraImport": true,
        "detail": "sf_examples.vizdoom.doom.wrappers.reward_shaping",
        "documentation": {}
    },
    {
        "label": "true_objective_winning_the_game",
        "importPath": "sf_examples.vizdoom.doom.wrappers.reward_shaping",
        "description": "sf_examples.vizdoom.doom.wrappers.reward_shaping",
        "isExtraImport": true,
        "detail": "sf_examples.vizdoom.doom.wrappers.reward_shaping",
        "documentation": {}
    },
    {
        "label": "Discretized",
        "importPath": "sample_factory.algo.utils.spaces.discretized",
        "description": "sample_factory.algo.utils.spaces.discretized",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.spaces.discretized",
        "documentation": {}
    },
    {
        "label": "Discretized",
        "importPath": "sample_factory.algo.utils.spaces.discretized",
        "description": "sample_factory.algo.utils.spaces.discretized",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.spaces.discretized",
        "documentation": {}
    },
    {
        "label": "Discretized",
        "importPath": "sample_factory.algo.utils.spaces.discretized",
        "description": "sample_factory.algo.utils.spaces.discretized",
        "isExtraImport": true,
        "detail": "sample_factory.algo.utils.spaces.discretized",
        "documentation": {}
    },
    {
        "label": "seeding",
        "importPath": "gymnasium.utils",
        "description": "gymnasium.utils",
        "isExtraImport": true,
        "detail": "gymnasium.utils",
        "documentation": {}
    },
    {
        "label": "AutomapMode",
        "importPath": "vizdoom.vizdoom",
        "description": "vizdoom.vizdoom",
        "isExtraImport": true,
        "detail": "vizdoom.vizdoom",
        "documentation": {}
    },
    {
        "label": "DoomGame",
        "importPath": "vizdoom.vizdoom",
        "description": "vizdoom.vizdoom",
        "isExtraImport": true,
        "detail": "vizdoom.vizdoom",
        "documentation": {}
    },
    {
        "label": "Mode",
        "importPath": "vizdoom.vizdoom",
        "description": "vizdoom.vizdoom",
        "isExtraImport": true,
        "detail": "vizdoom.vizdoom",
        "documentation": {}
    },
    {
        "label": "ScreenResolution",
        "importPath": "vizdoom.vizdoom",
        "description": "vizdoom.vizdoom",
        "isExtraImport": true,
        "detail": "vizdoom.vizdoom",
        "documentation": {}
    },
    {
        "label": "doom_env_by_name",
        "importPath": "sf_examples.vizdoom.doom.doom_utils",
        "description": "sf_examples.vizdoom.doom.doom_utils",
        "isExtraImport": true,
        "detail": "sf_examples.vizdoom.doom.doom_utils",
        "documentation": {}
    },
    {
        "label": "make_doom_env",
        "importPath": "sf_examples.vizdoom.doom.doom_utils",
        "description": "sf_examples.vizdoom.doom.doom_utils",
        "isExtraImport": true,
        "detail": "sf_examples.vizdoom.doom.doom_utils",
        "documentation": {}
    },
    {
        "label": "make_doom_env_impl",
        "importPath": "sf_examples.vizdoom.doom.doom_utils",
        "description": "sf_examples.vizdoom.doom.doom_utils",
        "isExtraImport": true,
        "detail": "sf_examples.vizdoom.doom.doom_utils",
        "documentation": {}
    },
    {
        "label": "doom_env_by_name",
        "importPath": "sf_examples.vizdoom.doom.doom_utils",
        "description": "sf_examples.vizdoom.doom.doom_utils",
        "isExtraImport": true,
        "detail": "sf_examples.vizdoom.doom.doom_utils",
        "documentation": {}
    },
    {
        "label": "make_doom_env_impl",
        "importPath": "sf_examples.vizdoom.doom.doom_utils",
        "description": "sf_examples.vizdoom.doom.doom_utils",
        "isExtraImport": true,
        "detail": "sf_examples.vizdoom.doom.doom_utils",
        "documentation": {}
    },
    {
        "label": "make_doom_multiplayer_env",
        "importPath": "sf_examples.vizdoom.doom.doom_utils",
        "description": "sf_examples.vizdoom.doom.doom_utils",
        "isExtraImport": true,
        "detail": "sf_examples.vizdoom.doom.doom_utils",
        "documentation": {}
    },
    {
        "label": "DoomSpec",
        "importPath": "sf_examples.vizdoom.doom.doom_utils",
        "description": "sf_examples.vizdoom.doom.doom_utils",
        "isExtraImport": true,
        "detail": "sf_examples.vizdoom.doom.doom_utils",
        "documentation": {}
    },
    {
        "label": "make_doom_env_from_spec",
        "importPath": "sf_examples.vizdoom.doom.doom_utils",
        "description": "sf_examples.vizdoom.doom.doom_utils",
        "isExtraImport": true,
        "detail": "sf_examples.vizdoom.doom.doom_utils",
        "documentation": {}
    },
    {
        "label": "DOOM_ENVS",
        "importPath": "sf_examples.vizdoom.doom.doom_utils",
        "description": "sf_examples.vizdoom.doom.doom_utils",
        "isExtraImport": true,
        "detail": "sf_examples.vizdoom.doom.doom_utils",
        "documentation": {}
    },
    {
        "label": "make_doom_env_from_spec",
        "importPath": "sf_examples.vizdoom.doom.doom_utils",
        "description": "sf_examples.vizdoom.doom.doom_utils",
        "isExtraImport": true,
        "detail": "sf_examples.vizdoom.doom.doom_utils",
        "documentation": {}
    },
    {
        "label": "doom_action_space",
        "importPath": "sf_examples.vizdoom.doom.action_space",
        "description": "sf_examples.vizdoom.doom.action_space",
        "isExtraImport": true,
        "detail": "sf_examples.vizdoom.doom.action_space",
        "documentation": {}
    },
    {
        "label": "doom_action_space_basic",
        "importPath": "sf_examples.vizdoom.doom.action_space",
        "description": "sf_examples.vizdoom.doom.action_space",
        "isExtraImport": true,
        "detail": "sf_examples.vizdoom.doom.action_space",
        "documentation": {}
    },
    {
        "label": "doom_action_space_discretized_no_weap",
        "importPath": "sf_examples.vizdoom.doom.action_space",
        "description": "sf_examples.vizdoom.doom.action_space",
        "isExtraImport": true,
        "detail": "sf_examples.vizdoom.doom.action_space",
        "documentation": {}
    },
    {
        "label": "doom_action_space_extended",
        "importPath": "sf_examples.vizdoom.doom.action_space",
        "description": "sf_examples.vizdoom.doom.action_space",
        "isExtraImport": true,
        "detail": "sf_examples.vizdoom.doom.action_space",
        "documentation": {}
    },
    {
        "label": "doom_action_space_full_discretized",
        "importPath": "sf_examples.vizdoom.doom.action_space",
        "description": "sf_examples.vizdoom.doom.action_space",
        "isExtraImport": true,
        "detail": "sf_examples.vizdoom.doom.action_space",
        "documentation": {}
    },
    {
        "label": "doom_turn_and_attack_only",
        "importPath": "sf_examples.vizdoom.doom.action_space",
        "description": "sf_examples.vizdoom.doom.action_space",
        "isExtraImport": true,
        "detail": "sf_examples.vizdoom.doom.action_space",
        "documentation": {}
    },
    {
        "label": "doom_action_space_extended",
        "importPath": "sf_examples.vizdoom.doom.action_space",
        "description": "sf_examples.vizdoom.doom.action_space",
        "isExtraImport": true,
        "detail": "sf_examples.vizdoom.doom.action_space",
        "documentation": {}
    },
    {
        "label": "DoomAdditionalInput",
        "importPath": "sf_examples.vizdoom.doom.wrappers.additional_input",
        "description": "sf_examples.vizdoom.doom.wrappers.additional_input",
        "isExtraImport": true,
        "detail": "sf_examples.vizdoom.doom.wrappers.additional_input",
        "documentation": {}
    },
    {
        "label": "MultiplayerStatsWrapper",
        "importPath": "sf_examples.vizdoom.doom.wrappers.multiplayer_stats",
        "description": "sf_examples.vizdoom.doom.wrappers.multiplayer_stats",
        "isExtraImport": true,
        "detail": "sf_examples.vizdoom.doom.wrappers.multiplayer_stats",
        "documentation": {}
    },
    {
        "label": "SetResolutionWrapper",
        "importPath": "sf_examples.vizdoom.doom.wrappers.observation_space",
        "description": "sf_examples.vizdoom.doom.wrappers.observation_space",
        "isExtraImport": true,
        "detail": "sf_examples.vizdoom.doom.wrappers.observation_space",
        "documentation": {}
    },
    {
        "label": "resolutions",
        "importPath": "sf_examples.vizdoom.doom.wrappers.observation_space",
        "description": "sf_examples.vizdoom.doom.wrappers.observation_space",
        "isExtraImport": true,
        "detail": "sf_examples.vizdoom.doom.wrappers.observation_space",
        "documentation": {}
    },
    {
        "label": "DoomGatheringRewardShaping",
        "importPath": "sf_examples.vizdoom.doom.wrappers.scenario_wrappers.gathering_reward_shaping",
        "description": "sf_examples.vizdoom.doom.wrappers.scenario_wrappers.gathering_reward_shaping",
        "isExtraImport": true,
        "detail": "sf_examples.vizdoom.doom.wrappers.scenario_wrappers.gathering_reward_shaping",
        "documentation": {}
    },
    {
        "label": "parse_vizdoom_cfg",
        "importPath": "sf_examples.vizdoom.train_vizdoom",
        "description": "sf_examples.vizdoom.train_vizdoom",
        "isExtraImport": true,
        "detail": "sf_examples.vizdoom.train_vizdoom",
        "documentation": {}
    },
    {
        "label": "register_vizdoom_components",
        "importPath": "sf_examples.vizdoom.train_vizdoom",
        "description": "sf_examples.vizdoom.train_vizdoom",
        "isExtraImport": true,
        "detail": "sf_examples.vizdoom.train_vizdoom",
        "documentation": {}
    },
    {
        "label": "register_vizdoom_components",
        "importPath": "sf_examples.vizdoom.train_vizdoom",
        "description": "sf_examples.vizdoom.train_vizdoom",
        "isExtraImport": true,
        "detail": "sf_examples.vizdoom.train_vizdoom",
        "documentation": {}
    },
    {
        "label": "register_vizdoom_components",
        "importPath": "sf_examples.vizdoom.train_vizdoom",
        "description": "sf_examples.vizdoom.train_vizdoom",
        "isExtraImport": true,
        "detail": "sf_examples.vizdoom.train_vizdoom",
        "documentation": {}
    },
    {
        "label": "add_doom_env_args",
        "importPath": "sf_examples.vizdoom.doom.doom_params",
        "description": "sf_examples.vizdoom.doom.doom_params",
        "isExtraImport": true,
        "detail": "sf_examples.vizdoom.doom.doom_params",
        "documentation": {}
    },
    {
        "label": "add_doom_env_eval_args",
        "importPath": "sf_examples.vizdoom.doom.doom_params",
        "description": "sf_examples.vizdoom.doom.doom_params",
        "isExtraImport": true,
        "detail": "sf_examples.vizdoom.doom.doom_params",
        "documentation": {}
    },
    {
        "label": "doom_override_defaults",
        "importPath": "sf_examples.vizdoom.doom.doom_params",
        "description": "sf_examples.vizdoom.doom.doom_params",
        "isExtraImport": true,
        "detail": "sf_examples.vizdoom.doom.doom_params",
        "documentation": {}
    },
    {
        "label": "add_doom_env_args",
        "importPath": "sf_examples.vizdoom.doom.doom_params",
        "description": "sf_examples.vizdoom.doom.doom_params",
        "isExtraImport": true,
        "detail": "sf_examples.vizdoom.doom.doom_params",
        "documentation": {}
    },
    {
        "label": "add_doom_env_eval_args",
        "importPath": "sf_examples.vizdoom.doom.doom_params",
        "description": "sf_examples.vizdoom.doom.doom_params",
        "isExtraImport": true,
        "detail": "sf_examples.vizdoom.doom.doom_params",
        "documentation": {}
    },
    {
        "label": "doom_override_defaults",
        "importPath": "sf_examples.vizdoom.doom.doom_params",
        "description": "sf_examples.vizdoom.doom.doom_params",
        "isExtraImport": true,
        "detail": "sf_examples.vizdoom.doom.doom_params",
        "documentation": {}
    },
    {
        "label": "add_doom_env_args",
        "importPath": "sf_examples.vizdoom.doom.doom_params",
        "description": "sf_examples.vizdoom.doom.doom_params",
        "isExtraImport": true,
        "detail": "sf_examples.vizdoom.doom.doom_params",
        "documentation": {}
    },
    {
        "label": "doom_override_defaults",
        "importPath": "sf_examples.vizdoom.doom.doom_params",
        "description": "sf_examples.vizdoom.doom.doom_params",
        "isExtraImport": true,
        "detail": "sf_examples.vizdoom.doom.doom_params",
        "documentation": {}
    },
    {
        "label": "add_doom_env_args",
        "importPath": "sf_examples.vizdoom.doom.doom_params",
        "description": "sf_examples.vizdoom.doom.doom_params",
        "isExtraImport": true,
        "detail": "sf_examples.vizdoom.doom.doom_params",
        "documentation": {}
    },
    {
        "label": "doom_override_defaults",
        "importPath": "sf_examples.vizdoom.doom.doom_params",
        "description": "sf_examples.vizdoom.doom.doom_params",
        "isExtraImport": true,
        "detail": "sf_examples.vizdoom.doom.doom_params",
        "documentation": {}
    },
    {
        "label": "add_custom_args",
        "importPath": "sf_examples.vizdoom.train_custom_vizdoom_env",
        "description": "sf_examples.vizdoom.train_custom_vizdoom_env",
        "isExtraImport": true,
        "detail": "sf_examples.vizdoom.train_custom_vizdoom_env",
        "documentation": {}
    },
    {
        "label": "register_custom_doom_env",
        "importPath": "sf_examples.vizdoom.train_custom_vizdoom_env",
        "description": "sf_examples.vizdoom.train_custom_vizdoom_env",
        "isExtraImport": true,
        "detail": "sf_examples.vizdoom.train_custom_vizdoom_env",
        "documentation": {}
    },
    {
        "label": "make_vizdoom_encoder",
        "importPath": "sf_examples.vizdoom.doom.doom_model",
        "description": "sf_examples.vizdoom.doom.doom_model",
        "isExtraImport": true,
        "detail": "sf_examples.vizdoom.doom.doom_model",
        "documentation": {}
    },
    {
        "label": "parse_custom_args",
        "importPath": "sf_examples.train_custom_env_custom_model",
        "description": "sf_examples.train_custom_env_custom_model",
        "isExtraImport": true,
        "detail": "sf_examples.train_custom_env_custom_model",
        "documentation": {}
    },
    {
        "label": "register_custom_components",
        "importPath": "sf_examples.train_custom_env_custom_model",
        "description": "sf_examples.train_custom_env_custom_model",
        "isExtraImport": true,
        "detail": "sf_examples.train_custom_env_custom_model",
        "documentation": {}
    },
    {
        "label": "make_custom_encoder",
        "importPath": "sf_examples.train_custom_env_custom_model",
        "description": "sf_examples.train_custom_env_custom_model",
        "isExtraImport": true,
        "detail": "sf_examples.train_custom_env_custom_model",
        "documentation": {}
    },
    {
        "label": "override_default_params",
        "importPath": "sf_examples.train_custom_env_custom_model",
        "description": "sf_examples.train_custom_env_custom_model",
        "isExtraImport": true,
        "detail": "sf_examples.train_custom_env_custom_model",
        "documentation": {}
    },
    {
        "label": "parse_custom_args",
        "importPath": "sf_examples.train_custom_env_custom_model",
        "description": "sf_examples.train_custom_env_custom_model",
        "isExtraImport": true,
        "detail": "sf_examples.train_custom_env_custom_model",
        "documentation": {}
    },
    {
        "label": "register_custom_components",
        "importPath": "sf_examples.train_custom_env_custom_model",
        "description": "sf_examples.train_custom_env_custom_model",
        "isExtraImport": true,
        "detail": "sf_examples.train_custom_env_custom_model",
        "documentation": {}
    },
    {
        "label": "parse_custom_args",
        "importPath": "sf_examples.train_custom_multi_env",
        "description": "sf_examples.train_custom_multi_env",
        "isExtraImport": true,
        "detail": "sf_examples.train_custom_multi_env",
        "documentation": {}
    },
    {
        "label": "register_custom_components",
        "importPath": "sf_examples.train_custom_multi_env",
        "description": "sf_examples.train_custom_multi_env",
        "isExtraImport": true,
        "detail": "sf_examples.train_custom_multi_env",
        "documentation": {}
    },
    {
        "label": "parse_custom_args",
        "importPath": "sf_examples.train_custom_multi_env",
        "description": "sf_examples.train_custom_multi_env",
        "isExtraImport": true,
        "detail": "sf_examples.train_custom_multi_env",
        "documentation": {}
    },
    {
        "label": "register_custom_components",
        "importPath": "sf_examples.train_custom_multi_env",
        "description": "sf_examples.train_custom_multi_env",
        "isExtraImport": true,
        "detail": "sf_examples.train_custom_multi_env",
        "documentation": {}
    },
    {
        "label": "parse_custom_args",
        "importPath": "sf_examples.train_gym_env",
        "description": "sf_examples.train_gym_env",
        "isExtraImport": true,
        "detail": "sf_examples.train_gym_env",
        "documentation": {}
    },
    {
        "label": "register_custom_components",
        "importPath": "sf_examples.train_gym_env",
        "description": "sf_examples.train_gym_env",
        "isExtraImport": true,
        "detail": "sf_examples.train_gym_env",
        "documentation": {}
    },
    {
        "label": "default_multi_cfg",
        "importPath": "tests.examples.test_example_multi",
        "description": "tests.examples.test_example_multi",
        "isExtraImport": true,
        "detail": "tests.examples.test_example_multi",
        "documentation": {}
    },
    {
        "label": "run_test_env_multi",
        "importPath": "tests.examples.test_example_multi",
        "description": "tests.examples.test_example_multi",
        "isExtraImport": true,
        "detail": "tests.examples.test_example_multi",
        "documentation": {}
    },
    {
        "label": "eval_env_performance",
        "importPath": "tests.envs.utils",
        "description": "tests.envs.utils",
        "isExtraImport": true,
        "detail": "tests.envs.utils",
        "documentation": {}
    },
    {
        "label": "eval_env_performance",
        "importPath": "tests.envs.utils",
        "description": "tests.envs.utils",
        "isExtraImport": true,
        "detail": "tests.envs.utils",
        "documentation": {}
    },
    {
        "label": "eval_env_performance",
        "importPath": "tests.envs.utils",
        "description": "tests.envs.utils",
        "isExtraImport": true,
        "detail": "tests.envs.utils",
        "documentation": {}
    },
    {
        "label": "clean_test_dir",
        "importPath": "tests.utils",
        "description": "tests.utils",
        "isExtraImport": true,
        "detail": "tests.utils",
        "documentation": {}
    },
    {
        "label": "clean_test_dir",
        "importPath": "tests.utils",
        "description": "tests.utils",
        "isExtraImport": true,
        "detail": "tests.utils",
        "documentation": {}
    },
    {
        "label": "clean_test_dir",
        "importPath": "tests.utils",
        "description": "tests.utils",
        "isExtraImport": true,
        "detail": "tests.utils",
        "documentation": {}
    },
    {
        "label": "clean_test_dir",
        "importPath": "tests.utils",
        "description": "tests.utils",
        "isExtraImport": true,
        "detail": "tests.utils",
        "documentation": {}
    },
    {
        "label": "parse_atari_args",
        "importPath": "sf_examples.envpool.atari.train_envpool_atari",
        "description": "sf_examples.envpool.atari.train_envpool_atari",
        "isExtraImport": true,
        "detail": "sf_examples.envpool.atari.train_envpool_atari",
        "documentation": {}
    },
    {
        "label": "MixedActions",
        "importPath": "tests.envs.tuple_action_envs.test_mixed_dist_env_non_batched",
        "description": "tests.envs.tuple_action_envs.test_mixed_dist_env_non_batched",
        "isExtraImport": true,
        "detail": "tests.envs.tuple_action_envs.test_mixed_dist_env_non_batched",
        "documentation": {}
    },
    {
        "label": "mixed_actions_get_reward",
        "importPath": "tests.envs.tuple_action_envs.test_mixed_dist_env_non_batched",
        "description": "tests.envs.tuple_action_envs.test_mixed_dist_env_non_batched",
        "isExtraImport": true,
        "detail": "tests.envs.tuple_action_envs.test_mixed_dist_env_non_batched",
        "documentation": {}
    },
    {
        "label": "DiscreteActions",
        "importPath": "tests.envs.tuple_action_envs.test_two_discrete_action_dist_env_non_batched",
        "description": "tests.envs.tuple_action_envs.test_two_discrete_action_dist_env_non_batched",
        "isExtraImport": true,
        "detail": "tests.envs.tuple_action_envs.test_two_discrete_action_dist_env_non_batched",
        "documentation": {}
    },
    {
        "label": "get_reward",
        "importPath": "tests.envs.tuple_action_envs.test_two_discrete_action_dist_env_non_batched",
        "description": "tests.envs.tuple_action_envs.test_two_discrete_action_dist_env_non_batched",
        "isExtraImport": true,
        "detail": "tests.envs.tuple_action_envs.test_two_discrete_action_dist_env_non_batched",
        "documentation": {}
    },
    {
        "label": "default_test_cfg",
        "importPath": "tests.examples.test_example",
        "description": "tests.examples.test_example",
        "isExtraImport": true,
        "detail": "tests.examples.test_example",
        "documentation": {}
    },
    {
        "label": "run_test_env",
        "importPath": "tests.examples.test_example",
        "description": "tests.examples.test_example",
        "isExtraImport": true,
        "detail": "tests.examples.test_example",
        "documentation": {}
    },
    {
        "label": "generate_trajectories",
        "importPath": "sf_examples.sampler.use_simplified_sampling_api",
        "description": "sf_examples.sampler.use_simplified_sampling_api",
        "isExtraImport": true,
        "detail": "sf_examples.sampler.use_simplified_sampling_api",
        "documentation": {}
    },
    {
        "label": "launcher_argparser",
        "importPath": "sample_factory.launcher.run",
        "description": "sample_factory.launcher.run",
        "isExtraImport": true,
        "detail": "sample_factory.launcher.run",
        "documentation": {}
    },
    {
        "label": "torch.multiprocessing",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "torch.multiprocessing",
        "description": "torch.multiprocessing",
        "detail": "torch.multiprocessing",
        "documentation": {}
    },
    {
        "label": "boto3",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "boto3",
        "description": "boto3",
        "detail": "boto3",
        "documentation": {}
    },
    {
        "label": "init",
        "importPath": "colorama",
        "description": "colorama",
        "isExtraImport": true,
        "detail": "colorama",
        "documentation": {}
    },
    {
        "label": "Fore",
        "importPath": "colorama",
        "description": "colorama",
        "isExtraImport": true,
        "detail": "colorama",
        "documentation": {}
    },
    {
        "label": "Style",
        "importPath": "colorama",
        "description": "colorama",
        "isExtraImport": true,
        "detail": "colorama",
        "documentation": {}
    },
    {
        "label": "netrc",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "netrc",
        "description": "netrc",
        "detail": "netrc",
        "documentation": {}
    },
    {
        "label": "f",
        "importPath": "matplotlib.pylab",
        "description": "matplotlib.pylab",
        "isExtraImport": true,
        "detail": "matplotlib.pylab",
        "documentation": {}
    },
    {
        "label": "f",
        "importPath": "matplotlib.pylab",
        "description": "matplotlib.pylab",
        "isExtraImport": true,
        "detail": "matplotlib.pylab",
        "documentation": {}
    },
    {
        "label": "imp",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "imp",
        "description": "imp",
        "detail": "imp",
        "documentation": {}
    },
    {
        "label": "itertools",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "itertools",
        "description": "itertools",
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "stats",
        "importPath": "scipy",
        "description": "scipy",
        "isExtraImport": true,
        "detail": "scipy",
        "documentation": {}
    },
    {
        "label": "evaluate",
        "importPath": "rl.sample_factory.sample_factory",
        "description": "rl.sample_factory.sample_factory",
        "isExtraImport": true,
        "detail": "rl.sample_factory.sample_factory",
        "documentation": {}
    },
    {
        "label": "init_wandb",
        "importPath": "rl.wandb.wandb",
        "description": "rl.wandb.wandb",
        "isExtraImport": true,
        "detail": "rl.wandb.wandb",
        "documentation": {}
    },
    {
        "label": "init_wandb",
        "importPath": "rl.wandb.wandb",
        "description": "rl.wandb.wandb",
        "isExtraImport": true,
        "detail": "rl.wandb.wandb",
        "documentation": {}
    },
    {
        "label": "init_wandb",
        "importPath": "rl.wandb.wandb",
        "description": "rl.wandb.wandb",
        "isExtraImport": true,
        "detail": "rl.wandb.wandb",
        "documentation": {}
    },
    {
        "label": "train",
        "importPath": "rl.pufferlib.train",
        "description": "rl.pufferlib.train",
        "isExtraImport": true,
        "detail": "rl.pufferlib.train",
        "documentation": {}
    },
    {
        "label": "train",
        "importPath": "rl.pufferlib.train",
        "description": "rl.pufferlib.train",
        "isExtraImport": true,
        "detail": "rl.pufferlib.train",
        "documentation": {}
    },
    {
        "label": "CommError",
        "importPath": "wandb.errors",
        "description": "wandb.errors",
        "isExtraImport": true,
        "detail": "wandb.errors",
        "documentation": {}
    },
    {
        "label": "fast_gae",
        "importPath": "fast_gae",
        "description": "fast_gae",
        "isExtraImport": true,
        "detail": "fast_gae",
        "documentation": {}
    },
    {
        "label": "load_policy_from_uri",
        "importPath": "rl.pufferlib.policy",
        "description": "rl.pufferlib.policy",
        "isExtraImport": true,
        "detail": "rl.pufferlib.policy",
        "documentation": {}
    },
    {
        "label": "load_policy_from_uri",
        "importPath": "rl.pufferlib.policy",
        "description": "rl.pufferlib.policy",
        "isExtraImport": true,
        "detail": "rl.pufferlib.policy",
        "documentation": {}
    },
    {
        "label": "print_policy_stats",
        "importPath": "util.stats",
        "description": "util.stats",
        "isExtraImport": true,
        "detail": "util.stats",
        "documentation": {}
    },
    {
        "label": "make_vecenv",
        "importPath": "rl.pufferlib.vecenv",
        "description": "rl.pufferlib.vecenv",
        "isExtraImport": true,
        "detail": "rl.pufferlib.vecenv",
        "documentation": {}
    },
    {
        "label": "make_vecenv",
        "importPath": "rl.pufferlib.vecenv",
        "description": "rl.pufferlib.vecenv",
        "isExtraImport": true,
        "detail": "rl.pufferlib.vecenv",
        "documentation": {}
    },
    {
        "label": "make_vecenv",
        "importPath": "rl.pufferlib.vecenv",
        "description": "rl.pufferlib.vecenv",
        "isExtraImport": true,
        "detail": "rl.pufferlib.vecenv",
        "documentation": {}
    },
    {
        "label": "MettaGridRaylibRenderer",
        "importPath": "mettagrid.renderer.raylib_renderer",
        "description": "mettagrid.renderer.raylib_renderer",
        "isExtraImport": true,
        "detail": "mettagrid.renderer.raylib_renderer",
        "documentation": {}
    },
    {
        "label": "MettaAgent",
        "importPath": "agent.metta_agent",
        "description": "agent.metta_agent",
        "isExtraImport": true,
        "detail": "agent.metta_agent",
        "documentation": {}
    },
    {
        "label": "PredictingActorCritic",
        "importPath": "rl.sample_factory.predicting_actor_critic",
        "description": "rl.sample_factory.predicting_actor_critic",
        "isExtraImport": true,
        "detail": "rl.sample_factory.predicting_actor_critic",
        "documentation": {}
    },
    {
        "label": "run_sweep",
        "importPath": "rl.carbs.carb_sweep",
        "description": "rl.carbs.carb_sweep",
        "isExtraImport": true,
        "detail": "rl.carbs.carb_sweep",
        "documentation": {}
    },
    {
        "label": "evaluate",
        "importPath": "rl.pufferlib.evaluate",
        "description": "rl.pufferlib.evaluate",
        "isExtraImport": true,
        "detail": "rl.pufferlib.evaluate",
        "documentation": {}
    },
    {
        "label": "play",
        "importPath": "rl.pufferlib.play",
        "description": "rl.pufferlib.play",
        "isExtraImport": true,
        "detail": "rl.pufferlib.play",
        "documentation": {}
    },
    {
        "label": "tabulate",
        "importPath": "tabulate",
        "description": "tabulate",
        "isExtraImport": true,
        "detail": "tabulate",
        "documentation": {}
    },
    {
        "label": "colored",
        "importPath": "termcolor",
        "description": "termcolor",
        "isExtraImport": true,
        "detail": "termcolor",
        "documentation": {}
    },
    {
        "label": "FastAPI",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "WebSocket",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "Query",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "HTTPException",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "HTMLResponse",
        "importPath": "fastapi.responses",
        "description": "fastapi.responses",
        "isExtraImport": true,
        "detail": "fastapi.responses",
        "documentation": {}
    },
    {
        "label": "FeatureListNormalizer",
        "kind": 6,
        "importPath": "agent.lib.normalizer",
        "description": "agent.lib.normalizer",
        "peekOfCode": "class FeatureListNormalizer(nn.Module):\n    def __init__(self, feature_names, input_shape=(1,)):\n        super().__init__()\n        self._feature_names = feature_names\n        self._norms_dict = nn.ModuleDict({\n            **{\n                k: RunningMeanStdInPlace(input_shape)\n                for k in self._feature_names\n            },\n        })",
        "detail": "agent.lib.normalizer",
        "documentation": {}
    },
    {
        "label": "position_embeddings",
        "kind": 2,
        "importPath": "agent.lib.position",
        "description": "agent.lib.position",
        "peekOfCode": "def position_embeddings(width, height, embedding_dim=128):\n    x = torch.linspace(-1, 1, width)\n    y = torch.linspace(-1, 1, height)\n    pos_x, pos_y = torch.meshgrid(x, y, indexing='xy')\n    return torch.stack((pos_x, pos_y), dim=-1)\ndef sinusoidal_position_embeddings(width, height, embedding_dim=128):\n    # Generate a grid of positions for x and y coordinates\n    x = torch.linspace(-1, 1, width, dtype=torch.float32)\n    y = torch.linspace(-1, 1, height, dtype=torch.float32)\n    pos_x, pos_y = torch.meshgrid(x, y, indexing='xy')",
        "detail": "agent.lib.position",
        "documentation": {}
    },
    {
        "label": "sinusoidal_position_embeddings",
        "kind": 2,
        "importPath": "agent.lib.position",
        "description": "agent.lib.position",
        "peekOfCode": "def sinusoidal_position_embeddings(width, height, embedding_dim=128):\n    # Generate a grid of positions for x and y coordinates\n    x = torch.linspace(-1, 1, width, dtype=torch.float32)\n    y = torch.linspace(-1, 1, height, dtype=torch.float32)\n    pos_x, pos_y = torch.meshgrid(x, y, indexing='xy')\n    # Prepare to generate sinusoidal embeddings\n    assert embedding_dim % 2 == 0, \"Embedding dimension must be even.\"\n    # Create a series of frequencies exponentially spaced apart\n    freqs = torch.exp2(torch.linspace(0, math.log(embedding_dim // 2 - 1), embedding_dim // 2))\n    # Apply sinusoidal functions to the positions",
        "detail": "agent.lib.position",
        "documentation": {}
    },
    {
        "label": "SkipConnectionStack",
        "kind": 6,
        "importPath": "agent.lib.util",
        "description": "agent.lib.util",
        "peekOfCode": "class SkipConnectionStack(nn.Module):\n    def __init__(self, layers):\n        super(SkipConnectionStack, self).__init__()\n        self.layers = nn.ModuleList(layers)\n    def forward(self, x):\n        skip_connections = []\n        for i, layer in enumerate(self.layers):\n            if isinstance(layer, nn.Linear):\n                if len(skip_connections) > 1:\n                    x = x + skip_connections[-1]",
        "detail": "agent.lib.util",
        "documentation": {}
    },
    {
        "label": "layer_init",
        "kind": 2,
        "importPath": "agent.lib.util",
        "description": "agent.lib.util",
        "peekOfCode": "def layer_init(layer, std=np.sqrt(2), bias_const=0.0):\n    \"\"\"\n    Simple function to init layers\n    \"\"\"\n    nn.init.orthogonal_(layer.weight, std)\n    nn.init.constant_(layer.bias, bias_const)\n    return layer\ndef make_nn_stack(\n    input_size,\n    output_size,",
        "detail": "agent.lib.util",
        "documentation": {}
    },
    {
        "label": "make_nn_stack",
        "kind": 2,
        "importPath": "agent.lib.util",
        "description": "agent.lib.util",
        "peekOfCode": "def make_nn_stack(\n    input_size,\n    output_size,\n    hidden_sizes,\n    nonlinearity=nn.ELU(),\n    layer_norm=False,\n    use_skip=False,\n):\n    \"\"\"Create a stack of fully connected layers with nonlinearity\"\"\"\n    sizes = [input_size] + hidden_sizes + [output_size]",
        "detail": "agent.lib.util",
        "documentation": {}
    },
    {
        "label": "stable_hash",
        "kind": 2,
        "importPath": "agent.lib.util",
        "description": "agent.lib.util",
        "peekOfCode": "def stable_hash(s, mod=10000):\n    \"\"\"Generate a stable hash for a string.\"\"\"\n    return int(hashlib.md5(s.encode()).hexdigest(), 16) % mod\ndef embed_strings(string_list, embedding_dim):\n    return torch.tensor([\n        embed_string(s, embedding_dim)\n        for s in string_list\n    ], dtype=torch.float32)\ndef embed_string(s, embedding_dim=128):\n    # Hash the string using SHA-256, which produces a 32-byte hash",
        "detail": "agent.lib.util",
        "documentation": {}
    },
    {
        "label": "embed_strings",
        "kind": 2,
        "importPath": "agent.lib.util",
        "description": "agent.lib.util",
        "peekOfCode": "def embed_strings(string_list, embedding_dim):\n    return torch.tensor([\n        embed_string(s, embedding_dim)\n        for s in string_list\n    ], dtype=torch.float32)\ndef embed_string(s, embedding_dim=128):\n    # Hash the string using SHA-256, which produces a 32-byte hash\n    hash_object = hashlib.sha256(s.encode())\n    hash_digest = hash_object.digest()\n    # Convert hash bytes to a numpy array of floats",
        "detail": "agent.lib.util",
        "documentation": {}
    },
    {
        "label": "embed_string",
        "kind": 2,
        "importPath": "agent.lib.util",
        "description": "agent.lib.util",
        "peekOfCode": "def embed_string(s, embedding_dim=128):\n    # Hash the string using SHA-256, which produces a 32-byte hash\n    hash_object = hashlib.sha256(s.encode())\n    hash_digest = hash_object.digest()\n    # Convert hash bytes to a numpy array of floats\n    # This example simply takes the first 'embedding_dim' bytes and scales them\n    byte_array = np.frombuffer(hash_digest[:embedding_dim], dtype=np.uint8)\n    embedding = byte_array / 255.0  # Normalize to range [0, 1]\n    # Ensure the embedding is the right size\n    if len(embedding) < embedding_dim:",
        "detail": "agent.lib.util",
        "documentation": {}
    },
    {
        "label": "MettaAgentInterface",
        "kind": 6,
        "importPath": "agent.agent_interface",
        "description": "agent.agent_interface",
        "peekOfCode": "class MettaAgentInterface():\n    def encode_observations(self, obs_dict: Dict[str, Tensor]) -> Tensor:\n        raise NotImplementedError()\n    def forward_core(self, head_output, rnn_states):\n        raise NotImplementedError()\n    def decode_state(self, core_output, values_only: bool, sample_actions: bool) -> TensorDict:\n        raise NotImplementedError()\n    def forward(self, obs_dict, rnn_states, values_only: bool = False) -> TensorDict:\n        raise NotImplementedError()\n    def aux_loss(self, obs_dict, rnn_states):",
        "detail": "agent.agent_interface",
        "documentation": {}
    },
    {
        "label": "Decoder",
        "kind": 6,
        "importPath": "agent.decoder",
        "description": "agent.decoder",
        "peekOfCode": "class Decoder(MlpDecoder):\n    def __init__(self, input_size: int):\n        super().__init__(\n            AttrDict({\n                'decoder_mlp_layers': [],\n                'nonlinearity': 'elu',\n            }),\n            input_size\n        )",
        "detail": "agent.decoder",
        "documentation": {}
    },
    {
        "label": "FeatureSetEncoder",
        "kind": 6,
        "importPath": "agent.feature_encoder",
        "description": "agent.feature_encoder",
        "peekOfCode": "class FeatureSetEncoder(nn.Module):\n    def __init__(\n            self,\n            obs_space,\n            obs_key: str,\n            feature_names: List[str],\n            normalize_features: bool,\n            label_dim: int,\n            output_dim: int,\n            layers: int",
        "detail": "agent.feature_encoder",
        "documentation": {}
    },
    {
        "label": "MultiFeatureSetEncoder",
        "kind": 6,
        "importPath": "agent.feature_encoder",
        "description": "agent.feature_encoder",
        "peekOfCode": "class MultiFeatureSetEncoder(nn.Module):\n    def __init__(self, obs_space, encoders_cfg, layers: int, output_dim: int):\n        super().__init__()\n        self.feature_set_encoders = nn.ModuleDict({\n            name: FeatureSetEncoder(obs_space, name, **cfg)\n            for name, cfg in encoders_cfg.items()\n            if len(cfg.feature_names) > 0\n        })\n        self.merged_encoder = make_nn_stack(\n            input_size=sum(encoder.output_dim() for encoder in self.feature_set_encoders.values()),",
        "detail": "agent.feature_encoder",
        "documentation": {}
    },
    {
        "label": "MettaAgent",
        "kind": 6,
        "importPath": "agent.metta_agent",
        "description": "agent.metta_agent",
        "peekOfCode": "class MettaAgent(nn.Module, MettaAgentInterface):\n    def __init__(\n        self,\n        obs_space: ObsSpace,\n        action_space: ActionSpace,\n        **cfg\n    ):\n        super().__init__()\n        cfg = OmegaConf.create(cfg)\n        self.cfg = cfg",
        "detail": "agent.metta_agent",
        "documentation": {}
    },
    {
        "label": "SpriteEncoder",
        "kind": 6,
        "importPath": "agent.sprite_encoder",
        "description": "agent.sprite_encoder",
        "peekOfCode": "class SpriteEncoder(nn.Module):\n    def __init__(self,\n                 sprite_width, height, channels, output_dim, hidden_dim=32):\n        super().__init__()\n        self.conv1 = nn.Conv2d(channels, 16, kernel_size=3, stride=1, padding=1)\n        self.conv2 = nn.Conv2d(16, hidden_dim, kernel_size=3, stride=1, padding=1)\n        self.fc = nn.Linear(hidden_dim*sprite_width*height, output_dim)\n    def forward(self, x):\n        x = F.relu(self.conv1(x))\n        x = F.relu(self.conv2(x))",
        "detail": "agent.sprite_encoder",
        "documentation": {}
    },
    {
        "label": "CARBS",
        "kind": 6,
        "importPath": "deps.carbs.carbs.carbs",
        "description": "deps.carbs.carbs.carbs",
        "peekOfCode": "class CARBS:\n    \"\"\"\n    C.A.R.B.S = Cost Aware (pareto-) Regional Bayesian Search\n    Definitions\n        Target function: the real function we're trying to find optimal hyperparameters for\n        Surrogate (fitness): the estimated output of the target function from the Gaussian process model\n        Param space: original space of all the hyperparameters before transforms to the given target function\n        Basic space: intermediate space that contains the actual input space of our target function\n            e.g. Learning rate in param space is any real positive number and in basic space we reduce the search range\n              to a log space `lr = LogSpace(max=1)`",
        "detail": "deps.carbs.carbs.carbs",
        "documentation": {}
    },
    {
        "label": "SurrogateObservationOutputs",
        "kind": 6,
        "importPath": "deps.carbs.carbs.model",
        "description": "deps.carbs.carbs.model",
        "peekOfCode": "class SurrogateObservationOutputs:\n    surrogate_output: Tensor\n    surrogate_var: Tensor\n    cost_estimate: Tensor\n    target_estimate: Tensor\n    target_var: Tensor\n    success_probability: Tensor\n    pareto_surrogate: Optional[Tensor]\n    pareto_estimate: Optional[Tensor]\nclass SurrogateModel:",
        "detail": "deps.carbs.carbs.model",
        "documentation": {}
    },
    {
        "label": "SurrogateModel",
        "kind": 6,
        "importPath": "deps.carbs.carbs.model",
        "description": "deps.carbs.carbs.model",
        "peekOfCode": "class SurrogateModel:\n    def __init__(\n        self,\n        params: SurrogateModelParams,\n    ) -> None:\n        self.params = params\n        self.output_transformer: Optional[QuantileTransformer] = None\n        self.cost_transformer: Optional[MinMaxScaler] = None\n        self.output_model: Optional[GPRegression] = None\n        self.cost_model: Optional[GPRegression] = None",
        "detail": "deps.carbs.carbs.model",
        "documentation": {}
    },
    {
        "label": "Serializable",
        "kind": 6,
        "importPath": "deps.carbs.carbs.serialization",
        "description": "deps.carbs.carbs.serialization",
        "peekOfCode": "class Serializable:\n    # noinspection PyDataclass\n    def __attrs_post_init__(self) -> None:\n        self.__dict__[FREEZE_KEY] = True\n    def __setattr__(self, item: str, value: Any):\n        if self.__dict__.get(FREEZE_KEY):\n            raise ValueError(\"instance is frozen; see: .mutable_clone()\")\n        else:\n            self.__dict__[item] = value\n    def mutable_clone(self: TC) -> ContextManager[TC]:",
        "detail": "deps.carbs.carbs.serialization",
        "documentation": {}
    },
    {
        "label": "ParamTypeError",
        "kind": 6,
        "importPath": "deps.carbs.carbs.serialization",
        "description": "deps.carbs.carbs.serialization",
        "peekOfCode": "class ParamTypeError(TypeError):\n    pass\ndef _get_all_subclasses(cls):\n    all_subclasses = []\n    for subclass in cls.__subclasses__():\n        all_subclasses.append(subclass)\n        all_subclasses.extend(_get_all_subclasses(subclass))\n    return all_subclasses\ndef _compute_unserializable(qualnames: List[str]) -> None:\n    global unserializable_types",
        "detail": "deps.carbs.carbs.serialization",
        "documentation": {}
    },
    {
        "label": "get_all_serializable_classes",
        "kind": 2,
        "importPath": "deps.carbs.carbs.serialization",
        "description": "deps.carbs.carbs.serialization",
        "peekOfCode": "def get_all_serializable_classes() -> List[type]:\n    # we don't reload the Enum class (since it's standard library) so we end up having duplicate subclasses for Enums\n    enum_subclasses = _dedupe_subclasses_by_qualname(_get_all_subclasses(Enum))\n    # we want to make sure we have classes with different names which is why we need to dedupe with the ids\n    serializable_subclasses = _dedupe_subclasses_by_id(_get_all_subclasses(Serializable))\n    return serializable_subclasses + enum_subclasses\ndef get_serializable_type_from_qualname(qualname: str) -> Type[Serializable]:\n    global qualname_to_serializable_type\n    global unserializable_types\n    if not qualname_to_serializable_type:",
        "detail": "deps.carbs.carbs.serialization",
        "documentation": {}
    },
    {
        "label": "get_serializable_type_from_qualname",
        "kind": 2,
        "importPath": "deps.carbs.carbs.serialization",
        "description": "deps.carbs.carbs.serialization",
        "peekOfCode": "def get_serializable_type_from_qualname(qualname: str) -> Type[Serializable]:\n    global qualname_to_serializable_type\n    global unserializable_types\n    if not qualname_to_serializable_type:\n        # makes our globals thread safe and hopefully free from weird race conditions\n        with lock:\n            if not qualname_to_serializable_type:\n                all_serializable_classes = get_all_serializable_classes()\n                qualname_to_serializable_type = {x.__qualname__: x for x in all_serializable_classes}\n                _compute_unserializable([x.__qualname__ for x in all_serializable_classes])",
        "detail": "deps.carbs.carbs.serialization",
        "documentation": {}
    },
    {
        "label": "get_qualname_from_serializable_type",
        "kind": 2,
        "importPath": "deps.carbs.carbs.serialization",
        "description": "deps.carbs.carbs.serialization",
        "peekOfCode": "def get_qualname_from_serializable_type(serializable_type: type) -> str:\n    global serializable_type_to_qualname\n    global unserializable_types\n    if not serializable_type_to_qualname:\n        # makes our globals thread safe and hopefully free from weird race conditions\n        with lock:\n            if not serializable_type_to_qualname:\n                all_serializable_classes = get_all_serializable_classes()\n                serializable_type_to_qualname = {x: x.__qualname__ for x in all_serializable_classes}\n                _compute_unserializable(list(serializable_type_to_qualname.values()))",
        "detail": "deps.carbs.carbs.serialization",
        "documentation": {}
    },
    {
        "label": "flatten_dict",
        "kind": 2,
        "importPath": "deps.carbs.carbs.serialization",
        "description": "deps.carbs.carbs.serialization",
        "peekOfCode": "def flatten_dict(d: DictNest, prefix: str = \"\") -> DictFlat:\n    flattened_dict = {}\n    for k, v in d.items():\n        if isinstance(v, dict):\n            flattened_dict.update(flatten_dict(v, f\"{prefix}{k}.\"))\n        else:\n            flattened_dict[f\"{prefix}{k}\"] = v\n    return flattened_dict\ndef inflate_dict(d: DictFlat) -> DictNest:\n    inflated_dict: DictNest = {}",
        "detail": "deps.carbs.carbs.serialization",
        "documentation": {}
    },
    {
        "label": "inflate_dict",
        "kind": 2,
        "importPath": "deps.carbs.carbs.serialization",
        "description": "deps.carbs.carbs.serialization",
        "peekOfCode": "def inflate_dict(d: DictFlat) -> DictNest:\n    inflated_dict: DictNest = {}\n    for key, value in d.items():\n        parts = key.split(\".\")\n        d = inflated_dict\n        for part in parts[:-1]:\n            d = d.setdefault(part, {})\n        d[parts[-1]] = value\n    return inflated_dict",
        "detail": "deps.carbs.carbs.serialization",
        "documentation": {}
    },
    {
        "label": "FREEZE_KEY",
        "kind": 5,
        "importPath": "deps.carbs.carbs.serialization",
        "description": "deps.carbs.carbs.serialization",
        "peekOfCode": "FREEZE_KEY = \"$_frozen\"\nTC = TypeVar(\"TC\", bound=\"Serializable\")\n_CLASS_KEY = \"$type\"\nlock = multiprocessing.Lock()\n@attr.s(hash=True, collect_by_mro=True)\nclass Serializable:\n    # noinspection PyDataclass\n    def __attrs_post_init__(self) -> None:\n        self.__dict__[FREEZE_KEY] = True\n    def __setattr__(self, item: str, value: Any):",
        "detail": "deps.carbs.carbs.serialization",
        "documentation": {}
    },
    {
        "label": "TC",
        "kind": 5,
        "importPath": "deps.carbs.carbs.serialization",
        "description": "deps.carbs.carbs.serialization",
        "peekOfCode": "TC = TypeVar(\"TC\", bound=\"Serializable\")\n_CLASS_KEY = \"$type\"\nlock = multiprocessing.Lock()\n@attr.s(hash=True, collect_by_mro=True)\nclass Serializable:\n    # noinspection PyDataclass\n    def __attrs_post_init__(self) -> None:\n        self.__dict__[FREEZE_KEY] = True\n    def __setattr__(self, item: str, value: Any):\n        if self.__dict__.get(FREEZE_KEY):",
        "detail": "deps.carbs.carbs.serialization",
        "documentation": {}
    },
    {
        "label": "_CLASS_KEY",
        "kind": 5,
        "importPath": "deps.carbs.carbs.serialization",
        "description": "deps.carbs.carbs.serialization",
        "peekOfCode": "_CLASS_KEY = \"$type\"\nlock = multiprocessing.Lock()\n@attr.s(hash=True, collect_by_mro=True)\nclass Serializable:\n    # noinspection PyDataclass\n    def __attrs_post_init__(self) -> None:\n        self.__dict__[FREEZE_KEY] = True\n    def __setattr__(self, item: str, value: Any):\n        if self.__dict__.get(FREEZE_KEY):\n            raise ValueError(\"instance is frozen; see: .mutable_clone()\")",
        "detail": "deps.carbs.carbs.serialization",
        "documentation": {}
    },
    {
        "label": "lock",
        "kind": 5,
        "importPath": "deps.carbs.carbs.serialization",
        "description": "deps.carbs.carbs.serialization",
        "peekOfCode": "lock = multiprocessing.Lock()\n@attr.s(hash=True, collect_by_mro=True)\nclass Serializable:\n    # noinspection PyDataclass\n    def __attrs_post_init__(self) -> None:\n        self.__dict__[FREEZE_KEY] = True\n    def __setattr__(self, item: str, value: Any):\n        if self.__dict__.get(FREEZE_KEY):\n            raise ValueError(\"instance is frozen; see: .mutable_clone()\")\n        else:",
        "detail": "deps.carbs.carbs.serialization",
        "documentation": {}
    },
    {
        "label": "T",
        "kind": 5,
        "importPath": "deps.carbs.carbs.serialization",
        "description": "deps.carbs.carbs.serialization",
        "peekOfCode": "T = TypeVar(\"T\", bool, int, float, str, tuple)\nDictNest = Dict[str, Union[T, Dict[str, Any]]]\nDictFlat = Dict[str, T]\ndef flatten_dict(d: DictNest, prefix: str = \"\") -> DictFlat:\n    flattened_dict = {}\n    for k, v in d.items():\n        if isinstance(v, dict):\n            flattened_dict.update(flatten_dict(v, f\"{prefix}{k}.\"))\n        else:\n            flattened_dict[f\"{prefix}{k}\"] = v",
        "detail": "deps.carbs.carbs.serialization",
        "documentation": {}
    },
    {
        "label": "DictNest",
        "kind": 5,
        "importPath": "deps.carbs.carbs.serialization",
        "description": "deps.carbs.carbs.serialization",
        "peekOfCode": "DictNest = Dict[str, Union[T, Dict[str, Any]]]\nDictFlat = Dict[str, T]\ndef flatten_dict(d: DictNest, prefix: str = \"\") -> DictFlat:\n    flattened_dict = {}\n    for k, v in d.items():\n        if isinstance(v, dict):\n            flattened_dict.update(flatten_dict(v, f\"{prefix}{k}.\"))\n        else:\n            flattened_dict[f\"{prefix}{k}\"] = v\n    return flattened_dict",
        "detail": "deps.carbs.carbs.serialization",
        "documentation": {}
    },
    {
        "label": "DictFlat",
        "kind": 5,
        "importPath": "deps.carbs.carbs.serialization",
        "description": "deps.carbs.carbs.serialization",
        "peekOfCode": "DictFlat = Dict[str, T]\ndef flatten_dict(d: DictNest, prefix: str = \"\") -> DictFlat:\n    flattened_dict = {}\n    for k, v in d.items():\n        if isinstance(v, dict):\n            flattened_dict.update(flatten_dict(v, f\"{prefix}{k}.\"))\n        else:\n            flattened_dict[f\"{prefix}{k}\"] = v\n    return flattened_dict\ndef inflate_dict(d: DictFlat) -> DictNest:",
        "detail": "deps.carbs.carbs.serialization",
        "documentation": {}
    },
    {
        "label": "carbs_config",
        "kind": 2,
        "importPath": "deps.carbs.carbs.test_carbs",
        "description": "deps.carbs.carbs.test_carbs",
        "peekOfCode": "def carbs_config() -> CARBSParams:\n    return CARBSParams(is_wandb_logging_enabled=False, is_saved_on_every_observation=False)\n@pytest.fixture\ndef params() -> List[Param]:\n    return [\n        Param(\"p1\", LogSpace(scale=1), 1e-2),\n        Param(\"p2\", LinearSpace(scale=2), 0),\n        Param(\"p3\", LogitSpace(scale=0.5), 0.5),\n    ]\n@pytest.fixture",
        "detail": "deps.carbs.carbs.test_carbs",
        "documentation": {}
    },
    {
        "label": "params",
        "kind": 2,
        "importPath": "deps.carbs.carbs.test_carbs",
        "description": "deps.carbs.carbs.test_carbs",
        "peekOfCode": "def params() -> List[Param]:\n    return [\n        Param(\"p1\", LogSpace(scale=1), 1e-2),\n        Param(\"p2\", LinearSpace(scale=2), 0),\n        Param(\"p3\", LogitSpace(scale=0.5), 0.5),\n    ]\n@pytest.fixture\ndef carbs_instance(carbs_config: CARBSParams, params: List[Param]) -> CARBS:\n    return CARBS(carbs_config, params)\ndef test_suggest_one(carbs_instance: CARBS) -> None:",
        "detail": "deps.carbs.carbs.test_carbs",
        "documentation": {}
    },
    {
        "label": "carbs_instance",
        "kind": 2,
        "importPath": "deps.carbs.carbs.test_carbs",
        "description": "deps.carbs.carbs.test_carbs",
        "peekOfCode": "def carbs_instance(carbs_config: CARBSParams, params: List[Param]) -> CARBS:\n    return CARBS(carbs_config, params)\ndef test_suggest_one(carbs_instance: CARBS) -> None:\n    start_suggestions = len(carbs_instance.outstanding_suggestions)\n    suggestion = carbs_instance.suggest()\n    assert len(carbs_instance.outstanding_suggestions) == start_suggestions + 1\n    assert suggestion is not None\n    assert \"suggestion_uuid\" in suggestion.suggestion\n    for param in carbs_instance.params:\n        assert param.name in suggestion.suggestion",
        "detail": "deps.carbs.carbs.test_carbs",
        "documentation": {}
    },
    {
        "label": "test_suggest_one",
        "kind": 2,
        "importPath": "deps.carbs.carbs.test_carbs",
        "description": "deps.carbs.carbs.test_carbs",
        "peekOfCode": "def test_suggest_one(carbs_instance: CARBS) -> None:\n    start_suggestions = len(carbs_instance.outstanding_suggestions)\n    suggestion = carbs_instance.suggest()\n    assert len(carbs_instance.outstanding_suggestions) == start_suggestions + 1\n    assert suggestion is not None\n    assert \"suggestion_uuid\" in suggestion.suggestion\n    for param in carbs_instance.params:\n        assert param.name in suggestion.suggestion\ndef test_suggest_observe_ten(carbs_instance: CARBS) -> None:\n    num_to_suggest = 10",
        "detail": "deps.carbs.carbs.test_carbs",
        "documentation": {}
    },
    {
        "label": "test_suggest_observe_ten",
        "kind": 2,
        "importPath": "deps.carbs.carbs.test_carbs",
        "description": "deps.carbs.carbs.test_carbs",
        "peekOfCode": "def test_suggest_observe_ten(carbs_instance: CARBS) -> None:\n    num_to_suggest = 10\n    start_suggestions = len(carbs_instance.outstanding_suggestions)\n    start_success_observations = len(carbs_instance.success_observations)\n    for i in range(num_to_suggest):\n        suggestion = carbs_instance.suggest()\n        observation = ObservationInParam(input=suggestion.suggestion, output=i, cost=i + 1)\n        carbs_instance.observe(observation)\n    assert len(carbs_instance.outstanding_suggestions) == start_suggestions\n    assert len(carbs_instance.success_observations) == start_success_observations + num_to_suggest",
        "detail": "deps.carbs.carbs.test_carbs",
        "documentation": {}
    },
    {
        "label": "test_observe",
        "kind": 2,
        "importPath": "deps.carbs.carbs.test_carbs",
        "description": "deps.carbs.carbs.test_carbs",
        "peekOfCode": "def test_observe(carbs_instance: CARBS) -> None:\n    start_success_obs = len(carbs_instance.success_observations)\n    start_failure_obs = len(carbs_instance.failure_observations)\n    obs_success = ObservationInParam(input={x.name: x.search_center for x in carbs_instance.params}, output=1, cost=1)\n    obs_failure = ObservationInParam(\n        input={x.name: x.search_center for x in carbs_instance.params}, output=1, cost=1, is_failure=True\n    )\n    obs_success_output = carbs_instance.observe(obs_success)\n    obs_failure_output = carbs_instance.observe(obs_failure)\n    assert len(carbs_instance.success_observations) == start_success_obs + 1",
        "detail": "deps.carbs.carbs.test_carbs",
        "documentation": {}
    },
    {
        "label": "test_forget",
        "kind": 2,
        "importPath": "deps.carbs.carbs.test_carbs",
        "description": "deps.carbs.carbs.test_carbs",
        "peekOfCode": "def test_forget(carbs_instance: CARBS) -> None:\n    start_suggestions = len(carbs_instance.outstanding_suggestions)\n    suggestion = carbs_instance.suggest()\n    carbs_instance.forget_suggestion(suggestion.suggestion)\n    assert len(carbs_instance.outstanding_suggestions) == start_suggestions",
        "detail": "deps.carbs.carbs.test_carbs",
        "documentation": {}
    },
    {
        "label": "os.environ[\"WANDB_MODE\"]",
        "kind": 5,
        "importPath": "deps.carbs.carbs.test_carbs",
        "description": "deps.carbs.carbs.test_carbs",
        "peekOfCode": "os.environ[\"WANDB_MODE\"] = \"dryrun\"\n# Initialize wandb\nwandb.init(project=\"my_project\", job_type=\"train\")\n@pytest.fixture\ndef carbs_config() -> CARBSParams:\n    return CARBSParams(is_wandb_logging_enabled=False, is_saved_on_every_observation=False)\n@pytest.fixture\ndef params() -> List[Param]:\n    return [\n        Param(\"p1\", LogSpace(scale=1), 1e-2),",
        "detail": "deps.carbs.carbs.test_carbs",
        "documentation": {}
    },
    {
        "label": "ParamSpace",
        "kind": 6,
        "importPath": "deps.carbs.carbs.utils",
        "description": "deps.carbs.carbs.utils",
        "peekOfCode": "class ParamSpace(Serializable):\n    def basic_from_param(self, value: ParamType) -> Any:\n        raise NotImplementedError()\n    def param_from_basic(self, value: Any) -> ParamType:\n        raise NotImplementedError()\n    def drop_type(self) -> Any:\n        return self\n@attr.s(auto_attribs=True, frozen=True)\nclass Param:\n    name: str",
        "detail": "deps.carbs.carbs.utils",
        "documentation": {}
    },
    {
        "label": "Param",
        "kind": 6,
        "importPath": "deps.carbs.carbs.utils",
        "description": "deps.carbs.carbs.utils",
        "peekOfCode": "class Param:\n    name: str\n    space: ParamSpace\n    search_center: Union[float, int]\n@attr.s(auto_attribs=True, hash=True)\nclass RealNumberSpace(ParamSpace):\n    min: float = float(\"-inf\")\n    max: float = float(\"+inf\")\n    scale: float = 1.0\n    is_integer: bool = False",
        "detail": "deps.carbs.carbs.utils",
        "documentation": {}
    },
    {
        "label": "RealNumberSpace",
        "kind": 6,
        "importPath": "deps.carbs.carbs.utils",
        "description": "deps.carbs.carbs.utils",
        "peekOfCode": "class RealNumberSpace(ParamSpace):\n    min: float = float(\"-inf\")\n    max: float = float(\"+inf\")\n    scale: float = 1.0\n    is_integer: bool = False\n    rounding_factor: int = 1\n    def basic_from_param(self, value: ParamType) -> float:\n        raise NotImplementedError()\n    def param_from_basic(self, value: float, is_rounded: bool = True) -> ParamType:\n        raise NotImplementedError()",
        "detail": "deps.carbs.carbs.utils",
        "documentation": {}
    },
    {
        "label": "LinearSpace",
        "kind": 6,
        "importPath": "deps.carbs.carbs.utils",
        "description": "deps.carbs.carbs.utils",
        "peekOfCode": "class LinearSpace(RealNumberSpace):\n    min: float = float(\"-inf\")\n    max: float = float(\"+inf\")\n    def __attrs_post_init__(self) -> None:\n        if self.is_integer and self.scale < 3:\n            logger.info(\n                \"scale<3 on integer LinearSpace, so may not be able to search neighboring integers!\"\n            )\n    def basic_from_param(self, value: ParamType) -> float:\n        assert isinstance(value, (int, float))",
        "detail": "deps.carbs.carbs.utils",
        "documentation": {}
    },
    {
        "label": "LogSpace",
        "kind": 6,
        "importPath": "deps.carbs.carbs.utils",
        "description": "deps.carbs.carbs.utils",
        "peekOfCode": "class LogSpace(RealNumberSpace):\n    min: float = 0.0\n    max: float = float(\"+inf\")\n    base: int = 10\n    def basic_from_param(self, value: ParamType) -> float:\n        assert isinstance(value, (int, float))\n        if value == 0.0:\n            return float(\"-inf\")\n        return math.log(value, self.base) / self.scale\n    def param_from_basic(self, value: float, is_rounded: bool = True) -> float:",
        "detail": "deps.carbs.carbs.utils",
        "documentation": {}
    },
    {
        "label": "LogitSpace",
        "kind": 6,
        "importPath": "deps.carbs.carbs.utils",
        "description": "deps.carbs.carbs.utils",
        "peekOfCode": "class LogitSpace(RealNumberSpace):\n    min: float = 0.0\n    max: float = 1.0\n    def basic_from_param(self, value: ParamType) -> float:\n        assert isinstance(value, (int, float))\n        if value == 0.0:\n            return float(\"-inf\")\n        if value == 1.0:\n            return float(\"+inf\")\n        return math.log10(value / (1 - value)) / self.scale",
        "detail": "deps.carbs.carbs.utils",
        "documentation": {}
    },
    {
        "label": "ObservationInParam",
        "kind": 6,
        "importPath": "deps.carbs.carbs.utils",
        "description": "deps.carbs.carbs.utils",
        "peekOfCode": "class ObservationInParam(Serializable):\n    input: ParamDictType\n    output: float\n    cost: float = 1.0\n    is_failure: bool = False\n@attr.s(auto_attribs=True, collect_by_mro=True)\nclass ObservationInBasic(Serializable):\n    real_number_input: Tensor\n    output: float\n    cost: float = 1.0",
        "detail": "deps.carbs.carbs.utils",
        "documentation": {}
    },
    {
        "label": "ObservationInBasic",
        "kind": 6,
        "importPath": "deps.carbs.carbs.utils",
        "description": "deps.carbs.carbs.utils",
        "peekOfCode": "class ObservationInBasic(Serializable):\n    real_number_input: Tensor\n    output: float\n    cost: float = 1.0\n    suggestion_id: Optional[str] = None\n@attr.s(auto_attribs=True, collect_by_mro=True)\nclass SuggestionInBasic(Serializable):\n    real_number_input: Tensor\n    log_info: Dict[str, float] = attr.Factory(dict)\nclass OutstandingSuggestionEstimatorEnum(Enum):",
        "detail": "deps.carbs.carbs.utils",
        "documentation": {}
    },
    {
        "label": "SuggestionInBasic",
        "kind": 6,
        "importPath": "deps.carbs.carbs.utils",
        "description": "deps.carbs.carbs.utils",
        "peekOfCode": "class SuggestionInBasic(Serializable):\n    real_number_input: Tensor\n    log_info: Dict[str, float] = attr.Factory(dict)\nclass OutstandingSuggestionEstimatorEnum(Enum):\n    MEAN = \"MEAN\"\n    CONSTANT = \"CONSTANT\"\n    THOMPSON = \"THOMPSON\"\nclass SuggestionRedistributionMethodEnum(Enum):\n    NONE = \"NONE\"\n    LOG_COST_CLAMPING = \"LOG_COST_CLAMPING\"",
        "detail": "deps.carbs.carbs.utils",
        "documentation": {}
    },
    {
        "label": "OutstandingSuggestionEstimatorEnum",
        "kind": 6,
        "importPath": "deps.carbs.carbs.utils",
        "description": "deps.carbs.carbs.utils",
        "peekOfCode": "class OutstandingSuggestionEstimatorEnum(Enum):\n    MEAN = \"MEAN\"\n    CONSTANT = \"CONSTANT\"\n    THOMPSON = \"THOMPSON\"\nclass SuggestionRedistributionMethodEnum(Enum):\n    NONE = \"NONE\"\n    LOG_COST_CLAMPING = \"LOG_COST_CLAMPING\"\n@attr.s(auto_attribs=True, collect_by_mro=True)\nclass WandbLoggingParams(Serializable):\n    project_name: Optional[str] = None",
        "detail": "deps.carbs.carbs.utils",
        "documentation": {}
    },
    {
        "label": "SuggestionRedistributionMethodEnum",
        "kind": 6,
        "importPath": "deps.carbs.carbs.utils",
        "description": "deps.carbs.carbs.utils",
        "peekOfCode": "class SuggestionRedistributionMethodEnum(Enum):\n    NONE = \"NONE\"\n    LOG_COST_CLAMPING = \"LOG_COST_CLAMPING\"\n@attr.s(auto_attribs=True, collect_by_mro=True)\nclass WandbLoggingParams(Serializable):\n    project_name: Optional[str] = None\n    group_name: Optional[str] = None\n    run_name: Optional[str] = None\n    run_id: Optional[str] = None\n    is_suggestion_logged: bool = True",
        "detail": "deps.carbs.carbs.utils",
        "documentation": {}
    },
    {
        "label": "WandbLoggingParams",
        "kind": 6,
        "importPath": "deps.carbs.carbs.utils",
        "description": "deps.carbs.carbs.utils",
        "peekOfCode": "class WandbLoggingParams(Serializable):\n    project_name: Optional[str] = None\n    group_name: Optional[str] = None\n    run_name: Optional[str] = None\n    run_id: Optional[str] = None\n    is_suggestion_logged: bool = True\n    is_observation_logged: bool = True\n    is_search_space_logged: bool = True\n    root_dir: str = \"/mnt/private\"\n@attr.s(auto_attribs=True, collect_by_mro=True)",
        "detail": "deps.carbs.carbs.utils",
        "documentation": {}
    },
    {
        "label": "CARBSParams",
        "kind": 6,
        "importPath": "deps.carbs.carbs.utils",
        "description": "deps.carbs.carbs.utils",
        "peekOfCode": "class CARBSParams(Serializable):\n    \"\"\"\n    Set `better_direction_sign`, `max_suggestion_cost` and `wandb_params` for your run.\n    I'm not aware of any situation in which we should change the other parameters -- they are mostly for testing.\n    \"\"\"\n    better_direction_sign: int = attr.field(\n        validator=attr.validators.in_([-1, 1]), default=1\n    )  # 1 for maximizing, -1 for minimizing\n    seed: int = 0\n    # will do random suggestions until this many observations are made",
        "detail": "deps.carbs.carbs.utils",
        "documentation": {}
    },
    {
        "label": "SurrogateModelParams",
        "kind": 6,
        "importPath": "deps.carbs.carbs.utils",
        "description": "deps.carbs.carbs.utils",
        "peekOfCode": "class SurrogateModelParams(Serializable):\n    real_dims: int\n    better_direction_sign: int  # 1 for maximizing, -1 for minimizing\n    device: str = \"cpu\"\n    min_category_observations: int = 3\n    scale_length: float = 1\n    outstanding_suggestion_estimator: OutstandingSuggestionEstimatorEnum = (\n        OutstandingSuggestionEstimatorEnum.MEAN\n    )\n@attr.s(auto_attribs=True, collect_by_mro=True)",
        "detail": "deps.carbs.carbs.utils",
        "documentation": {}
    },
    {
        "label": "SuggestOutput",
        "kind": 6,
        "importPath": "deps.carbs.carbs.utils",
        "description": "deps.carbs.carbs.utils",
        "peekOfCode": "class SuggestOutput:\n    suggestion: ParamDictType\n    log: Dict[str, Any] = attr.Factory(dict)\n@attr.s(auto_attribs=True, collect_by_mro=True)\nclass ObserveOutput:\n    logs: Dict[str, Any] = attr.Factory(dict)\ndef load_observations_from_wandb_run(\n    run_name: str,\n    prefix: str = \"observation/\",\n    add_params: Optional[ParamDictType] = None,",
        "detail": "deps.carbs.carbs.utils",
        "documentation": {}
    },
    {
        "label": "ObserveOutput",
        "kind": 6,
        "importPath": "deps.carbs.carbs.utils",
        "description": "deps.carbs.carbs.utils",
        "peekOfCode": "class ObserveOutput:\n    logs: Dict[str, Any] = attr.Factory(dict)\ndef load_observations_from_wandb_run(\n    run_name: str,\n    prefix: str = \"observation/\",\n    add_params: Optional[ParamDictType] = None,\n) -> List[ObservationInParam]:\n    api = wandb.Api()\n    run = api.run(run_name)\n    history_df = run.history()",
        "detail": "deps.carbs.carbs.utils",
        "documentation": {}
    },
    {
        "label": "log_norm_cdf",
        "kind": 2,
        "importPath": "deps.carbs.carbs.utils",
        "description": "deps.carbs.carbs.utils",
        "peekOfCode": "def log_norm_cdf(z: Tensor):\n    \"\"\"\n    @MISC {256009,\n        TITLE = {Approximation of logarithm of standard normal CDF for x&lt;0},\n        AUTHOR = {Isaac Asher (https://stats.stackexchange.com/users/145180/isaac-asher)},\n        HOWPUBLISHED = {Cross Validated},\n        URL = {https://stats.stackexchange.com/q/256009}\n    }\n    This contains -z**2/2 which exactly cancels the same term in prior.log_prob for EI... We can then take the log\n    out of the exp for the simplified form below",
        "detail": "deps.carbs.carbs.utils",
        "documentation": {}
    },
    {
        "label": "expected_improvement",
        "kind": 2,
        "importPath": "deps.carbs.carbs.utils",
        "description": "deps.carbs.carbs.utils",
        "peekOfCode": "def expected_improvement(\n    mu: Tensor, variance: Tensor, best_mu: Tensor, exploration_bias: float = 0.5\n) -> Tensor:\n    prior = Normal(0, 1)\n    sigma = variance.sqrt()\n    z = (mu - best_mu - exploration_bias) / sigma\n    # original form:\n    # ei: Tensor = sigma * torch.exp(prior.log_prob(z)) * (1 + z * torch.exp(log_norm_cdf(z) - prior.log_prob(z)))\n    # simplified form:\n    wofz_output = wofz(-z.cpu() * 1j / math.sqrt(2)).real.to(z.device)",
        "detail": "deps.carbs.carbs.utils",
        "documentation": {}
    },
    {
        "label": "probability_of_improvement",
        "kind": 2,
        "importPath": "deps.carbs.carbs.utils",
        "description": "deps.carbs.carbs.utils",
        "peekOfCode": "def probability_of_improvement(\n    mu: Tensor,\n    variance: Tensor,\n    best_mu: Tensor,\n    better_direction_sign: int,\n    exploration_bias: float = 0.0,\n) -> Tensor:\n    prior = Normal(0, 1)\n    mu_improvement = (mu - best_mu) * better_direction_sign - exploration_bias\n    sigma = variance.sqrt()",
        "detail": "deps.carbs.carbs.utils",
        "documentation": {}
    },
    {
        "label": "aggregate_logical_and_across_dim",
        "kind": 2,
        "importPath": "deps.carbs.carbs.utils",
        "description": "deps.carbs.carbs.utils",
        "peekOfCode": "def aggregate_logical_and_across_dim(x: Tensor, dim: int = -1) -> Tensor:\n    \"\"\"\n    Takes in BoolTensor x, aggregates across dimension dim.\n    \"\"\"\n    return torch.min(torch.where(x, 1, 0), dim=dim).values > 0\ndef add_dict_key_prefix(input_dict: Dict[str, Any], prefix: str):\n    return {f\"{prefix}{k}\": v for k, v in input_dict.items()}\n@attr.s(auto_attribs=True, collect_by_mro=True)\nclass ObservationInParam(Serializable):\n    input: ParamDictType",
        "detail": "deps.carbs.carbs.utils",
        "documentation": {}
    },
    {
        "label": "add_dict_key_prefix",
        "kind": 2,
        "importPath": "deps.carbs.carbs.utils",
        "description": "deps.carbs.carbs.utils",
        "peekOfCode": "def add_dict_key_prefix(input_dict: Dict[str, Any], prefix: str):\n    return {f\"{prefix}{k}\": v for k, v in input_dict.items()}\n@attr.s(auto_attribs=True, collect_by_mro=True)\nclass ObservationInParam(Serializable):\n    input: ParamDictType\n    output: float\n    cost: float = 1.0\n    is_failure: bool = False\n@attr.s(auto_attribs=True, collect_by_mro=True)\nclass ObservationInBasic(Serializable):",
        "detail": "deps.carbs.carbs.utils",
        "documentation": {}
    },
    {
        "label": "load_observations_from_wandb_run",
        "kind": 2,
        "importPath": "deps.carbs.carbs.utils",
        "description": "deps.carbs.carbs.utils",
        "peekOfCode": "def load_observations_from_wandb_run(\n    run_name: str,\n    prefix: str = \"observation/\",\n    add_params: Optional[ParamDictType] = None,\n) -> List[ObservationInParam]:\n    api = wandb.Api()\n    run = api.run(run_name)\n    history_df = run.history()\n    observations: List[ObservationInParam] = []\n    for idx, row in (",
        "detail": "deps.carbs.carbs.utils",
        "documentation": {}
    },
    {
        "label": "get_checkpoint_obs_count",
        "kind": 2,
        "importPath": "deps.carbs.carbs.utils",
        "description": "deps.carbs.carbs.utils",
        "peekOfCode": "def get_checkpoint_obs_count(checkpoint_name: str) -> int:\n    return int(\n        checkpoint_name.removeprefix(CARBS_CHECKPOINT_PREFIX).removesuffix(\n            CARBS_CHECKPOINT_SUFFIX\n        )\n    )\ndef load_latest_checkpoint_from_wandb_run(\n    run_path: str, temp_dir: Optional[str] = None\n) -> str:\n    api = wandb.Api()",
        "detail": "deps.carbs.carbs.utils",
        "documentation": {}
    },
    {
        "label": "load_latest_checkpoint_from_wandb_run",
        "kind": 2,
        "importPath": "deps.carbs.carbs.utils",
        "description": "deps.carbs.carbs.utils",
        "peekOfCode": "def load_latest_checkpoint_from_wandb_run(\n    run_path: str, temp_dir: Optional[str] = None\n) -> str:\n    api = wandb.Api()\n    run = api.run(run_path)\n    checkpoint_filenames = [\n        file.name\n        for file in run.files()\n        if file.name.startswith(CARBS_CHECKPOINT_PREFIX)\n        and file.name.endswith(CARBS_CHECKPOINT_SUFFIX)",
        "detail": "deps.carbs.carbs.utils",
        "documentation": {}
    },
    {
        "label": "load_checkpoint_from_wandb_run",
        "kind": 2,
        "importPath": "deps.carbs.carbs.utils",
        "description": "deps.carbs.carbs.utils",
        "peekOfCode": "def load_checkpoint_from_wandb_run(\n    run_path: str, checkpoint_filename: str, temp_dir: Optional[str] = None\n) -> str:\n    if temp_dir is None:\n        temp_dir = f\"/tmp/carbs/{run_path}\"\n        os.makedirs(temp_dir, exist_ok=True)\n    checkpoint_path = wandb.restore(\n        checkpoint_filename, run_path=run_path, replace=True, root=temp_dir\n    )\n    assert checkpoint_path is not None, \"Could not load checkpoint\"",
        "detail": "deps.carbs.carbs.utils",
        "documentation": {}
    },
    {
        "label": "assert_empty",
        "kind": 2,
        "importPath": "deps.carbs.carbs.utils",
        "description": "deps.carbs.carbs.utils",
        "peekOfCode": "def assert_empty(x: Sized, message: str = \"unexpected elements\") -> None:\n    assert len(x) == 0, f\"{message}: {x}\"\ndef ordered_dict_index(od: OrderedDict, value: Any) -> int:\n    for i, k in enumerate(od.keys()):\n        if k == value:\n            return i\n    raise KeyError(f\"{value} not found in {od}\")\n# All members of an ObservationGroup have the same parameters\nObservationGroup = Tuple[ObservationInBasic, ...]\ndef group_observations(",
        "detail": "deps.carbs.carbs.utils",
        "documentation": {}
    },
    {
        "label": "ordered_dict_index",
        "kind": 2,
        "importPath": "deps.carbs.carbs.utils",
        "description": "deps.carbs.carbs.utils",
        "peekOfCode": "def ordered_dict_index(od: OrderedDict, value: Any) -> int:\n    for i, k in enumerate(od.keys()):\n        if k == value:\n            return i\n    raise KeyError(f\"{value} not found in {od}\")\n# All members of an ObservationGroup have the same parameters\nObservationGroup = Tuple[ObservationInBasic, ...]\ndef group_observations(\n    observations_in_basic: List[ObservationInBasic],\n) -> Tuple[ObservationGroup, ...]:",
        "detail": "deps.carbs.carbs.utils",
        "documentation": {}
    },
    {
        "label": "group_observations",
        "kind": 2,
        "importPath": "deps.carbs.carbs.utils",
        "description": "deps.carbs.carbs.utils",
        "peekOfCode": "def group_observations(\n    observations_in_basic: List[ObservationInBasic],\n) -> Tuple[ObservationGroup, ...]:\n    \"\"\"\n    Gets observations grouped by matching input params\n    \"\"\"\n    outputs: List[ObservationGroup] = []\n    observations = observations_in_basic.copy()\n    observations.sort(key=lambda x: tuple(v.item() for v in x.real_number_input))\n    while len(observations) > 0:",
        "detail": "deps.carbs.carbs.utils",
        "documentation": {}
    },
    {
        "label": "observation_group_cost",
        "kind": 2,
        "importPath": "deps.carbs.carbs.utils",
        "description": "deps.carbs.carbs.utils",
        "peekOfCode": "def observation_group_cost(group: Sequence[ObservationInBasic]) -> float:\n    return sum(obs.cost for obs in group) / len(group)\ndef observation_group_output(group: Sequence[ObservationInBasic]) -> float:\n    return sum(obs.output for obs in group) / len(group)\ndef pareto_area_from_groups(obs_groups: Tuple[ObservationGroup, ...]) -> float:\n    if len(obs_groups) < 2:\n        return 0\n    last_cost = observation_group_cost(obs_groups[0])\n    last_output = observation_group_output(obs_groups[0])\n    total_area = 0.0",
        "detail": "deps.carbs.carbs.utils",
        "documentation": {}
    },
    {
        "label": "observation_group_output",
        "kind": 2,
        "importPath": "deps.carbs.carbs.utils",
        "description": "deps.carbs.carbs.utils",
        "peekOfCode": "def observation_group_output(group: Sequence[ObservationInBasic]) -> float:\n    return sum(obs.output for obs in group) / len(group)\ndef pareto_area_from_groups(obs_groups: Tuple[ObservationGroup, ...]) -> float:\n    if len(obs_groups) < 2:\n        return 0\n    last_cost = observation_group_cost(obs_groups[0])\n    last_output = observation_group_output(obs_groups[0])\n    total_area = 0.0\n    for group in obs_groups[1:]:\n        new_cost = observation_group_cost(group)",
        "detail": "deps.carbs.carbs.utils",
        "documentation": {}
    },
    {
        "label": "pareto_area_from_groups",
        "kind": 2,
        "importPath": "deps.carbs.carbs.utils",
        "description": "deps.carbs.carbs.utils",
        "peekOfCode": "def pareto_area_from_groups(obs_groups: Tuple[ObservationGroup, ...]) -> float:\n    if len(obs_groups) < 2:\n        return 0\n    last_cost = observation_group_cost(obs_groups[0])\n    last_output = observation_group_output(obs_groups[0])\n    total_area = 0.0\n    for group in obs_groups[1:]:\n        new_cost = observation_group_cost(group)\n        new_output = observation_group_output(group)\n        total_area += (new_cost - last_cost) * last_output",
        "detail": "deps.carbs.carbs.utils",
        "documentation": {}
    },
    {
        "label": "get_pareto_groups",
        "kind": 2,
        "importPath": "deps.carbs.carbs.utils",
        "description": "deps.carbs.carbs.utils",
        "peekOfCode": "def get_pareto_groups(\n    grouped_observations: Tuple[ObservationGroup, ...],\n    min_pareto_cost_fraction: float,\n    better_direction_sign: int,\n) -> Tuple[ObservationGroup, ...]:\n    min_pareto_cost = np.quantile(\n        np.array([x.cost for group in grouped_observations for x in group]),\n        min_pareto_cost_fraction,\n    )\n    observations_below_min_threshold = [",
        "detail": "deps.carbs.carbs.utils",
        "documentation": {}
    },
    {
        "label": "get_pareto_groups_conservative",
        "kind": 2,
        "importPath": "deps.carbs.carbs.utils",
        "description": "deps.carbs.carbs.utils",
        "peekOfCode": "def get_pareto_groups_conservative(\n    grouped_observations: Tuple[ObservationGroup, ...],\n    min_pareto_cost_fraction: float,\n    better_direction_sign: int,\n) -> Tuple[ObservationGroup, ...]:\n    \"\"\"\n    Just like get_pareto_groups but prefers groups with multiple samples. A single sample can only be \"better\" if\n    it is better than the max of the previous group. However, a multiple sample group is better if the mean is higher.\n    For example, with better_direction_sign=1:\n    Group A: ((output=0,cost=1),(output=1,cost=1))       # mean=0.5",
        "detail": "deps.carbs.carbs.utils",
        "documentation": {}
    },
    {
        "label": "get_pareto_curve_plot",
        "kind": 2,
        "importPath": "deps.carbs.carbs.utils",
        "description": "deps.carbs.carbs.utils",
        "peekOfCode": "def get_pareto_curve_plot(\n    observations: List[ObservationInBasic],\n    pareto_groups: Tuple[ObservationGroup, ...],\n    save_dir: Optional[str] = None,\n    obs_count: Optional[int] = None,\n) -> Optional[str]:\n    sns.set_theme(style=\"whitegrid\")\n    plt.clf()\n    pareto_set = [obs for group in pareto_groups for obs in group]\n    plt.scatter(",
        "detail": "deps.carbs.carbs.utils",
        "documentation": {}
    },
    {
        "label": "ParamType",
        "kind": 5,
        "importPath": "deps.carbs.carbs.utils",
        "description": "deps.carbs.carbs.utils",
        "peekOfCode": "ParamType = Union[int, float, str, bool, Enum]\nParamDictType = Dict[str, ParamType]\n@attr.s(auto_attribs=True, hash=True)\nclass ParamSpace(Serializable):\n    def basic_from_param(self, value: ParamType) -> Any:\n        raise NotImplementedError()\n    def param_from_basic(self, value: Any) -> ParamType:\n        raise NotImplementedError()\n    def drop_type(self) -> Any:\n        return self",
        "detail": "deps.carbs.carbs.utils",
        "documentation": {}
    },
    {
        "label": "ParamDictType",
        "kind": 5,
        "importPath": "deps.carbs.carbs.utils",
        "description": "deps.carbs.carbs.utils",
        "peekOfCode": "ParamDictType = Dict[str, ParamType]\n@attr.s(auto_attribs=True, hash=True)\nclass ParamSpace(Serializable):\n    def basic_from_param(self, value: ParamType) -> Any:\n        raise NotImplementedError()\n    def param_from_basic(self, value: Any) -> ParamType:\n        raise NotImplementedError()\n    def drop_type(self) -> Any:\n        return self\n@attr.s(auto_attribs=True, frozen=True)",
        "detail": "deps.carbs.carbs.utils",
        "documentation": {}
    },
    {
        "label": "CategoricalTuple",
        "kind": 5,
        "importPath": "deps.carbs.carbs.utils",
        "description": "deps.carbs.carbs.utils",
        "peekOfCode": "CategoricalTuple = Tuple[int, ...]\nSUGGESTION_ID_DICT_KEY = \"suggestion_uuid\"\ndef log_norm_cdf(z: Tensor):\n    \"\"\"\n    @MISC {256009,\n        TITLE = {Approximation of logarithm of standard normal CDF for x&lt;0},\n        AUTHOR = {Isaac Asher (https://stats.stackexchange.com/users/145180/isaac-asher)},\n        HOWPUBLISHED = {Cross Validated},\n        URL = {https://stats.stackexchange.com/q/256009}\n    }",
        "detail": "deps.carbs.carbs.utils",
        "documentation": {}
    },
    {
        "label": "SUGGESTION_ID_DICT_KEY",
        "kind": 5,
        "importPath": "deps.carbs.carbs.utils",
        "description": "deps.carbs.carbs.utils",
        "peekOfCode": "SUGGESTION_ID_DICT_KEY = \"suggestion_uuid\"\ndef log_norm_cdf(z: Tensor):\n    \"\"\"\n    @MISC {256009,\n        TITLE = {Approximation of logarithm of standard normal CDF for x&lt;0},\n        AUTHOR = {Isaac Asher (https://stats.stackexchange.com/users/145180/isaac-asher)},\n        HOWPUBLISHED = {Cross Validated},\n        URL = {https://stats.stackexchange.com/q/256009}\n    }\n    This contains -z**2/2 which exactly cancels the same term in prior.log_prob for EI... We can then take the log",
        "detail": "deps.carbs.carbs.utils",
        "documentation": {}
    },
    {
        "label": "CARBS_CHECKPOINT_PREFIX",
        "kind": 5,
        "importPath": "deps.carbs.carbs.utils",
        "description": "deps.carbs.carbs.utils",
        "peekOfCode": "CARBS_CHECKPOINT_PREFIX = \"carbs_\"\nCARBS_CHECKPOINT_SUFFIX = \"obs.pt\"\ndef get_checkpoint_obs_count(checkpoint_name: str) -> int:\n    return int(\n        checkpoint_name.removeprefix(CARBS_CHECKPOINT_PREFIX).removesuffix(\n            CARBS_CHECKPOINT_SUFFIX\n        )\n    )\ndef load_latest_checkpoint_from_wandb_run(\n    run_path: str, temp_dir: Optional[str] = None",
        "detail": "deps.carbs.carbs.utils",
        "documentation": {}
    },
    {
        "label": "CARBS_CHECKPOINT_SUFFIX",
        "kind": 5,
        "importPath": "deps.carbs.carbs.utils",
        "description": "deps.carbs.carbs.utils",
        "peekOfCode": "CARBS_CHECKPOINT_SUFFIX = \"obs.pt\"\ndef get_checkpoint_obs_count(checkpoint_name: str) -> int:\n    return int(\n        checkpoint_name.removeprefix(CARBS_CHECKPOINT_PREFIX).removesuffix(\n            CARBS_CHECKPOINT_SUFFIX\n        )\n    )\ndef load_latest_checkpoint_from_wandb_run(\n    run_path: str, temp_dir: Optional[str] = None\n) -> str:",
        "detail": "deps.carbs.carbs.utils",
        "documentation": {}
    },
    {
        "label": "ObservationGroup",
        "kind": 5,
        "importPath": "deps.carbs.carbs.utils",
        "description": "deps.carbs.carbs.utils",
        "peekOfCode": "ObservationGroup = Tuple[ObservationInBasic, ...]\ndef group_observations(\n    observations_in_basic: List[ObservationInBasic],\n) -> Tuple[ObservationGroup, ...]:\n    \"\"\"\n    Gets observations grouped by matching input params\n    \"\"\"\n    outputs: List[ObservationGroup] = []\n    observations = observations_in_basic.copy()\n    observations.sort(key=lambda x: tuple(v.item() for v in x.real_number_input))",
        "detail": "deps.carbs.carbs.utils",
        "documentation": {}
    },
    {
        "label": "ext_modules",
        "kind": 5,
        "importPath": "deps.fast_gae.setup",
        "description": "deps.fast_gae.setup",
        "peekOfCode": "ext_modules = [\n    Extension(\n            name=\"fast_gae.fast_gae\",\n            sources=[\"fast_gae/fast_gae.pyx\"],\n            define_macros=[('NPY_NO_DEPRECATED_API', 'NPY_1_7_API_VERSION')],\n            include_dirs=[numpy.get_include()],\n        )\n]\ndebug = os.getenv('DEBUG', '0') == '1'\nannotate = os.getenv('ANNOTATE', '0') == '1'",
        "detail": "deps.fast_gae.setup",
        "documentation": {}
    },
    {
        "label": "debug",
        "kind": 5,
        "importPath": "deps.fast_gae.setup",
        "description": "deps.fast_gae.setup",
        "peekOfCode": "debug = os.getenv('DEBUG', '0') == '1'\nannotate = os.getenv('ANNOTATE', '0') == '1'\nBUILD_DIR = 'build'\nif debug:\n    BUILD_DIR = 'build_debug'\nos.makedirs(BUILD_DIR, exist_ok=True)\nsetup(\n    name='fast_gae',\n    packages=find_packages(),\n    ext_modules=cythonize(",
        "detail": "deps.fast_gae.setup",
        "documentation": {}
    },
    {
        "label": "annotate",
        "kind": 5,
        "importPath": "deps.fast_gae.setup",
        "description": "deps.fast_gae.setup",
        "peekOfCode": "annotate = os.getenv('ANNOTATE', '0') == '1'\nBUILD_DIR = 'build'\nif debug:\n    BUILD_DIR = 'build_debug'\nos.makedirs(BUILD_DIR, exist_ok=True)\nsetup(\n    name='fast_gae',\n    packages=find_packages(),\n    ext_modules=cythonize(\n        ext_modules,",
        "detail": "deps.fast_gae.setup",
        "documentation": {}
    },
    {
        "label": "BUILD_DIR",
        "kind": 5,
        "importPath": "deps.fast_gae.setup",
        "description": "deps.fast_gae.setup",
        "peekOfCode": "BUILD_DIR = 'build'\nif debug:\n    BUILD_DIR = 'build_debug'\nos.makedirs(BUILD_DIR, exist_ok=True)\nsetup(\n    name='fast_gae',\n    packages=find_packages(),\n    ext_modules=cythonize(\n        ext_modules,\n        build_dir=BUILD_DIR,",
        "detail": "deps.fast_gae.setup",
        "documentation": {}
    },
    {
        "label": "NoAliasDumper",
        "kind": 6,
        "importPath": "deps.mettagrid.mettagrid.config.game_builder",
        "description": "deps.mettagrid.mettagrid.config.game_builder",
        "peekOfCode": "class NoAliasDumper(yaml.Dumper):\n    def ignore_aliases(self, data):\n        return True\nclass MettaGridGameBuilder():\n    def __init__(\n            self,\n            obs_width: int,\n            obs_height: int,\n            tile_size: int,\n            max_steps: int,",
        "detail": "deps.mettagrid.mettagrid.config.game_builder",
        "documentation": {}
    },
    {
        "label": "MettaGridGameBuilder",
        "kind": 6,
        "importPath": "deps.mettagrid.mettagrid.config.game_builder",
        "description": "deps.mettagrid.mettagrid.config.game_builder",
        "peekOfCode": "class MettaGridGameBuilder():\n    def __init__(\n            self,\n            obs_width: int,\n            obs_height: int,\n            tile_size: int,\n            max_steps: int,\n            num_agents: int,\n            no_energy_steps: int,\n            objects,",
        "detail": "deps.mettagrid.mettagrid.config.game_builder",
        "documentation": {}
    },
    {
        "label": "sample_config",
        "kind": 2,
        "importPath": "deps.mettagrid.mettagrid.config.sample_config",
        "description": "deps.mettagrid.mettagrid.config.sample_config",
        "peekOfCode": "def sample_config(value):\n    if isinstance(value, int):\n        return value\n    if isinstance(value, float):\n        return value\n    if isinstance(value, DictConfig):\n        return {\n            key: sample_config(value)\n            for key, value in value.items()\n        }",
        "detail": "deps.mettagrid.mettagrid.config.sample_config",
        "documentation": {}
    },
    {
        "label": "ObjectRenderer",
        "kind": 6,
        "importPath": "deps.mettagrid.mettagrid.renderer.raylib_renderer",
        "description": "deps.mettagrid.mettagrid.renderer.raylib_renderer",
        "peekOfCode": "class ObjectRenderer:\n    def __init__(self, sprite_sheet, tile_size=24):\n        sprites_dir = \"deps/mettagrid/mettagrid/renderer/assets/\"\n        sprite_sheet_path = os.path.join(sprites_dir, sprite_sheet)\n        assert os.path.exists(sprite_sheet_path), f\"Sprite sheet {sprite_sheet_path} does not exist\"\n        self.sprite_sheet = rl.LoadTexture(sprite_sheet_path.encode())\n        self.tile_size = tile_size\n    def _sprite_sheet_idx(self, obj):\n        return (0, 0)\n    def render(self, obj, render_tile_size):",
        "detail": "deps.mettagrid.mettagrid.renderer.raylib_renderer",
        "documentation": {}
    },
    {
        "label": "AgentRenderer",
        "kind": 6,
        "importPath": "deps.mettagrid.mettagrid.renderer.raylib_renderer",
        "description": "deps.mettagrid.mettagrid.renderer.raylib_renderer",
        "peekOfCode": "class AgentRenderer(ObjectRenderer):\n    def __init__(self, cfg: OmegaConf):\n        super().__init__(\"monsters.png\", 16)\n        self.cfg = cfg\n    def _sprite_sheet_idx(self, obj):\n        # orientation: 0 = Up, 1 = Down, 2 = Left, 3 = Right\n        # sprites: 0 = Right, 1 = Up, 2 = Down, 3 = Left\n        orientation_offset = [1, 2, 3, 0][obj[\"agent:orientation\"]]\n        return (4 * ((obj[\"agent_id\"] // 12) % 4) + orientation_offset, 2 * (obj[\"agent_id\"] % 12))\n    def render(self, obj, render_tile_size):",
        "detail": "deps.mettagrid.mettagrid.renderer.raylib_renderer",
        "documentation": {}
    },
    {
        "label": "WallRenderer",
        "kind": 6,
        "importPath": "deps.mettagrid.mettagrid.renderer.raylib_renderer",
        "description": "deps.mettagrid.mettagrid.renderer.raylib_renderer",
        "peekOfCode": "class WallRenderer(ObjectRenderer):\n    def __init__(self):\n        super().__init__(\"wall.png\")\nclass GeneratorRenderer(ObjectRenderer):\n    def __init__(self):\n        super().__init__(\"items.png\", 16)\n    def _sprite_sheet_idx(self, obj):\n        if obj[\"generator:ready\"]:\n            return (14, 2)\n        else:",
        "detail": "deps.mettagrid.mettagrid.renderer.raylib_renderer",
        "documentation": {}
    },
    {
        "label": "GeneratorRenderer",
        "kind": 6,
        "importPath": "deps.mettagrid.mettagrid.renderer.raylib_renderer",
        "description": "deps.mettagrid.mettagrid.renderer.raylib_renderer",
        "peekOfCode": "class GeneratorRenderer(ObjectRenderer):\n    def __init__(self):\n        super().__init__(\"items.png\", 16)\n    def _sprite_sheet_idx(self, obj):\n        if obj[\"generator:ready\"]:\n            return (14, 2)\n        else:\n            return (13, 2)\nclass ConverterRenderer(ObjectRenderer):\n    def __init__(self):",
        "detail": "deps.mettagrid.mettagrid.renderer.raylib_renderer",
        "documentation": {}
    },
    {
        "label": "ConverterRenderer",
        "kind": 6,
        "importPath": "deps.mettagrid.mettagrid.renderer.raylib_renderer",
        "description": "deps.mettagrid.mettagrid.renderer.raylib_renderer",
        "peekOfCode": "class ConverterRenderer(ObjectRenderer):\n    def __init__(self):\n        super().__init__(\"items.png\", 16)\n    def _sprite_sheet_idx(self, obj):\n        if obj[\"converter:ready\"]:\n            return (12, 0)\n        else:\n            return (13, 0)\nclass AltarRenderer(ObjectRenderer):\n    def __init__(self):",
        "detail": "deps.mettagrid.mettagrid.renderer.raylib_renderer",
        "documentation": {}
    },
    {
        "label": "AltarRenderer",
        "kind": 6,
        "importPath": "deps.mettagrid.mettagrid.renderer.raylib_renderer",
        "description": "deps.mettagrid.mettagrid.renderer.raylib_renderer",
        "peekOfCode": "class AltarRenderer(ObjectRenderer):\n    def __init__(self):\n        super().__init__(\"items.png\", 16)\n    def _sprite_sheet_idx(self, obj):\n        if obj[\"altar:ready\"]:\n            return (11, 2)\n        else:\n            return (12, 2)\nclass MettaGridRaylibRenderer:\n    def __init__(self, map_width: int, map_height: int, cfg: OmegaConf):",
        "detail": "deps.mettagrid.mettagrid.renderer.raylib_renderer",
        "documentation": {}
    },
    {
        "label": "MettaGridRaylibRenderer",
        "kind": 6,
        "importPath": "deps.mettagrid.mettagrid.renderer.raylib_renderer",
        "description": "deps.mettagrid.mettagrid.renderer.raylib_renderer",
        "peekOfCode": "class MettaGridRaylibRenderer:\n    def __init__(self, map_width: int, map_height: int, cfg: OmegaConf):\n        self.width = map_width\n        self.height = map_height\n        self.sidebar_width = 250\n        self.tile_size = cfg.game.tile_size\n        self.cfg = cfg\n        rl.InitWindow(self.width*self.tile_size + self.sidebar_width, self.height*self.tile_size,\n            \"PufferLib Ray Grid\".encode())\n        # Load custom font",
        "detail": "deps.mettagrid.mettagrid.renderer.raylib_renderer",
        "documentation": {}
    },
    {
        "label": "Actions",
        "kind": 5,
        "importPath": "deps.mettagrid.mettagrid.renderer.raylib_renderer",
        "description": "deps.mettagrid.mettagrid.renderer.raylib_renderer",
        "peekOfCode": "Actions = SimpleNamespace(\n    Noop = 0,\n    Move = 1,\n    Rotate = 2,\n    Use = 3,\n    Attack = 4,\n    ToggleShield = 5,\n)\nclass ObjectRenderer:\n    def __init__(self, sprite_sheet, tile_size=24):",
        "detail": "deps.mettagrid.mettagrid.renderer.raylib_renderer",
        "documentation": {}
    },
    {
        "label": "MettaGridEnv",
        "kind": 6,
        "importPath": "deps.mettagrid.mettagrid.mettagrid_env",
        "description": "deps.mettagrid.mettagrid.mettagrid_env",
        "peekOfCode": "class MettaGridEnv(pufferlib.PufferEnv):\n    def __init__(self, render_mode: str, **cfg):\n        super().__init__()\n        self._render_mode = render_mode\n        self._cfg = OmegaConf.create(cfg)\n        self.make_env()\n        self._renderer = None\n        self.done = False\n        self.buf = None\n    def make_env(self):",
        "detail": "deps.mettagrid.mettagrid.mettagrid_env",
        "documentation": {}
    },
    {
        "label": "build_ext",
        "kind": 2,
        "importPath": "deps.mettagrid.setup",
        "description": "deps.mettagrid.setup",
        "peekOfCode": "def build_ext(srcs, module_name=None):\n    if module_name is None:\n        module_name = srcs[0].replace(\"/\", \".\").replace(\".pyx\", \"\").replace(\".cpp\", \"\")\n    return Extension(\n        module_name,\n        srcs,\n        # include_dirs=[\"third_party/puffergrid\"],\n        define_macros=[('NPY_NO_DEPRECATED_API', 'NPY_1_7_API_VERSION')],\n    )\next_modules = [",
        "detail": "deps.mettagrid.setup",
        "documentation": {}
    },
    {
        "label": "ext_modules",
        "kind": 5,
        "importPath": "deps.mettagrid.setup",
        "description": "deps.mettagrid.setup",
        "peekOfCode": "ext_modules = [\n    build_ext([\"mettagrid/objects.pyx\"]),\n    build_ext([\"mettagrid/actions/actions.pyx\"]),\n    build_ext([\"mettagrid/actions/attack.pyx\"]),\n    build_ext([\"mettagrid/actions/gift.pyx\"]),\n    build_ext([\"mettagrid/actions/move.pyx\"]),\n    build_ext([\"mettagrid/actions/noop.pyx\"]),\n    build_ext([\"mettagrid/actions/rotate.pyx\"]),\n    build_ext([\"mettagrid/actions/shield.pyx\"]),\n    build_ext([\"mettagrid/actions/use.pyx\"]),",
        "detail": "deps.mettagrid.setup",
        "documentation": {}
    },
    {
        "label": "debug",
        "kind": 5,
        "importPath": "deps.mettagrid.setup",
        "description": "deps.mettagrid.setup",
        "peekOfCode": "debug = os.getenv('DEBUG', '0') == '1'\nannotate = os.getenv('ANNOTATE', '0') == '1'\nbuild_dir = 'build'\nif debug:\n    build_dir = 'build_debug'\nos.makedirs(build_dir, exist_ok=True)\nsetup(\n    name='metta',\n    version='0.1',\n    packages=find_packages(),",
        "detail": "deps.mettagrid.setup",
        "documentation": {}
    },
    {
        "label": "annotate",
        "kind": 5,
        "importPath": "deps.mettagrid.setup",
        "description": "deps.mettagrid.setup",
        "peekOfCode": "annotate = os.getenv('ANNOTATE', '0') == '1'\nbuild_dir = 'build'\nif debug:\n    build_dir = 'build_debug'\nos.makedirs(build_dir, exist_ok=True)\nsetup(\n    name='metta',\n    version='0.1',\n    packages=find_packages(),\n    install_requires=[",
        "detail": "deps.mettagrid.setup",
        "documentation": {}
    },
    {
        "label": "build_dir",
        "kind": 5,
        "importPath": "deps.mettagrid.setup",
        "description": "deps.mettagrid.setup",
        "peekOfCode": "build_dir = 'build'\nif debug:\n    build_dir = 'build_debug'\nos.makedirs(build_dir, exist_ok=True)\nsetup(\n    name='metta',\n    version='0.1',\n    packages=find_packages(),\n    install_requires=[\n        \"hydra-core\",",
        "detail": "deps.mettagrid.setup",
        "documentation": {}
    },
    {
        "label": "test_performance",
        "kind": 2,
        "importPath": "deps.mettagrid.test_perf",
        "description": "deps.mettagrid.test_perf",
        "peekOfCode": "def test_performance(env, actions, duration):\n    tick = 0\n    num_actions = actions.shape[0]\n    start = time.time()\n    with tqdm(total=duration, desc=\"Running performance test\") as pbar:\n        while time.time() - start < duration:\n            atns = actions[tick % num_actions]\n            obs, rewards, terminated, truncated, infos = env.step(atns)\n            tick += 1\n            if tick % 100 == 0:",
        "detail": "deps.mettagrid.test_perf",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "deps.mettagrid.test_perf",
        "description": "deps.mettagrid.test_perf",
        "peekOfCode": "def main(cfg):\n    # Run with c profile\n    from cProfile import run\n    global env\n    cfg.env.game.max_steps = 999999999\n    env = hydra.utils.instantiate(cfg.env, render_mode=\"human\")\n    env.reset()\n    global actions\n    num_agents = cfg.env.game.num_agents\n    actions = np.random.randint(0, env.action_space.nvec, (1024, num_agents, 2), dtype=np.uint32)",
        "detail": "deps.mettagrid.test_perf",
        "documentation": {}
    },
    {
        "label": "print_stats",
        "kind": 2,
        "importPath": "deps.mettagrid.test_perf",
        "description": "deps.mettagrid.test_perf",
        "peekOfCode": "def print_stats(stats):\n    # Extract game_stats\n    game_stats = stats[\"game\"]\n    # Extract agent_stats\n    agent_stats = stats[\"agent\"]\n    # Calculate total, average, min, and max for each agent stat\n    total_agent_stats = {}\n    avg_agent_stats = {}\n    min_agent_stats = {}\n    max_agent_stats = {}",
        "detail": "deps.mettagrid.test_perf",
        "documentation": {}
    },
    {
        "label": "actions",
        "kind": 5,
        "importPath": "deps.mettagrid.test_perf",
        "description": "deps.mettagrid.test_perf",
        "peekOfCode": "actions = {}\nenv = {}\n@hydra.main(version_base=None, config_path=\"configs\", config_name=\"a20_40x40\")\ndef main(cfg):\n    # Run with c profile\n    from cProfile import run\n    global env\n    cfg.env.game.max_steps = 999999999\n    env = hydra.utils.instantiate(cfg.env, render_mode=\"human\")\n    env.reset()",
        "detail": "deps.mettagrid.test_perf",
        "documentation": {}
    },
    {
        "label": "env",
        "kind": 5,
        "importPath": "deps.mettagrid.test_perf",
        "description": "deps.mettagrid.test_perf",
        "peekOfCode": "env = {}\n@hydra.main(version_base=None, config_path=\"configs\", config_name=\"a20_40x40\")\ndef main(cfg):\n    # Run with c profile\n    from cProfile import run\n    global env\n    cfg.env.game.max_steps = 999999999\n    env = hydra.utils.instantiate(cfg.env, render_mode=\"human\")\n    env.reset()\n    global actions",
        "detail": "deps.mettagrid.test_perf",
        "documentation": {}
    },
    {
        "label": "PufferGridEnv",
        "kind": 6,
        "importPath": "deps.puffergrid.puffergrid.wrappers.grid_env_wrapper",
        "description": "deps.puffergrid.puffergrid.wrappers.grid_env_wrapper",
        "peekOfCode": "class PufferGridEnv(PufferEnv):\n    def __init__(self, c_env) -> None:\n        super().__init__()\n        self._c_env = c_env\n        (o, tm, tr, re) = self._c_env.get_buffers()\n        self._buffers = SimpleNamespace(\n            observations=o,\n            terminals=tm,\n            truncations=tr,\n            rewards=re",
        "detail": "deps.puffergrid.puffergrid.wrappers.grid_env_wrapper",
        "documentation": {}
    },
    {
        "label": "CustomBuildExtCommand",
        "kind": 6,
        "importPath": "deps.puffergrid.setup",
        "description": "deps.puffergrid.setup",
        "peekOfCode": "class CustomBuildExtCommand(_build_ext):\n    def run(self):\n        self.run_command('build_ext')\n        super().run()\nsetup(\n    name='puffergrid',\n    packages=find_packages(),\n    ext_modules=cythonize(\n        ext_modules,\n        build_dir=build_dir,",
        "detail": "deps.puffergrid.setup",
        "documentation": {}
    },
    {
        "label": "build_ext",
        "kind": 2,
        "importPath": "deps.puffergrid.setup",
        "description": "deps.puffergrid.setup",
        "peekOfCode": "def build_ext(srcs, package=\"puffergrid\"):\n    return Extension(\n        name=package + \".\" + srcs[0].split('/')[-1].split('.')[0],\n        sources=srcs,\n        define_macros=[('NPY_NO_DEPRECATED_API', 'NPY_1_7_API_VERSION')],\n        include_dirs=[numpy.get_include()],\n    )\next_modules = [\n    build_ext([\"puffergrid/action.pyx\"]),\n    build_ext([\"puffergrid/event.pyx\"]),",
        "detail": "deps.puffergrid.setup",
        "documentation": {}
    },
    {
        "label": "ext_modules",
        "kind": 5,
        "importPath": "deps.puffergrid.setup",
        "description": "deps.puffergrid.setup",
        "peekOfCode": "ext_modules = [\n    build_ext([\"puffergrid/action.pyx\"]),\n    build_ext([\"puffergrid/event.pyx\"]),\n    build_ext([\"puffergrid/grid.cpp\"]),\n    build_ext([\"puffergrid/grid_env.pyx\"]),\n    build_ext([\"puffergrid/grid_object.pyx\"]),\n    build_ext([\"puffergrid/observation_encoder.pyx\"]),\n    build_ext([\"puffergrid/stats_tracker.pyx\"]),\n    build_ext([\"examples/forage.pyx\"], \"puffergrid.examples\"),\n]",
        "detail": "deps.puffergrid.setup",
        "documentation": {}
    },
    {
        "label": "debug",
        "kind": 5,
        "importPath": "deps.puffergrid.setup",
        "description": "deps.puffergrid.setup",
        "peekOfCode": "debug = os.getenv('DEBUG', '0') == '1'\nannotate = os.getenv('ANNOTATE', '0') == '1'\nbuild_dir = 'build'\nif debug:\n    build_dir = 'build_debug'\nos.makedirs(build_dir, exist_ok=True)\nos.makedirs(\"puffergrid/tests\", exist_ok=True)\nos.makedirs(\"puffergrid/examples\", exist_ok=True)\nclass CustomBuildExtCommand(_build_ext):\n    def run(self):",
        "detail": "deps.puffergrid.setup",
        "documentation": {}
    },
    {
        "label": "annotate",
        "kind": 5,
        "importPath": "deps.puffergrid.setup",
        "description": "deps.puffergrid.setup",
        "peekOfCode": "annotate = os.getenv('ANNOTATE', '0') == '1'\nbuild_dir = 'build'\nif debug:\n    build_dir = 'build_debug'\nos.makedirs(build_dir, exist_ok=True)\nos.makedirs(\"puffergrid/tests\", exist_ok=True)\nos.makedirs(\"puffergrid/examples\", exist_ok=True)\nclass CustomBuildExtCommand(_build_ext):\n    def run(self):\n        self.run_command('build_ext')",
        "detail": "deps.puffergrid.setup",
        "documentation": {}
    },
    {
        "label": "build_dir",
        "kind": 5,
        "importPath": "deps.puffergrid.setup",
        "description": "deps.puffergrid.setup",
        "peekOfCode": "build_dir = 'build'\nif debug:\n    build_dir = 'build_debug'\nos.makedirs(build_dir, exist_ok=True)\nos.makedirs(\"puffergrid/tests\", exist_ok=True)\nos.makedirs(\"puffergrid/examples\", exist_ok=True)\nclass CustomBuildExtCommand(_build_ext):\n    def run(self):\n        self.run_command('build_ext')\n        super().run()",
        "detail": "deps.puffergrid.setup",
        "documentation": {}
    },
    {
        "label": "test_performance",
        "kind": 2,
        "importPath": "deps.puffergrid.test_perf",
        "description": "deps.puffergrid.test_perf",
        "peekOfCode": "def test_performance(env, actions, duration, max_steps):\n    tick = 0\n    num_actions = actions.shape[0]\n    start = time.time()\n    with tqdm(total=duration, desc=\"Running performance test\") as pbar:\n        while time.time() - start < duration and (max_steps < 0 or tick < max_steps):\n            atns = actions[tick % num_actions]\n            env.step(atns)\n            # env.render()\n            tick += 1",
        "detail": "deps.puffergrid.test_perf",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "deps.puffergrid.test_perf",
        "description": "deps.puffergrid.test_perf",
        "peekOfCode": "def main():\n    parser = argparse.ArgumentParser(description=\"Performance testing script\")\n    parser.add_argument('--profile', action='store_true', help='Run with cProfile')\n    parser.add_argument('--env', type=str, default='examples.forage.Forage', help='Environment class to use')\n    parser.add_argument('--num_agents', type=int, default=20, help='Number of agents')\n    parser.add_argument('--duration', type=int, default=20, help='Duration of test')\n    parser.add_argument('--max_steps', type=int, default=-1, help='Max number of steps to simulate')\n    args = parser.parse_args()\n    module_name, class_name = args.env.rsplit('.', 1)\n    module = importlib.import_module(f'puffergrid.{module_name}')",
        "detail": "deps.puffergrid.test_perf",
        "documentation": {}
    },
    {
        "label": "make_env",
        "kind": 5,
        "importPath": "deps.pufferlib.examples.demo_emulation",
        "description": "deps.pufferlib.examples.demo_emulation",
        "peekOfCode": "make_env = minihack.env_creator()\nenv = make_env()\n# Unwrapped environment\nprint('Raw environment:', env.env)\nprint('Raw observation space:', env.env.observation_space.keys())\nprint('Raw action space:', env.env.action_space)\nbreakpoint()\nprint()\nprint('---')\nprint()",
        "detail": "deps.pufferlib.examples.demo_emulation",
        "documentation": {}
    },
    {
        "label": "env",
        "kind": 5,
        "importPath": "deps.pufferlib.examples.demo_emulation",
        "description": "deps.pufferlib.examples.demo_emulation",
        "peekOfCode": "env = make_env()\n# Unwrapped environment\nprint('Raw environment:', env.env)\nprint('Raw observation space:', env.env.observation_space.keys())\nprint('Raw action space:', env.env.action_space)\nbreakpoint()\nprint()\nprint('---')\nprint()\n# Wrapped environment",
        "detail": "deps.pufferlib.examples.demo_emulation",
        "documentation": {}
    },
    {
        "label": "struct_obs",
        "kind": 5,
        "importPath": "deps.pufferlib.examples.demo_emulation",
        "description": "deps.pufferlib.examples.demo_emulation",
        "peekOfCode": "struct_obs = flat_obs.view(env.emulated.emulated_observation_dtype)[0]\nprint('[red]blstats:', struct_obs['blstats'].shape, struct_obs['blstats'].dtype)\nprint('[red]chars:', struct_obs['chars'].shape, struct_obs['chars'].dtype)\nprint('[red]glyphs:', struct_obs['glyphs'].shape, struct_obs['glyphs'].dtype)\nbreakpoint()\nprint()\nprint('---')\nprint()\n# Vectorized demo\nimport pufferlib.vector",
        "detail": "deps.pufferlib.examples.demo_emulation",
        "documentation": {}
    },
    {
        "label": "vecenv",
        "kind": 5,
        "importPath": "deps.pufferlib.examples.demo_emulation",
        "description": "deps.pufferlib.examples.demo_emulation",
        "peekOfCode": "vecenv = pufferlib.vector.make(make_env, num_envs=4)\nflat_obs, _ = vecenv.reset()\nstruct_obs = flat_obs.view(env.emulated.emulated_observation_dtype)[:, 0]\nprint('Flat batch:', flat_obs.shape)\nprint('[red]blstats:', struct_obs['blstats'].shape, struct_obs['blstats'].dtype)\nprint('[red]chars:', struct_obs['chars'].shape, struct_obs['chars'].dtype)\nprint('[red]glyphs:', struct_obs['glyphs'].shape, struct_obs['glyphs'].dtype)",
        "detail": "deps.pufferlib.examples.demo_emulation",
        "documentation": {}
    },
    {
        "label": "struct_obs",
        "kind": 5,
        "importPath": "deps.pufferlib.examples.demo_emulation",
        "description": "deps.pufferlib.examples.demo_emulation",
        "peekOfCode": "struct_obs = flat_obs.view(env.emulated.emulated_observation_dtype)[:, 0]\nprint('Flat batch:', flat_obs.shape)\nprint('[red]blstats:', struct_obs['blstats'].shape, struct_obs['blstats'].dtype)\nprint('[red]chars:', struct_obs['chars'].shape, struct_obs['chars'].dtype)\nprint('[red]glyphs:', struct_obs['glyphs'].shape, struct_obs['glyphs'].dtype)",
        "detail": "deps.pufferlib.examples.demo_emulation",
        "documentation": {}
    },
    {
        "label": "Args",
        "kind": 6,
        "importPath": "deps.pufferlib.examples.large_ppo_atari",
        "description": "deps.pufferlib.examples.large_ppo_atari",
        "peekOfCode": "class Args:\n    exp_name: str = os.path.basename(__file__)[: -len(\".py\")]\n    \"\"\"the name of this experiment\"\"\"\n    seed: int = 1\n    \"\"\"seed of the experiment\"\"\"\n    torch_deterministic: bool = True\n    \"\"\"if toggled, `torch.backends.cudnn.deterministic=False`\"\"\"\n    cuda: bool = True\n    \"\"\"if toggled, cuda will be enabled by default\"\"\"\n    track: bool = False",
        "detail": "deps.pufferlib.examples.large_ppo_atari",
        "documentation": {}
    },
    {
        "label": "Agent",
        "kind": 6,
        "importPath": "deps.pufferlib.examples.large_ppo_atari",
        "description": "deps.pufferlib.examples.large_ppo_atari",
        "peekOfCode": "class Agent(nn.Module):\n    def __init__(self, envs):\n        super().__init__()\n        self.network = nn.Sequential(\n            layer_init(nn.Conv2d(4, 32, 8, stride=4)),\n            nn.ReLU(),\n            layer_init(nn.Conv2d(32, 64, 4, stride=2)),\n            nn.ReLU(),\n            layer_init(nn.Conv2d(64, 64, 3, stride=1)),\n            nn.ReLU(),",
        "detail": "deps.pufferlib.examples.large_ppo_atari",
        "documentation": {}
    },
    {
        "label": "make_env",
        "kind": 2,
        "importPath": "deps.pufferlib.examples.large_ppo_atari",
        "description": "deps.pufferlib.examples.large_ppo_atari",
        "peekOfCode": "def make_env(env_id, idx, capture_video, run_name):\n    def thunk():\n        if capture_video and idx == 0:\n            env = gym.make(env_id, render_mode=\"rgb_array\")\n            env = gym.wrappers.RecordVideo(env, f\"videos/{run_name}\")\n        else:\n            env = gym.make(env_id)\n        env = gym.wrappers.RecordEpisodeStatistics(env)\n        env = NoopResetEnv(env, noop_max=30)\n        env = MaxAndSkipEnv(env, skip=4)",
        "detail": "deps.pufferlib.examples.large_ppo_atari",
        "documentation": {}
    },
    {
        "label": "layer_init",
        "kind": 2,
        "importPath": "deps.pufferlib.examples.large_ppo_atari",
        "description": "deps.pufferlib.examples.large_ppo_atari",
        "peekOfCode": "def layer_init(layer, std=np.sqrt(2), bias_const=0.0):\n    torch.nn.init.orthogonal_(layer.weight, std)\n    torch.nn.init.constant_(layer.bias, bias_const)\n    return layer\nclass Agent(nn.Module):\n    def __init__(self, envs):\n        super().__init__()\n        self.network = nn.Sequential(\n            layer_init(nn.Conv2d(4, 32, 8, stride=4)),\n            nn.ReLU(),",
        "detail": "deps.pufferlib.examples.large_ppo_atari",
        "documentation": {}
    },
    {
        "label": "Args",
        "kind": 6,
        "importPath": "deps.pufferlib.examples.large_ppo_atari_envpool",
        "description": "deps.pufferlib.examples.large_ppo_atari_envpool",
        "peekOfCode": "class Args:\n    exp_name: str = os.path.basename(__file__)[: -len(\".py\")]\n    \"\"\"the name of this experiment\"\"\"\n    seed: int = 1\n    \"\"\"seed of the experiment\"\"\"\n    torch_deterministic: bool = True\n    \"\"\"if toggled, `torch.backends.cudnn.deterministic=False`\"\"\"\n    cuda: bool = True\n    \"\"\"if toggled, cuda will be enabled by default\"\"\"\n    track: bool = False",
        "detail": "deps.pufferlib.examples.large_ppo_atari_envpool",
        "documentation": {}
    },
    {
        "label": "RecordEpisodeStatistics",
        "kind": 6,
        "importPath": "deps.pufferlib.examples.large_ppo_atari_envpool",
        "description": "deps.pufferlib.examples.large_ppo_atari_envpool",
        "peekOfCode": "class RecordEpisodeStatistics(gym.Wrapper):\n    def __init__(self, env, deque_size=100):\n        super().__init__(env)\n        self.num_envs = getattr(env, \"num_envs\", 1)\n        self.episode_returns = None\n        self.episode_lengths = None\n    def reset(self, **kwargs):\n        observations = super().reset(**kwargs)\n        self.episode_returns = np.zeros(self.num_envs, dtype=np.float32)\n        self.episode_lengths = np.zeros(self.num_envs, dtype=np.int32)",
        "detail": "deps.pufferlib.examples.large_ppo_atari_envpool",
        "documentation": {}
    },
    {
        "label": "Agent",
        "kind": 6,
        "importPath": "deps.pufferlib.examples.large_ppo_atari_envpool",
        "description": "deps.pufferlib.examples.large_ppo_atari_envpool",
        "peekOfCode": "class Agent(nn.Module):\n    def __init__(self, envs):\n        super().__init__()\n        self.network = nn.Sequential(\n            layer_init(nn.Conv2d(4, 32, 8, stride=4)),\n            nn.ReLU(),\n            layer_init(nn.Conv2d(32, 64, 4, stride=2)),\n            nn.ReLU(),\n            layer_init(nn.Conv2d(64, 64, 3, stride=1)),\n            nn.ReLU(),",
        "detail": "deps.pufferlib.examples.large_ppo_atari_envpool",
        "documentation": {}
    },
    {
        "label": "layer_init",
        "kind": 2,
        "importPath": "deps.pufferlib.examples.large_ppo_atari_envpool",
        "description": "deps.pufferlib.examples.large_ppo_atari_envpool",
        "peekOfCode": "def layer_init(layer, std=np.sqrt(2), bias_const=0.0):\n    torch.nn.init.orthogonal_(layer.weight, std)\n    torch.nn.init.constant_(layer.bias, bias_const)\n    return layer\nclass Agent(nn.Module):\n    def __init__(self, envs):\n        super().__init__()\n        self.network = nn.Sequential(\n            layer_init(nn.Conv2d(4, 32, 8, stride=4)),\n            nn.ReLU(),",
        "detail": "deps.pufferlib.examples.large_ppo_atari_envpool",
        "documentation": {}
    },
    {
        "label": "Args",
        "kind": 6,
        "importPath": "deps.pufferlib.examples.large_puffer_ppo_atari",
        "description": "deps.pufferlib.examples.large_puffer_ppo_atari",
        "peekOfCode": "class Args:\n    exp_name: str = os.path.basename(__file__)[: -len(\".py\")]\n    \"\"\"the name of this experiment\"\"\"\n    seed: int = 1\n    \"\"\"seed of the experiment\"\"\"\n    torch_deterministic: bool = True\n    \"\"\"if toggled, `torch.backends.cudnn.deterministic=False`\"\"\"\n    cuda: bool = True\n    \"\"\"if toggled, cuda will be enabled by default\"\"\"\n    track: bool = False",
        "detail": "deps.pufferlib.examples.large_puffer_ppo_atari",
        "documentation": {}
    },
    {
        "label": "Agent",
        "kind": 6,
        "importPath": "deps.pufferlib.examples.large_puffer_ppo_atari",
        "description": "deps.pufferlib.examples.large_puffer_ppo_atari",
        "peekOfCode": "class Agent(nn.Module):\n    def __init__(self, envs):\n        super().__init__()\n        self.network = nn.Sequential(\n            layer_init(nn.Conv2d(4, 32, 8, stride=4)),\n            nn.ReLU(),\n            layer_init(nn.Conv2d(32, 64, 4, stride=2)),\n            nn.ReLU(),\n            layer_init(nn.Conv2d(64, 64, 3, stride=1)),\n            nn.ReLU(),",
        "detail": "deps.pufferlib.examples.large_puffer_ppo_atari",
        "documentation": {}
    },
    {
        "label": "make_env",
        "kind": 2,
        "importPath": "deps.pufferlib.examples.large_puffer_ppo_atari",
        "description": "deps.pufferlib.examples.large_puffer_ppo_atari",
        "peekOfCode": "def make_env(env_id, idx, capture_video, run_name):\n    def thunk():\n        if capture_video and idx == 0:\n            env = gym.make(env_id, render_mode=\"rgb_array\")\n            env = gym.wrappers.RecordVideo(env, f\"videos/{run_name}\")\n        else:\n            env = gym.make(env_id)\n        env = gym.wrappers.RecordEpisodeStatistics(env)\n        env = NoopResetEnv(env, noop_max=30)\n        env = MaxAndSkipEnv(env, skip=4)",
        "detail": "deps.pufferlib.examples.large_puffer_ppo_atari",
        "documentation": {}
    },
    {
        "label": "layer_init",
        "kind": 2,
        "importPath": "deps.pufferlib.examples.large_puffer_ppo_atari",
        "description": "deps.pufferlib.examples.large_puffer_ppo_atari",
        "peekOfCode": "def layer_init(layer, std=np.sqrt(2), bias_const=0.0):\n    torch.nn.init.orthogonal_(layer.weight, std)\n    torch.nn.init.constant_(layer.bias, bias_const)\n    return layer\nclass Agent(nn.Module):\n    def __init__(self, envs):\n        super().__init__()\n        self.network = nn.Sequential(\n            layer_init(nn.Conv2d(4, 32, 8, stride=4)),\n            nn.ReLU(),",
        "detail": "deps.pufferlib.examples.large_puffer_ppo_atari",
        "documentation": {}
    },
    {
        "label": "Args",
        "kind": 6,
        "importPath": "deps.pufferlib.examples.ppo_atari",
        "description": "deps.pufferlib.examples.ppo_atari",
        "peekOfCode": "class Args:\n    exp_name: str = os.path.basename(__file__)[: -len(\".py\")]\n    \"\"\"the name of this experiment\"\"\"\n    seed: int = 1\n    \"\"\"seed of the experiment\"\"\"\n    torch_deterministic: bool = True\n    \"\"\"if toggled, `torch.backends.cudnn.deterministic=False`\"\"\"\n    cuda: bool = True\n    \"\"\"if toggled, cuda will be enabled by default\"\"\"\n    track: bool = False",
        "detail": "deps.pufferlib.examples.ppo_atari",
        "documentation": {}
    },
    {
        "label": "Agent",
        "kind": 6,
        "importPath": "deps.pufferlib.examples.ppo_atari",
        "description": "deps.pufferlib.examples.ppo_atari",
        "peekOfCode": "class Agent(nn.Module):\n    def __init__(self, envs):\n        super().__init__()\n        self.network = nn.Sequential(\n            layer_init(nn.Conv2d(4, 32, 8, stride=4)),\n            nn.ReLU(),\n            layer_init(nn.Conv2d(32, 64, 4, stride=2)),\n            nn.ReLU(),\n            layer_init(nn.Conv2d(64, 64, 3, stride=1)),\n            nn.ReLU(),",
        "detail": "deps.pufferlib.examples.ppo_atari",
        "documentation": {}
    },
    {
        "label": "make_env",
        "kind": 2,
        "importPath": "deps.pufferlib.examples.ppo_atari",
        "description": "deps.pufferlib.examples.ppo_atari",
        "peekOfCode": "def make_env(env_id, idx, capture_video, run_name):\n    def thunk():\n        if capture_video and idx == 0:\n            env = gym.make(env_id, render_mode=\"rgb_array\")\n            env = gym.wrappers.RecordVideo(env, f\"videos/{run_name}\")\n        else:\n            env = gym.make(env_id)\n        env = gym.wrappers.RecordEpisodeStatistics(env)\n        env = NoopResetEnv(env, noop_max=30)\n        env = MaxAndSkipEnv(env, skip=4)",
        "detail": "deps.pufferlib.examples.ppo_atari",
        "documentation": {}
    },
    {
        "label": "layer_init",
        "kind": 2,
        "importPath": "deps.pufferlib.examples.ppo_atari",
        "description": "deps.pufferlib.examples.ppo_atari",
        "peekOfCode": "def layer_init(layer, std=np.sqrt(2), bias_const=0.0):\n    torch.nn.init.orthogonal_(layer.weight, std)\n    torch.nn.init.constant_(layer.bias, bias_const)\n    return layer\nclass Agent(nn.Module):\n    def __init__(self, envs):\n        super().__init__()\n        self.network = nn.Sequential(\n            layer_init(nn.Conv2d(4, 32, 8, stride=4)),\n            nn.ReLU(),",
        "detail": "deps.pufferlib.examples.ppo_atari",
        "documentation": {}
    },
    {
        "label": "Args",
        "kind": 6,
        "importPath": "deps.pufferlib.examples.ppo_atari_envpool",
        "description": "deps.pufferlib.examples.ppo_atari_envpool",
        "peekOfCode": "class Args:\n    exp_name: str = os.path.basename(__file__)[: -len(\".py\")]\n    \"\"\"the name of this experiment\"\"\"\n    seed: int = 1\n    \"\"\"seed of the experiment\"\"\"\n    torch_deterministic: bool = True\n    \"\"\"if toggled, `torch.backends.cudnn.deterministic=False`\"\"\"\n    cuda: bool = True\n    \"\"\"if toggled, cuda will be enabled by default\"\"\"\n    track: bool = False",
        "detail": "deps.pufferlib.examples.ppo_atari_envpool",
        "documentation": {}
    },
    {
        "label": "RecordEpisodeStatistics",
        "kind": 6,
        "importPath": "deps.pufferlib.examples.ppo_atari_envpool",
        "description": "deps.pufferlib.examples.ppo_atari_envpool",
        "peekOfCode": "class RecordEpisodeStatistics(gym.Wrapper):\n    def __init__(self, env, deque_size=100):\n        super().__init__(env)\n        self.num_envs = getattr(env, \"num_envs\", 1)\n        self.episode_returns = None\n        self.episode_lengths = None\n    def reset(self, **kwargs):\n        observations = super().reset(**kwargs)\n        self.episode_returns = np.zeros(self.num_envs, dtype=np.float32)\n        self.episode_lengths = np.zeros(self.num_envs, dtype=np.int32)",
        "detail": "deps.pufferlib.examples.ppo_atari_envpool",
        "documentation": {}
    },
    {
        "label": "Agent",
        "kind": 6,
        "importPath": "deps.pufferlib.examples.ppo_atari_envpool",
        "description": "deps.pufferlib.examples.ppo_atari_envpool",
        "peekOfCode": "class Agent(nn.Module):\n    def __init__(self, envs):\n        super().__init__()\n        self.network = nn.Sequential(\n            layer_init(nn.Conv2d(4, 32, 8, stride=4)),\n            nn.ReLU(),\n            layer_init(nn.Conv2d(32, 64, 4, stride=2)),\n            nn.ReLU(),\n            layer_init(nn.Conv2d(64, 64, 3, stride=1)),\n            nn.ReLU(),",
        "detail": "deps.pufferlib.examples.ppo_atari_envpool",
        "documentation": {}
    },
    {
        "label": "layer_init",
        "kind": 2,
        "importPath": "deps.pufferlib.examples.ppo_atari_envpool",
        "description": "deps.pufferlib.examples.ppo_atari_envpool",
        "peekOfCode": "def layer_init(layer, std=np.sqrt(2), bias_const=0.0):\n    torch.nn.init.orthogonal_(layer.weight, std)\n    torch.nn.init.constant_(layer.bias, bias_const)\n    return layer\nclass Agent(nn.Module):\n    def __init__(self, envs):\n        super().__init__()\n        self.network = nn.Sequential(\n            layer_init(nn.Conv2d(4, 32, 8, stride=4)),\n            nn.ReLU(),",
        "detail": "deps.pufferlib.examples.ppo_atari_envpool",
        "documentation": {}
    },
    {
        "label": "Args",
        "kind": 6,
        "importPath": "deps.pufferlib.examples.ppo_minihack",
        "description": "deps.pufferlib.examples.ppo_minihack",
        "peekOfCode": "class Args:\n    exp_name: str = os.path.basename(__file__)[: -len(\".py\")]\n    \"\"\"the name of this experiment\"\"\"\n    seed: int = 1\n    \"\"\"seed of the experiment\"\"\"\n    torch_deterministic: bool = True\n    \"\"\"if toggled, `torch.backends.cudnn.deterministic=False`\"\"\"\n    cuda: bool = True\n    \"\"\"if toggled, cuda will be enabled by default\"\"\"\n    track: bool = False",
        "detail": "deps.pufferlib.examples.ppo_minihack",
        "documentation": {}
    },
    {
        "label": "Agent",
        "kind": 6,
        "importPath": "deps.pufferlib.examples.ppo_minihack",
        "description": "deps.pufferlib.examples.ppo_minihack",
        "peekOfCode": "class Agent(nn.Module):\n    def __init__(self, emulated):\n        super().__init__()\n        self.dtype = pufferlib.pytorch.nativize_dtype(emulated)\n        self.blstats_net = nn.Sequential(\n            nn.Embedding(256, 32),\n            nn.Flatten(),\n        )\n        self.char_embed = nn.Embedding(256, 32)\n        self.chars_net = nn.Sequential(",
        "detail": "deps.pufferlib.examples.ppo_minihack",
        "documentation": {}
    },
    {
        "label": "make_env",
        "kind": 2,
        "importPath": "deps.pufferlib.examples.ppo_minihack",
        "description": "deps.pufferlib.examples.ppo_minihack",
        "peekOfCode": "def make_env(name):\n    def thunk():\n        import minihack\n        env = old_gym.make(name)\n        env = shimmy.GymV21CompatibilityV0(env=env)\n        return env\n    return thunk\ndef layer_init(layer, std=np.sqrt(2), bias_const=0.0):\n    torch.nn.init.orthogonal_(layer.weight, std)\n    torch.nn.init.constant_(layer.bias, bias_const)",
        "detail": "deps.pufferlib.examples.ppo_minihack",
        "documentation": {}
    },
    {
        "label": "layer_init",
        "kind": 2,
        "importPath": "deps.pufferlib.examples.ppo_minihack",
        "description": "deps.pufferlib.examples.ppo_minihack",
        "peekOfCode": "def layer_init(layer, std=np.sqrt(2), bias_const=0.0):\n    torch.nn.init.orthogonal_(layer.weight, std)\n    torch.nn.init.constant_(layer.bias, bias_const)\n    return layer\nclass Agent(nn.Module):\n    def __init__(self, emulated):\n        super().__init__()\n        self.dtype = pufferlib.pytorch.nativize_dtype(emulated)\n        self.blstats_net = nn.Sequential(\n            nn.Embedding(256, 32),",
        "detail": "deps.pufferlib.examples.ppo_minihack",
        "documentation": {}
    },
    {
        "label": "Args",
        "kind": 6,
        "importPath": "deps.pufferlib.examples.puffer_ppo_atari",
        "description": "deps.pufferlib.examples.puffer_ppo_atari",
        "peekOfCode": "class Args:\n    exp_name: str = os.path.basename(__file__)[: -len(\".py\")]\n    \"\"\"the name of this experiment\"\"\"\n    seed: int = 1\n    \"\"\"seed of the experiment\"\"\"\n    torch_deterministic: bool = True\n    \"\"\"if toggled, `torch.backends.cudnn.deterministic=False`\"\"\"\n    cuda: bool = True\n    \"\"\"if toggled, cuda will be enabled by default\"\"\"\n    track: bool = False",
        "detail": "deps.pufferlib.examples.puffer_ppo_atari",
        "documentation": {}
    },
    {
        "label": "Agent",
        "kind": 6,
        "importPath": "deps.pufferlib.examples.puffer_ppo_atari",
        "description": "deps.pufferlib.examples.puffer_ppo_atari",
        "peekOfCode": "class Agent(nn.Module):\n    def __init__(self, envs):\n        super().__init__()\n        self.network = nn.Sequential(\n            layer_init(nn.Conv2d(4, 32, 8, stride=4)),\n            nn.ReLU(),\n            layer_init(nn.Conv2d(32, 64, 4, stride=2)),\n            nn.ReLU(),\n            layer_init(nn.Conv2d(64, 64, 3, stride=1)),\n            nn.ReLU(),",
        "detail": "deps.pufferlib.examples.puffer_ppo_atari",
        "documentation": {}
    },
    {
        "label": "make_env",
        "kind": 2,
        "importPath": "deps.pufferlib.examples.puffer_ppo_atari",
        "description": "deps.pufferlib.examples.puffer_ppo_atari",
        "peekOfCode": "def make_env(env_id, idx, capture_video, run_name):\n    def thunk():\n        if capture_video and idx == 0:\n            env = gym.make(env_id, render_mode=\"rgb_array\")\n            env = gym.wrappers.RecordVideo(env, f\"videos/{run_name}\")\n        else:\n            env = gym.make(env_id)\n        env = gym.wrappers.RecordEpisodeStatistics(env)\n        env = NoopResetEnv(env, noop_max=30)\n        env = MaxAndSkipEnv(env, skip=4)",
        "detail": "deps.pufferlib.examples.puffer_ppo_atari",
        "documentation": {}
    },
    {
        "label": "layer_init",
        "kind": 2,
        "importPath": "deps.pufferlib.examples.puffer_ppo_atari",
        "description": "deps.pufferlib.examples.puffer_ppo_atari",
        "peekOfCode": "def layer_init(layer, std=np.sqrt(2), bias_const=0.0):\n    torch.nn.init.orthogonal_(layer.weight, std)\n    torch.nn.init.constant_(layer.bias, bias_const)\n    return layer\nclass Agent(nn.Module):\n    def __init__(self, envs):\n        super().__init__()\n        self.network = nn.Sequential(\n            layer_init(nn.Conv2d(4, 32, 8, stride=4)),\n            nn.ReLU(),",
        "detail": "deps.pufferlib.examples.puffer_ppo_atari",
        "documentation": {}
    },
    {
        "label": "Args",
        "kind": 6,
        "importPath": "deps.pufferlib.examples.puffer_ppo_minihack",
        "description": "deps.pufferlib.examples.puffer_ppo_minihack",
        "peekOfCode": "class Args:\n    exp_name: str = os.path.basename(__file__)[: -len(\".py\")]\n    \"\"\"the name of this experiment\"\"\"\n    seed: int = 1\n    \"\"\"seed of the experiment\"\"\"\n    torch_deterministic: bool = True\n    \"\"\"if toggled, `torch.backends.cudnn.deterministic=False`\"\"\"\n    cuda: bool = True\n    \"\"\"if toggled, cuda will be enabled by default\"\"\"\n    track: bool = False",
        "detail": "deps.pufferlib.examples.puffer_ppo_minihack",
        "documentation": {}
    },
    {
        "label": "Agent",
        "kind": 6,
        "importPath": "deps.pufferlib.examples.puffer_ppo_minihack",
        "description": "deps.pufferlib.examples.puffer_ppo_minihack",
        "peekOfCode": "class Agent(nn.Module):\n    def __init__(self, emulated):\n        super().__init__()\n        self.dtype = pufferlib.pytorch.nativize_dtype(emulated)\n        self.blstats_net = nn.Sequential(\n            nn.Embedding(256, 32),\n            nn.Flatten(),\n        )\n        self.char_embed = nn.Embedding(256, 32)\n        self.chars_net = nn.Sequential(",
        "detail": "deps.pufferlib.examples.puffer_ppo_minihack",
        "documentation": {}
    },
    {
        "label": "make_env",
        "kind": 2,
        "importPath": "deps.pufferlib.examples.puffer_ppo_minihack",
        "description": "deps.pufferlib.examples.puffer_ppo_minihack",
        "peekOfCode": "def make_env(name):\n    def thunk():\n        import minihack\n        env = old_gym.make(name)\n        env = shimmy.GymV21CompatibilityV0(env=env)\n        env = pufferlib.emulation.GymnasiumPufferEnv(env)\n        return env\n    return thunk\ndef layer_init(layer, std=np.sqrt(2), bias_const=0.0):\n    torch.nn.init.orthogonal_(layer.weight, std)",
        "detail": "deps.pufferlib.examples.puffer_ppo_minihack",
        "documentation": {}
    },
    {
        "label": "layer_init",
        "kind": 2,
        "importPath": "deps.pufferlib.examples.puffer_ppo_minihack",
        "description": "deps.pufferlib.examples.puffer_ppo_minihack",
        "peekOfCode": "def layer_init(layer, std=np.sqrt(2), bias_const=0.0):\n    torch.nn.init.orthogonal_(layer.weight, std)\n    torch.nn.init.constant_(layer.bias, bias_const)\n    return layer\nclass Agent(nn.Module):\n    def __init__(self, emulated):\n        super().__init__()\n        self.dtype = pufferlib.pytorch.nativize_dtype(emulated)\n        self.blstats_net = nn.Sequential(\n            nn.Embedding(256, 32),",
        "detail": "deps.pufferlib.examples.puffer_ppo_minihack",
        "documentation": {}
    },
    {
        "label": "Args",
        "kind": 6,
        "importPath": "deps.pufferlib.examples.puffer_vec_ppo_minihack",
        "description": "deps.pufferlib.examples.puffer_vec_ppo_minihack",
        "peekOfCode": "class Args:\n    exp_name: str = os.path.basename(__file__)[: -len(\".py\")]\n    \"\"\"the name of this experiment\"\"\"\n    seed: int = 1\n    \"\"\"seed of the experiment\"\"\"\n    torch_deterministic: bool = True\n    \"\"\"if toggled, `torch.backends.cudnn.deterministic=False`\"\"\"\n    cuda: bool = True\n    \"\"\"if toggled, cuda will be enabled by default\"\"\"\n    track: bool = False",
        "detail": "deps.pufferlib.examples.puffer_vec_ppo_minihack",
        "documentation": {}
    },
    {
        "label": "Agent",
        "kind": 6,
        "importPath": "deps.pufferlib.examples.puffer_vec_ppo_minihack",
        "description": "deps.pufferlib.examples.puffer_vec_ppo_minihack",
        "peekOfCode": "class Agent(nn.Module):\n    def __init__(self, emulated):\n        super().__init__()\n        self.dtype = pufferlib.pytorch.nativize_dtype(emulated)\n        self.blstats_net = nn.Sequential(\n            nn.Embedding(256, 32),\n            nn.Flatten(),\n        )\n        self.char_embed = nn.Embedding(256, 32)\n        self.chars_net = nn.Sequential(",
        "detail": "deps.pufferlib.examples.puffer_vec_ppo_minihack",
        "documentation": {}
    },
    {
        "label": "layer_init",
        "kind": 2,
        "importPath": "deps.pufferlib.examples.puffer_vec_ppo_minihack",
        "description": "deps.pufferlib.examples.puffer_vec_ppo_minihack",
        "peekOfCode": "def layer_init(layer, std=np.sqrt(2), bias_const=0.0):\n    torch.nn.init.orthogonal_(layer.weight, std)\n    torch.nn.init.constant_(layer.bias, bias_const)\n    return layer\nclass Agent(nn.Module):\n    def __init__(self, emulated):\n        super().__init__()\n        self.dtype = pufferlib.pytorch.nativize_dtype(emulated)\n        self.blstats_net = nn.Sequential(\n            nn.Embedding(256, 32),",
        "detail": "deps.pufferlib.examples.puffer_vec_ppo_minihack",
        "documentation": {}
    },
    {
        "label": "Args",
        "kind": 6,
        "importPath": "deps.pufferlib.examples.vanilla_ppo_atari",
        "description": "deps.pufferlib.examples.vanilla_ppo_atari",
        "peekOfCode": "class Args:\n    exp_name: str = os.path.basename(__file__)[: -len(\".py\")]\n    \"\"\"the name of this experiment\"\"\"\n    seed: int = 1\n    \"\"\"seed of the experiment\"\"\"\n    torch_deterministic: bool = True\n    \"\"\"if toggled, `torch.backends.cudnn.deterministic=False`\"\"\"\n    cuda: bool = True\n    \"\"\"if toggled, cuda will be enabled by default\"\"\"\n    track: bool = False",
        "detail": "deps.pufferlib.examples.vanilla_ppo_atari",
        "documentation": {}
    },
    {
        "label": "Agent",
        "kind": 6,
        "importPath": "deps.pufferlib.examples.vanilla_ppo_atari",
        "description": "deps.pufferlib.examples.vanilla_ppo_atari",
        "peekOfCode": "class Agent(nn.Module):\n    def __init__(self, envs):\n        super().__init__()\n        self.network = nn.Sequential(\n            layer_init(nn.Conv2d(4, 32, 8, stride=4)),\n            nn.ReLU(),\n            layer_init(nn.Conv2d(32, 64, 4, stride=2)),\n            nn.ReLU(),\n            layer_init(nn.Conv2d(64, 64, 3, stride=1)),\n            nn.ReLU(),",
        "detail": "deps.pufferlib.examples.vanilla_ppo_atari",
        "documentation": {}
    },
    {
        "label": "make_env",
        "kind": 2,
        "importPath": "deps.pufferlib.examples.vanilla_ppo_atari",
        "description": "deps.pufferlib.examples.vanilla_ppo_atari",
        "peekOfCode": "def make_env(env_id, idx, capture_video, run_name):\n    def thunk():\n        if capture_video and idx == 0:\n            env = gym.make(env_id, render_mode=\"rgb_array\")\n            env = gym.wrappers.RecordVideo(env, f\"videos/{run_name}\")\n        else:\n            env = gym.make(env_id)\n        env = gym.wrappers.RecordEpisodeStatistics(env)\n        env = NoopResetEnv(env, noop_max=30)\n        env = MaxAndSkipEnv(env, skip=4)",
        "detail": "deps.pufferlib.examples.vanilla_ppo_atari",
        "documentation": {}
    },
    {
        "label": "layer_init",
        "kind": 2,
        "importPath": "deps.pufferlib.examples.vanilla_ppo_atari",
        "description": "deps.pufferlib.examples.vanilla_ppo_atari",
        "peekOfCode": "def layer_init(layer, std=np.sqrt(2), bias_const=0.0):\n    torch.nn.init.orthogonal_(layer.weight, std)\n    torch.nn.init.constant_(layer.bias, bias_const)\n    return layer\nclass Agent(nn.Module):\n    def __init__(self, envs):\n        super().__init__()\n        self.network = nn.Sequential(\n            layer_init(nn.Conv2d(4, 32, 8, stride=4)),\n            nn.ReLU(),",
        "detail": "deps.pufferlib.examples.vanilla_ppo_atari",
        "documentation": {}
    },
    {
        "label": "AtariPostprocessor",
        "kind": 6,
        "importPath": "deps.pufferlib.pufferlib.environments.atari.environment",
        "description": "deps.pufferlib.pufferlib.environments.atari.environment",
        "peekOfCode": "class AtariPostprocessor(gym.Wrapper):\n    '''Atari breaks the normal PufferLib postprocessor because\n    it sends terminal=True every live, not every episode'''\n    def __init__(self, env):\n        super().__init__(env)\n        shape = env.observation_space.shape\n        if len(shape) < 3:\n            shape = (1, *shape)\n        else:\n            shape = (shape[2], shape[0], shape[1])",
        "detail": "deps.pufferlib.pufferlib.environments.atari.environment",
        "documentation": {}
    },
    {
        "label": "RaylibClient",
        "kind": 6,
        "importPath": "deps.pufferlib.pufferlib.environments.atari.environment",
        "description": "deps.pufferlib.pufferlib.environments.atari.environment",
        "peekOfCode": "class RaylibClient(gym.Wrapper):\n    def __init__(self, env, action_set, frameskip=4, upscale=4):\n        self.env = env\n        self.keymap = {}\n        for i, atn in enumerate(action_set):\n            self.keymap[atn.value] = i\n        obs_shape = env.observation_space.shape\n        if len(obs_shape) == 2:\n            height, width = obs_shape\n            channels = 1",
        "detail": "deps.pufferlib.pufferlib.environments.atari.environment",
        "documentation": {}
    },
    {
        "label": "env_creator",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.environments.atari.environment",
        "description": "deps.pufferlib.pufferlib.environments.atari.environment",
        "peekOfCode": "def env_creator(name='breakout'):\n    return functools.partial(make, name)\ndef make(name, obs_type='grayscale', frameskip=4, full_action_space=False,\n        repeat_action_probability=0.0, render_mode='rgb_array'):\n    '''Atari creation function'''\n    pufferlib.environments.try_import('ale_py', 'AtariEnv')\n    ale_render_mode = render_mode\n    if render_mode == 'human':\n        ale_render_mode = 'rgb_array'\n        obs_type = 'rgb'",
        "detail": "deps.pufferlib.pufferlib.environments.atari.environment",
        "documentation": {}
    },
    {
        "label": "make",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.environments.atari.environment",
        "description": "deps.pufferlib.pufferlib.environments.atari.environment",
        "peekOfCode": "def make(name, obs_type='grayscale', frameskip=4, full_action_space=False,\n        repeat_action_probability=0.0, render_mode='rgb_array'):\n    '''Atari creation function'''\n    pufferlib.environments.try_import('ale_py', 'AtariEnv')\n    ale_render_mode = render_mode\n    if render_mode == 'human':\n        ale_render_mode = 'rgb_array'\n        obs_type = 'rgb'\n        frameskip = 1\n        full_action_space = True",
        "detail": "deps.pufferlib.pufferlib.environments.atari.environment",
        "documentation": {}
    },
    {
        "label": "Recurrent",
        "kind": 6,
        "importPath": "deps.pufferlib.pufferlib.environments.atari.torch",
        "description": "deps.pufferlib.pufferlib.environments.atari.torch",
        "peekOfCode": "class Recurrent(pufferlib.models.LSTMWrapper):\n    def __init__(self, env, policy, input_size=512, hidden_size=512, num_layers=1):\n        super().__init__(env, policy, input_size, hidden_size, num_layers)\nclass Policy(pufferlib.models.Convolutional):\n    def __init__(self, env, input_size=512, hidden_size=512, output_size=512,\n            framestack=1, flat_size=64*6*9):\n        super().__init__(\n            env=env,\n            input_size=input_size,\n            hidden_size=hidden_size,",
        "detail": "deps.pufferlib.pufferlib.environments.atari.torch",
        "documentation": {}
    },
    {
        "label": "Policy",
        "kind": 6,
        "importPath": "deps.pufferlib.pufferlib.environments.atari.torch",
        "description": "deps.pufferlib.pufferlib.environments.atari.torch",
        "peekOfCode": "class Policy(pufferlib.models.Convolutional):\n    def __init__(self, env, input_size=512, hidden_size=512, output_size=512,\n            framestack=1, flat_size=64*6*9):\n        super().__init__(\n            env=env,\n            input_size=input_size,\n            hidden_size=hidden_size,\n            output_size=output_size,\n            framestack=framestack,\n            flat_size=flat_size,",
        "detail": "deps.pufferlib.pufferlib.environments.atari.torch",
        "documentation": {}
    },
    {
        "label": "env_creator",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.environments.box2d.environment",
        "description": "deps.pufferlib.pufferlib.environments.box2d.environment",
        "peekOfCode": "def env_creator(name='car-racing'):\n    return functools.partial(make, name=name)\ndef make(name, domain_randomize=True, continuous=False, render_mode='rgb_array'):\n    if name == 'car-racing':\n        name = 'CarRacing-v2'\n    env = gymnasium.make(name, render_mode=render_mode,\n        domain_randomize=domain_randomize, continuous=continuous)\n    env = pufferlib.postprocess.EpisodeStats(env)\n    return pufferlib.emulation.GymnasiumPufferEnv(env=env)",
        "detail": "deps.pufferlib.pufferlib.environments.box2d.environment",
        "documentation": {}
    },
    {
        "label": "make",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.environments.box2d.environment",
        "description": "deps.pufferlib.pufferlib.environments.box2d.environment",
        "peekOfCode": "def make(name, domain_randomize=True, continuous=False, render_mode='rgb_array'):\n    if name == 'car-racing':\n        name = 'CarRacing-v2'\n    env = gymnasium.make(name, render_mode=render_mode,\n        domain_randomize=domain_randomize, continuous=continuous)\n    env = pufferlib.postprocess.EpisodeStats(env)\n    return pufferlib.emulation.GymnasiumPufferEnv(env=env)",
        "detail": "deps.pufferlib.pufferlib.environments.box2d.environment",
        "documentation": {}
    },
    {
        "label": "Recurrent",
        "kind": 6,
        "importPath": "deps.pufferlib.pufferlib.environments.box2d.torch",
        "description": "deps.pufferlib.pufferlib.environments.box2d.torch",
        "peekOfCode": "class Recurrent(pufferlib.models.LSTMWrapper):\n    def __init__(self, env, policy,\n            input_size=128, hidden_size=128, num_layers=1):\n        super().__init__(env, policy,\n            input_size, hidden_size, num_layers)\nclass Policy(pufferlib.models.Convolutional):\n    def __init__(self, env,\n            input_size=128, hidden_size=128, output_size=128,\n            framestack=3, flat_size=64*8*8):\n        super().__init__(",
        "detail": "deps.pufferlib.pufferlib.environments.box2d.torch",
        "documentation": {}
    },
    {
        "label": "Policy",
        "kind": 6,
        "importPath": "deps.pufferlib.pufferlib.environments.box2d.torch",
        "description": "deps.pufferlib.pufferlib.environments.box2d.torch",
        "peekOfCode": "class Policy(pufferlib.models.Convolutional):\n    def __init__(self, env,\n            input_size=128, hidden_size=128, output_size=128,\n            framestack=3, flat_size=64*8*8):\n        super().__init__(\n            env=env,\n            input_size=input_size,\n            hidden_size=hidden_size,\n            output_size=output_size,\n            framestack=framestack,",
        "detail": "deps.pufferlib.pufferlib.environments.box2d.torch",
        "documentation": {}
    },
    {
        "label": "BSuiteStopper",
        "kind": 6,
        "importPath": "deps.pufferlib.pufferlib.environments.bsuite.environment",
        "description": "deps.pufferlib.pufferlib.environments.bsuite.environment",
        "peekOfCode": "class BSuiteStopper:\n    def __init__(self, env):\n        self.env = env\n        self.num_episodes = 0\n        self.step = self.env.step\n        self.render = self.env.render\n        self.close = self.env.close\n        self.observation_space = self.env.observation_space\n        self.action_space = self.env.action_space\n    def reset(self):",
        "detail": "deps.pufferlib.pufferlib.environments.bsuite.environment",
        "documentation": {}
    },
    {
        "label": "env_creator",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.environments.bsuite.environment",
        "description": "deps.pufferlib.pufferlib.environments.bsuite.environment",
        "peekOfCode": "def env_creator(name='bandit/0'):\n    return functools.partial(make, name)\ndef make(name='bandit/0', results_dir='experiments/bsuite', overwrite=True):\n    '''BSuite environments'''\n    bsuite = pufferlib.environments.try_import('bsuite')\n    from bsuite.utils import gym_wrapper\n    env = bsuite.load_and_record_to_csv(name, results_dir, overwrite=overwrite)\n    env = gym_wrapper.GymFromDMEnv(env)\n    env = BSuiteStopper(env)\n    env = pufferlib.wrappers.GymToGymnasium(env)",
        "detail": "deps.pufferlib.pufferlib.environments.bsuite.environment",
        "documentation": {}
    },
    {
        "label": "make",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.environments.bsuite.environment",
        "description": "deps.pufferlib.pufferlib.environments.bsuite.environment",
        "peekOfCode": "def make(name='bandit/0', results_dir='experiments/bsuite', overwrite=True):\n    '''BSuite environments'''\n    bsuite = pufferlib.environments.try_import('bsuite')\n    from bsuite.utils import gym_wrapper\n    env = bsuite.load_and_record_to_csv(name, results_dir, overwrite=overwrite)\n    env = gym_wrapper.GymFromDMEnv(env)\n    env = BSuiteStopper(env)\n    env = pufferlib.wrappers.GymToGymnasium(env)\n    env = pufferlib.emulation.GymnasiumPufferEnv(env)\n    return env",
        "detail": "deps.pufferlib.pufferlib.environments.bsuite.environment",
        "documentation": {}
    },
    {
        "label": "Squared",
        "kind": 6,
        "importPath": "deps.pufferlib.pufferlib.environments.bsuite.squared",
        "description": "deps.pufferlib.pufferlib.environments.bsuite.squared",
        "peekOfCode": "class Squared(gym.Env):\n    __init__ = init\n    reset = reset\n    step = step\n    render = render",
        "detail": "deps.pufferlib.pufferlib.environments.bsuite.squared",
        "documentation": {}
    },
    {
        "label": "all_possible_targets",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.environments.bsuite.squared",
        "description": "deps.pufferlib.pufferlib.environments.bsuite.squared",
        "peekOfCode": "def all_possible_targets(n):\n    '''Generate all points on the perimeter of a square with side n'''\n    return ([(i, j) for i in range(n) for j in [0, n-1]]\n        + [(i, j) for i in [0, n-1] for j in range(1, n-1)])\ndef init(self,\n        distance_to_target=1,\n        num_targets=-1,\n        ):\n    '''Pufferlib Diamond environment\n    Agent starts at the center of a square grid.",
        "detail": "deps.pufferlib.pufferlib.environments.bsuite.squared",
        "documentation": {}
    },
    {
        "label": "init",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.environments.bsuite.squared",
        "description": "deps.pufferlib.pufferlib.environments.bsuite.squared",
        "peekOfCode": "def init(self,\n        distance_to_target=1,\n        num_targets=-1,\n        ):\n    '''Pufferlib Diamond environment\n    Agent starts at the center of a square grid.\n    Targets are placed on the perimeter of the grid.\n    Reward is 1 minus the L-inf distance to the closest target.\n    This means that reward varies from -1 to 1.\n    Reward is not given for targets that have already been hit.",
        "detail": "deps.pufferlib.pufferlib.environments.bsuite.squared",
        "documentation": {}
    },
    {
        "label": "reset",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.environments.bsuite.squared",
        "description": "deps.pufferlib.pufferlib.environments.bsuite.squared",
        "peekOfCode": "def reset(state, seed=None):\n    if seed is not None:\n        random.seed(seed)\n        np.random.seed(seed)\n    # Allocating a new grid is faster than resetting an old one\n    state.grid = np.zeros((state.grid_size, state.grid_size), dtype=np.float32)\n    state.grid[state.distance_to_target, state.distance_to_target] = -1\n    state.agent_pos = (state.distance_to_target, state.distance_to_target)\n    state.tick = 0\n    state.targets = random.sample(state.possible_targets, state.num_targets)",
        "detail": "deps.pufferlib.pufferlib.environments.bsuite.squared",
        "documentation": {}
    },
    {
        "label": "step",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.environments.bsuite.squared",
        "description": "deps.pufferlib.pufferlib.environments.bsuite.squared",
        "peekOfCode": "def step(state, action):\n    x, y = state.agent_pos\n    state.grid[x, y] = 0\n    dx, dy = MOVES[action]\n    x += dx\n    y += dy\n    min_dist = min([max(abs(x-tx), abs(y-ty)) for tx, ty in state.targets])\n    # This reward function will return 0.46 average reward for an unsuccessful\n    # episode with distance_to_target=4 and num_targets=1 (0.5 for solve)\n    # It looks reasonable but is not very discriminative",
        "detail": "deps.pufferlib.pufferlib.environments.bsuite.squared",
        "documentation": {}
    },
    {
        "label": "render",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.environments.bsuite.squared",
        "description": "deps.pufferlib.pufferlib.environments.bsuite.squared",
        "peekOfCode": "def render(state):\n    for row in state.grid:\n        for val in row:\n            if val == 1:\n                color = 94 # Blue\n            elif val == -1:\n                color = 91 # Red\n            else:\n                color = 90 # Gray\n            print(f'\\033[{color}m\\033[0m', end='') # Gray block",
        "detail": "deps.pufferlib.pufferlib.environments.bsuite.squared",
        "documentation": {}
    },
    {
        "label": "MOVES",
        "kind": 5,
        "importPath": "deps.pufferlib.pufferlib.environments.bsuite.squared",
        "description": "deps.pufferlib.pufferlib.environments.bsuite.squared",
        "peekOfCode": "MOVES = [(0, -1), (0, 1), (-1, 0), (1, 0), (1, -1), (-1, -1), (1, 1), (-1, 1)]\ndef all_possible_targets(n):\n    '''Generate all points on the perimeter of a square with side n'''\n    return ([(i, j) for i in range(n) for j in [0, n-1]]\n        + [(i, j) for i in [0, n-1] for j in range(1, n-1)])\ndef init(self,\n        distance_to_target=1,\n        num_targets=-1,\n        ):\n    '''Pufferlib Diamond environment",
        "detail": "deps.pufferlib.pufferlib.environments.bsuite.squared",
        "documentation": {}
    },
    {
        "label": "env_creator",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.environments.butterfly.environment",
        "description": "deps.pufferlib.pufferlib.environments.butterfly.environment",
        "peekOfCode": "def env_creator(name='cooperative_pong_v5'):\n    return functools.partial(make, name)\ndef make(name):\n    pufferlib.environments.try_import('pettingzoo.butterfly', 'butterfly')\n    if name == 'cooperative_pong_v5':\n        from pettingzoo.butterfly import cooperative_pong_v5 as pong\n        env_cls = pong.raw_env\n    elif name == 'knights_archers_zombies_v10':\n        from pettingzoo.butterfly import knights_archers_zombies_v10 as kaz\n        env_cls = kaz.raw_env",
        "detail": "deps.pufferlib.pufferlib.environments.butterfly.environment",
        "documentation": {}
    },
    {
        "label": "make",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.environments.butterfly.environment",
        "description": "deps.pufferlib.pufferlib.environments.butterfly.environment",
        "peekOfCode": "def make(name):\n    pufferlib.environments.try_import('pettingzoo.butterfly', 'butterfly')\n    if name == 'cooperative_pong_v5':\n        from pettingzoo.butterfly import cooperative_pong_v5 as pong\n        env_cls = pong.raw_env\n    elif name == 'knights_archers_zombies_v10':\n        from pettingzoo.butterfly import knights_archers_zombies_v10 as kaz\n        env_cls = kaz.raw_env\n    else:\n        raise ValueError(f'Unknown environment: {name}')",
        "detail": "deps.pufferlib.pufferlib.environments.butterfly.environment",
        "documentation": {}
    },
    {
        "label": "Policy",
        "kind": 6,
        "importPath": "deps.pufferlib.pufferlib.environments.butterfly.torch",
        "description": "deps.pufferlib.pufferlib.environments.butterfly.torch",
        "peekOfCode": "class Policy(pufferlib.models.Convolutional):\n    def __init__(\n            self,\n            env,\n            flat_size=3520,\n            channels_last=True,\n            downsample=4,\n            input_size=512,\n            hidden_size=128,\n            output_size=128,",
        "detail": "deps.pufferlib.pufferlib.environments.butterfly.torch",
        "documentation": {}
    },
    {
        "label": "MountainCarWrapper",
        "kind": 6,
        "importPath": "deps.pufferlib.pufferlib.environments.classic_control.environment",
        "description": "deps.pufferlib.pufferlib.environments.classic_control.environment",
        "peekOfCode": "class MountainCarWrapper(gymnasium.Wrapper):\n    def step(self, action):\n        obs, reward, terminated, truncated, info = self.env.step(action)\n        reward = abs(obs[0]+0.5)\n        return obs, reward, terminated, truncated, info",
        "detail": "deps.pufferlib.pufferlib.environments.classic_control.environment",
        "documentation": {}
    },
    {
        "label": "env_creator",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.environments.classic_control.environment",
        "description": "deps.pufferlib.pufferlib.environments.classic_control.environment",
        "peekOfCode": "def env_creator(name='cartpole'):\n    return functools.partial(make, name)\ndef make(name, render_mode='rgb_array'):\n    '''Create an environment by name'''\n    if name in ALIASES:\n        name = ALIASES[name]\n    env = gymnasium.make(name, render_mode=render_mode)\n    if name == 'MountainCar-v0':\n        env = MountainCarWrapper(env)\n    #env = gymnasium.wrappers.NormalizeObservation(env)",
        "detail": "deps.pufferlib.pufferlib.environments.classic_control.environment",
        "documentation": {}
    },
    {
        "label": "make",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.environments.classic_control.environment",
        "description": "deps.pufferlib.pufferlib.environments.classic_control.environment",
        "peekOfCode": "def make(name, render_mode='rgb_array'):\n    '''Create an environment by name'''\n    if name in ALIASES:\n        name = ALIASES[name]\n    env = gymnasium.make(name, render_mode=render_mode)\n    if name == 'MountainCar-v0':\n        env = MountainCarWrapper(env)\n    #env = gymnasium.wrappers.NormalizeObservation(env)\n    env = gymnasium.wrappers.TransformObservation(env, lambda obs: np.clip(obs, -1, 1))\n    #env = gymnasium.wrappers.NormalizeReward(env, gamma=gamma)",
        "detail": "deps.pufferlib.pufferlib.environments.classic_control.environment",
        "documentation": {}
    },
    {
        "label": "ALIASES",
        "kind": 5,
        "importPath": "deps.pufferlib.pufferlib.environments.classic_control.environment",
        "description": "deps.pufferlib.pufferlib.environments.classic_control.environment",
        "peekOfCode": "ALIASES = {\n    'cartpole': 'CartPole-v0',\n    'mountaincar': 'MountainCar-v0',\n}\ndef env_creator(name='cartpole'):\n    return functools.partial(make, name)\ndef make(name, render_mode='rgb_array'):\n    '''Create an environment by name'''\n    if name in ALIASES:\n        name = ALIASES[name]",
        "detail": "deps.pufferlib.pufferlib.environments.classic_control.environment",
        "documentation": {}
    },
    {
        "label": "Policy",
        "kind": 6,
        "importPath": "deps.pufferlib.pufferlib.environments.classic_control.torch",
        "description": "deps.pufferlib.pufferlib.environments.classic_control.torch",
        "peekOfCode": "class Policy(pufferlib.models.Default):\n    def __init__(self, env, hidden_size=64):\n        super().__init__(env, hidden_size)",
        "detail": "deps.pufferlib.pufferlib.environments.classic_control.torch",
        "documentation": {}
    },
    {
        "label": "MountainCarWrapper",
        "kind": 6,
        "importPath": "deps.pufferlib.pufferlib.environments.classic_control_continuous.environment",
        "description": "deps.pufferlib.pufferlib.environments.classic_control_continuous.environment",
        "peekOfCode": "class MountainCarWrapper(gymnasium.Wrapper):\n    def step(self, action):\n        obs, reward, terminated, truncated, info = self.env.step(action)\n        reward = abs(obs[0]+0.5)\n        return obs, reward, terminated, truncated, info",
        "detail": "deps.pufferlib.pufferlib.environments.classic_control_continuous.environment",
        "documentation": {}
    },
    {
        "label": "env_creator",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.environments.classic_control_continuous.environment",
        "description": "deps.pufferlib.pufferlib.environments.classic_control_continuous.environment",
        "peekOfCode": "def env_creator(name='MountainCarContinuous-v0'):\n    return functools.partial(make, name)\ndef make(name, render_mode='rgb_array'):\n    '''Create an environment by name'''\n    env = gymnasium.make(name, render_mode=render_mode)\n    if name == 'MountainCarContinuous-v0':\n        env = MountainCarWrapper(env)\n    env = pufferlib.postprocess.ClipAction(env)\n    env = pufferlib.postprocess.EpisodeStats(env)\n    return pufferlib.emulation.GymnasiumPufferEnv(env=env)",
        "detail": "deps.pufferlib.pufferlib.environments.classic_control_continuous.environment",
        "documentation": {}
    },
    {
        "label": "make",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.environments.classic_control_continuous.environment",
        "description": "deps.pufferlib.pufferlib.environments.classic_control_continuous.environment",
        "peekOfCode": "def make(name, render_mode='rgb_array'):\n    '''Create an environment by name'''\n    env = gymnasium.make(name, render_mode=render_mode)\n    if name == 'MountainCarContinuous-v0':\n        env = MountainCarWrapper(env)\n    env = pufferlib.postprocess.ClipAction(env)\n    env = pufferlib.postprocess.EpisodeStats(env)\n    return pufferlib.emulation.GymnasiumPufferEnv(env=env)\nclass MountainCarWrapper(gymnasium.Wrapper):\n    def step(self, action):",
        "detail": "deps.pufferlib.pufferlib.environments.classic_control_continuous.environment",
        "documentation": {}
    },
    {
        "label": "Policy",
        "kind": 6,
        "importPath": "deps.pufferlib.pufferlib.environments.classic_control_continuous.torch",
        "description": "deps.pufferlib.pufferlib.environments.classic_control_continuous.torch",
        "peekOfCode": "class Policy(pufferlib.models.Default):\n    def __init__(self, env, hidden_size=64):\n        super().__init__(env, hidden_size)",
        "detail": "deps.pufferlib.pufferlib.environments.classic_control_continuous.torch",
        "documentation": {}
    },
    {
        "label": "TransposeObs",
        "kind": 6,
        "importPath": "deps.pufferlib.pufferlib.environments.crafter.environment",
        "description": "deps.pufferlib.pufferlib.environments.crafter.environment",
        "peekOfCode": "class TransposeObs(gym.Wrapper):\n    def observation(self, observation):\n        return observation.transpose(2, 0, 1)\ndef env_creator(name='crafter'):\n    return functools.partial(make, name)\ndef make(name):\n    '''Crafter creation function'''\n    if name == 'crafter':\n        name = 'CrafterReward-v1'\n    pufferlib.environments.try_import('crafter')",
        "detail": "deps.pufferlib.pufferlib.environments.crafter.environment",
        "documentation": {}
    },
    {
        "label": "RenderWrapper",
        "kind": 6,
        "importPath": "deps.pufferlib.pufferlib.environments.crafter.environment",
        "description": "deps.pufferlib.pufferlib.environments.crafter.environment",
        "peekOfCode": "class RenderWrapper(gym.Wrapper):\n    def __init__(self, env):\n        super().__init__(env)\n        self.env = env\n    @property\n    def render_mode(self):\n        return 'rgb_array'\n    def render(self, *args, **kwargs):\n        return self.env.unwrapped.env.unwrapped.render((256,256))",
        "detail": "deps.pufferlib.pufferlib.environments.crafter.environment",
        "documentation": {}
    },
    {
        "label": "env_creator",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.environments.crafter.environment",
        "description": "deps.pufferlib.pufferlib.environments.crafter.environment",
        "peekOfCode": "def env_creator(name='crafter'):\n    return functools.partial(make, name)\ndef make(name):\n    '''Crafter creation function'''\n    if name == 'crafter':\n        name = 'CrafterReward-v1'\n    pufferlib.environments.try_import('crafter')\n    env = gym.make(name)\n    env.reset = pufferlib.utils.silence_warnings(env.reset)\n    env = shimmy.GymV21CompatibilityV0(env=env)",
        "detail": "deps.pufferlib.pufferlib.environments.crafter.environment",
        "documentation": {}
    },
    {
        "label": "make",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.environments.crafter.environment",
        "description": "deps.pufferlib.pufferlib.environments.crafter.environment",
        "peekOfCode": "def make(name):\n    '''Crafter creation function'''\n    if name == 'crafter':\n        name = 'CrafterReward-v1'\n    pufferlib.environments.try_import('crafter')\n    env = gym.make(name)\n    env.reset = pufferlib.utils.silence_warnings(env.reset)\n    env = shimmy.GymV21CompatibilityV0(env=env)\n    env = RenderWrapper(env)\n    env = TransposeObs(env)",
        "detail": "deps.pufferlib.pufferlib.environments.crafter.environment",
        "documentation": {}
    },
    {
        "label": "Policy",
        "kind": 6,
        "importPath": "deps.pufferlib.pufferlib.environments.crafter.torch",
        "description": "deps.pufferlib.pufferlib.environments.crafter.torch",
        "peekOfCode": "class Policy(pufferlib.models.Convolutional):\n    def __init__(\n            self,\n            env,\n            flat_size=1024,\n            channels_last=True,\n            downsample=1,\n            input_size=512,\n            hidden_size=128,\n            output_size=128,",
        "detail": "deps.pufferlib.pufferlib.environments.crafter.torch",
        "documentation": {}
    },
    {
        "label": "env_creator",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.environments.dm_control.environment",
        "description": "deps.pufferlib.pufferlib.environments.dm_control.environment",
        "peekOfCode": "def env_creator(name='walker'):\n    '''Deepmind Control environment creation function\n    No support for bindings yet because PufferLib does\n    not support continuous action spaces.'''\n    return functools.partial(make, name)\ndef make(name, task_name='walk'):\n    '''No PufferLib support for continuous actions yet.'''\n    dm_control = pufferlib.environments.try_import('dm_control.suite', 'dmc')\n    env = dm_control.suite.load(name, task_name)\n    env = shimmy.DmControlCompatibilityV0(env=env)",
        "detail": "deps.pufferlib.pufferlib.environments.dm_control.environment",
        "documentation": {}
    },
    {
        "label": "make",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.environments.dm_control.environment",
        "description": "deps.pufferlib.pufferlib.environments.dm_control.environment",
        "peekOfCode": "def make(name, task_name='walk'):\n    '''No PufferLib support for continuous actions yet.'''\n    dm_control = pufferlib.environments.try_import('dm_control.suite', 'dmc')\n    env = dm_control.suite.load(name, task_name)\n    env = shimmy.DmControlCompatibilityV0(env=env)\n    return pufferlib.emulation.GymnasiumPufferEnv(env)",
        "detail": "deps.pufferlib.pufferlib.environments.dm_control.environment",
        "documentation": {}
    },
    {
        "label": "env_creator",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.environments.dm_lab.environment",
        "description": "deps.pufferlib.pufferlib.environments.dm_lab.environment",
        "peekOfCode": "def env_creator(name='seekavoid_arena_01'):\n    '''Deepmind Lab binding creation function\n    dm-lab requires extensive setup. Use PufferTank.'''\n    return functools.partial(make, name=name)\ndef make(name):\n    '''Deepmind Lab binding creation function\n    dm-lab requires extensive setup. Use PufferTank.'''\n    dm_lab = pufferlib.environments.try_import('deepmind_lab', 'dm-lab')\n    env = dm_lab.Lab(name, ['RGB_INTERLEAVED'])\n    env = shimmy.DmLabCompatibilityV0(env=env)",
        "detail": "deps.pufferlib.pufferlib.environments.dm_lab.environment",
        "documentation": {}
    },
    {
        "label": "make",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.environments.dm_lab.environment",
        "description": "deps.pufferlib.pufferlib.environments.dm_lab.environment",
        "peekOfCode": "def make(name):\n    '''Deepmind Lab binding creation function\n    dm-lab requires extensive setup. Use PufferTank.'''\n    dm_lab = pufferlib.environments.try_import('deepmind_lab', 'dm-lab')\n    env = dm_lab.Lab(name, ['RGB_INTERLEAVED'])\n    env = shimmy.DmLabCompatibilityV0(env=env)\n    return pufferlib.emulation.GymnasiumPufferEnv(env=env)",
        "detail": "deps.pufferlib.pufferlib.environments.dm_lab.environment",
        "documentation": {}
    },
    {
        "label": "Policy",
        "kind": 6,
        "importPath": "deps.pufferlib.pufferlib.environments.dm_lab.torch",
        "description": "deps.pufferlib.pufferlib.environments.dm_lab.torch",
        "peekOfCode": "class Policy(pufferlib.models.Convolutional):\n    def __init__(\n            self,\n            env,\n            flat_size=3136,\n            channels_last=True,\n            downsample=1,\n            input_size=512,\n            hidden_size=128,\n            output_size=128,",
        "detail": "deps.pufferlib.pufferlib.environments.dm_lab.torch",
        "documentation": {}
    },
    {
        "label": "PufferGPUDrive",
        "kind": 6,
        "importPath": "deps.pufferlib.pufferlib.environments.gpudrive.environment",
        "description": "deps.pufferlib.pufferlib.environments.gpudrive.environment",
        "peekOfCode": "class PufferGPUDrive:\n    def __init__(self, device='cuda', max_cont_agents=64, num_worlds=64, k_unique_scenes=1):\n        self.device = device\n        self.max_cont_agents = max_cont_agents\n        self.num_worlds = num_worlds\n        self.k_unique_scenes = k_unique_scenes\n        self.total_agents = max_cont_agents * num_worlds\n        # Set working directory to the base directory 'gpudrive'\n        working_dir = os.path.join(Path.cwd(), '../gpudrive')\n        os.chdir(working_dir)",
        "detail": "deps.pufferlib.pufferlib.environments.gpudrive.environment",
        "documentation": {}
    },
    {
        "label": "env_creator",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.environments.gpudrive.environment",
        "description": "deps.pufferlib.pufferlib.environments.gpudrive.environment",
        "peekOfCode": "def env_creator(name='gpudrive'):\n    return PufferGPUDrive\nclass PufferGPUDrive:\n    def __init__(self, device='cuda', max_cont_agents=64, num_worlds=64, k_unique_scenes=1):\n        self.device = device\n        self.max_cont_agents = max_cont_agents\n        self.num_worlds = num_worlds\n        self.k_unique_scenes = k_unique_scenes\n        self.total_agents = max_cont_agents * num_worlds\n        # Set working directory to the base directory 'gpudrive'",
        "detail": "deps.pufferlib.pufferlib.environments.gpudrive.environment",
        "documentation": {}
    },
    {
        "label": "Policy",
        "kind": 6,
        "importPath": "deps.pufferlib.pufferlib.environments.gpudrive.torch",
        "description": "deps.pufferlib.pufferlib.environments.gpudrive.torch",
        "peekOfCode": "class Policy(nn.Module):\n    def __init__(self, env, input_size=64, hidden_size=128, **kwargs):\n        super().__init__()\n        self.ego_embed = nn.Sequential(\n            pufferlib.pytorch.layer_init(nn.Linear(EGO_STATE_DIM, input_size)),\n            torch.nn.ReLU(),\n            pufferlib.pytorch.layer_init(nn.Linear(input_size, input_size)),\n        )\n        self.partner_embed = nn.Sequential(\n            pufferlib.pytorch.layer_init(nn.Linear(PARTNER_DIM, input_size)),",
        "detail": "deps.pufferlib.pufferlib.environments.gpudrive.torch",
        "documentation": {}
    },
    {
        "label": "unpack_obs",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.environments.gpudrive.torch",
        "description": "deps.pufferlib.pufferlib.environments.gpudrive.torch",
        "peekOfCode": "def unpack_obs(obs_flat):\n    \"\"\"\n    Unpack the flattened observation into the ego state and visible state.\n    Args:\n        obs_flat (torch.Tensor): flattened observation tensor of shape (batch_size, obs_dim)\n    Return:\n        ego_state, road_objects, stop_signs, road_graph (torch.Tensor).\n    \"\"\"\n    # Unpack ego and visible state\n    ego_state = obs_flat[:, :EGO_STATE_DIM]",
        "detail": "deps.pufferlib.pufferlib.environments.gpudrive.torch",
        "documentation": {}
    },
    {
        "label": "Recurrent",
        "kind": 5,
        "importPath": "deps.pufferlib.pufferlib.environments.gpudrive.torch",
        "description": "deps.pufferlib.pufferlib.environments.gpudrive.torch",
        "peekOfCode": "Recurrent = pufferlib.models.LSTMWrapper\nEGO_STATE_DIM = 6\nPARTNER_DIM = 10\nROAD_MAP_DIM = 13\nMAX_CONTROLLED_VEHICLES = 32\nROADMAP_AGENT_FEAT_DIM = MAX_CONTROLLED_VEHICLES - 1\nTOP_K_ROADPOINTS = 64 # Number of visible roadpoints from the road graph\ndef unpack_obs(obs_flat):\n    \"\"\"\n    Unpack the flattened observation into the ego state and visible state.",
        "detail": "deps.pufferlib.pufferlib.environments.gpudrive.torch",
        "documentation": {}
    },
    {
        "label": "EGO_STATE_DIM",
        "kind": 5,
        "importPath": "deps.pufferlib.pufferlib.environments.gpudrive.torch",
        "description": "deps.pufferlib.pufferlib.environments.gpudrive.torch",
        "peekOfCode": "EGO_STATE_DIM = 6\nPARTNER_DIM = 10\nROAD_MAP_DIM = 13\nMAX_CONTROLLED_VEHICLES = 32\nROADMAP_AGENT_FEAT_DIM = MAX_CONTROLLED_VEHICLES - 1\nTOP_K_ROADPOINTS = 64 # Number of visible roadpoints from the road graph\ndef unpack_obs(obs_flat):\n    \"\"\"\n    Unpack the flattened observation into the ego state and visible state.\n    Args:",
        "detail": "deps.pufferlib.pufferlib.environments.gpudrive.torch",
        "documentation": {}
    },
    {
        "label": "PARTNER_DIM",
        "kind": 5,
        "importPath": "deps.pufferlib.pufferlib.environments.gpudrive.torch",
        "description": "deps.pufferlib.pufferlib.environments.gpudrive.torch",
        "peekOfCode": "PARTNER_DIM = 10\nROAD_MAP_DIM = 13\nMAX_CONTROLLED_VEHICLES = 32\nROADMAP_AGENT_FEAT_DIM = MAX_CONTROLLED_VEHICLES - 1\nTOP_K_ROADPOINTS = 64 # Number of visible roadpoints from the road graph\ndef unpack_obs(obs_flat):\n    \"\"\"\n    Unpack the flattened observation into the ego state and visible state.\n    Args:\n        obs_flat (torch.Tensor): flattened observation tensor of shape (batch_size, obs_dim)",
        "detail": "deps.pufferlib.pufferlib.environments.gpudrive.torch",
        "documentation": {}
    },
    {
        "label": "ROAD_MAP_DIM",
        "kind": 5,
        "importPath": "deps.pufferlib.pufferlib.environments.gpudrive.torch",
        "description": "deps.pufferlib.pufferlib.environments.gpudrive.torch",
        "peekOfCode": "ROAD_MAP_DIM = 13\nMAX_CONTROLLED_VEHICLES = 32\nROADMAP_AGENT_FEAT_DIM = MAX_CONTROLLED_VEHICLES - 1\nTOP_K_ROADPOINTS = 64 # Number of visible roadpoints from the road graph\ndef unpack_obs(obs_flat):\n    \"\"\"\n    Unpack the flattened observation into the ego state and visible state.\n    Args:\n        obs_flat (torch.Tensor): flattened observation tensor of shape (batch_size, obs_dim)\n    Return:",
        "detail": "deps.pufferlib.pufferlib.environments.gpudrive.torch",
        "documentation": {}
    },
    {
        "label": "MAX_CONTROLLED_VEHICLES",
        "kind": 5,
        "importPath": "deps.pufferlib.pufferlib.environments.gpudrive.torch",
        "description": "deps.pufferlib.pufferlib.environments.gpudrive.torch",
        "peekOfCode": "MAX_CONTROLLED_VEHICLES = 32\nROADMAP_AGENT_FEAT_DIM = MAX_CONTROLLED_VEHICLES - 1\nTOP_K_ROADPOINTS = 64 # Number of visible roadpoints from the road graph\ndef unpack_obs(obs_flat):\n    \"\"\"\n    Unpack the flattened observation into the ego state and visible state.\n    Args:\n        obs_flat (torch.Tensor): flattened observation tensor of shape (batch_size, obs_dim)\n    Return:\n        ego_state, road_objects, stop_signs, road_graph (torch.Tensor).",
        "detail": "deps.pufferlib.pufferlib.environments.gpudrive.torch",
        "documentation": {}
    },
    {
        "label": "ROADMAP_AGENT_FEAT_DIM",
        "kind": 5,
        "importPath": "deps.pufferlib.pufferlib.environments.gpudrive.torch",
        "description": "deps.pufferlib.pufferlib.environments.gpudrive.torch",
        "peekOfCode": "ROADMAP_AGENT_FEAT_DIM = MAX_CONTROLLED_VEHICLES - 1\nTOP_K_ROADPOINTS = 64 # Number of visible roadpoints from the road graph\ndef unpack_obs(obs_flat):\n    \"\"\"\n    Unpack the flattened observation into the ego state and visible state.\n    Args:\n        obs_flat (torch.Tensor): flattened observation tensor of shape (batch_size, obs_dim)\n    Return:\n        ego_state, road_objects, stop_signs, road_graph (torch.Tensor).\n    \"\"\"",
        "detail": "deps.pufferlib.pufferlib.environments.gpudrive.torch",
        "documentation": {}
    },
    {
        "label": "TOP_K_ROADPOINTS",
        "kind": 5,
        "importPath": "deps.pufferlib.pufferlib.environments.gpudrive.torch",
        "description": "deps.pufferlib.pufferlib.environments.gpudrive.torch",
        "peekOfCode": "TOP_K_ROADPOINTS = 64 # Number of visible roadpoints from the road graph\ndef unpack_obs(obs_flat):\n    \"\"\"\n    Unpack the flattened observation into the ego state and visible state.\n    Args:\n        obs_flat (torch.Tensor): flattened observation tensor of shape (batch_size, obs_dim)\n    Return:\n        ego_state, road_objects, stop_signs, road_graph (torch.Tensor).\n    \"\"\"\n    # Unpack ego and visible state",
        "detail": "deps.pufferlib.pufferlib.environments.gpudrive.torch",
        "documentation": {}
    },
    {
        "label": "env_creator",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.environments.griddly.environment",
        "description": "deps.pufferlib.pufferlib.environments.griddly.environment",
        "peekOfCode": "def env_creator(name='spiders'):\n    return functools.partial(make, name)\n# TODO: fix griddly\ndef make(name):\n    '''Griddly creation function\n    Note that Griddly environments do not have observation spaces until\n    they are created and reset'''\n    if name in ALIASES:\n        name = ALIASES[name]\n    pufferlib.environments.try_import('griddly')",
        "detail": "deps.pufferlib.pufferlib.environments.griddly.environment",
        "documentation": {}
    },
    {
        "label": "make",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.environments.griddly.environment",
        "description": "deps.pufferlib.pufferlib.environments.griddly.environment",
        "peekOfCode": "def make(name):\n    '''Griddly creation function\n    Note that Griddly environments do not have observation spaces until\n    they are created and reset'''\n    if name in ALIASES:\n        name = ALIASES[name]\n    pufferlib.environments.try_import('griddly')\n    with pufferlib.utils.Suppress():\n        env = gym.make(name)\n        env.reset() # Populate observation space",
        "detail": "deps.pufferlib.pufferlib.environments.griddly.environment",
        "documentation": {}
    },
    {
        "label": "ALIASES",
        "kind": 5,
        "importPath": "deps.pufferlib.pufferlib.environments.griddly.environment",
        "description": "deps.pufferlib.pufferlib.environments.griddly.environment",
        "peekOfCode": "ALIASES = {\n    'spiders': 'GDY-Spiders-v0',\n}    \ndef env_creator(name='spiders'):\n    return functools.partial(make, name)\n# TODO: fix griddly\ndef make(name):\n    '''Griddly creation function\n    Note that Griddly environments do not have observation spaces until\n    they are created and reset'''",
        "detail": "deps.pufferlib.pufferlib.environments.griddly.environment",
        "documentation": {}
    },
    {
        "label": "env_creator",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.environments.gvgai.environment",
        "description": "deps.pufferlib.pufferlib.environments.gvgai.environment",
        "peekOfCode": "def env_creator(name='zelda'):\n    if name == 'zelda':\n        name = 'gvgai-zelda-lvl0-v0'\n    return functools.partial(make, name)\ndef make(name, obs_type='grayscale', frameskip=4, full_action_space=False,\n        repeat_action_probability=0.0, render_mode='rgb_array'):\n    '''Atari creation function'''\n    pufferlib.environments.try_import('gym_gvgai')\n    env = gym.make(name)\n    env = pufferlib.wrappers.GymToGymnasium(env)",
        "detail": "deps.pufferlib.pufferlib.environments.gvgai.environment",
        "documentation": {}
    },
    {
        "label": "make",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.environments.gvgai.environment",
        "description": "deps.pufferlib.pufferlib.environments.gvgai.environment",
        "peekOfCode": "def make(name, obs_type='grayscale', frameskip=4, full_action_space=False,\n        repeat_action_probability=0.0, render_mode='rgb_array'):\n    '''Atari creation function'''\n    pufferlib.environments.try_import('gym_gvgai')\n    env = gym.make(name)\n    env = pufferlib.wrappers.GymToGymnasium(env)\n    env = pufferlib.postprocess.EpisodeStats(env)\n    env = pufferlib.emulation.GymnasiumPufferEnv(env=env)\n    return env",
        "detail": "deps.pufferlib.pufferlib.environments.gvgai.environment",
        "documentation": {}
    },
    {
        "label": "make_env",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.environments.links_awaken.environment",
        "description": "deps.pufferlib.pufferlib.environments.links_awaken.environment",
        "peekOfCode": "def make_env(headless: bool = True, state_path=None):\n    '''Links Awakening'''\n    env = env_creator(headless=headless, state_path=state_path)\n    env = gymnasium.wrappers.ResizeObservation(env, shape=(72, 80))\n    return pufferlib.emulation.GymnasiumPufferEnv(env=env,\n        postprocessor_cls=pufferlib.emulation.BasicPostprocessor)",
        "detail": "deps.pufferlib.pufferlib.environments.links_awaken.environment",
        "documentation": {}
    },
    {
        "label": "Recurrent",
        "kind": 6,
        "importPath": "deps.pufferlib.pufferlib.environments.links_awaken.torch",
        "description": "deps.pufferlib.pufferlib.environments.links_awaken.torch",
        "peekOfCode": "class Recurrent:\n    input_size = 512\n    hidden_size = 512\n    num_layers = 1\nclass Policy(pufferlib.models.Convolutional):\n    def __init__(self, env, input_size=512, hidden_size=512, output_size=512,\n            framestack=3, flat_size=64*5*6):\n        super().__init__(\n            env=env,\n            input_size=input_size,",
        "detail": "deps.pufferlib.pufferlib.environments.links_awaken.torch",
        "documentation": {}
    },
    {
        "label": "Policy",
        "kind": 6,
        "importPath": "deps.pufferlib.pufferlib.environments.links_awaken.torch",
        "description": "deps.pufferlib.pufferlib.environments.links_awaken.torch",
        "peekOfCode": "class Policy(pufferlib.models.Convolutional):\n    def __init__(self, env, input_size=512, hidden_size=512, output_size=512,\n            framestack=3, flat_size=64*5*6):\n        super().__init__(\n            env=env,\n            input_size=input_size,\n            hidden_size=hidden_size,\n            output_size=output_size,\n            framestack=framestack,\n            flat_size=flat_size,",
        "detail": "deps.pufferlib.pufferlib.environments.links_awaken.torch",
        "documentation": {}
    },
    {
        "label": "env_creator",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.environments.magent.environment",
        "description": "deps.pufferlib.pufferlib.environments.magent.environment",
        "peekOfCode": "def env_creator(name='battle_v4'):\n    return functools.partial(make, name)\n    pufferlib.environments.try_import('pettingzoo.magent', 'magent')\ndef make(name):\n    '''MAgent Battle V4 creation function'''\n    if name == 'battle_v4':\n        from pettingzoo.magent import battle_v4\n        env_cls = battle_v4.env\n    else:\n        raise ValueError(f'Unknown environment name {name}')",
        "detail": "deps.pufferlib.pufferlib.environments.magent.environment",
        "documentation": {}
    },
    {
        "label": "make",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.environments.magent.environment",
        "description": "deps.pufferlib.pufferlib.environments.magent.environment",
        "peekOfCode": "def make(name):\n    '''MAgent Battle V4 creation function'''\n    if name == 'battle_v4':\n        from pettingzoo.magent import battle_v4\n        env_cls = battle_v4.env\n    else:\n        raise ValueError(f'Unknown environment name {name}')\n    env = env_cls()\n    env = aec_to_parallel_wrapper(env)\n    env = pufferlib.wrappers.PettingZooTruncatedWrapper(env)",
        "detail": "deps.pufferlib.pufferlib.environments.magent.environment",
        "documentation": {}
    },
    {
        "label": "Policy",
        "kind": 6,
        "importPath": "deps.pufferlib.pufferlib.environments.magent.torch",
        "description": "deps.pufferlib.pufferlib.environments.magent.torch",
        "peekOfCode": "class Policy(pufferlib.models.Policy):\n    '''Based off of the DQN policy in MAgent'''\n    def __init__(self, env, hidden_size=256, output_size=256, kernel_num=32):\n        '''The CleanRL default Atari policy: a stack of three convolutions followed by a linear layer\n        Takes framestack as a mandatory keyword arguments. Suggested default is 1 frame\n        with LSTM or 4 frames without.'''\n        super().__init__(env)\n        self.num_actions = self.action_space.n\n        self.network = nn.Sequential(\n            pufferlib.pytorch.layer_init(nn.Conv2d(5, kernel_num, 3)),",
        "detail": "deps.pufferlib.pufferlib.environments.magent.torch",
        "documentation": {}
    },
    {
        "label": "MicroRTS",
        "kind": 6,
        "importPath": "deps.pufferlib.pufferlib.environments.microrts.environment",
        "description": "deps.pufferlib.pufferlib.environments.microrts.environment",
        "peekOfCode": "class MicroRTS:\n    def __init__(self, env):\n        self.env = env\n        self.observation_space = self.env.observation_space\n        self.action_space = self.env.action_space\n        self.render = self.env.render\n        self.close = self.env.close\n        self.seed = self.env.seed\n    def reset(self):\n        return self.env.reset().astype(np.int32)",
        "detail": "deps.pufferlib.pufferlib.environments.microrts.environment",
        "documentation": {}
    },
    {
        "label": "env_creator",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.environments.microrts.environment",
        "description": "deps.pufferlib.pufferlib.environments.microrts.environment",
        "peekOfCode": "def env_creator(name='GlobalAgentCombinedRewardEnv'):\n    return functools.partial(make, name)\ndef make(name):\n    '''Gym MicroRTS creation function\n    This library appears broken. Step crashes in Java.\n    '''\n    pufferlib.environments.try_import('gym_microrts')\n    if name == 'GlobalAgentCombinedRewardEnv':\n        from gym_microrts.envs import GlobalAgentCombinedRewardEnv\n    else:",
        "detail": "deps.pufferlib.pufferlib.environments.microrts.environment",
        "documentation": {}
    },
    {
        "label": "make",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.environments.microrts.environment",
        "description": "deps.pufferlib.pufferlib.environments.microrts.environment",
        "peekOfCode": "def make(name):\n    '''Gym MicroRTS creation function\n    This library appears broken. Step crashes in Java.\n    '''\n    pufferlib.environments.try_import('gym_microrts')\n    if name == 'GlobalAgentCombinedRewardEnv':\n        from gym_microrts.envs import GlobalAgentCombinedRewardEnv\n    else:\n        raise ValueError(f'Unknown environment: {name}')\n    with pufferlib.utils.Suppress():",
        "detail": "deps.pufferlib.pufferlib.environments.microrts.environment",
        "documentation": {}
    },
    {
        "label": "env_creator",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.environments.minerl.environment",
        "description": "deps.pufferlib.pufferlib.environments.minerl.environment",
        "peekOfCode": "def env_creator(name='MineRLBasaltFindCave-v0'):\n    return functools.partial(make, name=name)\ndef make(name):\n    '''Minecraft environment creation function'''\n    pufferlib.environments.try_import('minerl')\n    # Monkey patch to add .itmes to old gym.spaces.Dict\n    #gym.spaces.Dict.items = lambda self: self.spaces.items()\n    #with pufferlib.utils.Suppress():\n    env = gym.make(name)\n    env = shimmy.GymV21CompatibilityV0(env=env)",
        "detail": "deps.pufferlib.pufferlib.environments.minerl.environment",
        "documentation": {}
    },
    {
        "label": "make",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.environments.minerl.environment",
        "description": "deps.pufferlib.pufferlib.environments.minerl.environment",
        "peekOfCode": "def make(name):\n    '''Minecraft environment creation function'''\n    pufferlib.environments.try_import('minerl')\n    # Monkey patch to add .itmes to old gym.spaces.Dict\n    #gym.spaces.Dict.items = lambda self: self.spaces.items()\n    #with pufferlib.utils.Suppress():\n    env = gym.make(name)\n    env = shimmy.GymV21CompatibilityV0(env=env)\n    return pufferlib.emulation.GymnasiumPufferEnv(env)",
        "detail": "deps.pufferlib.pufferlib.environments.minerl.environment",
        "documentation": {}
    },
    {
        "label": "MiniGridWrapper",
        "kind": 6,
        "importPath": "deps.pufferlib.pufferlib.environments.minigrid.environment",
        "description": "deps.pufferlib.pufferlib.environments.minigrid.environment",
        "peekOfCode": "class MiniGridWrapper:\n    def __init__(self, env):\n        self.env = env\n        self.observation_space = gymnasium.spaces.Dict({\n            k: v for k, v in self.env.observation_space.items() if\n            k != 'mission'\n        })\n        self.action_space = self.env.action_space\n        self.close = self.env.close\n        self.render = self.env.render",
        "detail": "deps.pufferlib.pufferlib.environments.minigrid.environment",
        "documentation": {}
    },
    {
        "label": "env_creator",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.environments.minigrid.environment",
        "description": "deps.pufferlib.pufferlib.environments.minigrid.environment",
        "peekOfCode": "def env_creator(name='minigrid'):\n    return functools.partial(make, name=name)\ndef make(name, render_mode='rgb_array'):\n    if name in ALIASES:\n        name = ALIASES[name]\n    minigrid = pufferlib.environments.try_import('minigrid')\n    env = gymnasium.make(name, render_mode=render_mode)\n    env = MiniGridWrapper(env)\n    env = pufferlib.postprocess.EpisodeStats(env)\n    return pufferlib.emulation.GymnasiumPufferEnv(env=env)",
        "detail": "deps.pufferlib.pufferlib.environments.minigrid.environment",
        "documentation": {}
    },
    {
        "label": "make",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.environments.minigrid.environment",
        "description": "deps.pufferlib.pufferlib.environments.minigrid.environment",
        "peekOfCode": "def make(name, render_mode='rgb_array'):\n    if name in ALIASES:\n        name = ALIASES[name]\n    minigrid = pufferlib.environments.try_import('minigrid')\n    env = gymnasium.make(name, render_mode=render_mode)\n    env = MiniGridWrapper(env)\n    env = pufferlib.postprocess.EpisodeStats(env)\n    return pufferlib.emulation.GymnasiumPufferEnv(env=env)\nclass MiniGridWrapper:\n    def __init__(self, env):",
        "detail": "deps.pufferlib.pufferlib.environments.minigrid.environment",
        "documentation": {}
    },
    {
        "label": "ALIASES",
        "kind": 5,
        "importPath": "deps.pufferlib.pufferlib.environments.minigrid.environment",
        "description": "deps.pufferlib.pufferlib.environments.minigrid.environment",
        "peekOfCode": "ALIASES = {\n    'minigrid': 'MiniGrid-LavaGapS7-v0',\n}\ndef env_creator(name='minigrid'):\n    return functools.partial(make, name=name)\ndef make(name, render_mode='rgb_array'):\n    if name in ALIASES:\n        name = ALIASES[name]\n    minigrid = pufferlib.environments.try_import('minigrid')\n    env = gymnasium.make(name, render_mode=render_mode)",
        "detail": "deps.pufferlib.pufferlib.environments.minigrid.environment",
        "documentation": {}
    },
    {
        "label": "MinihackWrapper",
        "kind": 6,
        "importPath": "deps.pufferlib.pufferlib.environments.minihack.environment",
        "description": "deps.pufferlib.pufferlib.environments.minihack.environment",
        "peekOfCode": "class MinihackWrapper:\n    def __init__(self, env):\n        self.env = env\n        self.observation_space = self.env.observation_space\n        self.action_space = self.env.action_space\n        self.close = self.env.close\n        self.close = self.env.close\n        self.render_mode = 'ansi'\n    def reset(self, seed=None):\n        obs, info = self.env.reset(seed=seed)",
        "detail": "deps.pufferlib.pufferlib.environments.minihack.environment",
        "documentation": {}
    },
    {
        "label": "env_creator",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.environments.minihack.environment",
        "description": "deps.pufferlib.pufferlib.environments.minihack.environment",
        "peekOfCode": "def env_creator(name='minihack'):\n    return functools.partial(make, name)\ndef make(name):\n    '''NetHack binding creation function'''\n    if name in ALIASES:\n        name = ALIASES[name]\n    import minihack\n    pufferlib.environments.try_import('minihack')\n    obs_key = minihack.base.MH_DEFAULT_OBS_KEYS + EXTRA_OBS_KEYS\n    env = gym.make(name, observation_keys=obs_key)",
        "detail": "deps.pufferlib.pufferlib.environments.minihack.environment",
        "documentation": {}
    },
    {
        "label": "make",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.environments.minihack.environment",
        "description": "deps.pufferlib.pufferlib.environments.minihack.environment",
        "peekOfCode": "def make(name):\n    '''NetHack binding creation function'''\n    if name in ALIASES:\n        name = ALIASES[name]\n    import minihack\n    pufferlib.environments.try_import('minihack')\n    obs_key = minihack.base.MH_DEFAULT_OBS_KEYS + EXTRA_OBS_KEYS\n    env = gym.make(name, observation_keys=obs_key)\n    env = shimmy.GymV21CompatibilityV0(env=env)\n    env = MinihackWrapper(env)",
        "detail": "deps.pufferlib.pufferlib.environments.minihack.environment",
        "documentation": {}
    },
    {
        "label": "EXTRA_OBS_KEYS",
        "kind": 5,
        "importPath": "deps.pufferlib.pufferlib.environments.minihack.environment",
        "description": "deps.pufferlib.pufferlib.environments.minihack.environment",
        "peekOfCode": "EXTRA_OBS_KEYS = [\n    'tty_chars',\n    'tty_colors',\n    'tty_cursor',\n]\nALIASES = {\n    'minihack': 'MiniHack-River-v0',\n}\ndef env_creator(name='minihack'):\n    return functools.partial(make, name)",
        "detail": "deps.pufferlib.pufferlib.environments.minihack.environment",
        "documentation": {}
    },
    {
        "label": "ALIASES",
        "kind": 5,
        "importPath": "deps.pufferlib.pufferlib.environments.minihack.environment",
        "description": "deps.pufferlib.pufferlib.environments.minihack.environment",
        "peekOfCode": "ALIASES = {\n    'minihack': 'MiniHack-River-v0',\n}\ndef env_creator(name='minihack'):\n    return functools.partial(make, name)\ndef make(name):\n    '''NetHack binding creation function'''\n    if name in ALIASES:\n        name = ALIASES[name]\n    import minihack",
        "detail": "deps.pufferlib.pufferlib.environments.minihack.environment",
        "documentation": {}
    },
    {
        "label": "Recurrent",
        "kind": 6,
        "importPath": "deps.pufferlib.pufferlib.environments.minihack.torch",
        "description": "deps.pufferlib.pufferlib.environments.minihack.torch",
        "peekOfCode": "class Recurrent(pufferlib.models.LSTMWrapper):\n    def __init__(self, env, policy, input_size=512, hidden_size=512, num_layers=1):\n        super().__init__(env, policy, input_size, hidden_size, num_layers)",
        "detail": "deps.pufferlib.pufferlib.environments.minihack.torch",
        "documentation": {}
    },
    {
        "label": "single_env_creator",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.environments.mujoco.environment",
        "description": "deps.pufferlib.pufferlib.environments.mujoco.environment",
        "peekOfCode": "def single_env_creator(env_name, capture_video, gamma, run_name=None, idx=None, obs_norm=True, pufferl=False):\n    if capture_video and idx == 0:\n        assert run_name is not None, \"run_name must be specified when capturing videos\"\n        env = gymnasium.make(env_name, render_mode=\"rgb_array\")\n        env = gymnasium.wrappers.RecordVideo(env, f\"videos/{run_name}\")\n    else:\n        env = gymnasium.make(env_name)\n    env = pufferlib.postprocess.ClipAction(env)  # NOTE: this changed actions space\n    env = pufferlib.postprocess.EpisodeStats(env)\n    if obs_norm:",
        "detail": "deps.pufferlib.pufferlib.environments.mujoco.environment",
        "documentation": {}
    },
    {
        "label": "cleanrl_env_creator",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.environments.mujoco.environment",
        "description": "deps.pufferlib.pufferlib.environments.mujoco.environment",
        "peekOfCode": "def cleanrl_env_creator(env_name, run_name, capture_video, gamma, idx):\n    kwargs = {\n        \"env_name\": env_name,\n        \"run_name\": run_name,\n        \"capture_video\": capture_video,\n        \"gamma\": gamma,\n        \"idx\": idx,\n        \"pufferl\": False,\n    }\n    return functools.partial(single_env_creator, **kwargs)",
        "detail": "deps.pufferlib.pufferlib.environments.mujoco.environment",
        "documentation": {}
    },
    {
        "label": "env_creator",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.environments.mujoco.environment",
        "description": "deps.pufferlib.pufferlib.environments.mujoco.environment",
        "peekOfCode": "def env_creator(env_name=\"HalfCheetah-v4\", gamma=0.99):\n    default_kwargs = {\n        \"env_name\": env_name,\n        \"capture_video\": False,\n        \"gamma\": gamma,\n        \"pufferl\": True,\n    }\n    return functools.partial(single_env_creator, **default_kwargs)",
        "detail": "deps.pufferlib.pufferlib.environments.mujoco.environment",
        "documentation": {}
    },
    {
        "label": "Recurrent",
        "kind": 6,
        "importPath": "deps.pufferlib.pufferlib.environments.mujoco.policy",
        "description": "deps.pufferlib.pufferlib.environments.mujoco.policy",
        "peekOfCode": "class Recurrent(pufferlib.models.LSTMWrapper):\n    def __init__(self, env, policy, input_size=128, hidden_size=128, num_layers=1):\n        super().__init__(env, policy, input_size, hidden_size, num_layers)\n# Difference between CleanRL and PufferRL policies is that\n# CleanRL has seperate actor and critic networks, while\n# PufferRL has a single encoding network that is shared between\n# the actor and critic networks\nclass CleanRLPolicy(torch.nn.Module):\n    def __init__(self, env, hidden_size=64):\n        super().__init__()",
        "detail": "deps.pufferlib.pufferlib.environments.mujoco.policy",
        "documentation": {}
    },
    {
        "label": "CleanRLPolicy",
        "kind": 6,
        "importPath": "deps.pufferlib.pufferlib.environments.mujoco.policy",
        "description": "deps.pufferlib.pufferlib.environments.mujoco.policy",
        "peekOfCode": "class CleanRLPolicy(torch.nn.Module):\n    def __init__(self, env, hidden_size=64):\n        super().__init__()\n        self.is_continuous = isinstance(env.single_action_space, pufferlib.spaces.Box)\n        self.actor_encoder = nn.Sequential(\n            layer_init(nn.Linear(np.array(env.single_observation_space.shape).prod(), hidden_size)),\n            nn.Tanh(),\n            layer_init(nn.Linear(hidden_size, hidden_size)),\n            nn.Tanh(),\n        )",
        "detail": "deps.pufferlib.pufferlib.environments.mujoco.policy",
        "documentation": {}
    },
    {
        "label": "NethackWrapper",
        "kind": 6,
        "importPath": "deps.pufferlib.pufferlib.environments.nethack.environment",
        "description": "deps.pufferlib.pufferlib.environments.nethack.environment",
        "peekOfCode": "class NethackWrapper:\n    def __init__(self, env):\n        self.env = env\n        self.observation_space = self.env.observation_space\n        self.action_space = self.env.action_space\n        self.close = self.env.close\n        self.close = self.env.close\n        self.render_mode = 'ansi'\n    def reset(self, seed=None):\n        obs, info = self.env.reset(seed=seed)",
        "detail": "deps.pufferlib.pufferlib.environments.nethack.environment",
        "documentation": {}
    },
    {
        "label": "env_creator",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.environments.nethack.environment",
        "description": "deps.pufferlib.pufferlib.environments.nethack.environment",
        "peekOfCode": "def env_creator(name='nethack'):\n    return functools.partial(make, name)\ndef make(name):\n    '''NetHack binding creation function'''\n    if name == 'nethack':\n        name = 'NetHackScore-v0'\n    nle = pufferlib.environments.try_import('nle')\n    env = gym.make(name)\n    #env = RenderCharImagesWithNumpyWrapper(env)\n    env = shimmy.GymV21CompatibilityV0(env=env)",
        "detail": "deps.pufferlib.pufferlib.environments.nethack.environment",
        "documentation": {}
    },
    {
        "label": "make",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.environments.nethack.environment",
        "description": "deps.pufferlib.pufferlib.environments.nethack.environment",
        "peekOfCode": "def make(name):\n    '''NetHack binding creation function'''\n    if name == 'nethack':\n        name = 'NetHackScore-v0'\n    nle = pufferlib.environments.try_import('nle')\n    env = gym.make(name)\n    #env = RenderCharImagesWithNumpyWrapper(env)\n    env = shimmy.GymV21CompatibilityV0(env=env)\n    env = NethackWrapper(env)\n    env = pufferlib.postprocess.EpisodeStats(env)",
        "detail": "deps.pufferlib.pufferlib.environments.nethack.environment",
        "documentation": {}
    },
    {
        "label": "Recurrent",
        "kind": 6,
        "importPath": "deps.pufferlib.pufferlib.environments.nethack.torch",
        "description": "deps.pufferlib.pufferlib.environments.nethack.torch",
        "peekOfCode": "class Recurrent(pufferlib.models.LSTMWrapper):\n    def __init__(self, env, policy, input_size=256, hidden_size=256, num_layers=1):\n        super().__init__(env, policy, input_size, hidden_size, num_layers)\nclass Policy(nn.Module):\n    def __init__(self, env):\n        super().__init__()\n        self.dtype = pufferlib.pytorch.nativize_dtype(env.emulated)\n        self.blstats_net = nn.Sequential(\n            nn.Embedding(256, 32),\n            nn.Flatten(),",
        "detail": "deps.pufferlib.pufferlib.environments.nethack.torch",
        "documentation": {}
    },
    {
        "label": "Policy",
        "kind": 6,
        "importPath": "deps.pufferlib.pufferlib.environments.nethack.torch",
        "description": "deps.pufferlib.pufferlib.environments.nethack.torch",
        "peekOfCode": "class Policy(nn.Module):\n    def __init__(self, env):\n        super().__init__()\n        self.dtype = pufferlib.pytorch.nativize_dtype(env.emulated)\n        self.blstats_net = nn.Sequential(\n            nn.Embedding(256, 32),\n            nn.Flatten(),\n        )\n        self.char_embed = nn.Embedding(256, 32)\n        self.chars_net = nn.Sequential(",
        "detail": "deps.pufferlib.pufferlib.environments.nethack.torch",
        "documentation": {}
    },
    {
        "label": "RenderCharImagesWithNumpyWrapper",
        "kind": 6,
        "importPath": "deps.pufferlib.pufferlib.environments.nethack.wrapper",
        "description": "deps.pufferlib.pufferlib.environments.nethack.wrapper",
        "peekOfCode": "class RenderCharImagesWithNumpyWrapper(gym.Wrapper):\n    \"\"\"\n    Render characters as images, using PIL to render characters like we humans see on screen\n    but then some caching and numpy stuff to speed up things.\n    To speed things up, crop image around the player.\n    \"\"\"\n    def __init__(\n        self,\n        env,\n        font_size=9,",
        "detail": "deps.pufferlib.pufferlib.environments.nethack.wrapper",
        "documentation": {}
    },
    {
        "label": "RenderCharImagesWithNumpyWrapperV2",
        "kind": 6,
        "importPath": "deps.pufferlib.pufferlib.environments.nethack.wrapper",
        "description": "deps.pufferlib.pufferlib.environments.nethack.wrapper",
        "peekOfCode": "class RenderCharImagesWithNumpyWrapperV2(gym.Wrapper):\n    \"\"\"\n    Same as V1, but simpler and faster.\n    \"\"\"\n    def __init__(\n        self,\n        env,\n        font_size=9,\n        crop_size=12,\n        rescale_font_size=(6, 6),",
        "detail": "deps.pufferlib.pufferlib.environments.nethack.wrapper",
        "documentation": {}
    },
    {
        "label": "SMALL_FONT_PATH",
        "kind": 5,
        "importPath": "deps.pufferlib.pufferlib.environments.nethack.wrapper",
        "description": "deps.pufferlib.pufferlib.environments.nethack.wrapper",
        "peekOfCode": "SMALL_FONT_PATH = os.path.join(__package__.replace(\".\", \"/\"), \"Hack-Regular.ttf\")\n# Mapping of 0-15 colors used.\n# Taken from bottom image here. It seems about right\n# https://i.stack.imgur.com/UQVe5.png\nCOLORS = [\n    \"#000000\",\n    \"#800000\",\n    \"#008000\",\n    \"#808000\",\n    \"#000080\",",
        "detail": "deps.pufferlib.pufferlib.environments.nethack.wrapper",
        "documentation": {}
    },
    {
        "label": "COLORS",
        "kind": 5,
        "importPath": "deps.pufferlib.pufferlib.environments.nethack.wrapper",
        "description": "deps.pufferlib.pufferlib.environments.nethack.wrapper",
        "peekOfCode": "COLORS = [\n    \"#000000\",\n    \"#800000\",\n    \"#008000\",\n    \"#808000\",\n    \"#000080\",\n    \"#800080\",\n    \"#008080\",\n    \"#808080\",  # - flipped these ones around\n    \"#C0C0C0\",  # | the gray-out dull stuff",
        "detail": "deps.pufferlib.pufferlib.environments.nethack.wrapper",
        "documentation": {}
    },
    {
        "label": "NMMOWrapper",
        "kind": 6,
        "importPath": "deps.pufferlib.pufferlib.environments.nmmo.environment",
        "description": "deps.pufferlib.pufferlib.environments.nmmo.environment",
        "peekOfCode": "class NMMOWrapper(pufferlib.postprocess.PettingZooWrapper):\n    '''Remove task spam'''\n    @property\n    def render_mode(self):\n        return 'rgb_array'\n    def render(self):\n        '''Quick little renderer for NMMO'''\n        tiles = self.env.tile_map[:, :, 2].astype(np.uint8)\n        render = np.zeros((tiles.shape[0], tiles.shape[1], 3), dtype=np.uint8)\n        BROWN = (136, 69, 19)",
        "detail": "deps.pufferlib.pufferlib.environments.nmmo.environment",
        "documentation": {}
    },
    {
        "label": "env_creator",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.environments.nmmo.environment",
        "description": "deps.pufferlib.pufferlib.environments.nmmo.environment",
        "peekOfCode": "def env_creator(name='nmmo'):\n    return functools.partial(make, name)\ndef make(name, *args, **kwargs):\n    '''Neural MMO creation function'''\n    nmmo = pufferlib.environments.try_import('nmmo')\n    env = nmmo.Env(*args, **kwargs)\n    env = NMMOWrapper(env)\n    env = pufferlib.postprocess.MultiagentEpisodeStats(env)\n    env = pufferlib.postprocess.MeanOverAgents(env)\n    return pufferlib.emulation.PettingZooPufferEnv(env=env)",
        "detail": "deps.pufferlib.pufferlib.environments.nmmo.environment",
        "documentation": {}
    },
    {
        "label": "make",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.environments.nmmo.environment",
        "description": "deps.pufferlib.pufferlib.environments.nmmo.environment",
        "peekOfCode": "def make(name, *args, **kwargs):\n    '''Neural MMO creation function'''\n    nmmo = pufferlib.environments.try_import('nmmo')\n    env = nmmo.Env(*args, **kwargs)\n    env = NMMOWrapper(env)\n    env = pufferlib.postprocess.MultiagentEpisodeStats(env)\n    env = pufferlib.postprocess.MeanOverAgents(env)\n    return pufferlib.emulation.PettingZooPufferEnv(env=env)\nclass NMMOWrapper(pufferlib.postprocess.PettingZooWrapper):\n    '''Remove task spam'''",
        "detail": "deps.pufferlib.pufferlib.environments.nmmo.environment",
        "documentation": {}
    },
    {
        "label": "Recurrent",
        "kind": 6,
        "importPath": "deps.pufferlib.pufferlib.environments.nmmo.torch",
        "description": "deps.pufferlib.pufferlib.environments.nmmo.torch",
        "peekOfCode": "class Recurrent(pufferlib.models.LSTMWrapper):\n    def __init__(self, env, policy, input_size=256, hidden_size=256, num_layers=1):\n        super().__init__(env, policy, input_size, hidden_size, num_layers)\nclass Policy(torch.nn.Module):\n  NUM_ATTRS = 34\n  EntityId = EntityState.State.attr_name_to_col[\"id\"]\n  tile_offset = torch.tensor([i*256 for i in range(3)])\n  entity_offset = torch.tensor([i*256 for i in range(3, 34)])\n  def __init__(self, env, input_size=256, hidden_size=256, output_size=256):\n      super().__init__()",
        "detail": "deps.pufferlib.pufferlib.environments.nmmo.torch",
        "documentation": {}
    },
    {
        "label": "Policy",
        "kind": 6,
        "importPath": "deps.pufferlib.pufferlib.environments.nmmo.torch",
        "description": "deps.pufferlib.pufferlib.environments.nmmo.torch",
        "peekOfCode": "class Policy(torch.nn.Module):\n  NUM_ATTRS = 34\n  EntityId = EntityState.State.attr_name_to_col[\"id\"]\n  tile_offset = torch.tensor([i*256 for i in range(3)])\n  entity_offset = torch.tensor([i*256 for i in range(3, 34)])\n  def __init__(self, env, input_size=256, hidden_size=256, output_size=256):\n      super().__init__()\n      self.dtype = pufferlib.pytorch.nativize_dtype(env.emulated)\n      # A dumb example encoder that applies a linear layer to agent self features\n      self.embedding = torch.nn.Embedding(self.NUM_ATTRS*256, 32)",
        "detail": "deps.pufferlib.pufferlib.environments.nmmo.torch",
        "documentation": {}
    },
    {
        "label": "env_creator",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.environments.nmmo3.environment",
        "description": "deps.pufferlib.pufferlib.environments.nmmo3.environment",
        "peekOfCode": "def env_creator(name='nmmo3'):\n    return functools.partial(make, name)\ndef make(name, num_envs=1):\n    return PuffEnv(\n        width=2*[2048],\n        height=2*[2048],\n        num_envs=2,\n    )",
        "detail": "deps.pufferlib.pufferlib.environments.nmmo3.environment",
        "documentation": {}
    },
    {
        "label": "make",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.environments.nmmo3.environment",
        "description": "deps.pufferlib.pufferlib.environments.nmmo3.environment",
        "peekOfCode": "def make(name, num_envs=1):\n    return PuffEnv(\n        width=2*[2048],\n        height=2*[2048],\n        num_envs=2,\n    )",
        "detail": "deps.pufferlib.pufferlib.environments.nmmo3.environment",
        "documentation": {}
    },
    {
        "label": "Recurrent",
        "kind": 6,
        "importPath": "deps.pufferlib.pufferlib.environments.nmmo3.torch",
        "description": "deps.pufferlib.pufferlib.environments.nmmo3.torch",
        "peekOfCode": "class Recurrent(pufferlib.models.LSTMWrapper):\n    def __init__(self, env, policy, input_size=384, hidden_size=256, num_layers=1):\n        super().__init__(env, policy, input_size, hidden_size, num_layers)\nclass Decompressor(nn.Module):\n    def __init__(self):\n        super().__init__()\n        factors = np.array([4, 4, 16, 5, 3, 5, 5, 6, 7, 4])\n        n_channels = sum(factors)\n        add = np.array([0, *np.cumsum(factors).tolist()[:-1]])[None, :, None]\n        div = np.array([1, *np.cumprod(factors).tolist()[:-1]])[None, :, None]",
        "detail": "deps.pufferlib.pufferlib.environments.nmmo3.torch",
        "documentation": {}
    },
    {
        "label": "Decompressor",
        "kind": 6,
        "importPath": "deps.pufferlib.pufferlib.environments.nmmo3.torch",
        "description": "deps.pufferlib.pufferlib.environments.nmmo3.torch",
        "peekOfCode": "class Decompressor(nn.Module):\n    def __init__(self):\n        super().__init__()\n        factors = np.array([4, 4, 16, 5, 3, 5, 5, 6, 7, 4])\n        n_channels = sum(factors)\n        add = np.array([0, *np.cumsum(factors).tolist()[:-1]])[None, :, None]\n        div = np.array([1, *np.cumprod(factors).tolist()[:-1]])[None, :, None]\n        factors = torch.tensor(factors)[None, :, None].cuda()\n        add = torch.tensor(add).cuda()\n        div = torch.tensor(div).cuda()",
        "detail": "deps.pufferlib.pufferlib.environments.nmmo3.torch",
        "documentation": {}
    },
    {
        "label": "PlayerProjEncoder",
        "kind": 6,
        "importPath": "deps.pufferlib.pufferlib.environments.nmmo3.torch",
        "description": "deps.pufferlib.pufferlib.environments.nmmo3.torch",
        "peekOfCode": "class PlayerProjEncoder(nn.Module):\n    def __init__(self, hidden_size):\n        super().__init__()\n        self.player_embed = nn.Embedding(128, 32)\n        self.player_continuous = pufferlib.pytorch.layer_init(\n            nn.Linear(47, hidden_size//2))\n        self.discrete_proj = pufferlib.pytorch.layer_init(\n            nn.Linear(32*47, hidden_size//2))\n        self.player_proj = pufferlib.pytorch.layer_init(\n            nn.Linear(hidden_size, hidden_size//2))",
        "detail": "deps.pufferlib.pufferlib.environments.nmmo3.torch",
        "documentation": {}
    },
    {
        "label": "PlayerEncoder",
        "kind": 6,
        "importPath": "deps.pufferlib.pufferlib.environments.nmmo3.torch",
        "description": "deps.pufferlib.pufferlib.environments.nmmo3.torch",
        "peekOfCode": "class PlayerEncoder(nn.Module):\n    def __init__(self, hidden_size):\n        super().__init__()\n        self.player_embed = nn.Embedding(128, hidden_size//4)\n        self.player_continuous = pufferlib.pytorch.layer_init(\n            nn.Linear(47, hidden_size//4))\n        self.player_proj = pufferlib.pytorch.layer_init(\n            nn.Linear(hidden_size, hidden_size//4))\n    def forward(self, player):\n        player[-2:] /= 10",
        "detail": "deps.pufferlib.pufferlib.environments.nmmo3.torch",
        "documentation": {}
    },
    {
        "label": "Policy",
        "kind": 6,
        "importPath": "deps.pufferlib.pufferlib.environments.nmmo3.torch",
        "description": "deps.pufferlib.pufferlib.environments.nmmo3.torch",
        "peekOfCode": "class Policy(nn.Module):\n    def __init__(self, env, hidden_size=256, output_size=256):\n        super().__init__()\n        #self.dtype = pufferlib.pytorch.nativize_dtype(env.emulated)\n        self.num_actions = env.single_action_space.n\n        self.decompressor = Decompressor()\n        self.map_2d = nn.Sequential(\n            pufferlib.pytorch.layer_init(nn.Conv2d(59, 64, 5, stride=3)),\n            nn.ReLU(),\n            pufferlib.pytorch.layer_init(nn.Conv2d(64, 64, 3, stride=1)),",
        "detail": "deps.pufferlib.pufferlib.environments.nmmo3.torch",
        "documentation": {}
    },
    {
        "label": "PufferGrid",
        "kind": 6,
        "importPath": "deps.pufferlib.pufferlib.environments.ocean.grid.grid",
        "description": "deps.pufferlib.pufferlib.environments.ocean.grid.grid",
        "peekOfCode": "class PufferGrid(pufferlib.PufferEnv):\n    def __init__(self, width=1024, height=1024, num_agents=4096,\n            horizon=1024, vision_range=5, agent_speed=1.0,\n            discretize=False, food_reward=0.1,\n            init_fn=init_group, reward_fn=reward_group,\n            expected_lifespan=1000, report_interval=32, render_mode='rgb_array'):\n        super().__init__()\n        self.width = width \n        self.height = height\n        self.num_agents = num_agents",
        "detail": "deps.pufferlib.pufferlib.environments.ocean.grid.grid",
        "documentation": {}
    },
    {
        "label": "RaylibClient",
        "kind": 6,
        "importPath": "deps.pufferlib.pufferlib.environments.ocean.grid.grid",
        "description": "deps.pufferlib.pufferlib.environments.ocean.grid.grid",
        "peekOfCode": "class RaylibClient:\n    def __init__(self, width, height, tile_size=32):\n        self.width = width\n        self.height = height\n        self.tile_size = tile_size\n        self.uv_coords = {\n            3: (0, 0, 128, 128),\n            4: (128, 0, 128, 128),\n            5: (256, 0, 128, 128),\n            6: (384, 0, 128, 128),",
        "detail": "deps.pufferlib.pufferlib.environments.ocean.grid.grid",
        "documentation": {}
    },
    {
        "label": "init_introverts",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.environments.ocean.grid.grid",
        "description": "deps.pufferlib.pufferlib.environments.ocean.grid.grid",
        "peekOfCode": "def init_introverts(env):\n    pass\ndef reward_introverts(env):\n    '''-1 for each nearby agent'''\n    raw_rewards = 1 - (env.obs_view>=AGENT_1).sum(axis=(1,2))\n    return np.clip(raw_rewards/10, -1, 0)\ndef reward_centralized(env):\n    '''Centralized Euclidean distance'''\n    pos = env.agent_positions / env.map_size\n    sq_diff = (pos[None, :, :] - pos[:, None, :])**2",
        "detail": "deps.pufferlib.pufferlib.environments.ocean.grid.grid",
        "documentation": {}
    },
    {
        "label": "reward_introverts",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.environments.ocean.grid.grid",
        "description": "deps.pufferlib.pufferlib.environments.ocean.grid.grid",
        "peekOfCode": "def reward_introverts(env):\n    '''-1 for each nearby agent'''\n    raw_rewards = 1 - (env.obs_view>=AGENT_1).sum(axis=(1,2))\n    return np.clip(raw_rewards/10, -1, 0)\ndef reward_centralized(env):\n    '''Centralized Euclidean distance'''\n    pos = env.agent_positions / env.map_size\n    sq_diff = (pos[None, :, :] - pos[:, None, :])**2\n    return np.sqrt(sq_diff.sum(2)).sum(1) / env.map_size\ndef init_introverts(env):",
        "detail": "deps.pufferlib.pufferlib.environments.ocean.grid.grid",
        "documentation": {}
    },
    {
        "label": "reward_centralized",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.environments.ocean.grid.grid",
        "description": "deps.pufferlib.pufferlib.environments.ocean.grid.grid",
        "peekOfCode": "def reward_centralized(env):\n    '''Centralized Euclidean distance'''\n    pos = env.agent_positions / env.map_size\n    sq_diff = (pos[None, :, :] - pos[:, None, :])**2\n    return np.sqrt(sq_diff.sum(2)).sum(1) / env.map_size\ndef init_introverts(env):\n    pass\ndef init_foraging(env, food_prob=0.1):\n    rng = np.random.rand(env.height, env.width)\n    env.grid[(rng<food_prob) * (env.grid==EMPTY)] = FOOD",
        "detail": "deps.pufferlib.pufferlib.environments.ocean.grid.grid",
        "documentation": {}
    },
    {
        "label": "init_introverts",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.environments.ocean.grid.grid",
        "description": "deps.pufferlib.pufferlib.environments.ocean.grid.grid",
        "peekOfCode": "def init_introverts(env):\n    pass\ndef init_foraging(env, food_prob=0.1):\n    rng = np.random.rand(env.height, env.width)\n    env.grid[(rng<food_prob) * (env.grid==EMPTY)] = FOOD\n    env.grid[(rng>=food_prob) * (env.grid==EMPTY)] = EMPTY\ndef reward_foraging(env):\n    return np.zeros(env.num_agents, dtype=np.float32)\ndef init_predator_prey(env):\n    n = env.num_agents // 2",
        "detail": "deps.pufferlib.pufferlib.environments.ocean.grid.grid",
        "documentation": {}
    },
    {
        "label": "init_foraging",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.environments.ocean.grid.grid",
        "description": "deps.pufferlib.pufferlib.environments.ocean.grid.grid",
        "peekOfCode": "def init_foraging(env, food_prob=0.1):\n    rng = np.random.rand(env.height, env.width)\n    env.grid[(rng<food_prob) * (env.grid==EMPTY)] = FOOD\n    env.grid[(rng>=food_prob) * (env.grid==EMPTY)] = EMPTY\ndef reward_foraging(env):\n    return np.zeros(env.num_agents, dtype=np.float32)\ndef init_predator_prey(env):\n    n = env.num_agents // 2\n    env.agent_colors[:n] = AGENT_1\n    env.agent_colors[n:] = AGENT_2",
        "detail": "deps.pufferlib.pufferlib.environments.ocean.grid.grid",
        "documentation": {}
    },
    {
        "label": "reward_foraging",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.environments.ocean.grid.grid",
        "description": "deps.pufferlib.pufferlib.environments.ocean.grid.grid",
        "peekOfCode": "def reward_foraging(env):\n    return np.zeros(env.num_agents, dtype=np.float32)\ndef init_predator_prey(env):\n    n = env.num_agents // 2\n    env.agent_colors[:n] = AGENT_1\n    env.agent_colors[n:] = AGENT_2\ndef reward_predator_prey(env):\n    rewards = np.zeros(env.num_agents, dtype=np.float32)\n    n = env.num_agents // 2\n    # Predator wants to keep prey in sight",
        "detail": "deps.pufferlib.pufferlib.environments.ocean.grid.grid",
        "documentation": {}
    },
    {
        "label": "init_predator_prey",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.environments.ocean.grid.grid",
        "description": "deps.pufferlib.pufferlib.environments.ocean.grid.grid",
        "peekOfCode": "def init_predator_prey(env):\n    n = env.num_agents // 2\n    env.agent_colors[:n] = AGENT_1\n    env.agent_colors[n:] = AGENT_2\ndef reward_predator_prey(env):\n    rewards = np.zeros(env.num_agents, dtype=np.float32)\n    n = env.num_agents // 2\n    # Predator wants to keep prey in sight\n    rewards[:n] = (env.obs_view[:n] == AGENT_2).sum(axis=(1,2))\n    # Prey wants to keep predator out of sight",
        "detail": "deps.pufferlib.pufferlib.environments.ocean.grid.grid",
        "documentation": {}
    },
    {
        "label": "reward_predator_prey",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.environments.ocean.grid.grid",
        "description": "deps.pufferlib.pufferlib.environments.ocean.grid.grid",
        "peekOfCode": "def reward_predator_prey(env):\n    rewards = np.zeros(env.num_agents, dtype=np.float32)\n    n = env.num_agents // 2\n    # Predator wants to keep prey in sight\n    rewards[:n] = (env.obs_view[:n] == AGENT_2).sum(axis=(1,2))\n    # Prey wants to keep predator out of sight\n    rewards[n:] = -(env.obs_view[n:] == AGENT_1).sum(axis=(1,2))\n    return np.clip(rewards/10, -1, 1)\ndef init_group(env):\n    pass",
        "detail": "deps.pufferlib.pufferlib.environments.ocean.grid.grid",
        "documentation": {}
    },
    {
        "label": "init_group",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.environments.ocean.grid.grid",
        "description": "deps.pufferlib.pufferlib.environments.ocean.grid.grid",
        "peekOfCode": "def init_group(env):\n    pass\ndef reward_group(env):\n    same_group = env.obs_view == env.agent_colors[:, None, None]\n    same_reward = same_group.sum(axis=(1,2)) - 1\n    diff_group = (env.obs_view>=AGENT_1) * (~same_group)\n    diff_reward = diff_group.sum(axis=(1,2))\n    rewards = same_reward - diff_reward\n    return np.clip(rewards/10, -1, 1)\ndef init_puffer(env):",
        "detail": "deps.pufferlib.pufferlib.environments.ocean.grid.grid",
        "documentation": {}
    },
    {
        "label": "reward_group",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.environments.ocean.grid.grid",
        "description": "deps.pufferlib.pufferlib.environments.ocean.grid.grid",
        "peekOfCode": "def reward_group(env):\n    same_group = env.obs_view == env.agent_colors[:, None, None]\n    same_reward = same_group.sum(axis=(1,2)) - 1\n    diff_group = (env.obs_view>=AGENT_1) * (~same_group)\n    diff_reward = diff_group.sum(axis=(1,2))\n    rewards = same_reward - diff_reward\n    return np.clip(rewards/10, -1, 1)\ndef init_puffer(env):\n    from PIL import Image\n    path = os.path.join(*env.__module__.split('.')[:-1], 'pufferlib.png')",
        "detail": "deps.pufferlib.pufferlib.environments.ocean.grid.grid",
        "documentation": {}
    },
    {
        "label": "init_puffer",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.environments.ocean.grid.grid",
        "description": "deps.pufferlib.pufferlib.environments.ocean.grid.grid",
        "peekOfCode": "def init_puffer(env):\n    from PIL import Image\n    path = os.path.join(*env.__module__.split('.')[:-1], 'pufferlib.png')\n    env.puffer = np.array(Image.open(path))\n    env.filled = env.puffer[:, :, 3] != 0\n    env.red = (env.puffer[:, :, 0] == 255) * env.filled\n    env.blue = (env.puffer[:, :, 1] == 255) * env.filled\n    env.agent_red = (env.agent_colors == AGENT_1) + (env.agent_colors==AGENT_3)\n    env.agent_blue = (env.agent_colors == AGENT_2) + (env.agent_colors==AGENT_4)\ndef reward_puffer(env):",
        "detail": "deps.pufferlib.pufferlib.environments.ocean.grid.grid",
        "documentation": {}
    },
    {
        "label": "reward_puffer",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.environments.ocean.grid.grid",
        "description": "deps.pufferlib.pufferlib.environments.ocean.grid.grid",
        "peekOfCode": "def reward_puffer(env):\n    agent_position = env.agent_positions.astype(np.int32)\n    red = env.red[agent_position[:, 0], agent_position[:, 1]]\n    blue = env.blue[agent_position[:, 0], agent_position[:, 1]]\n    filled_red = (red * env.agent_red).astype(bool)\n    filled_blue = (blue * env.agent_blue).astype(bool)\n    r = env.agent_positions[:, 0]/env.height - 0.5\n    c = env.agent_positions[:, 1]/env.width - 0.5\n    dist = np.sqrt(r**2 + c**2)\n    return filled_red + filled_blue - 0.01*dist",
        "detail": "deps.pufferlib.pufferlib.environments.ocean.grid.grid",
        "documentation": {}
    },
    {
        "label": "init_center",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.environments.ocean.grid.grid",
        "description": "deps.pufferlib.pufferlib.environments.ocean.grid.grid",
        "peekOfCode": "def init_center(env):\n    pass\ndef reward_center(env):\n    r = env.agent_positions[:, 0]/env.height - 0.5\n    c = env.agent_positions[:, 1]/env.width - 0.5\n    return -0.01*np.sqrt(r**2 + c**2)\nclass PufferGrid(pufferlib.PufferEnv):\n    def __init__(self, width=1024, height=1024, num_agents=4096,\n            horizon=1024, vision_range=5, agent_speed=1.0,\n            discretize=False, food_reward=0.1,",
        "detail": "deps.pufferlib.pufferlib.environments.ocean.grid.grid",
        "documentation": {}
    },
    {
        "label": "reward_center",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.environments.ocean.grid.grid",
        "description": "deps.pufferlib.pufferlib.environments.ocean.grid.grid",
        "peekOfCode": "def reward_center(env):\n    r = env.agent_positions[:, 0]/env.height - 0.5\n    c = env.agent_positions[:, 1]/env.width - 0.5\n    return -0.01*np.sqrt(r**2 + c**2)\nclass PufferGrid(pufferlib.PufferEnv):\n    def __init__(self, width=1024, height=1024, num_agents=4096,\n            horizon=1024, vision_range=5, agent_speed=1.0,\n            discretize=False, food_reward=0.1,\n            init_fn=init_group, reward_fn=reward_group,\n            expected_lifespan=1000, report_interval=32, render_mode='rgb_array'):",
        "detail": "deps.pufferlib.pufferlib.environments.ocean.grid.grid",
        "documentation": {}
    },
    {
        "label": "test_puffer_performance",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.environments.ocean.grid.grid",
        "description": "deps.pufferlib.pufferlib.environments.ocean.grid.grid",
        "peekOfCode": "def test_puffer_performance(env, actions, timeout):\n    import time\n    N = actions.shape[0]\n    idx = 0\n    dones = {1: True}\n    start = time.time()\n    while time.time() - start < timeout:\n        if env.done:\n            env.reset()\n            dones = {1: False}",
        "detail": "deps.pufferlib.pufferlib.environments.ocean.grid.grid",
        "documentation": {}
    },
    {
        "label": "EMPTY",
        "kind": 5,
        "importPath": "deps.pufferlib.pufferlib.environments.ocean.grid.grid",
        "description": "deps.pufferlib.pufferlib.environments.ocean.grid.grid",
        "peekOfCode": "EMPTY = 0\nFOOD = 1\nWALL = 2\nAGENT_1 = 3\nAGENT_2 = 4\nAGENT_3 = 5\nAGENT_4 = 6\nPASS = 0\nNORTH = 1\nSOUTH = 2",
        "detail": "deps.pufferlib.pufferlib.environments.ocean.grid.grid",
        "documentation": {}
    },
    {
        "label": "FOOD",
        "kind": 5,
        "importPath": "deps.pufferlib.pufferlib.environments.ocean.grid.grid",
        "description": "deps.pufferlib.pufferlib.environments.ocean.grid.grid",
        "peekOfCode": "FOOD = 1\nWALL = 2\nAGENT_1 = 3\nAGENT_2 = 4\nAGENT_3 = 5\nAGENT_4 = 6\nPASS = 0\nNORTH = 1\nSOUTH = 2\nEAST = 3",
        "detail": "deps.pufferlib.pufferlib.environments.ocean.grid.grid",
        "documentation": {}
    },
    {
        "label": "WALL",
        "kind": 5,
        "importPath": "deps.pufferlib.pufferlib.environments.ocean.grid.grid",
        "description": "deps.pufferlib.pufferlib.environments.ocean.grid.grid",
        "peekOfCode": "WALL = 2\nAGENT_1 = 3\nAGENT_2 = 4\nAGENT_3 = 5\nAGENT_4 = 6\nPASS = 0\nNORTH = 1\nSOUTH = 2\nEAST = 3\nWEST = 4",
        "detail": "deps.pufferlib.pufferlib.environments.ocean.grid.grid",
        "documentation": {}
    },
    {
        "label": "AGENT_1",
        "kind": 5,
        "importPath": "deps.pufferlib.pufferlib.environments.ocean.grid.grid",
        "description": "deps.pufferlib.pufferlib.environments.ocean.grid.grid",
        "peekOfCode": "AGENT_1 = 3\nAGENT_2 = 4\nAGENT_3 = 5\nAGENT_4 = 6\nPASS = 0\nNORTH = 1\nSOUTH = 2\nEAST = 3\nWEST = 4\ndef init_introverts(env):",
        "detail": "deps.pufferlib.pufferlib.environments.ocean.grid.grid",
        "documentation": {}
    },
    {
        "label": "AGENT_2",
        "kind": 5,
        "importPath": "deps.pufferlib.pufferlib.environments.ocean.grid.grid",
        "description": "deps.pufferlib.pufferlib.environments.ocean.grid.grid",
        "peekOfCode": "AGENT_2 = 4\nAGENT_3 = 5\nAGENT_4 = 6\nPASS = 0\nNORTH = 1\nSOUTH = 2\nEAST = 3\nWEST = 4\ndef init_introverts(env):\n    pass",
        "detail": "deps.pufferlib.pufferlib.environments.ocean.grid.grid",
        "documentation": {}
    },
    {
        "label": "AGENT_3",
        "kind": 5,
        "importPath": "deps.pufferlib.pufferlib.environments.ocean.grid.grid",
        "description": "deps.pufferlib.pufferlib.environments.ocean.grid.grid",
        "peekOfCode": "AGENT_3 = 5\nAGENT_4 = 6\nPASS = 0\nNORTH = 1\nSOUTH = 2\nEAST = 3\nWEST = 4\ndef init_introverts(env):\n    pass\ndef reward_introverts(env):",
        "detail": "deps.pufferlib.pufferlib.environments.ocean.grid.grid",
        "documentation": {}
    },
    {
        "label": "AGENT_4",
        "kind": 5,
        "importPath": "deps.pufferlib.pufferlib.environments.ocean.grid.grid",
        "description": "deps.pufferlib.pufferlib.environments.ocean.grid.grid",
        "peekOfCode": "AGENT_4 = 6\nPASS = 0\nNORTH = 1\nSOUTH = 2\nEAST = 3\nWEST = 4\ndef init_introverts(env):\n    pass\ndef reward_introverts(env):\n    '''-1 for each nearby agent'''",
        "detail": "deps.pufferlib.pufferlib.environments.ocean.grid.grid",
        "documentation": {}
    },
    {
        "label": "PASS",
        "kind": 5,
        "importPath": "deps.pufferlib.pufferlib.environments.ocean.grid.grid",
        "description": "deps.pufferlib.pufferlib.environments.ocean.grid.grid",
        "peekOfCode": "PASS = 0\nNORTH = 1\nSOUTH = 2\nEAST = 3\nWEST = 4\ndef init_introverts(env):\n    pass\ndef reward_introverts(env):\n    '''-1 for each nearby agent'''\n    raw_rewards = 1 - (env.obs_view>=AGENT_1).sum(axis=(1,2))",
        "detail": "deps.pufferlib.pufferlib.environments.ocean.grid.grid",
        "documentation": {}
    },
    {
        "label": "NORTH",
        "kind": 5,
        "importPath": "deps.pufferlib.pufferlib.environments.ocean.grid.grid",
        "description": "deps.pufferlib.pufferlib.environments.ocean.grid.grid",
        "peekOfCode": "NORTH = 1\nSOUTH = 2\nEAST = 3\nWEST = 4\ndef init_introverts(env):\n    pass\ndef reward_introverts(env):\n    '''-1 for each nearby agent'''\n    raw_rewards = 1 - (env.obs_view>=AGENT_1).sum(axis=(1,2))\n    return np.clip(raw_rewards/10, -1, 0)",
        "detail": "deps.pufferlib.pufferlib.environments.ocean.grid.grid",
        "documentation": {}
    },
    {
        "label": "SOUTH",
        "kind": 5,
        "importPath": "deps.pufferlib.pufferlib.environments.ocean.grid.grid",
        "description": "deps.pufferlib.pufferlib.environments.ocean.grid.grid",
        "peekOfCode": "SOUTH = 2\nEAST = 3\nWEST = 4\ndef init_introverts(env):\n    pass\ndef reward_introverts(env):\n    '''-1 for each nearby agent'''\n    raw_rewards = 1 - (env.obs_view>=AGENT_1).sum(axis=(1,2))\n    return np.clip(raw_rewards/10, -1, 0)\ndef reward_centralized(env):",
        "detail": "deps.pufferlib.pufferlib.environments.ocean.grid.grid",
        "documentation": {}
    },
    {
        "label": "EAST",
        "kind": 5,
        "importPath": "deps.pufferlib.pufferlib.environments.ocean.grid.grid",
        "description": "deps.pufferlib.pufferlib.environments.ocean.grid.grid",
        "peekOfCode": "EAST = 3\nWEST = 4\ndef init_introverts(env):\n    pass\ndef reward_introverts(env):\n    '''-1 for each nearby agent'''\n    raw_rewards = 1 - (env.obs_view>=AGENT_1).sum(axis=(1,2))\n    return np.clip(raw_rewards/10, -1, 0)\ndef reward_centralized(env):\n    '''Centralized Euclidean distance'''",
        "detail": "deps.pufferlib.pufferlib.environments.ocean.grid.grid",
        "documentation": {}
    },
    {
        "label": "WEST",
        "kind": 5,
        "importPath": "deps.pufferlib.pufferlib.environments.ocean.grid.grid",
        "description": "deps.pufferlib.pufferlib.environments.ocean.grid.grid",
        "peekOfCode": "WEST = 4\ndef init_introverts(env):\n    pass\ndef reward_introverts(env):\n    '''-1 for each nearby agent'''\n    raw_rewards = 1 - (env.obs_view>=AGENT_1).sum(axis=(1,2))\n    return np.clip(raw_rewards/10, -1, 0)\ndef reward_centralized(env):\n    '''Centralized Euclidean distance'''\n    pos = env.agent_positions / env.map_size",
        "detail": "deps.pufferlib.pufferlib.environments.ocean.grid.grid",
        "documentation": {}
    },
    {
        "label": "game_map",
        "kind": 5,
        "importPath": "deps.pufferlib.pufferlib.environments.ocean.moba.convert_map",
        "description": "deps.pufferlib.pufferlib.environments.ocean.moba.convert_map",
        "peekOfCode": "game_map = np.array(Image.open('dota_map.png'))[:, :, -1]\ngame_map = game_map[::2, ::2][1:-1, 1:-1]\ngame_map[game_map == 0] = 1\ngame_map[game_map == 255] = 0\n# Precompute all ai pathfinding\nfrom c_precompute_pathing import precompute_pathing\nai_paths = np.asarray(precompute_pathing(game_map))\nbreakpoint()\nai_paths = ai_paths.astype(np.uint8).ravel()\nai_paths.tofile('ai_paths.npy')",
        "detail": "deps.pufferlib.pufferlib.environments.ocean.moba.convert_map",
        "documentation": {}
    },
    {
        "label": "game_map",
        "kind": 5,
        "importPath": "deps.pufferlib.pufferlib.environments.ocean.moba.convert_map",
        "description": "deps.pufferlib.pufferlib.environments.ocean.moba.convert_map",
        "peekOfCode": "game_map = game_map[::2, ::2][1:-1, 1:-1]\ngame_map[game_map == 0] = 1\ngame_map[game_map == 255] = 0\n# Precompute all ai pathfinding\nfrom c_precompute_pathing import precompute_pathing\nai_paths = np.asarray(precompute_pathing(game_map))\nbreakpoint()\nai_paths = ai_paths.astype(np.uint8).ravel()\nai_paths.tofile('ai_paths.npy')\n# Save game map",
        "detail": "deps.pufferlib.pufferlib.environments.ocean.moba.convert_map",
        "documentation": {}
    },
    {
        "label": "ai_paths",
        "kind": 5,
        "importPath": "deps.pufferlib.pufferlib.environments.ocean.moba.convert_map",
        "description": "deps.pufferlib.pufferlib.environments.ocean.moba.convert_map",
        "peekOfCode": "ai_paths = np.asarray(precompute_pathing(game_map))\nbreakpoint()\nai_paths = ai_paths.astype(np.uint8).ravel()\nai_paths.tofile('ai_paths.npy')\n# Save game map\ngame_map = game_map.ravel()\ngame_map = game_map.astype(np.uint8)\ngame_map.tofile('game_map.npy')",
        "detail": "deps.pufferlib.pufferlib.environments.ocean.moba.convert_map",
        "documentation": {}
    },
    {
        "label": "ai_paths",
        "kind": 5,
        "importPath": "deps.pufferlib.pufferlib.environments.ocean.moba.convert_map",
        "description": "deps.pufferlib.pufferlib.environments.ocean.moba.convert_map",
        "peekOfCode": "ai_paths = ai_paths.astype(np.uint8).ravel()\nai_paths.tofile('ai_paths.npy')\n# Save game map\ngame_map = game_map.ravel()\ngame_map = game_map.astype(np.uint8)\ngame_map.tofile('game_map.npy')",
        "detail": "deps.pufferlib.pufferlib.environments.ocean.moba.convert_map",
        "documentation": {}
    },
    {
        "label": "game_map",
        "kind": 5,
        "importPath": "deps.pufferlib.pufferlib.environments.ocean.moba.convert_map",
        "description": "deps.pufferlib.pufferlib.environments.ocean.moba.convert_map",
        "peekOfCode": "game_map = game_map.ravel()\ngame_map = game_map.astype(np.uint8)\ngame_map.tofile('game_map.npy')",
        "detail": "deps.pufferlib.pufferlib.environments.ocean.moba.convert_map",
        "documentation": {}
    },
    {
        "label": "game_map",
        "kind": 5,
        "importPath": "deps.pufferlib.pufferlib.environments.ocean.moba.convert_map",
        "description": "deps.pufferlib.pufferlib.environments.ocean.moba.convert_map",
        "peekOfCode": "game_map = game_map.astype(np.uint8)\ngame_map.tofile('game_map.npy')",
        "detail": "deps.pufferlib.pufferlib.environments.ocean.moba.convert_map",
        "documentation": {}
    },
    {
        "label": "PufferMoba",
        "kind": 6,
        "importPath": "deps.pufferlib.pufferlib.environments.ocean.moba.moba",
        "description": "deps.pufferlib.pufferlib.environments.ocean.moba.moba",
        "peekOfCode": "class PufferMoba(pufferlib.PufferEnv):\n    def __init__(self, num_envs=4, vision_range=5, agent_speed=1.0,\n            discretize=True, reward_death=-1.0, reward_xp=0.006,\n            reward_distance=0.05, reward_tower=3.0,\n            report_interval=32, render_mode='human'):\n        super().__init__()\n        self.height = 128\n        self.width = 128\n        self.num_envs = num_envs\n        self.num_agents = 10 * num_envs",
        "detail": "deps.pufferlib.pufferlib.environments.ocean.moba.moba",
        "documentation": {}
    },
    {
        "label": "test_performance",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.environments.ocean.moba.moba",
        "description": "deps.pufferlib.pufferlib.environments.ocean.moba.moba",
        "peekOfCode": "def test_performance(timeout=20, atn_cache=1024, num_envs=400):\n    tick = 0\n    import time\n    start = time.time()\n    while time.time() - start < timeout:\n        atns = actions[tick % atn_cache]\n        env.step(atns)\n        tick += 1\n    print(f'SPS: %f', 10*num_envs*tick / (time.time() - start))\nif __name__ == '__main__':",
        "detail": "deps.pufferlib.pufferlib.environments.ocean.moba.moba",
        "documentation": {}
    },
    {
        "label": "HUMAN_PLAYER",
        "kind": 5,
        "importPath": "deps.pufferlib.pufferlib.environments.ocean.moba.moba",
        "description": "deps.pufferlib.pufferlib.environments.ocean.moba.moba",
        "peekOfCode": "HUMAN_PLAYER = 1\nEMPTY = 0\nWALL = 1\nPASS = 0\nNORTH = 1\nSOUTH = 2\nEAST = 3\nWEST = 4\nCOLORS = np.array([\n    [6, 24, 24, 255],     # Empty",
        "detail": "deps.pufferlib.pufferlib.environments.ocean.moba.moba",
        "documentation": {}
    },
    {
        "label": "EMPTY",
        "kind": 5,
        "importPath": "deps.pufferlib.pufferlib.environments.ocean.moba.moba",
        "description": "deps.pufferlib.pufferlib.environments.ocean.moba.moba",
        "peekOfCode": "EMPTY = 0\nWALL = 1\nPASS = 0\nNORTH = 1\nSOUTH = 2\nEAST = 3\nWEST = 4\nCOLORS = np.array([\n    [6, 24, 24, 255],     # Empty\n    [0, 178, 178, 255],   # Wall",
        "detail": "deps.pufferlib.pufferlib.environments.ocean.moba.moba",
        "documentation": {}
    },
    {
        "label": "WALL",
        "kind": 5,
        "importPath": "deps.pufferlib.pufferlib.environments.ocean.moba.moba",
        "description": "deps.pufferlib.pufferlib.environments.ocean.moba.moba",
        "peekOfCode": "WALL = 1\nPASS = 0\nNORTH = 1\nSOUTH = 2\nEAST = 3\nWEST = 4\nCOLORS = np.array([\n    [6, 24, 24, 255],     # Empty\n    [0, 178, 178, 255],   # Wall\n    [255, 165, 0, 255],   # Tower",
        "detail": "deps.pufferlib.pufferlib.environments.ocean.moba.moba",
        "documentation": {}
    },
    {
        "label": "PASS",
        "kind": 5,
        "importPath": "deps.pufferlib.pufferlib.environments.ocean.moba.moba",
        "description": "deps.pufferlib.pufferlib.environments.ocean.moba.moba",
        "peekOfCode": "PASS = 0\nNORTH = 1\nSOUTH = 2\nEAST = 3\nWEST = 4\nCOLORS = np.array([\n    [6, 24, 24, 255],     # Empty\n    [0, 178, 178, 255],   # Wall\n    [255, 165, 0, 255],   # Tower\n    [0, 0, 128, 255],   # Radiant Creep",
        "detail": "deps.pufferlib.pufferlib.environments.ocean.moba.moba",
        "documentation": {}
    },
    {
        "label": "NORTH",
        "kind": 5,
        "importPath": "deps.pufferlib.pufferlib.environments.ocean.moba.moba",
        "description": "deps.pufferlib.pufferlib.environments.ocean.moba.moba",
        "peekOfCode": "NORTH = 1\nSOUTH = 2\nEAST = 3\nWEST = 4\nCOLORS = np.array([\n    [6, 24, 24, 255],     # Empty\n    [0, 178, 178, 255],   # Wall\n    [255, 165, 0, 255],   # Tower\n    [0, 0, 128, 255],   # Radiant Creep\n    [128, 0, 0, 255],   # Dire Creep",
        "detail": "deps.pufferlib.pufferlib.environments.ocean.moba.moba",
        "documentation": {}
    },
    {
        "label": "SOUTH",
        "kind": 5,
        "importPath": "deps.pufferlib.pufferlib.environments.ocean.moba.moba",
        "description": "deps.pufferlib.pufferlib.environments.ocean.moba.moba",
        "peekOfCode": "SOUTH = 2\nEAST = 3\nWEST = 4\nCOLORS = np.array([\n    [6, 24, 24, 255],     # Empty\n    [0, 178, 178, 255],   # Wall\n    [255, 165, 0, 255],   # Tower\n    [0, 0, 128, 255],   # Radiant Creep\n    [128, 0, 0, 255],   # Dire Creep\n    [128, 128, 128, 255], # Neutral",
        "detail": "deps.pufferlib.pufferlib.environments.ocean.moba.moba",
        "documentation": {}
    },
    {
        "label": "EAST",
        "kind": 5,
        "importPath": "deps.pufferlib.pufferlib.environments.ocean.moba.moba",
        "description": "deps.pufferlib.pufferlib.environments.ocean.moba.moba",
        "peekOfCode": "EAST = 3\nWEST = 4\nCOLORS = np.array([\n    [6, 24, 24, 255],     # Empty\n    [0, 178, 178, 255],   # Wall\n    [255, 165, 0, 255],   # Tower\n    [0, 0, 128, 255],   # Radiant Creep\n    [128, 0, 0, 255],   # Dire Creep\n    [128, 128, 128, 255], # Neutral\n    [0, 0, 255, 255],     # Radiant Support",
        "detail": "deps.pufferlib.pufferlib.environments.ocean.moba.moba",
        "documentation": {}
    },
    {
        "label": "WEST",
        "kind": 5,
        "importPath": "deps.pufferlib.pufferlib.environments.ocean.moba.moba",
        "description": "deps.pufferlib.pufferlib.environments.ocean.moba.moba",
        "peekOfCode": "WEST = 4\nCOLORS = np.array([\n    [6, 24, 24, 255],     # Empty\n    [0, 178, 178, 255],   # Wall\n    [255, 165, 0, 255],   # Tower\n    [0, 0, 128, 255],   # Radiant Creep\n    [128, 0, 0, 255],   # Dire Creep\n    [128, 128, 128, 255], # Neutral\n    [0, 0, 255, 255],     # Radiant Support\n    [0, 0, 255, 255],     # Radiant Assassin",
        "detail": "deps.pufferlib.pufferlib.environments.ocean.moba.moba",
        "documentation": {}
    },
    {
        "label": "COLORS",
        "kind": 5,
        "importPath": "deps.pufferlib.pufferlib.environments.ocean.moba.moba",
        "description": "deps.pufferlib.pufferlib.environments.ocean.moba.moba",
        "peekOfCode": "COLORS = np.array([\n    [6, 24, 24, 255],     # Empty\n    [0, 178, 178, 255],   # Wall\n    [255, 165, 0, 255],   # Tower\n    [0, 0, 128, 255],   # Radiant Creep\n    [128, 0, 0, 255],   # Dire Creep\n    [128, 128, 128, 255], # Neutral\n    [0, 0, 255, 255],     # Radiant Support\n    [0, 0, 255, 255],     # Radiant Assassin\n    [0, 0, 255, 255],     # Radiant Burst",
        "detail": "deps.pufferlib.pufferlib.environments.ocean.moba.moba",
        "documentation": {}
    },
    {
        "label": "PLAYER_OBS_N",
        "kind": 5,
        "importPath": "deps.pufferlib.pufferlib.environments.ocean.moba.moba",
        "description": "deps.pufferlib.pufferlib.environments.ocean.moba.moba",
        "peekOfCode": "PLAYER_OBS_N = 26\nclass PufferMoba(pufferlib.PufferEnv):\n    def __init__(self, num_envs=4, vision_range=5, agent_speed=1.0,\n            discretize=True, reward_death=-1.0, reward_xp=0.006,\n            reward_distance=0.05, reward_tower=3.0,\n            report_interval=32, render_mode='human'):\n        super().__init__()\n        self.height = 128\n        self.width = 128\n        self.num_envs = num_envs",
        "detail": "deps.pufferlib.pufferlib.environments.ocean.moba.moba",
        "documentation": {}
    },
    {
        "label": "RaylibVectorField",
        "kind": 6,
        "importPath": "deps.pufferlib.pufferlib.environments.ocean.moba.precompute_pathing",
        "description": "deps.pufferlib.pufferlib.environments.ocean.moba.precompute_pathing",
        "peekOfCode": "class RaylibVectorField:\n    def __init__(self, grid, paths, tile_size=12):\n        self.tile_size = tile_size\n        self.grid = grid\n        self.paths = paths\n        width = grid.shape[1]\n        height = grid.shape[0]\n        self.tile_size = tile_size\n        self.client = GridRender(\n            width, height, tile_size*width, tile_size*height, fps=15)",
        "detail": "deps.pufferlib.pufferlib.environments.ocean.moba.precompute_pathing",
        "documentation": {}
    },
    {
        "label": "precompute_pathing",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.environments.ocean.moba.precompute_pathing",
        "description": "deps.pufferlib.pufferlib.environments.ocean.moba.precompute_pathing",
        "peekOfCode": "def precompute_pathing(grid):\n    N = grid.shape[0]\n    paths = np.zeros((N, N, N, N), dtype=np.uint8) + 255\n    buffer = np.zeros((8*N*N, 3), dtype=np.int32)\n    for r in range(N):\n        for c in range(N):\n            bfs(grid, paths[r, c], buffer, r, c)\n    return paths\ndef bfs(grid, paths, buffer, dest_r, dest_c):\n    N = grid.shape[0]",
        "detail": "deps.pufferlib.pufferlib.environments.ocean.moba.precompute_pathing",
        "documentation": {}
    },
    {
        "label": "bfs",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.environments.ocean.moba.precompute_pathing",
        "description": "deps.pufferlib.pufferlib.environments.ocean.moba.precompute_pathing",
        "peekOfCode": "def bfs(grid, paths, buffer, dest_r, dest_c):\n    N = grid.shape[0]\n    if grid[dest_r, dest_c] == 1:\n        return\n    start = 0\n    end = 1\n    buffer[start, 0] = 0\n    buffer[start, 1] = dest_r\n    buffer[start, 2] = dest_c\n    while start < end:",
        "detail": "deps.pufferlib.pufferlib.environments.ocean.moba.precompute_pathing",
        "documentation": {}
    },
    {
        "label": "test_bfs",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.environments.ocean.moba.precompute_pathing",
        "description": "deps.pufferlib.pufferlib.environments.ocean.moba.precompute_pathing",
        "peekOfCode": "def test_bfs(grid, r1, c1):\n    import time\n    start = time.time()\n    paths = c_precompute_pathing(grid)\n    end = time.time()\n    print(f'C Precompute Pathing: {end - start:.2f} seconds')\n    renderer = RaylibVectorField(grid, paths)\n    frames = []\n    for i in range(90000000):\n        frame = renderer.render()",
        "detail": "deps.pufferlib.pufferlib.environments.ocean.moba.precompute_pathing",
        "documentation": {}
    },
    {
        "label": "test_performance",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.environments.ocean.moba.precompute_pathing",
        "description": "deps.pufferlib.pufferlib.environments.ocean.moba.precompute_pathing",
        "peekOfCode": "def test_performance(grid, r1, c1, timeout=10):\n    N = grid.shape[0]\n    paths = np.zeros((N, N), dtype=np.uint8) + 255\n    buffer = np.zeros((8*N*N, 3), dtype=np.int32)\n    import time\n    start = time.time()\n    iters = 0\n    while time.time() - start < timeout:\n        paths[:] = 255\n        bfs(grid, paths, buffer, r1, c1)",
        "detail": "deps.pufferlib.pufferlib.environments.ocean.moba.precompute_pathing",
        "documentation": {}
    },
    {
        "label": "dtype",
        "kind": 5,
        "importPath": "deps.pufferlib.pufferlib.environments.ocean.moba.test",
        "description": "deps.pufferlib.pufferlib.environments.ocean.moba.test",
        "peekOfCode": "dtype = player_dtype()\ndata = np.zeros((10, 5, dtype.itemsize), dtype=np.uint8)\nstruct_data = np.frombuffer(data, dtype=dtype).view(np.recarray).reshape(10, 5)\nstruct_data.x = np.arange(1, 51).reshape(10, 5)\ntest_struct(struct_data)\ntest_struct_view()",
        "detail": "deps.pufferlib.pufferlib.environments.ocean.moba.test",
        "documentation": {}
    },
    {
        "label": "data",
        "kind": 5,
        "importPath": "deps.pufferlib.pufferlib.environments.ocean.moba.test",
        "description": "deps.pufferlib.pufferlib.environments.ocean.moba.test",
        "peekOfCode": "data = np.zeros((10, 5, dtype.itemsize), dtype=np.uint8)\nstruct_data = np.frombuffer(data, dtype=dtype).view(np.recarray).reshape(10, 5)\nstruct_data.x = np.arange(1, 51).reshape(10, 5)\ntest_struct(struct_data)\ntest_struct_view()",
        "detail": "deps.pufferlib.pufferlib.environments.ocean.moba.test",
        "documentation": {}
    },
    {
        "label": "struct_data",
        "kind": 5,
        "importPath": "deps.pufferlib.pufferlib.environments.ocean.moba.test",
        "description": "deps.pufferlib.pufferlib.environments.ocean.moba.test",
        "peekOfCode": "struct_data = np.frombuffer(data, dtype=dtype).view(np.recarray).reshape(10, 5)\nstruct_data.x = np.arange(1, 51).reshape(10, 5)\ntest_struct(struct_data)\ntest_struct_view()",
        "detail": "deps.pufferlib.pufferlib.environments.ocean.moba.test",
        "documentation": {}
    },
    {
        "label": "struct_data.x",
        "kind": 5,
        "importPath": "deps.pufferlib.pufferlib.environments.ocean.moba.test",
        "description": "deps.pufferlib.pufferlib.environments.ocean.moba.test",
        "peekOfCode": "struct_data.x = np.arange(1, 51).reshape(10, 5)\ntest_struct(struct_data)\ntest_struct_view()",
        "detail": "deps.pufferlib.pufferlib.environments.ocean.moba.test",
        "documentation": {}
    },
    {
        "label": "MyPong",
        "kind": 6,
        "importPath": "deps.pufferlib.pufferlib.environments.ocean.pong.pong",
        "description": "deps.pufferlib.pufferlib.environments.ocean.pong.pong",
        "peekOfCode": "class MyPong(pufferlib.PufferEnv):\n    def __init__(self, num_envs=1, render_mode=None,\n            width=500, height=640, paddle_width=20, paddle_height=70,\n            ball_width=10, ball_height=15, paddle_speed=8,\n            ball_initial_speed_x=10, ball_initial_speed_y=1,\n            ball_speed_y_increment=3, ball_max_speed_y=13,\n            max_score=21):\n        super().__init__()\n        # env\n        self.num_envs = num_envs",
        "detail": "deps.pufferlib.pufferlib.environments.ocean.pong.pong",
        "documentation": {}
    },
    {
        "label": "test_performance",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.environments.ocean.pong.pong",
        "description": "deps.pufferlib.pufferlib.environments.ocean.pong.pong",
        "peekOfCode": "def test_performance(timeout=10, atn_cache=1024):\n    env = MyPong(num_envs=1000)\n    env.reset()\n    tick = 0\n    actions = np.random.randint(0, 2, (atn_cache, env.num_envs))\n    import time\n    start = time.time()\n    while time.time() - start < timeout:\n        atn = actions[tick % atn_cache]\n        env.step(atn)",
        "detail": "deps.pufferlib.pufferlib.environments.ocean.pong.pong",
        "documentation": {}
    },
    {
        "label": "Snake",
        "kind": 6,
        "importPath": "deps.pufferlib.pufferlib.environments.ocean.snake.csnake",
        "description": "deps.pufferlib.pufferlib.environments.ocean.snake.csnake",
        "peekOfCode": "class Snake(pufferlib.PufferEnv):\n    def __init__(self, widths=[2560], heights=[1440], num_snakes=[4096],\n            num_food=[65536], vision=5, leave_corpse_on_death=True,\n            reward_food=0.1, reward_corpse=0.1, reward_death=-1.0,\n            report_interval=128,  max_snake_length=1024,\n            render_mode='rgb_array'):\n        assert isinstance(vision, int)\n        if isinstance(leave_corpse_on_death, bool):\n            leave_corpse_on_death = len(widths)*[leave_corpse_on_death]\n        assert (len(widths) == len(heights) == len(num_snakes)",
        "detail": "deps.pufferlib.pufferlib.environments.ocean.snake.csnake",
        "documentation": {}
    },
    {
        "label": "RaylibClient",
        "kind": 6,
        "importPath": "deps.pufferlib.pufferlib.environments.ocean.snake.csnake",
        "description": "deps.pufferlib.pufferlib.environments.ocean.snake.csnake",
        "peekOfCode": "class RaylibClient:\n    def __init__(self, width, height, colors, tile_size=16):\n        self.width = width\n        self.height = height\n        self.colors = colors\n        self.tile_size = tile_size\n        rl.InitWindow(width*tile_size, height*tile_size,\n            \"PufferLib Ray Snake\".encode())\n        rl.SetTargetFPS(15)\n    def render(self, grid, agent_positions):",
        "detail": "deps.pufferlib.pufferlib.environments.ocean.snake.csnake",
        "documentation": {}
    },
    {
        "label": "test_performance",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.environments.ocean.snake.csnake",
        "description": "deps.pufferlib.pufferlib.environments.ocean.snake.csnake",
        "peekOfCode": "def test_performance(timeout=10, atn_cache=1024):\n    env = Snake()\n    env.reset()\n    tick = 0\n    total_snakes = sum(env.num_snakes)\n    actions = np.random.randint(0, 4, (atn_cache, total_snakes))\n    import time\n    start = time.time()\n    while time.time() - start < timeout:\n        atns = actions[tick % atn_cache]",
        "detail": "deps.pufferlib.pufferlib.environments.ocean.snake.csnake",
        "documentation": {}
    },
    {
        "label": "Snake",
        "kind": 6,
        "importPath": "deps.pufferlib.pufferlib.environments.ocean.snake.snake",
        "description": "deps.pufferlib.pufferlib.environments.ocean.snake.snake",
        "peekOfCode": "class Snake(pufferlib.PufferEnv):\n    def __init__(self, widths=[2560], heights=[1440], num_snakes=[4096],\n            num_food=[65536], vision=5, leave_corpse_on_death=True,\n            reward_food=0.1, reward_corpse=0.1, reward_death=-1.0,\n            report_interval=128,  max_snake_length=1024,\n            render_mode='rgb_array'):\n        assert isinstance(vision, int)\n        if isinstance(leave_corpse_on_death, bool):\n            leave_corpse_on_death = len(widths)*[leave_corpse_on_death]\n        assert (len(widths) == len(heights) == len(num_snakes)",
        "detail": "deps.pufferlib.pufferlib.environments.ocean.snake.snake",
        "documentation": {}
    },
    {
        "label": "RaylibClient",
        "kind": 6,
        "importPath": "deps.pufferlib.pufferlib.environments.ocean.snake.snake",
        "description": "deps.pufferlib.pufferlib.environments.ocean.snake.snake",
        "peekOfCode": "class RaylibClient:\n    def __init__(self, width, height, colors, tile_size=16):\n        self.width = width\n        self.height = height\n        self.colors = colors\n        self.tile_size = tile_size\n        rl.InitWindow(width*tile_size, height*tile_size,\n            \"PufferLib Ray Snake\".encode())\n        rl.SetTargetFPS(15)\n    def render(self, grid, agent_positions):",
        "detail": "deps.pufferlib.pufferlib.environments.ocean.snake.snake",
        "documentation": {}
    },
    {
        "label": "test_performance",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.environments.ocean.snake.snake",
        "description": "deps.pufferlib.pufferlib.environments.ocean.snake.snake",
        "peekOfCode": "def test_performance(timeout=10, atn_cache=1024):\n    env = Snake()\n    env.reset()\n    tick = 0\n    total_snakes = sum(env.num_snakes)\n    actions = np.random.randint(0, 4, (atn_cache, total_snakes))\n    import time\n    start = time.time()\n    while time.time() - start < timeout:\n        atns = actions[tick % atn_cache]",
        "detail": "deps.pufferlib.pufferlib.environments.ocean.snake.snake",
        "documentation": {}
    },
    {
        "label": "make_moba",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.environments.ocean.environment",
        "description": "deps.pufferlib.pufferlib.environments.ocean.environment",
        "peekOfCode": "def make_moba(num_envs=200, reward_death=-1.0, reward_xp=0.006,\n        reward_distance=0.05, reward_tower=3, render_mode='rgb_array'):\n    from .moba import moba\n    return moba.PufferMoba(num_envs=num_envs, reward_death=reward_death,\n        reward_xp=reward_xp, reward_distance=reward_distance,\n        reward_tower=reward_tower, render_mode=render_mode)\ndef make_pong(num_envs=1):\n    from .pong import pong\n    return pong.MyPong(num_envs=num_envs)\ndef make_foraging(width=1080, height=720, num_agents=4096, horizon=512,",
        "detail": "deps.pufferlib.pufferlib.environments.ocean.environment",
        "documentation": {}
    },
    {
        "label": "make_pong",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.environments.ocean.environment",
        "description": "deps.pufferlib.pufferlib.environments.ocean.environment",
        "peekOfCode": "def make_pong(num_envs=1):\n    from .pong import pong\n    return pong.MyPong(num_envs=num_envs)\ndef make_foraging(width=1080, height=720, num_agents=4096, horizon=512,\n        discretize=True, food_reward=0.1, render_mode='rgb_array'):\n    from .grid import grid\n    init_fn = grid.init_foraging\n    reward_fn = grid.reward_foraging\n    return grid.PufferGrid(width, height, num_agents,\n        horizon, discretize=discretize, food_reward=food_reward,",
        "detail": "deps.pufferlib.pufferlib.environments.ocean.environment",
        "documentation": {}
    },
    {
        "label": "make_foraging",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.environments.ocean.environment",
        "description": "deps.pufferlib.pufferlib.environments.ocean.environment",
        "peekOfCode": "def make_foraging(width=1080, height=720, num_agents=4096, horizon=512,\n        discretize=True, food_reward=0.1, render_mode='rgb_array'):\n    from .grid import grid\n    init_fn = grid.init_foraging\n    reward_fn = grid.reward_foraging\n    return grid.PufferGrid(width, height, num_agents,\n        horizon, discretize=discretize, food_reward=food_reward,\n        init_fn=init_fn, reward_fn=reward_fn,\n        render_mode=render_mode)\ndef make_predator_prey(width=1080, height=720, num_agents=4096, horizon=512,",
        "detail": "deps.pufferlib.pufferlib.environments.ocean.environment",
        "documentation": {}
    },
    {
        "label": "make_predator_prey",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.environments.ocean.environment",
        "description": "deps.pufferlib.pufferlib.environments.ocean.environment",
        "peekOfCode": "def make_predator_prey(width=1080, height=720, num_agents=4096, horizon=512,\n        discretize=True, food_reward=0.1, render_mode='rgb_array'):\n    from .grid import grid\n    init_fn = grid.init_predator_prey\n    reward_fn = grid.reward_predator_prey\n    return grid.PufferGrid(width, height, num_agents,\n        horizon, discretize=discretize, food_reward=food_reward,\n        init_fn=init_fn, reward_fn=reward_fn,\n        render_mode=render_mode)\ndef make_group(width=1080, height=720, num_agents=4096, horizon=512,",
        "detail": "deps.pufferlib.pufferlib.environments.ocean.environment",
        "documentation": {}
    },
    {
        "label": "make_group",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.environments.ocean.environment",
        "description": "deps.pufferlib.pufferlib.environments.ocean.environment",
        "peekOfCode": "def make_group(width=1080, height=720, num_agents=4096, horizon=512,\n        discretize=True, food_reward=0.1, render_mode='rgb_array'):\n    from .grid import grid\n    init_fn = grid.init_group\n    reward_fn = grid.reward_group\n    return grid.PufferGrid(width, height, num_agents,\n        horizon, discretize=discretize, food_reward=food_reward,\n        init_fn=init_fn, reward_fn=reward_fn,\n        render_mode=render_mode)\ndef make_puffer(width=1080, height=720, num_agents=4096, horizon=512,",
        "detail": "deps.pufferlib.pufferlib.environments.ocean.environment",
        "documentation": {}
    },
    {
        "label": "make_puffer",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.environments.ocean.environment",
        "description": "deps.pufferlib.pufferlib.environments.ocean.environment",
        "peekOfCode": "def make_puffer(width=1080, height=720, num_agents=4096, horizon=512,\n        discretize=True, food_reward=0.1, render_mode='rgb_array'):\n    from .grid import grid\n    init_fn = grid.init_puffer\n    reward_fn = grid.reward_puffer\n    return grid.PufferGrid(width, height, num_agents,\n        horizon, discretize=discretize, food_reward=food_reward,\n        init_fn=init_fn, reward_fn=reward_fn,\n        render_mode=render_mode)\ndef make_snake(widths=None, heights=None, num_snakes=None, num_food=None, vision=5,",
        "detail": "deps.pufferlib.pufferlib.environments.ocean.environment",
        "documentation": {}
    },
    {
        "label": "make_snake",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.environments.ocean.environment",
        "description": "deps.pufferlib.pufferlib.environments.ocean.environment",
        "peekOfCode": "def make_snake(widths=None, heights=None, num_snakes=None, num_food=None, vision=5,\n        leave_corpse_on_death=None, preset='1440p-4096', render_mode=None):\n    # TODO: Fix render_mode\n    if preset is None:\n        render_mode = render_mode or 'rgb_array'\n    elif preset == '1440p-4096':\n        widths = widths or [2560]\n        heights = heights or [1440]\n        num_snakes = num_snakes or [4096]\n        num_food = num_food or [65536]",
        "detail": "deps.pufferlib.pufferlib.environments.ocean.environment",
        "documentation": {}
    },
    {
        "label": "make_continuous",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.environments.ocean.environment",
        "description": "deps.pufferlib.pufferlib.environments.ocean.environment",
        "peekOfCode": "def make_continuous(discretize=False, **kwargs):\n    from . import sanity\n    env = sanity.Continuous(discretize=discretize)\n    if not discretize:\n        env = pufferlib.postprocess.ClipAction(env)\n    env = pufferlib.postprocess.EpisodeStats(env)\n    return pufferlib.emulation.GymnasiumPufferEnv(env=env)\ndef make_squared(distance_to_target=3, num_targets=1, **kwargs):\n    from . import sanity\n    env = sanity.Squared(distance_to_target=distance_to_target, num_targets=num_targets, **kwargs)",
        "detail": "deps.pufferlib.pufferlib.environments.ocean.environment",
        "documentation": {}
    },
    {
        "label": "make_squared",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.environments.ocean.environment",
        "description": "deps.pufferlib.pufferlib.environments.ocean.environment",
        "peekOfCode": "def make_squared(distance_to_target=3, num_targets=1, **kwargs):\n    from . import sanity\n    env = sanity.Squared(distance_to_target=distance_to_target, num_targets=num_targets, **kwargs)\n    env = pufferlib.postprocess.EpisodeStats(env)\n    return pufferlib.emulation.GymnasiumPufferEnv(env=env, **kwargs)\ndef make_bandit(num_actions=10, reward_scale=1, reward_noise=1):\n    from . import sanity\n    env = sanity.Bandit(num_actions=num_actions, reward_scale=reward_scale,\n        reward_noise=reward_noise)\n    env = pufferlib.postprocess.EpisodeStats(env)",
        "detail": "deps.pufferlib.pufferlib.environments.ocean.environment",
        "documentation": {}
    },
    {
        "label": "make_bandit",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.environments.ocean.environment",
        "description": "deps.pufferlib.pufferlib.environments.ocean.environment",
        "peekOfCode": "def make_bandit(num_actions=10, reward_scale=1, reward_noise=1):\n    from . import sanity\n    env = sanity.Bandit(num_actions=num_actions, reward_scale=reward_scale,\n        reward_noise=reward_noise)\n    env = pufferlib.postprocess.EpisodeStats(env)\n    return pufferlib.emulation.GymnasiumPufferEnv(env=env)\ndef make_memory(mem_length=2, mem_delay=2, **kwargs):\n    from . import sanity\n    env = sanity.Memory(mem_length=mem_length, mem_delay=mem_delay)\n    env = pufferlib.postprocess.EpisodeStats(env)",
        "detail": "deps.pufferlib.pufferlib.environments.ocean.environment",
        "documentation": {}
    },
    {
        "label": "make_memory",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.environments.ocean.environment",
        "description": "deps.pufferlib.pufferlib.environments.ocean.environment",
        "peekOfCode": "def make_memory(mem_length=2, mem_delay=2, **kwargs):\n    from . import sanity\n    env = sanity.Memory(mem_length=mem_length, mem_delay=mem_delay)\n    env = pufferlib.postprocess.EpisodeStats(env)\n    return pufferlib.emulation.GymnasiumPufferEnv(env=env)\ndef make_password(password_length=5, **kwargs):\n    from . import sanity\n    env = sanity.Password(password_length=password_length)\n    env = pufferlib.postprocess.EpisodeStats(env)\n    return pufferlib.emulation.GymnasiumPufferEnv(env=env)",
        "detail": "deps.pufferlib.pufferlib.environments.ocean.environment",
        "documentation": {}
    },
    {
        "label": "make_password",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.environments.ocean.environment",
        "description": "deps.pufferlib.pufferlib.environments.ocean.environment",
        "peekOfCode": "def make_password(password_length=5, **kwargs):\n    from . import sanity\n    env = sanity.Password(password_length=password_length)\n    env = pufferlib.postprocess.EpisodeStats(env)\n    return pufferlib.emulation.GymnasiumPufferEnv(env=env)\ndef make_performance(delay_mean=0, delay_std=0, bandwidth=1, **kwargs):\n    from . import sanity\n    env = sanity.Performance(delay_mean=delay_mean, delay_std=delay_std, bandwidth=bandwidth)\n    env = pufferlib.postprocess.EpisodeStats(env)\n    return pufferlib.emulation.GymnasiumPufferEnv(env=env)",
        "detail": "deps.pufferlib.pufferlib.environments.ocean.environment",
        "documentation": {}
    },
    {
        "label": "make_performance",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.environments.ocean.environment",
        "description": "deps.pufferlib.pufferlib.environments.ocean.environment",
        "peekOfCode": "def make_performance(delay_mean=0, delay_std=0, bandwidth=1, **kwargs):\n    from . import sanity\n    env = sanity.Performance(delay_mean=delay_mean, delay_std=delay_std, bandwidth=bandwidth)\n    env = pufferlib.postprocess.EpisodeStats(env)\n    return pufferlib.emulation.GymnasiumPufferEnv(env=env)\ndef make_performance_empiric(count_n=0, count_std=0, bandwidth=1, **kwargs):\n    from . import sanity\n    env = sanity.PerformanceEmpiric(count_n=count_n, count_std=count_std, bandwidth=bandwidth)\n    env = pufferlib.postprocess.EpisodeStats(env)\n    return pufferlib.emulation.GymnasiumPufferEnv(env=env)",
        "detail": "deps.pufferlib.pufferlib.environments.ocean.environment",
        "documentation": {}
    },
    {
        "label": "make_performance_empiric",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.environments.ocean.environment",
        "description": "deps.pufferlib.pufferlib.environments.ocean.environment",
        "peekOfCode": "def make_performance_empiric(count_n=0, count_std=0, bandwidth=1, **kwargs):\n    from . import sanity\n    env = sanity.PerformanceEmpiric(count_n=count_n, count_std=count_std, bandwidth=bandwidth)\n    env = pufferlib.postprocess.EpisodeStats(env)\n    return pufferlib.emulation.GymnasiumPufferEnv(env=env)\ndef make_stochastic(p=0.7, horizon=100, **kwargs):\n    from . import sanity\n    env = sanity.Stochastic(p=p, horizon=100)\n    env = pufferlib.postprocess.EpisodeStats(env)\n    return pufferlib.emulation.GymnasiumPufferEnv(env=env)",
        "detail": "deps.pufferlib.pufferlib.environments.ocean.environment",
        "documentation": {}
    },
    {
        "label": "make_stochastic",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.environments.ocean.environment",
        "description": "deps.pufferlib.pufferlib.environments.ocean.environment",
        "peekOfCode": "def make_stochastic(p=0.7, horizon=100, **kwargs):\n    from . import sanity\n    env = sanity.Stochastic(p=p, horizon=100)\n    env = pufferlib.postprocess.EpisodeStats(env)\n    return pufferlib.emulation.GymnasiumPufferEnv(env=env)\ndef make_spaces(**kwargs):\n    from . import sanity\n    env = sanity.Spaces()\n    env = pufferlib.postprocess.EpisodeStats(env)\n    return pufferlib.emulation.GymnasiumPufferEnv(env=env, **kwargs)",
        "detail": "deps.pufferlib.pufferlib.environments.ocean.environment",
        "documentation": {}
    },
    {
        "label": "make_spaces",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.environments.ocean.environment",
        "description": "deps.pufferlib.pufferlib.environments.ocean.environment",
        "peekOfCode": "def make_spaces(**kwargs):\n    from . import sanity\n    env = sanity.Spaces()\n    env = pufferlib.postprocess.EpisodeStats(env)\n    return pufferlib.emulation.GymnasiumPufferEnv(env=env, **kwargs)\ndef make_multiagent(**kwargs):\n    from . import sanity\n    env = sanity.Multiagent()\n    env = pufferlib.postprocess.MultiagentEpisodeStats(env)\n    return pufferlib.emulation.PettingZooPufferEnv(env=env)",
        "detail": "deps.pufferlib.pufferlib.environments.ocean.environment",
        "documentation": {}
    },
    {
        "label": "make_multiagent",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.environments.ocean.environment",
        "description": "deps.pufferlib.pufferlib.environments.ocean.environment",
        "peekOfCode": "def make_multiagent(**kwargs):\n    from . import sanity\n    env = sanity.Multiagent()\n    env = pufferlib.postprocess.MultiagentEpisodeStats(env)\n    return pufferlib.emulation.PettingZooPufferEnv(env=env)\nMAKE_FNS = {\n    'moba': make_moba,\n    'my_pong': make_pong,\n    'foraging': make_foraging,\n    'predator_prey': make_predator_prey,",
        "detail": "deps.pufferlib.pufferlib.environments.ocean.environment",
        "documentation": {}
    },
    {
        "label": "env_creator",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.environments.ocean.environment",
        "description": "deps.pufferlib.pufferlib.environments.ocean.environment",
        "peekOfCode": "def env_creator(name='squared'):\n    if name in MAKE_FNS:\n        return MAKE_FNS[name]\n    else:\n        raise ValueError(f'Invalid environment name: {name}')",
        "detail": "deps.pufferlib.pufferlib.environments.ocean.environment",
        "documentation": {}
    },
    {
        "label": "MAKE_FNS",
        "kind": 5,
        "importPath": "deps.pufferlib.pufferlib.environments.ocean.environment",
        "description": "deps.pufferlib.pufferlib.environments.ocean.environment",
        "peekOfCode": "MAKE_FNS = {\n    'moba': make_moba,\n    'my_pong': make_pong,\n    'foraging': make_foraging,\n    'predator_prey': make_predator_prey,\n    'group': make_group,\n    'puffer': make_puffer,\n    'snake': make_snake,\n    'continuous': make_continuous,\n    'squared': make_squared,",
        "detail": "deps.pufferlib.pufferlib.environments.ocean.environment",
        "documentation": {}
    },
    {
        "label": "AnsiRender",
        "kind": 6,
        "importPath": "deps.pufferlib.pufferlib.environments.ocean.render",
        "description": "deps.pufferlib.pufferlib.environments.ocean.render",
        "peekOfCode": "class AnsiRender:\n    def __init__(self, colors=None):\n        self.colors = colors\n        if colors is None:\n            self.colors = ANSI_COLORS\n    def render(self, grid):\n        frame = ''\n        for v in range(grid.shape[0]):\n            lines = []\n            for line in grid[v-1:-v, v-1:-v]:",
        "detail": "deps.pufferlib.pufferlib.environments.ocean.render",
        "documentation": {}
    },
    {
        "label": "RGBArrayRender",
        "kind": 6,
        "importPath": "deps.pufferlib.pufferlib.environments.ocean.render",
        "description": "deps.pufferlib.pufferlib.environments.ocean.render",
        "peekOfCode": "class RGBArrayRender:\n    def __init__(self, colors=None, upscale=1):\n        self.colors = colors\n        if colors is None:\n            self.colors = COLORS\n        self.rescaler = np.ones((upscale, upscale, 1), dtype=np.uint8)\n        self.upscale = upscale\n    def render(self, grid):\n        frame = self.colors[grid]\n        if self.upscale > 1:",
        "detail": "deps.pufferlib.pufferlib.environments.ocean.render",
        "documentation": {}
    },
    {
        "label": "GridRender",
        "kind": 6,
        "importPath": "deps.pufferlib.pufferlib.environments.ocean.render",
        "description": "deps.pufferlib.pufferlib.environments.ocean.render",
        "peekOfCode": "class GridRender:\n    def __init__(self, width, height, screen_width=1080, screen_height=720,\n            colors=None, fps=60, name='PufferLib Raylib Renderer'):\n        self.width = width\n        self.height = height\n        self.fps = fps\n        self.colors = colors\n        if colors is None:\n            self.colors = COLORS\n        rl.InitWindow(screen_width, screen_height, name.encode())",
        "detail": "deps.pufferlib.pufferlib.environments.ocean.render",
        "documentation": {}
    },
    {
        "label": "GameRender",
        "kind": 6,
        "importPath": "deps.pufferlib.pufferlib.environments.ocean.render",
        "description": "deps.pufferlib.pufferlib.environments.ocean.render",
        "peekOfCode": "class GameRender:\n    def __init__(self, width, height, screen_width=1080, screen_height=720,\n            colors=None, name='PufferLib Raylib Game'):\n        self.client = GridRender(width, height,\n            screen_width, screen_height, colors, name)\n    def render(self, grid, x, y):\n        self.client.camera.target.x = x\n        self.client.camera.target.y = y\n        return self.client.render(grid)\nclass TestGameRender:",
        "detail": "deps.pufferlib.pufferlib.environments.ocean.render",
        "documentation": {}
    },
    {
        "label": "TestGameRender",
        "kind": 6,
        "importPath": "deps.pufferlib.pufferlib.environments.ocean.render",
        "description": "deps.pufferlib.pufferlib.environments.ocean.render",
        "peekOfCode": "class TestGameRender:\n    def __init__(self, width, height, colors=None,\n            tile_size=16, name='PufferLib Raylib Game'):\n        assert width % tile_size == 0\n        assert height % tile_size == 0\n        assert (width // tile_size) % 2 == 1\n        assert (height // tile_size) % 2 == 1\n        self.width = width\n        self.height = height\n        self.colors = colors",
        "detail": "deps.pufferlib.pufferlib.environments.ocean.render",
        "documentation": {}
    },
    {
        "label": "any_key_down",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.environments.ocean.render",
        "description": "deps.pufferlib.pufferlib.environments.ocean.render",
        "peekOfCode": "def any_key_down(keys):\n    for key in keys:\n        if rl.IsKeyDown(key):\n            return True\n    return False\ndef any_key_pressed(keys):\n    for key in keys:\n        if rl.IsKeyPressed(key):\n            return True\n    return False",
        "detail": "deps.pufferlib.pufferlib.environments.ocean.render",
        "documentation": {}
    },
    {
        "label": "any_key_pressed",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.environments.ocean.render",
        "description": "deps.pufferlib.pufferlib.environments.ocean.render",
        "peekOfCode": "def any_key_pressed(keys):\n    for key in keys:\n        if rl.IsKeyPressed(key):\n            return True\n    return False\ndef cdata_to_numpy():\n    image = rl.LoadImageFromScreen()\n    data_pointer = image.data\n    width = image.width\n    height = image.height",
        "detail": "deps.pufferlib.pufferlib.environments.ocean.render",
        "documentation": {}
    },
    {
        "label": "cdata_to_numpy",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.environments.ocean.render",
        "description": "deps.pufferlib.pufferlib.environments.ocean.render",
        "peekOfCode": "def cdata_to_numpy():\n    image = rl.LoadImageFromScreen()\n    data_pointer = image.data\n    width = image.width\n    height = image.height\n    channels = 4\n    data_size = width * height * channels\n    cdata = FFI().buffer(data_pointer, data_size)\n    return np.frombuffer(cdata, dtype=np.uint8\n        ).reshape((height, width, channels))",
        "detail": "deps.pufferlib.pufferlib.environments.ocean.render",
        "documentation": {}
    },
    {
        "label": "make_texture",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.environments.ocean.render",
        "description": "deps.pufferlib.pufferlib.environments.ocean.render",
        "peekOfCode": "def make_texture(width, height):\n    rendered = np.zeros((height, width, 4), dtype=np.uint8)\n    raylib_image = pyray.Image(FFI().from_buffer(rendered.data),\n        width, height, 1, pyray.PIXELFORMAT_UNCOMPRESSED_R8G8B8)\n    return rl.LoadTextureFromImage(raylib_image)\nclass AnsiRender:\n    def __init__(self, colors=None):\n        self.colors = colors\n        if colors is None:\n            self.colors = ANSI_COLORS",
        "detail": "deps.pufferlib.pufferlib.environments.ocean.render",
        "documentation": {}
    },
    {
        "label": "PUFF_BACKGROUND",
        "kind": 5,
        "importPath": "deps.pufferlib.pufferlib.environments.ocean.render",
        "description": "deps.pufferlib.pufferlib.environments.ocean.render",
        "peekOfCode": "PUFF_BACKGROUND = [6, 24, 24, 255]\nPUFF_TEXT = [0, 187, 187, 255]\nANSI_COLORS = [30, 34, 36, 90, 31, 97, 91, 37]\nCOLORS = np.array([\n    [6, 24, 24 ],     # Background\n    [0, 0, 255],     # Food\n    [0, 128, 255],   # Corpse\n    [128, 128, 128], # Wall\n    [255, 0, 0],     # Snake\n    [255, 255, 255], # Snake",
        "detail": "deps.pufferlib.pufferlib.environments.ocean.render",
        "documentation": {}
    },
    {
        "label": "PUFF_TEXT",
        "kind": 5,
        "importPath": "deps.pufferlib.pufferlib.environments.ocean.render",
        "description": "deps.pufferlib.pufferlib.environments.ocean.render",
        "peekOfCode": "PUFF_TEXT = [0, 187, 187, 255]\nANSI_COLORS = [30, 34, 36, 90, 31, 97, 91, 37]\nCOLORS = np.array([\n    [6, 24, 24 ],     # Background\n    [0, 0, 255],     # Food\n    [0, 128, 255],   # Corpse\n    [128, 128, 128], # Wall\n    [255, 0, 0],     # Snake\n    [255, 255, 255], # Snake\n    [255, 85, 85],     # Snake",
        "detail": "deps.pufferlib.pufferlib.environments.ocean.render",
        "documentation": {}
    },
    {
        "label": "ANSI_COLORS",
        "kind": 5,
        "importPath": "deps.pufferlib.pufferlib.environments.ocean.render",
        "description": "deps.pufferlib.pufferlib.environments.ocean.render",
        "peekOfCode": "ANSI_COLORS = [30, 34, 36, 90, 31, 97, 91, 37]\nCOLORS = np.array([\n    [6, 24, 24 ],     # Background\n    [0, 0, 255],     # Food\n    [0, 128, 255],   # Corpse\n    [128, 128, 128], # Wall\n    [255, 0, 0],     # Snake\n    [255, 255, 255], # Snake\n    [255, 85, 85],     # Snake\n    [170, 170, 170], # Snake",
        "detail": "deps.pufferlib.pufferlib.environments.ocean.render",
        "documentation": {}
    },
    {
        "label": "COLORS",
        "kind": 5,
        "importPath": "deps.pufferlib.pufferlib.environments.ocean.render",
        "description": "deps.pufferlib.pufferlib.environments.ocean.render",
        "peekOfCode": "COLORS = np.array([\n    [6, 24, 24 ],     # Background\n    [0, 0, 255],     # Food\n    [0, 128, 255],   # Corpse\n    [128, 128, 128], # Wall\n    [255, 0, 0],     # Snake\n    [255, 255, 255], # Snake\n    [255, 85, 85],     # Snake\n    [170, 170, 170], # Snake\n], dtype=np.uint8)",
        "detail": "deps.pufferlib.pufferlib.environments.ocean.render",
        "documentation": {}
    },
    {
        "label": "Bandit",
        "kind": 6,
        "importPath": "deps.pufferlib.pufferlib.environments.ocean.sanity",
        "description": "deps.pufferlib.pufferlib.environments.ocean.sanity",
        "peekOfCode": "class Bandit(gymnasium.Env):\n    '''Pufferlib Bandit environment\n    Simulates a classic multiarmed bandit problem.\n    Observation space: Box(0, 1, (1,)). The observation is always 1.\n    Action space: Discrete(num_actions). Which arm to pull.\n    Args:\n        num_actions: The number of bandit arms\n        reward_scale: The scale of the reward\n        reward_noise: The standard deviation of the reward signal\n        hard_fixed_seed: All instances of the environment should share the same seed.",
        "detail": "deps.pufferlib.pufferlib.environments.ocean.sanity",
        "documentation": {}
    },
    {
        "label": "Memory",
        "kind": 6,
        "importPath": "deps.pufferlib.pufferlib.environments.ocean.sanity",
        "description": "deps.pufferlib.pufferlib.environments.ocean.sanity",
        "peekOfCode": "class Memory(gymnasium.Env):\n    '''Pufferlib Memory environment\n    Repeat the observed sequence after a delay. It is randomly generated upon every reset. This is a test of memory length and capacity. It starts requiring credit assignment if you make the sequence too long.\n    The sequence is presented one digit at a time, followed by a string of 0. The agent should output 0s for the first mem_length + mem_delay steps, then output the sequence.\n    Observation space: Box(0, 1, (1,)). The current digit.\n    Action space: Discrete(2). Your guess for the next digit.\n    Args:\n        mem_length: The length of the sequence\n        mem_delay: The number of 0s between the sequence and the agent's response\n    '''",
        "detail": "deps.pufferlib.pufferlib.environments.ocean.sanity",
        "documentation": {}
    },
    {
        "label": "Multiagent",
        "kind": 6,
        "importPath": "deps.pufferlib.pufferlib.environments.ocean.sanity",
        "description": "deps.pufferlib.pufferlib.environments.ocean.sanity",
        "peekOfCode": "class Multiagent(pettingzoo.ParallelEnv):\n    '''Pufferlib Multiagent environment\n    Agent 1 must pick action 0 and Agent 2 must pick action 1\n    Observation space: Box(0, 1, (1,)). 0 for Agent 1 and 1 for Agent 2\n    Action space: Discrete(2). Which action to take.\n    '''\n    def __init__(self):\n        self.observation = {\n            1: np.zeros(1, dtype=np.float32),\n            2: np.ones(1, dtype=np.float32),",
        "detail": "deps.pufferlib.pufferlib.environments.ocean.sanity",
        "documentation": {}
    },
    {
        "label": "Password",
        "kind": 6,
        "importPath": "deps.pufferlib.pufferlib.environments.ocean.sanity",
        "description": "deps.pufferlib.pufferlib.environments.ocean.sanity",
        "peekOfCode": "class Password(gymnasium.Env):\n    '''Pufferlib Password environment\n    Guess the password, which is a static binary string. Your policy has to\n    not determinize before it happens to get the reward, and it also has to\n    latch onto the reward within a few instances of getting it. \n    Observation space: Box(0, 1, (password_length,)). A binary vector containing your guesses so far, so that the environment will be solvable without memory.\n    Action space: Discrete(2). Your guess for the next digit.\n    Args:\n        password_length: The number of binary digits in the password.\n        hard_fixed_seed: A fixed seed for the environment. It should be the same for all instances. This environment does not make sense when randomly generated.",
        "detail": "deps.pufferlib.pufferlib.environments.ocean.sanity",
        "documentation": {}
    },
    {
        "label": "Performance",
        "kind": 6,
        "importPath": "deps.pufferlib.pufferlib.environments.ocean.sanity",
        "description": "deps.pufferlib.pufferlib.environments.ocean.sanity",
        "peekOfCode": "class Performance(gymnasium.Env):\n    def __init__(self, delay_mean=0, delay_std=0, bandwidth=1):\n        np.random.seed(time.time_ns() % 2**32)\n        self.observation_space = gymnasium.spaces.Box(\n            low=-2**20, high=2**20,\n            shape=(bandwidth,), dtype=np.float32\n        )\n        self.action_space = gymnasium.spaces.Discrete(2)\n        self.observation = self.observation_space.sample()\n        self.render_mode = 'ansi'",
        "detail": "deps.pufferlib.pufferlib.environments.ocean.sanity",
        "documentation": {}
    },
    {
        "label": "PerformanceEmpiric",
        "kind": 6,
        "importPath": "deps.pufferlib.pufferlib.environments.ocean.sanity",
        "description": "deps.pufferlib.pufferlib.environments.ocean.sanity",
        "peekOfCode": "class PerformanceEmpiric(gymnasium.Env):\n    def __init__(self, count_n=0, count_std=0, bandwidth=1):\n        np.random.seed(time.time_ns() % 2**32)\n        self.observation_space = gymnasium.spaces.Box(\n            low=-2**20, high=2**20,\n            shape=(bandwidth,), dtype=np.float32\n        )\n        self.action_space = gymnasium.spaces.Discrete(2)\n        self.observation = self.observation_space.sample()\n        self.count_n = count_n",
        "detail": "deps.pufferlib.pufferlib.environments.ocean.sanity",
        "documentation": {}
    },
    {
        "label": "Spaces",
        "kind": 6,
        "importPath": "deps.pufferlib.pufferlib.environments.ocean.sanity",
        "description": "deps.pufferlib.pufferlib.environments.ocean.sanity",
        "peekOfCode": "class Spaces(gymnasium.Env):\n    '''Pufferlib Spaces environment\n    A simple environment with hierarchical observation and action spaces\n    The image action should be 1 if the sum of the image is positive, 0 otherwise\n    The flat action should be 1 if the sum of the flat obs is positive, 0 otherwise\n    0.5 reward is given for each correct action\n    Does not provide rendering\n    '''\n    def __init__(self):\n        self.observation_space = gymnasium.spaces.Dict({",
        "detail": "deps.pufferlib.pufferlib.environments.ocean.sanity",
        "documentation": {}
    },
    {
        "label": "Squared",
        "kind": 6,
        "importPath": "deps.pufferlib.pufferlib.environments.ocean.sanity",
        "description": "deps.pufferlib.pufferlib.environments.ocean.sanity",
        "peekOfCode": "class Squared(gymnasium.Env):\n    '''Pufferlib Squared environment\n    Agent starts at the center of a square grid.\n    Targets are placed on the perimeter of the grid.\n    Reward is 1 minus the L-inf distance to the closest target.\n    This means that reward varies from -1 to 1.\n    Reward is not given for targets that have already been hit.\n    Observation space: Box(-1, 1, (grid_size, grid_size)). The map.\n    Action space: Discrete(8). Which direction to move.\n    Args:",
        "detail": "deps.pufferlib.pufferlib.environments.ocean.sanity",
        "documentation": {}
    },
    {
        "label": "Stochastic",
        "kind": 6,
        "importPath": "deps.pufferlib.pufferlib.environments.ocean.sanity",
        "description": "deps.pufferlib.pufferlib.environments.ocean.sanity",
        "peekOfCode": "class Stochastic(gymnasium.Env):\n    '''Pufferlib Stochastic environment\n    The optimal policy is to play action 0 < p % of the time and action 1 < (1 - p) %\n    This is a test of whether your algorithm can learn a nontrivial stochastic policy.\n    Do not use a policy with memory, as that will trivialize the problem.\n    Observation space: Box(0, 1, (1,)). The observation is always 0.\n    Action space: Discrete(2). Select action 0 or action 1.\n    Args:\n        p: The optimal probability for action 0\n        horizon: How often the environment should reset",
        "detail": "deps.pufferlib.pufferlib.environments.ocean.sanity",
        "documentation": {}
    },
    {
        "label": "Continuous",
        "kind": 6,
        "importPath": "deps.pufferlib.pufferlib.environments.ocean.sanity",
        "description": "deps.pufferlib.pufferlib.environments.ocean.sanity",
        "peekOfCode": "class Continuous(gymnasium.Env):\n    def __init__(self, discretize=False):\n        self.observation_space=gymnasium.spaces.Box(\n            low=-1, high=1, shape=(6,))\n        self.discretize = discretize\n        if discretize:\n            self.action_space=gymnasium.spaces.Discrete(4)\n        else:\n            self.action_space=gymnasium.spaces.Box(\n                low=-1, high=1, shape=(2,))",
        "detail": "deps.pufferlib.pufferlib.environments.ocean.sanity",
        "documentation": {}
    },
    {
        "label": "RaylibClient",
        "kind": 6,
        "importPath": "deps.pufferlib.pufferlib.environments.ocean.sanity",
        "description": "deps.pufferlib.pufferlib.environments.ocean.sanity",
        "peekOfCode": "class RaylibClient:\n    def __init__(self, width=1080, height=720, size=20):\n        self.width = width\n        self.height = height\n        self.size = size\n        from raylib import rl\n        rl.InitWindow(width, height,\n            \"PufferLib Simple Continuous\".encode())\n        rl.SetTargetFPS(10)\n        self.rl = rl",
        "detail": "deps.pufferlib.pufferlib.environments.ocean.sanity",
        "documentation": {}
    },
    {
        "label": "Snake",
        "kind": 6,
        "importPath": "deps.pufferlib.pufferlib.environments.ocean.torch",
        "description": "deps.pufferlib.pufferlib.environments.ocean.torch",
        "peekOfCode": "class Snake(nn.Module):\n    def __init__(self, env, cnn_channels=32, hidden_size=128, **kwargs):\n        super().__init__()\n        self.network= nn.Sequential(\n            pufferlib.pytorch.layer_init(\n                nn.Conv2d(8, cnn_channels, 5, stride=3)),\n            nn.ReLU(),\n            pufferlib.pytorch.layer_init(\n                nn.Conv2d(cnn_channels, cnn_channels, 3, stride=1)),\n            nn.ReLU(),",
        "detail": "deps.pufferlib.pufferlib.environments.ocean.torch",
        "documentation": {}
    },
    {
        "label": "Grid",
        "kind": 6,
        "importPath": "deps.pufferlib.pufferlib.environments.ocean.torch",
        "description": "deps.pufferlib.pufferlib.environments.ocean.torch",
        "peekOfCode": "class Grid(nn.Module):\n    def __init__(self, env, cnn_channels=32, hidden_size=128, **kwargs):\n        super().__init__()\n        self.cnn = nn.Sequential(\n            pufferlib.pytorch.layer_init(\n                nn.Conv2d(7, cnn_channels, 5, stride=3)),\n            nn.ReLU(),\n            pufferlib.pytorch.layer_init(\n                nn.Conv2d(cnn_channels, cnn_channels, 3, stride=1)),\n            nn.Flatten(),",
        "detail": "deps.pufferlib.pufferlib.environments.ocean.torch",
        "documentation": {}
    },
    {
        "label": "MOBA",
        "kind": 6,
        "importPath": "deps.pufferlib.pufferlib.environments.ocean.torch",
        "description": "deps.pufferlib.pufferlib.environments.ocean.torch",
        "peekOfCode": "class MOBA(nn.Module):\n    def __init__(self, env, cnn_channels=32, hidden_size=128, **kwargs):\n        super().__init__()\n        self.cnn = nn.Sequential(\n            pufferlib.pytorch.layer_init(\n                nn.Conv2d(16 + 3, cnn_channels, 5, stride=3)),\n            nn.ReLU(),\n            pufferlib.pytorch.layer_init(\n                nn.Conv2d(cnn_channels, cnn_channels, 3, stride=1)),\n            nn.Flatten(),",
        "detail": "deps.pufferlib.pufferlib.environments.ocean.torch",
        "documentation": {}
    },
    {
        "label": "Recurrent",
        "kind": 5,
        "importPath": "deps.pufferlib.pufferlib.environments.ocean.torch",
        "description": "deps.pufferlib.pufferlib.environments.ocean.torch",
        "peekOfCode": "Recurrent = pufferlib.models.LSTMWrapper\nclass Snake(nn.Module):\n    def __init__(self, env, cnn_channels=32, hidden_size=128, **kwargs):\n        super().__init__()\n        self.network= nn.Sequential(\n            pufferlib.pytorch.layer_init(\n                nn.Conv2d(8, cnn_channels, 5, stride=3)),\n            nn.ReLU(),\n            pufferlib.pytorch.layer_init(\n                nn.Conv2d(cnn_channels, cnn_channels, 3, stride=1)),",
        "detail": "deps.pufferlib.pufferlib.environments.ocean.torch",
        "documentation": {}
    },
    {
        "label": "env_creator",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.environments.open_spiel.environment",
        "description": "deps.pufferlib.pufferlib.environments.open_spiel.environment",
        "peekOfCode": "def env_creator(name='connect_four'):\n    '''OpenSpiel creation function'''\n    return functools.partial(make, name)\ndef make(\n        name,\n        multiplayer=False,\n        n_rollouts=5,\n        max_simulations=10,\n        min_simulations=None\n    ):",
        "detail": "deps.pufferlib.pufferlib.environments.open_spiel.environment",
        "documentation": {}
    },
    {
        "label": "make",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.environments.open_spiel.environment",
        "description": "deps.pufferlib.pufferlib.environments.open_spiel.environment",
        "peekOfCode": "def make(\n        name,\n        multiplayer=False,\n        n_rollouts=5,\n        max_simulations=10,\n        min_simulations=None\n    ):\n    '''OpenSpiel creation function'''\n    pyspiel = pufferlib.environments.try_import('pyspiel', 'open_spiel')\n    env = pyspiel.load_game(name)",
        "detail": "deps.pufferlib.pufferlib.environments.open_spiel.environment",
        "documentation": {}
    },
    {
        "label": "OpenSpielGymnasiumEnvironment",
        "kind": 6,
        "importPath": "deps.pufferlib.pufferlib.environments.open_spiel.gymnasium_environment",
        "description": "deps.pufferlib.pufferlib.environments.open_spiel.gymnasium_environment",
        "peekOfCode": "class OpenSpielGymnasiumEnvironment:\n    __init__ = init\n    step = step\n    reset = reset\n    observation_space = property(observation_space)\n    action_space = property(action_space)\n    render = render\n    close = close",
        "detail": "deps.pufferlib.pufferlib.environments.open_spiel.gymnasium_environment",
        "documentation": {}
    },
    {
        "label": "create_bots",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.environments.open_spiel.gymnasium_environment",
        "description": "deps.pufferlib.pufferlib.environments.open_spiel.gymnasium_environment",
        "peekOfCode": "def create_bots(state, seed):\n    assert seed is not None, 'seed must be set'\n    rnd_state = np.random.RandomState(seed)\n    evaluator = mcts.RandomRolloutEvaluator(\n        n_rollouts=state.n_rollouts,\n        random_state=rnd_state\n    )\n    return [mcts.MCTSBot(\n        game=state.env,\n        uct_c=2,",
        "detail": "deps.pufferlib.pufferlib.environments.open_spiel.gymnasium_environment",
        "documentation": {}
    },
    {
        "label": "reset",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.environments.open_spiel.gymnasium_environment",
        "description": "deps.pufferlib.pufferlib.environments.open_spiel.gymnasium_environment",
        "peekOfCode": "def reset(state, seed = None, options = None):\n    state.state = state.env.new_initial_state()\n    if not state.has_reset:\n        state.has_reset = True\n        state.seed_value = seed\n        np.random.seed(seed)\n        state.all_bots = create_bots(state, seed)\n    state.bot = np.random.choice(state.all_bots)\n    if np.random.rand() < 0.5:\n        bot_atn = state.bot.step(state.state)",
        "detail": "deps.pufferlib.pufferlib.environments.open_spiel.gymnasium_environment",
        "documentation": {}
    },
    {
        "label": "step",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.environments.open_spiel.gymnasium_environment",
        "description": "deps.pufferlib.pufferlib.environments.open_spiel.gymnasium_environment",
        "peekOfCode": "def step(state, action):\n    player = state.state.current_player()\n    solve_chance_nodes(state)\n    state.state.apply_action(action)\n    # Take other move with a bot\n    if not state.state.is_terminal():\n        bot_atn = state.bot.step(state.state)\n        solve_chance_nodes(state)\n        state.state.apply_action(bot_atn)\n    # Now that we have applied all actions, get the next obs.",
        "detail": "deps.pufferlib.pufferlib.environments.open_spiel.gymnasium_environment",
        "documentation": {}
    },
    {
        "label": "OpenSpielPettingZooEnvironment",
        "kind": 6,
        "importPath": "deps.pufferlib.pufferlib.environments.open_spiel.pettingzoo_environment",
        "description": "deps.pufferlib.pufferlib.environments.open_spiel.pettingzoo_environment",
        "peekOfCode": "class OpenSpielPettingZooEnvironment:\n    __init__ = init\n    step = step\n    reset = reset\n    agents = lambda state: state.agents\n    possible_agents = property(possible_agents)\n    observation_space = pz_observation_space\n    action_space = pz_action_space\n    render = render\n    close = close",
        "detail": "deps.pufferlib.pufferlib.environments.open_spiel.pettingzoo_environment",
        "documentation": {}
    },
    {
        "label": "agents",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.environments.open_spiel.pettingzoo_environment",
        "description": "deps.pufferlib.pufferlib.environments.open_spiel.pettingzoo_environment",
        "peekOfCode": "def agents(state):\n    return state.agents\ndef possible_agents(state):\n    return list(range(state.env.num_players()))\ndef pz_observation_space(state, agent):\n    return observation_space(state)\ndef pz_action_space(state, agent):\n    return action_space(state)\ndef reset(state, seed = None, options = None):\n    state.state = state.env.new_initial_state()",
        "detail": "deps.pufferlib.pufferlib.environments.open_spiel.pettingzoo_environment",
        "documentation": {}
    },
    {
        "label": "possible_agents",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.environments.open_spiel.pettingzoo_environment",
        "description": "deps.pufferlib.pufferlib.environments.open_spiel.pettingzoo_environment",
        "peekOfCode": "def possible_agents(state):\n    return list(range(state.env.num_players()))\ndef pz_observation_space(state, agent):\n    return observation_space(state)\ndef pz_action_space(state, agent):\n    return action_space(state)\ndef reset(state, seed = None, options = None):\n    state.state = state.env.new_initial_state()\n    obs, infos = get_obs_and_infos(state)\n    state.agents = state.possible_agents",
        "detail": "deps.pufferlib.pufferlib.environments.open_spiel.pettingzoo_environment",
        "documentation": {}
    },
    {
        "label": "pz_observation_space",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.environments.open_spiel.pettingzoo_environment",
        "description": "deps.pufferlib.pufferlib.environments.open_spiel.pettingzoo_environment",
        "peekOfCode": "def pz_observation_space(state, agent):\n    return observation_space(state)\ndef pz_action_space(state, agent):\n    return action_space(state)\ndef reset(state, seed = None, options = None):\n    state.state = state.env.new_initial_state()\n    obs, infos = get_obs_and_infos(state)\n    state.agents = state.possible_agents\n    if not state.has_reset:\n        state.has_reset = True",
        "detail": "deps.pufferlib.pufferlib.environments.open_spiel.pettingzoo_environment",
        "documentation": {}
    },
    {
        "label": "pz_action_space",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.environments.open_spiel.pettingzoo_environment",
        "description": "deps.pufferlib.pufferlib.environments.open_spiel.pettingzoo_environment",
        "peekOfCode": "def pz_action_space(state, agent):\n    return action_space(state)\ndef reset(state, seed = None, options = None):\n    state.state = state.env.new_initial_state()\n    obs, infos = get_obs_and_infos(state)\n    state.agents = state.possible_agents\n    if not state.has_reset:\n        state.has_reset = True\n        state.seed_value = seed\n        np.random.seed(seed)",
        "detail": "deps.pufferlib.pufferlib.environments.open_spiel.pettingzoo_environment",
        "documentation": {}
    },
    {
        "label": "reset",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.environments.open_spiel.pettingzoo_environment",
        "description": "deps.pufferlib.pufferlib.environments.open_spiel.pettingzoo_environment",
        "peekOfCode": "def reset(state, seed = None, options = None):\n    state.state = state.env.new_initial_state()\n    obs, infos = get_obs_and_infos(state)\n    state.agents = state.possible_agents\n    if not state.has_reset:\n        state.has_reset = True\n        state.seed_value = seed\n        np.random.seed(seed)\n    return obs, infos\ndef step(state, actions):",
        "detail": "deps.pufferlib.pufferlib.environments.open_spiel.pettingzoo_environment",
        "documentation": {}
    },
    {
        "label": "step",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.environments.open_spiel.pettingzoo_environment",
        "description": "deps.pufferlib.pufferlib.environments.open_spiel.pettingzoo_environment",
        "peekOfCode": "def step(state, actions):\n    curr_player = state.state.current_player()\n    solve_chance_nodes(state)\n    state.state.apply_action(actions[curr_player])\n    obs, infos = get_obs_and_infos(state)\n    rewards = {ag: r for ag, r in enumerate(state.state.returns())}\n    # Are we done?\n    is_terminated = state.state.is_terminal()\n    terminateds = {a: False for a in obs}\n    truncateds = {a: False for a in obs}",
        "detail": "deps.pufferlib.pufferlib.environments.open_spiel.pettingzoo_environment",
        "documentation": {}
    },
    {
        "label": "Policy",
        "kind": 6,
        "importPath": "deps.pufferlib.pufferlib.environments.open_spiel.torch",
        "description": "deps.pufferlib.pufferlib.environments.open_spiel.torch",
        "peekOfCode": "class Policy(Base):\n    def __init__(self, env, input_size=128, hidden_size=128):\n        '''Default PyTorch policy, meant for debugging.\n        This should run with any environment but is unlikely to learn anything.\n        Uses a single linear layer + relu to encode observations and a list of\n        linear layers to decode actions. The value function is a single linear layer.\n        '''\n        super().__init__(env)\n        self.flat_observation_space = env.flat_observation_space\n        self.flat_observation_structure = env.flat_observation_structure",
        "detail": "deps.pufferlib.pufferlib.environments.open_spiel.torch",
        "documentation": {}
    },
    {
        "label": "init",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.environments.open_spiel.utils",
        "description": "deps.pufferlib.pufferlib.environments.open_spiel.utils",
        "peekOfCode": "def init(self, \n    env,\n    n_rollouts,\n    min_simulations,\n    max_simulations\n    ):\n    #state.num_agents = state.env.num_players()\n    return namespace(self,\n        env=env,\n        type=env.get_type(),",
        "detail": "deps.pufferlib.pufferlib.environments.open_spiel.utils",
        "documentation": {}
    },
    {
        "label": "observation_space",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.environments.open_spiel.utils",
        "description": "deps.pufferlib.pufferlib.environments.open_spiel.utils",
        "peekOfCode": "def observation_space(state):\n    return gymnasium.spaces.Dict({\n        'obs': gymnasium.spaces.Box(\n            low=0.0,\n            high=1.0,\n            shape=(state.env.observation_tensor_size(),),\n            dtype=np.float32,\n        ),\n        'action_mask': gymnasium.spaces.Box(\n            low=0,",
        "detail": "deps.pufferlib.pufferlib.environments.open_spiel.utils",
        "documentation": {}
    },
    {
        "label": "action_space",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.environments.open_spiel.utils",
        "description": "deps.pufferlib.pufferlib.environments.open_spiel.utils",
        "peekOfCode": "def action_space(state):\n    return gymnasium.spaces.Discrete(\n        state.env.num_distinct_actions())\ndef render(state, mode=None) -> None:\n    if mode == \"human\":\n        print(state.state)\ndef close(state):\n    pass\ndef act(state, action):\n    solve_chance_nodes(state)",
        "detail": "deps.pufferlib.pufferlib.environments.open_spiel.utils",
        "documentation": {}
    },
    {
        "label": "render",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.environments.open_spiel.utils",
        "description": "deps.pufferlib.pufferlib.environments.open_spiel.utils",
        "peekOfCode": "def render(state, mode=None) -> None:\n    if mode == \"human\":\n        print(state.state)\ndef close(state):\n    pass\ndef act(state, action):\n    solve_chance_nodes(state)\n    state.state.apply_action(action)\ndef get_obs_and_infos(state):\n    # Before calculating an observation, there could be chance nodes",
        "detail": "deps.pufferlib.pufferlib.environments.open_spiel.utils",
        "documentation": {}
    },
    {
        "label": "close",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.environments.open_spiel.utils",
        "description": "deps.pufferlib.pufferlib.environments.open_spiel.utils",
        "peekOfCode": "def close(state):\n    pass\ndef act(state, action):\n    solve_chance_nodes(state)\n    state.state.apply_action(action)\ndef get_obs_and_infos(state):\n    # Before calculating an observation, there could be chance nodes\n    # (that may have an effect on the actual observations).\n    # E.g. After reset, figure out initial (random) positions of the\n    # agents.",
        "detail": "deps.pufferlib.pufferlib.environments.open_spiel.utils",
        "documentation": {}
    },
    {
        "label": "act",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.environments.open_spiel.utils",
        "description": "deps.pufferlib.pufferlib.environments.open_spiel.utils",
        "peekOfCode": "def act(state, action):\n    solve_chance_nodes(state)\n    state.state.apply_action(action)\ndef get_obs_and_infos(state):\n    # Before calculating an observation, there could be chance nodes\n    # (that may have an effect on the actual observations).\n    # E.g. After reset, figure out initial (random) positions of the\n    # agents.\n    solve_chance_nodes(state)\n    if state.state.is_terminal():",
        "detail": "deps.pufferlib.pufferlib.environments.open_spiel.utils",
        "documentation": {}
    },
    {
        "label": "get_obs_and_infos",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.environments.open_spiel.utils",
        "description": "deps.pufferlib.pufferlib.environments.open_spiel.utils",
        "peekOfCode": "def get_obs_and_infos(state):\n    # Before calculating an observation, there could be chance nodes\n    # (that may have an effect on the actual observations).\n    # E.g. After reset, figure out initial (random) positions of the\n    # agents.\n    solve_chance_nodes(state)\n    if state.state.is_terminal():\n        return (\n            state.last_obs, \n            {player: {} for player in range(state.env.num_players())},",
        "detail": "deps.pufferlib.pufferlib.environments.open_spiel.utils",
        "documentation": {}
    },
    {
        "label": "solve_chance_nodes",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.environments.open_spiel.utils",
        "description": "deps.pufferlib.pufferlib.environments.open_spiel.utils",
        "peekOfCode": "def solve_chance_nodes(state):\n    # Before applying action(s), there could be chance nodes.\n    # E.g. if env has to figure out, which agent's action should get\n    # resolved first in a simultaneous node.\n    # Chance node(s): Sample a (non-player) action and apply.\n    while state.state.is_chance_node():\n        assert state.state.current_player() == -1\n        actions, probs = zip(*state.state.chance_outcomes())\n        action = np.random.choice(actions, p=probs)\n        state.state.apply_action(action)",
        "detail": "deps.pufferlib.pufferlib.environments.open_spiel.utils",
        "documentation": {}
    },
    {
        "label": "RenderWrapper",
        "kind": 6,
        "importPath": "deps.pufferlib.pufferlib.environments.pokemon_red.environment",
        "description": "deps.pufferlib.pufferlib.environments.pokemon_red.environment",
        "peekOfCode": "class RenderWrapper(gymnasium.Wrapper):\n    def __init__(self, env):\n        self.env = env\n    @property\n    def render_mode(self):\n        return 'rgb_array'\n    def render(self):\n        return self.env.screen.screen_ndarray()",
        "detail": "deps.pufferlib.pufferlib.environments.pokemon_red.environment",
        "documentation": {}
    },
    {
        "label": "env_creator",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.environments.pokemon_red.environment",
        "description": "deps.pufferlib.pufferlib.environments.pokemon_red.environment",
        "peekOfCode": "def env_creator(name='pokemon_red'):\n    return functools.partial(make, name)\ndef make(name, headless: bool = True, state_path=None):\n    '''Pokemon Red'''\n    env = Environment(headless=headless, state_path=state_path)\n    env = RenderWrapper(env)\n    env = pufferlib.postprocess.EpisodeStats(env)\n    return pufferlib.emulation.GymnasiumPufferEnv(env=env)\nclass RenderWrapper(gymnasium.Wrapper):\n    def __init__(self, env):",
        "detail": "deps.pufferlib.pufferlib.environments.pokemon_red.environment",
        "documentation": {}
    },
    {
        "label": "make",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.environments.pokemon_red.environment",
        "description": "deps.pufferlib.pufferlib.environments.pokemon_red.environment",
        "peekOfCode": "def make(name, headless: bool = True, state_path=None):\n    '''Pokemon Red'''\n    env = Environment(headless=headless, state_path=state_path)\n    env = RenderWrapper(env)\n    env = pufferlib.postprocess.EpisodeStats(env)\n    return pufferlib.emulation.GymnasiumPufferEnv(env=env)\nclass RenderWrapper(gymnasium.Wrapper):\n    def __init__(self, env):\n        self.env = env\n    @property",
        "detail": "deps.pufferlib.pufferlib.environments.pokemon_red.environment",
        "documentation": {}
    },
    {
        "label": "Recurrent",
        "kind": 6,
        "importPath": "deps.pufferlib.pufferlib.environments.pokemon_red.torch",
        "description": "deps.pufferlib.pufferlib.environments.pokemon_red.torch",
        "peekOfCode": "class Recurrent(pufferlib.models.LSTMWrapper):\n    def __init__(self, env, policy,\n            input_size=512, hidden_size=512, num_layers=1):\n        super().__init__(env, policy,\n            input_size, hidden_size, num_layers)\nclass Policy(pufferlib.models.Convolutional):\n    def __init__(self, env,\n            input_size=512, hidden_size=512, output_size=512,\n            framestack=4, flat_size=64*5*6):\n        super().__init__(",
        "detail": "deps.pufferlib.pufferlib.environments.pokemon_red.torch",
        "documentation": {}
    },
    {
        "label": "Policy",
        "kind": 6,
        "importPath": "deps.pufferlib.pufferlib.environments.pokemon_red.torch",
        "description": "deps.pufferlib.pufferlib.environments.pokemon_red.torch",
        "peekOfCode": "class Policy(pufferlib.models.Convolutional):\n    def __init__(self, env,\n            input_size=512, hidden_size=512, output_size=512,\n            framestack=4, flat_size=64*5*6):\n        super().__init__(\n            env=env,\n            input_size=input_size,\n            hidden_size=hidden_size,\n            output_size=output_size,\n            framestack=framestack,",
        "detail": "deps.pufferlib.pufferlib.environments.pokemon_red.torch",
        "documentation": {}
    },
    {
        "label": "Policy",
        "kind": 6,
        "importPath": "deps.pufferlib.pufferlib.environments.pokemon_red.torch",
        "description": "deps.pufferlib.pufferlib.environments.pokemon_red.torch",
        "peekOfCode": "class Policy(pufferlib.models.ProcgenResnet):\n    def __init__(self, env, cnn_width=16, mlp_width=512):\n        super().__init__(\n            env=env,\n            cnn_width=cnn_width,\n            mlp_width=mlp_width,\n        )\n'''",
        "detail": "deps.pufferlib.pufferlib.environments.pokemon_red.torch",
        "documentation": {}
    },
    {
        "label": "ProcgenWrapper",
        "kind": 6,
        "importPath": "deps.pufferlib.pufferlib.environments.procgen.environment",
        "description": "deps.pufferlib.pufferlib.environments.procgen.environment",
        "peekOfCode": "class ProcgenWrapper:\n    def __init__(self, env):\n        self.env = env\n        self.observation_space = self.env.observation_space['rgb']\n        self.action_space = self.env.action_space\n    @property\n    def render_mode(self):\n        return 'rgb_array'\n    def reset(self, seed=None):\n        obs = self.env.reset()[0]",
        "detail": "deps.pufferlib.pufferlib.environments.procgen.environment",
        "documentation": {}
    },
    {
        "label": "env_creator",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.environments.procgen.environment",
        "description": "deps.pufferlib.pufferlib.environments.procgen.environment",
        "peekOfCode": "def env_creator(name='bigfish'):\n    return functools.partial(make, name)\ndef make(name, num_envs=1, num_levels=0,\n        start_level=0, distribution_mode='easy', render_mode=None):\n    '''Atari creation function with default CleanRL preprocessing based on Stable Baselines3 wrappers'''\n    assert int(num_envs) == float(num_envs), \"num_envs must be an integer\"\n    num_envs = int(num_envs)\n    procgen = pufferlib.environments.try_import('procgen') \n    envs = procgen.ProcgenEnv(\n        env_name=name,",
        "detail": "deps.pufferlib.pufferlib.environments.procgen.environment",
        "documentation": {}
    },
    {
        "label": "make",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.environments.procgen.environment",
        "description": "deps.pufferlib.pufferlib.environments.procgen.environment",
        "peekOfCode": "def make(name, num_envs=1, num_levels=0,\n        start_level=0, distribution_mode='easy', render_mode=None):\n    '''Atari creation function with default CleanRL preprocessing based on Stable Baselines3 wrappers'''\n    assert int(num_envs) == float(num_envs), \"num_envs must be an integer\"\n    num_envs = int(num_envs)\n    procgen = pufferlib.environments.try_import('procgen') \n    envs = procgen.ProcgenEnv(\n        env_name=name,\n        num_envs=num_envs,\n        num_levels=num_levels,",
        "detail": "deps.pufferlib.pufferlib.environments.procgen.environment",
        "documentation": {}
    },
    {
        "label": "Recurrent",
        "kind": 6,
        "importPath": "deps.pufferlib.pufferlib.environments.procgen.torch",
        "description": "deps.pufferlib.pufferlib.environments.procgen.torch",
        "peekOfCode": "class Recurrent(pufferlib.models.LSTMWrapper):\n    def __init__(self, env, policy, input_size=256, hidden_size=256, num_layers=1):\n        super().__init__(env, policy, input_size, hidden_size, num_layers)\nclass Policy (nn.Module):\n    def __init__(self, env, *args, input_size=256, hidden_size=256,\n            output_size=256, **kwargs):\n        '''The CleanRL default NatureCNN policy used for Atari.\n        It's just a stack of three convolutions followed by a linear layer\n        Takes framestack as a mandatory keyword argument. Suggested default is 1 frame\n        with LSTM or 4 frames without.'''",
        "detail": "deps.pufferlib.pufferlib.environments.procgen.torch",
        "documentation": {}
    },
    {
        "label": "Polic",
        "kind": 6,
        "importPath": "deps.pufferlib.pufferlib.environments.procgen.torch",
        "description": "deps.pufferlib.pufferlib.environments.procgen.torch",
        "peekOfCode": "class Policy (nn.Module):\n    def __init__(self, env, *args, input_size=256, hidden_size=256,\n            output_size=256, **kwargs):\n        '''The CleanRL default NatureCNN policy used for Atari.\n        It's just a stack of three convolutions followed by a linear layer\n        Takes framestack as a mandatory keyword argument. Suggested default is 1 frame\n        with LSTM or 4 frames without.'''\n        super().__init__()\n        self.network= nn.Sequential(\n            pufferlib.pytorch.layer_init(nn.Conv2d(3, 16, 8, stride=4)),",
        "detail": "deps.pufferlib.pufferlib.environments.procgen.torch",
        "documentation": {}
    },
    {
        "label": "Policy",
        "kind": 5,
        "importPath": "deps.pufferlib.pufferlib.environments.procgen.torch",
        "description": "deps.pufferlib.pufferlib.environments.procgen.torch",
        "peekOfCode": "Policy = pufferlib.models.ProcgenResnet",
        "detail": "deps.pufferlib.pufferlib.environments.procgen.torch",
        "documentation": {}
    },
    {
        "label": "SlimeVolleyMultiDiscrete",
        "kind": 6,
        "importPath": "deps.pufferlib.pufferlib.environments.slimevolley.environment",
        "description": "deps.pufferlib.pufferlib.environments.slimevolley.environment",
        "peekOfCode": "class SlimeVolleyMultiDiscrete(gym.Wrapper):\n    def __init__(self, env):\n        super().__init__(env)\n        #self.action_space = gym.spaces.MultiDiscrete(\n        #    [2 for _ in range(env.action_space.n)])\n    def reset(self, seed=None):\n        return self.env.reset().astype(np.float32)\n    def step(self, action):\n        obs, reward, done, info = self.env.step(action)\n        return obs.astype(np.float32), reward, done, info",
        "detail": "deps.pufferlib.pufferlib.environments.slimevolley.environment",
        "documentation": {}
    },
    {
        "label": "SkipWrapper",
        "kind": 6,
        "importPath": "deps.pufferlib.pufferlib.environments.slimevolley.environment",
        "description": "deps.pufferlib.pufferlib.environments.slimevolley.environment",
        "peekOfCode": "class SkipWrapper(gym.Wrapper):\n    \"\"\"\n        Generic common frame skipping wrapper\n        Will perform action for `x` additional steps\n    \"\"\"\n    def __init__(self, env, repeat_count):\n        super(SkipWrapper, self).__init__(env)\n        self.repeat_count = repeat_count\n        self.stepcount = 0\n    def step(self, action):",
        "detail": "deps.pufferlib.pufferlib.environments.slimevolley.environment",
        "documentation": {}
    },
    {
        "label": "env_creator",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.environments.slimevolley.environment",
        "description": "deps.pufferlib.pufferlib.environments.slimevolley.environment",
        "peekOfCode": "def env_creator(name='SlimeVolley-v0'):\n    return functools.partial(make, name)\ndef make(name, render_mode='rgb_array'):\n    if name == 'slimevolley':\n        name = 'SlimeVolley-v0'\n    from slimevolleygym import SlimeVolleyEnv\n    SlimeVolleyEnv.atari_mode = True\n    env = SlimeVolleyEnv()\n    env.policy.predict = lambda obs: np.random.randint(0, 2, 3)\n    env = SlimeVolleyMultiDiscrete(env)",
        "detail": "deps.pufferlib.pufferlib.environments.slimevolley.environment",
        "documentation": {}
    },
    {
        "label": "make",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.environments.slimevolley.environment",
        "description": "deps.pufferlib.pufferlib.environments.slimevolley.environment",
        "peekOfCode": "def make(name, render_mode='rgb_array'):\n    if name == 'slimevolley':\n        name = 'SlimeVolley-v0'\n    from slimevolleygym import SlimeVolleyEnv\n    SlimeVolleyEnv.atari_mode = True\n    env = SlimeVolleyEnv()\n    env.policy.predict = lambda obs: np.random.randint(0, 2, 3)\n    env = SlimeVolleyMultiDiscrete(env)\n    env = SkipWrapper(env, repeat_count=4)\n    env = shimmy.GymV21CompatibilityV0(env=env)",
        "detail": "deps.pufferlib.pufferlib.environments.slimevolley.environment",
        "documentation": {}
    },
    {
        "label": "Recurrent",
        "kind": 5,
        "importPath": "deps.pufferlib.pufferlib.environments.slimevolley.torch",
        "description": "deps.pufferlib.pufferlib.environments.slimevolley.torch",
        "peekOfCode": "Recurrent = pufferlib.models.LSTMWrapper\nPolicy = pufferlib.models.Default",
        "detail": "deps.pufferlib.pufferlib.environments.slimevolley.torch",
        "documentation": {}
    },
    {
        "label": "Policy",
        "kind": 5,
        "importPath": "deps.pufferlib.pufferlib.environments.slimevolley.torch",
        "description": "deps.pufferlib.pufferlib.environments.slimevolley.torch",
        "peekOfCode": "Policy = pufferlib.models.Default",
        "detail": "deps.pufferlib.pufferlib.environments.slimevolley.torch",
        "documentation": {}
    },
    {
        "label": "env_creator",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.environments.smac.environment",
        "description": "deps.pufferlib.pufferlib.environments.smac.environment",
        "peekOfCode": "def env_creator(name='smac'):\n    return functools.partial(make, name)\ndef make(name):\n    '''Starcraft Multiagent Challenge creation function\n    Support for SMAC is WIP because environments do not function without\n    an action-masked baseline policy.'''\n    pufferlib.environments.try_import('smac')\n    from smac.env.pettingzoo.StarCraft2PZEnv import _parallel_env as smac_env\n    env = smac_env(1000)\n    env = pufferlib.wrappers.PettingZooTruncatedWrapper(env)",
        "detail": "deps.pufferlib.pufferlib.environments.smac.environment",
        "documentation": {}
    },
    {
        "label": "make",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.environments.smac.environment",
        "description": "deps.pufferlib.pufferlib.environments.smac.environment",
        "peekOfCode": "def make(name):\n    '''Starcraft Multiagent Challenge creation function\n    Support for SMAC is WIP because environments do not function without\n    an action-masked baseline policy.'''\n    pufferlib.environments.try_import('smac')\n    from smac.env.pettingzoo.StarCraft2PZEnv import _parallel_env as smac_env\n    env = smac_env(1000)\n    env = pufferlib.wrappers.PettingZooTruncatedWrapper(env)\n    env = pufferlib.emulation.PettingZooPufferEnv(env)\n    return env",
        "detail": "deps.pufferlib.pufferlib.environments.smac.environment",
        "documentation": {}
    },
    {
        "label": "AtariFeaturizer",
        "kind": 6,
        "importPath": "deps.pufferlib.pufferlib.environments.stable_retro.environment",
        "description": "deps.pufferlib.pufferlib.environments.stable_retro.environment",
        "peekOfCode": "class AtariFeaturizer(pufferlib.emulation.Postprocessor):\n    def reset(self, obs):\n        self.epoch_return = 0\n        self.epoch_length = 0\n        self.done = False\n    #@property\n    #def observation_space(self):\n    #    return gym.spaces.Box(0, 255, (1, 84, 84), dtype=np.uint8)\n    def observation(self, obs):\n        return np.array(obs)",
        "detail": "deps.pufferlib.pufferlib.environments.stable_retro.environment",
        "documentation": {}
    },
    {
        "label": "env_creator",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.environments.stable_retro.environment",
        "description": "deps.pufferlib.pufferlib.environments.stable_retro.environment",
        "peekOfCode": "def env_creator(name='Airstriker-Genesis'):\n    return functools.partial(make, name)\ndef make(name='Airstriker-Genesis', framestack=4):\n    '''Atari creation function with default CleanRL preprocessing based on Stable Baselines3 wrappers'''\n    retro = pufferlib.environments.try_import('retro', 'stable-retro')\n    from stable_baselines3.common.atari_wrappers import (\n        ClipRewardEnv,\n        EpisodicLifeEnv,\n        FireResetEnv,\n        MaxAndSkipEnv,",
        "detail": "deps.pufferlib.pufferlib.environments.stable_retro.environment",
        "documentation": {}
    },
    {
        "label": "make",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.environments.stable_retro.environment",
        "description": "deps.pufferlib.pufferlib.environments.stable_retro.environment",
        "peekOfCode": "def make(name='Airstriker-Genesis', framestack=4):\n    '''Atari creation function with default CleanRL preprocessing based on Stable Baselines3 wrappers'''\n    retro = pufferlib.environments.try_import('retro', 'stable-retro')\n    from stable_baselines3.common.atari_wrappers import (\n        ClipRewardEnv,\n        EpisodicLifeEnv,\n        FireResetEnv,\n        MaxAndSkipEnv,\n    )\n    with pufferlib.utils.Suppress():",
        "detail": "deps.pufferlib.pufferlib.environments.stable_retro.environment",
        "documentation": {}
    },
    {
        "label": "Recurrent",
        "kind": 6,
        "importPath": "deps.pufferlib.pufferlib.environments.stable_retro.torch",
        "description": "deps.pufferlib.pufferlib.environments.stable_retro.torch",
        "peekOfCode": "class Recurrent:\n    input_size = 512\n    hidden_size = 512\n    num_layers = 1\nclass Policy(pufferlib.models.Convolutional):\n    def __init__(self, env, input_size=512, hidden_size=512, output_size=512,\n            framestack=4, flat_size=64*7*7):\n        super().__init__(\n            env=env,\n            input_size=input_size,",
        "detail": "deps.pufferlib.pufferlib.environments.stable_retro.torch",
        "documentation": {}
    },
    {
        "label": "Policy",
        "kind": 6,
        "importPath": "deps.pufferlib.pufferlib.environments.stable_retro.torch",
        "description": "deps.pufferlib.pufferlib.environments.stable_retro.torch",
        "peekOfCode": "class Policy(pufferlib.models.Convolutional):\n    def __init__(self, env, input_size=512, hidden_size=512, output_size=512,\n            framestack=4, flat_size=64*7*7):\n        super().__init__(\n            env=env,\n            input_size=input_size,\n            hidden_size=hidden_size,\n            output_size=output_size,\n            framestack=framestack,\n            flat_size=flat_size,",
        "detail": "deps.pufferlib.pufferlib.environments.stable_retro.torch",
        "documentation": {}
    },
    {
        "label": "GymnasiumPerformanceEnv",
        "kind": 6,
        "importPath": "deps.pufferlib.pufferlib.environments.test.environment",
        "description": "deps.pufferlib.pufferlib.environments.test.environment",
        "peekOfCode": "class GymnasiumPerformanceEnv:\n    def __init__(self, delay_mean=0, delay_std=0):\n        self.observation_space = DEFAULT_OBSERVATION_SPACE\n        self.action_space = DEFAULT_ACTION_SPACE\n        self.observation = self.observation_space.sample()\n        self.delay_mean = delay_mean\n        self.delay_std = delay_std\n        # Test performance independent of PufferLib seeding\n        np.random.seed(time.time_ns() % 2**32)\n    def reset(self, seed=None):",
        "detail": "deps.pufferlib.pufferlib.environments.test.environment",
        "documentation": {}
    },
    {
        "label": "PettingZooPerformanceEnv",
        "kind": 6,
        "importPath": "deps.pufferlib.pufferlib.environments.test.environment",
        "description": "deps.pufferlib.pufferlib.environments.test.environment",
        "peekOfCode": "class PettingZooPerformanceEnv:\n    def __init__(self, delay_mean, delay_std):\n        self.possible_agents = [1]\n        self.agents = [1]\n        self.done = False\n        self.delay_mean = delay_mean\n        self.delay_std = delay_std\n    def observation_space(self, agent):\n        return DEFAULT_OBSERVATION_SPACE\n    def action_space(self, agent):",
        "detail": "deps.pufferlib.pufferlib.environments.test.environment",
        "documentation": {}
    },
    {
        "label": "GymnasiumTestEnv",
        "kind": 6,
        "importPath": "deps.pufferlib.pufferlib.environments.test.environment",
        "description": "deps.pufferlib.pufferlib.environments.test.environment",
        "peekOfCode": "class GymnasiumTestEnv(gym.Env):\n    def __init__(self,\n            observation_space=DEFAULT_OBSERVATION_SPACE,\n            action_space=DEFAULT_ACTION_SPACE):\n        self.observation_space = observation_space\n        self.action_space = action_space\n    def reset(self, seed=None):\n        self.tick = 0\n        self.rng = pufferlib.utils.RandomState(seed)\n        ob = _sample_space('agent_1', self.tick, self.observation_space)",
        "detail": "deps.pufferlib.pufferlib.environments.test.environment",
        "documentation": {}
    },
    {
        "label": "PettingZooTestEnv",
        "kind": 6,
        "importPath": "deps.pufferlib.pufferlib.environments.test.environment",
        "description": "deps.pufferlib.pufferlib.environments.test.environment",
        "peekOfCode": "class PettingZooTestEnv(ParallelEnv):\n    def __init__(self,\n            observation_space=DEFAULT_OBSERVATION_SPACE,\n            action_space=DEFAULT_ACTION_SPACE,\n            initial_agents=16, max_agents=16,\n            spawn_per_tick=0, death_per_tick=1,\n            homogeneous_spaces=True):\n        self._observation_space = observation_space\n        self._action_space = action_space\n        self.initial_agents = initial_agents",
        "detail": "deps.pufferlib.pufferlib.environments.test.environment",
        "documentation": {}
    },
    {
        "label": "make_all_mock_environments",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.environments.test.environment",
        "description": "deps.pufferlib.pufferlib.environments.test.environment",
        "peekOfCode": "def make_all_mock_environments():\n    mock_single_agent_environments = []\n    mock_multi_agent_environments = []\n    for obs_space in MOCK_OBSERVATION_SPACES:\n        for act_space in MOCK_ACTION_SPACES:\n            mock_single_agent_environments.append(\n                GymnasiumTestEnv(\n                    observation_space=obs_space,\n                    action_space=act_space,\n                )",
        "detail": "deps.pufferlib.pufferlib.environments.test.environment",
        "documentation": {}
    },
    {
        "label": "do_work",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.environments.test.environment",
        "description": "deps.pufferlib.pufferlib.environments.test.environment",
        "peekOfCode": "def do_work(delay_mean, delay_std):\n    start, idx = time.process_time(), 0\n    target_time = delay_mean + delay_std*np.random.randn()\n    while time.process_time() - start < target_time:\n        idx += 1\n    return\nclass GymnasiumPerformanceEnv:\n    def __init__(self, delay_mean=0, delay_std=0):\n        self.observation_space = DEFAULT_OBSERVATION_SPACE\n        self.action_space = DEFAULT_ACTION_SPACE",
        "detail": "deps.pufferlib.pufferlib.environments.test.environment",
        "documentation": {}
    },
    {
        "label": "HIGH",
        "kind": 5,
        "importPath": "deps.pufferlib.pufferlib.environments.test.environment",
        "description": "deps.pufferlib.pufferlib.environments.test.environment",
        "peekOfCode": "HIGH = 100\nLOW = 0\nMOCK_OBSERVATION_SPACES = [\n    # Atari space\n    Box(low=0, high=255, shape=(4, 84, 84), dtype=np.uint8),\n    # NetHack space\n    Dict({\n        'blstats': Box(-2147483648, 2147483647, (27,), 'int64'),\n        'chars': Box(0, 255, (21, 79), 'uint8'),\n        'colors': Box(0, 15, (21, 79), 'uint8'),",
        "detail": "deps.pufferlib.pufferlib.environments.test.environment",
        "documentation": {}
    },
    {
        "label": "LOW",
        "kind": 5,
        "importPath": "deps.pufferlib.pufferlib.environments.test.environment",
        "description": "deps.pufferlib.pufferlib.environments.test.environment",
        "peekOfCode": "LOW = 0\nMOCK_OBSERVATION_SPACES = [\n    # Atari space\n    Box(low=0, high=255, shape=(4, 84, 84), dtype=np.uint8),\n    # NetHack space\n    Dict({\n        'blstats': Box(-2147483648, 2147483647, (27,), 'int64'),\n        'chars': Box(0, 255, (21, 79), 'uint8'),\n        'colors': Box(0, 15, (21, 79), 'uint8'),\n        'glyphs': Box(0, 5976, (21, 79), 'int16'),",
        "detail": "deps.pufferlib.pufferlib.environments.test.environment",
        "documentation": {}
    },
    {
        "label": "MOCK_OBSERVATION_SPACES",
        "kind": 5,
        "importPath": "deps.pufferlib.pufferlib.environments.test.environment",
        "description": "deps.pufferlib.pufferlib.environments.test.environment",
        "peekOfCode": "MOCK_OBSERVATION_SPACES = [\n    # Atari space\n    Box(low=0, high=255, shape=(4, 84, 84), dtype=np.uint8),\n    # NetHack space\n    Dict({\n        'blstats': Box(-2147483648, 2147483647, (27,), 'int64'),\n        'chars': Box(0, 255, (21, 79), 'uint8'),\n        'colors': Box(0, 15, (21, 79), 'uint8'),\n        'glyphs': Box(0, 5976, (21, 79), 'int16'),\n        'inv_glyphs': Box(0, 5976, (55,), 'int16'),",
        "detail": "deps.pufferlib.pufferlib.environments.test.environment",
        "documentation": {}
    },
    {
        "label": "MOCK_ACTION_SPACES",
        "kind": 5,
        "importPath": "deps.pufferlib.pufferlib.environments.test.environment",
        "description": "deps.pufferlib.pufferlib.environments.test.environment",
        "peekOfCode": "MOCK_ACTION_SPACES = [\n    # NetHack action space\n    Discrete(5),\n    # Neural MMO action space\n    Dict({\n        'Attack': Dict({\n            'Style': Discrete(3),\n            'Target': Discrete(100),\n        }),\n        'Buy': Dict({",
        "detail": "deps.pufferlib.pufferlib.environments.test.environment",
        "documentation": {}
    },
    {
        "label": "MOCK_TEAMS",
        "kind": 5,
        "importPath": "deps.pufferlib.pufferlib.environments.test.environment",
        "description": "deps.pufferlib.pufferlib.environments.test.environment",
        "peekOfCode": "MOCK_TEAMS = {\n    'None': None,\n    'single': {\n        'team_1': ['agent_1'],\n        'team_2': ['agent_2'],\n        'team_3': ['agent_3'],\n        'team_4': ['agent_4'],\n        'team_5': ['agent_5'],\n        'team_6': ['agent_6'],\n        'team_7': ['agent_7'],",
        "detail": "deps.pufferlib.pufferlib.environments.test.environment",
        "documentation": {}
    },
    {
        "label": "DEFAULT_OBSERVATION_SPACE",
        "kind": 5,
        "importPath": "deps.pufferlib.pufferlib.environments.test.environment",
        "description": "deps.pufferlib.pufferlib.environments.test.environment",
        "peekOfCode": "DEFAULT_OBSERVATION_SPACE = gymnasium.spaces.Box(\n    low=-2**20, high=2**20,\n    shape=(1,), dtype=np.float32\n)\nDEFAULT_ACTION_SPACE = gymnasium.spaces.Discrete(2)\ndef make_all_mock_environments():\n    mock_single_agent_environments = []\n    mock_multi_agent_environments = []\n    for obs_space in MOCK_OBSERVATION_SPACES:\n        for act_space in MOCK_ACTION_SPACES:",
        "detail": "deps.pufferlib.pufferlib.environments.test.environment",
        "documentation": {}
    },
    {
        "label": "DEFAULT_ACTION_SPACE",
        "kind": 5,
        "importPath": "deps.pufferlib.pufferlib.environments.test.environment",
        "description": "deps.pufferlib.pufferlib.environments.test.environment",
        "peekOfCode": "DEFAULT_ACTION_SPACE = gymnasium.spaces.Discrete(2)\ndef make_all_mock_environments():\n    mock_single_agent_environments = []\n    mock_multi_agent_environments = []\n    for obs_space in MOCK_OBSERVATION_SPACES:\n        for act_space in MOCK_ACTION_SPACES:\n            mock_single_agent_environments.append(\n                GymnasiumTestEnv(\n                    observation_space=obs_space,\n                    action_space=act_space,",
        "detail": "deps.pufferlib.pufferlib.environments.test.environment",
        "documentation": {}
    },
    {
        "label": "PerformanceEnv",
        "kind": 6,
        "importPath": "deps.pufferlib.pufferlib.environments.test.mock_environments",
        "description": "deps.pufferlib.pufferlib.environments.test.mock_environments",
        "peekOfCode": "class PerformanceEnv:\n    def __init__(self, delay=0, bandwith=1):\n        self.agents = [1]\n        self.possible_agents = [1]\n        self.done = False\n        self.delay = delay\n        assert bandwith > 0\n        self.bandwidth = bandwith\n    def reset(self, seed=None):\n        return {1: self.observation_space(1).sample()}, {1: {}}",
        "detail": "deps.pufferlib.pufferlib.environments.test.mock_environments",
        "documentation": {}
    },
    {
        "label": "GymnasiumTestEnv",
        "kind": 6,
        "importPath": "deps.pufferlib.pufferlib.environments.test.mock_environments",
        "description": "deps.pufferlib.pufferlib.environments.test.mock_environments",
        "peekOfCode": "class GymnasiumTestEnv(gym.Env):\n    def __init__(self, observation_space, action_space):\n        self.observation_space = observation_space\n        self.action_space = action_space\n    def reset(self, seed=None):\n        self.tick = 0\n        self.rng = pufferlib.utils.RandomState(seed)\n        ob = _sample_space('agent_1', self.tick, self.observation_space)\n        return ob, {}\n    def step(self, actions):",
        "detail": "deps.pufferlib.pufferlib.environments.test.mock_environments",
        "documentation": {}
    },
    {
        "label": "TestEnv",
        "kind": 6,
        "importPath": "deps.pufferlib.pufferlib.environments.test.mock_environments",
        "description": "deps.pufferlib.pufferlib.environments.test.mock_environments",
        "peekOfCode": "class TestEnv(ParallelEnv):\n    def __init__(self, observation_space, action_space, initial_agents,\n            max_agents, spawn_per_tick, death_per_tick):\n        self.single_observation_space = observation_space\n        self.single_action_space = action_space\n        self.initial_agents = initial_agents\n        self.max_agents = max_agents\n        self.spawn_per_tick = spawn_per_tick\n        self.death_per_tick = death_per_tick\n        self.possible_agents = [f'agent_{i+1}' for i in range(max_agents)]",
        "detail": "deps.pufferlib.pufferlib.environments.test.mock_environments",
        "documentation": {}
    },
    {
        "label": "make_performance_env",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.environments.test.mock_environments",
        "description": "deps.pufferlib.pufferlib.environments.test.mock_environments",
        "peekOfCode": "def make_performance_env(delay=0, bandwidth=1):\n    return pufferlib.emulation.PettingZooPufferEnv(\n        env_creator=PerformanceEnv,\n        env_args=[delay, bandwidth],\n    )\nclass PerformanceEnv:\n    def __init__(self, delay=0, bandwith=1):\n        self.agents = [1]\n        self.possible_agents = [1]\n        self.done = False",
        "detail": "deps.pufferlib.pufferlib.environments.test.mock_environments",
        "documentation": {}
    },
    {
        "label": "make_mock_singleagent_env",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.environments.test.mock_environments",
        "description": "deps.pufferlib.pufferlib.environments.test.mock_environments",
        "peekOfCode": "def make_mock_singleagent_env(observation_space, action_space):\n    return partial(\n        GymnasiumTestEnv,\n        observation_space=observation_space,\n        action_space=action_space,\n    )\nclass TestEnv(ParallelEnv):\n    def __init__(self, observation_space, action_space, initial_agents,\n            max_agents, spawn_per_tick, death_per_tick):\n        self.single_observation_space = observation_space",
        "detail": "deps.pufferlib.pufferlib.environments.test.mock_environments",
        "documentation": {}
    },
    {
        "label": "make_mock_multiagent_env",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.environments.test.mock_environments",
        "description": "deps.pufferlib.pufferlib.environments.test.mock_environments",
        "peekOfCode": "def make_mock_multiagent_env(\n        observation_space,\n        action_space,\n        initial_agents,\n        max_agents,\n        spawn_per_tick,\n        death_per_tick,\n        homogeneous_spaces=True):\n    return partial(\n        TestEnv,",
        "detail": "deps.pufferlib.pufferlib.environments.test.mock_environments",
        "documentation": {}
    },
    {
        "label": "HIGH",
        "kind": 5,
        "importPath": "deps.pufferlib.pufferlib.environments.test.mock_environments",
        "description": "deps.pufferlib.pufferlib.environments.test.mock_environments",
        "peekOfCode": "HIGH = 100\nLOW = 0\ndef make_performance_env(delay=0, bandwidth=1):\n    return pufferlib.emulation.PettingZooPufferEnv(\n        env_creator=PerformanceEnv,\n        env_args=[delay, bandwidth],\n    )\nclass PerformanceEnv:\n    def __init__(self, delay=0, bandwith=1):\n        self.agents = [1]",
        "detail": "deps.pufferlib.pufferlib.environments.test.mock_environments",
        "documentation": {}
    },
    {
        "label": "LOW",
        "kind": 5,
        "importPath": "deps.pufferlib.pufferlib.environments.test.mock_environments",
        "description": "deps.pufferlib.pufferlib.environments.test.mock_environments",
        "peekOfCode": "LOW = 0\ndef make_performance_env(delay=0, bandwidth=1):\n    return pufferlib.emulation.PettingZooPufferEnv(\n        env_creator=PerformanceEnv,\n        env_args=[delay, bandwidth],\n    )\nclass PerformanceEnv:\n    def __init__(self, delay=0, bandwith=1):\n        self.agents = [1]\n        self.possible_agents = [1]",
        "detail": "deps.pufferlib.pufferlib.environments.test.mock_environments",
        "documentation": {}
    },
    {
        "label": "MOCK_OBSERVATION_SPACES",
        "kind": 5,
        "importPath": "deps.pufferlib.pufferlib.environments.test.mock_environments",
        "description": "deps.pufferlib.pufferlib.environments.test.mock_environments",
        "peekOfCode": "MOCK_OBSERVATION_SPACES = [\n    # Atari space\n    Box(low=0, high=255, shape=(4, 84, 84), dtype=np.uint8),\n    # NetHack space\n    Dict({\n        'blstats': Box(-2147483648, 2147483647, (27,), 'int64'),\n        'chars': Box(0, 255, (21, 79), 'uint8'),\n        'colors': Box(0, 15, (21, 79), 'uint8'),\n        'glyphs': Box(0, 5976, (21, 79), 'int16'),\n        'inv_glyphs': Box(0, 5976, (55,), 'int16'),",
        "detail": "deps.pufferlib.pufferlib.environments.test.mock_environments",
        "documentation": {}
    },
    {
        "label": "MOCK_ACTION_SPACES",
        "kind": 5,
        "importPath": "deps.pufferlib.pufferlib.environments.test.mock_environments",
        "description": "deps.pufferlib.pufferlib.environments.test.mock_environments",
        "peekOfCode": "MOCK_ACTION_SPACES = [\n    # NetHack action space\n    Discrete(5),\n    # Neural MMO action space\n    Dict({\n        'Attack': Dict({\n            'Style': Discrete(3),\n            'Target': Discrete(100),\n        }),\n        'Buy': Dict({",
        "detail": "deps.pufferlib.pufferlib.environments.test.mock_environments",
        "documentation": {}
    },
    {
        "label": "MOCK_TEAMS",
        "kind": 5,
        "importPath": "deps.pufferlib.pufferlib.environments.test.mock_environments",
        "description": "deps.pufferlib.pufferlib.environments.test.mock_environments",
        "peekOfCode": "MOCK_TEAMS = {\n    'None': None,\n    'single': {\n        'team_1': ['agent_1'],\n        'team_2': ['agent_2'],\n        'team_3': ['agent_3'],\n        'team_4': ['agent_4'],\n        'team_5': ['agent_5'],\n        'team_6': ['agent_6'],\n        'team_7': ['agent_7'],",
        "detail": "deps.pufferlib.pufferlib.environments.test.mock_environments",
        "documentation": {}
    },
    {
        "label": "MOCK_SINGLE_AGENT_ENVIRONMENTS",
        "kind": 5,
        "importPath": "deps.pufferlib.pufferlib.environments.test.mock_environments",
        "description": "deps.pufferlib.pufferlib.environments.test.mock_environments",
        "peekOfCode": "MOCK_SINGLE_AGENT_ENVIRONMENTS = []\nMOCK_MULTI_AGENT_ENVIRONMENTS = []\nfor obs_space in MOCK_OBSERVATION_SPACES:\n    for act_space in MOCK_ACTION_SPACES:\n        MOCK_SINGLE_AGENT_ENVIRONMENTS.append(\n            make_mock_singleagent_env(\n                observation_space=obs_space,\n                action_space=act_space,\n            )\n        )",
        "detail": "deps.pufferlib.pufferlib.environments.test.mock_environments",
        "documentation": {}
    },
    {
        "label": "MOCK_MULTI_AGENT_ENVIRONMENTS",
        "kind": 5,
        "importPath": "deps.pufferlib.pufferlib.environments.test.mock_environments",
        "description": "deps.pufferlib.pufferlib.environments.test.mock_environments",
        "peekOfCode": "MOCK_MULTI_AGENT_ENVIRONMENTS = []\nfor obs_space in MOCK_OBSERVATION_SPACES:\n    for act_space in MOCK_ACTION_SPACES:\n        MOCK_SINGLE_AGENT_ENVIRONMENTS.append(\n            make_mock_singleagent_env(\n                observation_space=obs_space,\n                action_space=act_space,\n            )\n        )\n        MOCK_MULTI_AGENT_ENVIRONMENTS.append(",
        "detail": "deps.pufferlib.pufferlib.environments.test.mock_environments",
        "documentation": {}
    },
    {
        "label": "DoomWrapper",
        "kind": 6,
        "importPath": "deps.pufferlib.pufferlib.environments.vizdoom.environment",
        "description": "deps.pufferlib.pufferlib.environments.vizdoom.environment",
        "peekOfCode": "class DoomWrapper(gym.Wrapper):\n    '''Gymnasium env does not expose proper options for screen scale and\n    render format. This is slow. So we do it ourselves. Not it is fast. Yay!'''\n    def __init__(self, env):\n        super().__init__(env.unwrapped)\n        if env.observation_space['screen'].shape[0] != 120:\n            raise ValueError('Wrong screen resolution. Doom does not provide '\n                'a way to change this. You must edit scenarios/<env_name>.cfg'\n                'This is inside your local ViZDoom installation. Likely in python system packages'\n                'Set screen resolution to RES_160X120 and screen format to GRAY8')",
        "detail": "deps.pufferlib.pufferlib.environments.vizdoom.environment",
        "documentation": {}
    },
    {
        "label": "env_creator",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.environments.vizdoom.environment",
        "description": "deps.pufferlib.pufferlib.environments.vizdoom.environment",
        "peekOfCode": "def env_creator(name='doom'):\n    return functools.partial(make, name)\ndef make(name, framestack=1, render_mode='rgb_array'):\n    '''Atari creation function with default CleanRL preprocessing based on Stable Baselines3 wrappers'''\n    if name == 'doom':\n        name = 'VizdoomHealthGatheringSupreme-v0'\n    #pufferlib.environments.try_import('vizdoom', 'gymnasium_wrapper')\n    from stable_baselines3.common.atari_wrappers import (\n        ClipRewardEnv,\n        EpisodicLifeEnv,",
        "detail": "deps.pufferlib.pufferlib.environments.vizdoom.environment",
        "documentation": {}
    },
    {
        "label": "make",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.environments.vizdoom.environment",
        "description": "deps.pufferlib.pufferlib.environments.vizdoom.environment",
        "peekOfCode": "def make(name, framestack=1, render_mode='rgb_array'):\n    '''Atari creation function with default CleanRL preprocessing based on Stable Baselines3 wrappers'''\n    if name == 'doom':\n        name = 'VizdoomHealthGatheringSupreme-v0'\n    #pufferlib.environments.try_import('vizdoom', 'gymnasium_wrapper')\n    from stable_baselines3.common.atari_wrappers import (\n        ClipRewardEnv,\n        EpisodicLifeEnv,\n        FireResetEnv,\n        MaxAndSkipEnv,",
        "detail": "deps.pufferlib.pufferlib.environments.vizdoom.environment",
        "documentation": {}
    },
    {
        "label": "Recurrent",
        "kind": 6,
        "importPath": "deps.pufferlib.pufferlib.environments.vizdoom.torch",
        "description": "deps.pufferlib.pufferlib.environments.vizdoom.torch",
        "peekOfCode": "class Recurrent(pufferlib.models.LSTMWrapper):\n    def __init__(self, env, policy, input_size=512, hidden_size=512, num_layers=1):\n        super().__init__(env, policy, input_size, hidden_size, num_layers)\nclass Policy(pufferlib.models.Convolutional):\n    def __init__(self, env, input_size=512, hidden_size=512, output_size=512,\n            framestack=1, flat_size=64*4*6):\n        super().__init__(\n            env=env,\n            input_size=input_size,\n            hidden_size=hidden_size,",
        "detail": "deps.pufferlib.pufferlib.environments.vizdoom.torch",
        "documentation": {}
    },
    {
        "label": "Policy",
        "kind": 6,
        "importPath": "deps.pufferlib.pufferlib.environments.vizdoom.torch",
        "description": "deps.pufferlib.pufferlib.environments.vizdoom.torch",
        "peekOfCode": "class Policy(pufferlib.models.Convolutional):\n    def __init__(self, env, input_size=512, hidden_size=512, output_size=512,\n            framestack=1, flat_size=64*4*6):\n        super().__init__(\n            env=env,\n            input_size=input_size,\n            hidden_size=hidden_size,\n            output_size=output_size,\n            framestack=framestack,\n            flat_size=flat_size,",
        "detail": "deps.pufferlib.pufferlib.environments.vizdoom.torch",
        "documentation": {}
    },
    {
        "label": "Policy",
        "kind": 6,
        "importPath": "deps.pufferlib.pufferlib.frameworks.cleanrl",
        "description": "deps.pufferlib.pufferlib.frameworks.cleanrl",
        "peekOfCode": "class Policy(torch.nn.Module):\n    '''Wrap a non-recurrent PyTorch model for use with CleanRL'''\n    def __init__(self, policy):\n        super().__init__()\n        self.policy = policy\n        self.is_continuous = hasattr(policy, 'is_continuous') and policy.is_continuous\n    def get_value(self, x, state=None):\n        _, value = self.policy(x)\n        return value\n    def get_action_and_value(self, x, action=None):",
        "detail": "deps.pufferlib.pufferlib.frameworks.cleanrl",
        "documentation": {}
    },
    {
        "label": "RecurrentPolicy",
        "kind": 6,
        "importPath": "deps.pufferlib.pufferlib.frameworks.cleanrl",
        "description": "deps.pufferlib.pufferlib.frameworks.cleanrl",
        "peekOfCode": "class RecurrentPolicy(torch.nn.Module):\n    '''Wrap a recurrent PyTorch model for use with CleanRL'''\n    def __init__(self, policy):\n        super().__init__()\n        self.policy = policy\n        self.is_continuous = hasattr(policy.policy, 'is_continuous') and policy.policy.is_continuous\n    @property\n    def lstm(self):\n        if hasattr(self.policy, 'recurrent'):\n            return self.policy.recurrent",
        "detail": "deps.pufferlib.pufferlib.frameworks.cleanrl",
        "documentation": {}
    },
    {
        "label": "log_prob",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.frameworks.cleanrl",
        "description": "deps.pufferlib.pufferlib.frameworks.cleanrl",
        "peekOfCode": "def log_prob(logits, value):\n    value = value.long().unsqueeze(-1)\n    value, log_pmf = torch.broadcast_tensors(value, logits)\n    value = value[..., :1]\n    return log_pmf.gather(-1, value).squeeze(-1)\n# taken from torch.distributions.Categorical\ndef entropy(logits):\n    min_real = torch.finfo(logits.dtype).min\n    logits = torch.clamp(logits, min=min_real)\n    p_log_p = logits * logits_to_probs(logits)",
        "detail": "deps.pufferlib.pufferlib.frameworks.cleanrl",
        "documentation": {}
    },
    {
        "label": "entropy",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.frameworks.cleanrl",
        "description": "deps.pufferlib.pufferlib.frameworks.cleanrl",
        "peekOfCode": "def entropy(logits):\n    min_real = torch.finfo(logits.dtype).min\n    logits = torch.clamp(logits, min=min_real)\n    p_log_p = logits * logits_to_probs(logits)\n    return -p_log_p.sum(-1)\ndef sample_logits(logits: Union[torch.Tensor, List[torch.Tensor]],\n        action=None, is_continuous=False):\n    is_discrete = isinstance(logits, torch.Tensor)\n    if is_continuous:\n        batch = logits.loc.shape[0]",
        "detail": "deps.pufferlib.pufferlib.frameworks.cleanrl",
        "documentation": {}
    },
    {
        "label": "sample_logits",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.frameworks.cleanrl",
        "description": "deps.pufferlib.pufferlib.frameworks.cleanrl",
        "peekOfCode": "def sample_logits(logits: Union[torch.Tensor, List[torch.Tensor]],\n        action=None, is_continuous=False):\n    is_discrete = isinstance(logits, torch.Tensor)\n    if is_continuous:\n        batch = logits.loc.shape[0]\n        if action is None:\n            action = logits.sample().view(batch, -1)\n        log_probs = logits.log_prob(action.view(batch, -1)).sum(1)\n        logits_entropy = logits.entropy().view(batch, -1).sum(1)\n        return action, log_probs, logits_entropy",
        "detail": "deps.pufferlib.pufferlib.frameworks.cleanrl",
        "documentation": {}
    },
    {
        "label": "RLPredictor",
        "kind": 6,
        "importPath": "deps.pufferlib.pufferlib.frameworks.rllib",
        "description": "deps.pufferlib.pufferlib.frameworks.rllib",
        "peekOfCode": "class RLPredictor(RLlibPredictor):\n    def predict(self, data, **kwargs):\n        batch = data.shape[0]\n        #data = data.reshape(batch, -1)\n        data = data.squeeze()\n        result = super().predict(data, **kwargs)\n        if type(result) == dict:\n            result = np.stack(list(result.values()), axis=-1)\n        return result\n        result = np.concatenate(list(result.values())).reshape(1, -1)",
        "detail": "deps.pufferlib.pufferlib.frameworks.rllib",
        "documentation": {}
    },
    {
        "label": "Callbacks",
        "kind": 6,
        "importPath": "deps.pufferlib.pufferlib.frameworks.rllib",
        "description": "deps.pufferlib.pufferlib.frameworks.rllib",
        "peekOfCode": "class Callbacks(DefaultCallbacks):\n    def on_train_result(self, *, algorithm, result, trainer, **kwargs) -> None:\n        '''Run after 1 epoch at the trainer level'''\n        return super().on_train_result(\n            algorithm=algorithm,\n            result=result,\n            trainer=trainer,\n            **kwargs\n        )\n    def on_episode_end(self, *, worker, base_env, policies, episode, **kwargs):",
        "detail": "deps.pufferlib.pufferlib.frameworks.rllib",
        "documentation": {}
    },
    {
        "label": "register_env",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.frameworks.rllib",
        "description": "deps.pufferlib.pufferlib.frameworks.rllib",
        "peekOfCode": "def register_env(name, env_creator):\n    assert type(name) == str, 'Name must be a str'\n    tune_register_env(name, lambda config: ParallelPettingZooEnv(env_creator())) \ndef read_checkpoints(tune_path):\n     folders = sorted([f.path for f in os.scandir(tune_path) if f.is_dir()])\n     assert len(folders) <= 1, 'Tune folder contains multiple trials'\n     if len(folders) == 0:\n        return []\n     all_checkpoints = []\n     trial_path = folders[0]",
        "detail": "deps.pufferlib.pufferlib.frameworks.rllib",
        "documentation": {}
    },
    {
        "label": "read_checkpoints",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.frameworks.rllib",
        "description": "deps.pufferlib.pufferlib.frameworks.rllib",
        "peekOfCode": "def read_checkpoints(tune_path):\n     folders = sorted([f.path for f in os.scandir(tune_path) if f.is_dir()])\n     assert len(folders) <= 1, 'Tune folder contains multiple trials'\n     if len(folders) == 0:\n        return []\n     all_checkpoints = []\n     trial_path = folders[0]\n     for f in os.listdir(trial_path):\n        if not f.startswith('checkpoint'):\n            continue",
        "detail": "deps.pufferlib.pufferlib.frameworks.rllib",
        "documentation": {}
    },
    {
        "label": "create_policies",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.frameworks.rllib",
        "description": "deps.pufferlib.pufferlib.frameworks.rllib",
        "peekOfCode": "def create_policies(n):\n    return {f'policy_{i}': \n        PolicySpec(\n            policy_class=None,\n            observation_space=None,\n            action_space=None,\n            config={\"gamma\": -1.85},\n        )\n        for i in range(n)\n    }",
        "detail": "deps.pufferlib.pufferlib.frameworks.rllib",
        "documentation": {}
    },
    {
        "label": "make_policy",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.frameworks.rllib",
        "description": "deps.pufferlib.pufferlib.frameworks.rllib",
        "peekOfCode": "def make_policy(policy_cls, lstm_layers):\n    '''Wrap a PyTorch model for use with RLLib \n    Args:\n        policy_cls: A pufferlib.models.Policy subclass that implements the PufferLib model API\n        lstm_layers: The number of LSTM layers to use. If 0, no LSTM is used\n    Returns:\n        A new RLlib model class wrapping your model\n    '''\n    assert issubclass(policy_cls, pufferlib.binding.Policy)\n    if lstm_layers > 0:",
        "detail": "deps.pufferlib.pufferlib.frameworks.rllib",
        "documentation": {}
    },
    {
        "label": "GymnasiumPufferEnv",
        "kind": 6,
        "importPath": "deps.pufferlib.pufferlib.emulation",
        "description": "deps.pufferlib.pufferlib.emulation",
        "peekOfCode": "class GymnasiumPufferEnv(gymnasium.Env):\n    def __init__(self, env=None, env_creator=None, env_args=[], env_kwargs={}):\n        self.env = make_object(env, env_creator, env_args, env_kwargs)\n        self.initialized = False\n        self.done = True\n        self.is_observation_checked = False\n        self.is_action_checked = False\n        self.observation_space, self.obs_dtype = emulate_observation_space(\n            self.env.observation_space)\n        self.action_space, self.atn_dtype = emulate_action_space(",
        "detail": "deps.pufferlib.pufferlib.emulation",
        "documentation": {}
    },
    {
        "label": "PettingZooPufferEnv",
        "kind": 6,
        "importPath": "deps.pufferlib.pufferlib.emulation",
        "description": "deps.pufferlib.pufferlib.emulation",
        "peekOfCode": "class PettingZooPufferEnv:\n    def __init__(self, env=None, env_creator=None, env_args=[], env_kwargs={}, to_puffer=False):\n        self.env = make_object(env, env_creator, env_args, env_kwargs)\n        self.to_puffer = to_puffer\n        self.initialized = False\n        self.all_done = True\n        self.is_observation_checked = False\n        self.is_action_checked = False\n        # Compute the observation and action spaces\n        single_agent = self.possible_agents[0]",
        "detail": "deps.pufferlib.pufferlib.emulation",
        "documentation": {}
    },
    {
        "label": "emulate",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.emulation",
        "description": "deps.pufferlib.pufferlib.emulation",
        "peekOfCode": "def emulate(struct, sample):\n    if isinstance(sample, dict):\n        for k, v in sample.items():\n            emulate(struct[k], v)\n    elif isinstance(sample, tuple):\n        for i, v in enumerate(sample):\n            emulate(struct[f'f{i}'], v)\n    else:\n        struct[()] = sample\ndef make_buffer(arr_dtype, struct_dtype, n=None):",
        "detail": "deps.pufferlib.pufferlib.emulation",
        "documentation": {}
    },
    {
        "label": "make_buffer",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.emulation",
        "description": "deps.pufferlib.pufferlib.emulation",
        "peekOfCode": "def make_buffer(arr_dtype, struct_dtype, n=None):\n    '''None instead of 1 makes it work for 1 agent PZ envs'''\n    if n is None:\n        struct = np.zeros(1, dtype=struct_dtype)\n    else:\n        struct = np.zeros(n, dtype=struct_dtype)\n    arr = struct.view(arr_dtype)\n    if n is None:\n        arr = arr.ravel()\n    else:",
        "detail": "deps.pufferlib.pufferlib.emulation",
        "documentation": {}
    },
    {
        "label": "emulate_copy",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.emulation",
        "description": "deps.pufferlib.pufferlib.emulation",
        "peekOfCode": "def emulate_copy(sample, arr_dtype, struct_dtype):\n    arr, struct = make_buffer(arr_dtype, struct_dtype)\n    emulate(struct, sample)\n    return arr\ndef _nativize(struct, space):\n    if isinstance(space, Discrete):\n        return struct.item()\n    elif isinstance(space, Tuple):\n        return tuple(_nativize(struct[f'f{i}'], elem)\n            for i, elem in enumerate(space))",
        "detail": "deps.pufferlib.pufferlib.emulation",
        "documentation": {}
    },
    {
        "label": "nativize",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.emulation",
        "description": "deps.pufferlib.pufferlib.emulation",
        "peekOfCode": "def nativize(arr, space, struct_dtype):\n    struct = np.asarray(arr).view(struct_dtype)[0]\n    return _nativize(struct, space)\ntry:\n    from pufferlib.extensions import emulate, nativize\nexcept ImportError:\n    warnings.warn('PufferLib Cython extensions not installed. Using slow Python versions')\ndef dtype_from_space(space):\n    if isinstance(space, pufferlib.spaces.Tuple):\n        dtype = []",
        "detail": "deps.pufferlib.pufferlib.emulation",
        "documentation": {}
    },
    {
        "label": "dtype_from_space",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.emulation",
        "description": "deps.pufferlib.pufferlib.emulation",
        "peekOfCode": "def dtype_from_space(space):\n    if isinstance(space, pufferlib.spaces.Tuple):\n        dtype = []\n        for i, elem in enumerate(space):\n            dtype.append((f'f{i}', dtype_from_space(elem)))\n    elif isinstance(space, pufferlib.spaces.Dict):\n        dtype = []\n        for k, value in space.items():\n            dtype.append((k, dtype_from_space(value)))\n    else:",
        "detail": "deps.pufferlib.pufferlib.emulation",
        "documentation": {}
    },
    {
        "label": "flatten_space",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.emulation",
        "description": "deps.pufferlib.pufferlib.emulation",
        "peekOfCode": "def flatten_space(space):\n    if isinstance(space, pufferlib.spaces.Tuple):\n        subspaces = []\n        for e in space:\n            subspaces.extend(flatten_space(e))\n        return subspaces\n    elif isinstance(space, pufferlib.spaces.Dict):\n        subspaces = []\n        for e in space.values():\n            subspaces.extend(flatten_space(e))",
        "detail": "deps.pufferlib.pufferlib.emulation",
        "documentation": {}
    },
    {
        "label": "emulate_observation_space",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.emulation",
        "description": "deps.pufferlib.pufferlib.emulation",
        "peekOfCode": "def emulate_observation_space(space):\n    emulated_dtype = dtype_from_space(space)\n    if isinstance(space, pufferlib.spaces.Box):\n        return space, emulated_dtype\n    leaves = flatten_space(space)\n    dtypes = [e.dtype for e in leaves]\n    if dtypes.count(dtypes[0]) == len(dtypes):\n        dtype = dtypes[0]\n    else:\n        dtype = np.dtype(np.uint8)",
        "detail": "deps.pufferlib.pufferlib.emulation",
        "documentation": {}
    },
    {
        "label": "emulate_action_space",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.emulation",
        "description": "deps.pufferlib.pufferlib.emulation",
        "peekOfCode": "def emulate_action_space(space):\n    if isinstance(space, (\n        (pufferlib.spaces.Discrete,\n            pufferlib.spaces.MultiDiscrete, pufferlib.spaces.Box),\n        pufferlib.spaces.MultiDiscrete,\n    )):\n        return space, space.dtype\n    emulated_dtype = dtype_from_space(space)\n    leaves = flatten_space(space)\n    emulated_space = gymnasium.spaces.MultiDiscrete([e.n for e in leaves])",
        "detail": "deps.pufferlib.pufferlib.emulation",
        "documentation": {}
    },
    {
        "label": "pad_agent_data",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.emulation",
        "description": "deps.pufferlib.pufferlib.emulation",
        "peekOfCode": "def pad_agent_data(data, agents, pad_value):\n    return {agent: data[agent] if agent in data else pad_value\n        for agent in agents}\ndef make_object(object_instance=None, object_creator=None, creator_args=[], creator_kwargs={}):\n    if (object_instance is None) == (object_creator is None):\n        raise ValueError('Exactly one of object_instance or object_creator must be provided')\n    if object_instance is not None:\n        if callable(object_instance) or inspect.isclass(object_instance):\n            raise TypeError('object_instance must be an instance, not a function or class')\n        return object_instance",
        "detail": "deps.pufferlib.pufferlib.emulation",
        "documentation": {}
    },
    {
        "label": "make_object",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.emulation",
        "description": "deps.pufferlib.pufferlib.emulation",
        "peekOfCode": "def make_object(object_instance=None, object_creator=None, creator_args=[], creator_kwargs={}):\n    if (object_instance is None) == (object_creator is None):\n        raise ValueError('Exactly one of object_instance or object_creator must be provided')\n    if object_instance is not None:\n        if callable(object_instance) or inspect.isclass(object_instance):\n            raise TypeError('object_instance must be an instance, not a function or class')\n        return object_instance\n    if object_creator is not None:\n        if not callable(object_creator):\n            raise TypeError('object_creator must be a callable')",
        "detail": "deps.pufferlib.pufferlib.emulation",
        "documentation": {}
    },
    {
        "label": "check_space",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.emulation",
        "description": "deps.pufferlib.pufferlib.emulation",
        "peekOfCode": "def check_space(data, space):\n    try:\n        contains = space.contains(data)\n    except:\n        raise exceptions.APIUsageError(\n            f'Error checking space {space} with sample :\\n{data}')\n    if not contains:\n        raise exceptions.APIUsageError(\n            f'Data:\\n{data}\\n not in space:\\n{space}')\n    return True",
        "detail": "deps.pufferlib.pufferlib.emulation",
        "documentation": {}
    },
    {
        "label": "PufferEnv",
        "kind": 6,
        "importPath": "deps.pufferlib.pufferlib.environment",
        "description": "deps.pufferlib.pufferlib.environment",
        "peekOfCode": "class PufferEnv:\n    #@property\n    #def num_agents(self):\n    #    raise NotImplementedError\n    #@property\n    #def observation_space(self):\n    #    raise NotImplementedError\n    #@property\n    #def action_space(self):\n    #    raise NotImplementedError",
        "detail": "deps.pufferlib.pufferlib.environment",
        "documentation": {}
    },
    {
        "label": "EnvironmentSetupError",
        "kind": 6,
        "importPath": "deps.pufferlib.pufferlib.exceptions",
        "description": "deps.pufferlib.pufferlib.exceptions",
        "peekOfCode": "class EnvironmentSetupError(RuntimeError):\n    def __init__(self, e, package):\n        super().__init__(self.message)\nclass APIUsageError(RuntimeError):\n    \"\"\"Exception raised when the API is used incorrectly.\"\"\"\n    def __init__(self, message=\"API usage error.\"):\n        self.message = message\n        super().__init__(self.message)\nclass InvalidAgentError(ValueError):\n    \"\"\"Exception raised when an invalid agent key is used.\"\"\"",
        "detail": "deps.pufferlib.pufferlib.exceptions",
        "documentation": {}
    },
    {
        "label": "APIUsageError",
        "kind": 6,
        "importPath": "deps.pufferlib.pufferlib.exceptions",
        "description": "deps.pufferlib.pufferlib.exceptions",
        "peekOfCode": "class APIUsageError(RuntimeError):\n    \"\"\"Exception raised when the API is used incorrectly.\"\"\"\n    def __init__(self, message=\"API usage error.\"):\n        self.message = message\n        super().__init__(self.message)\nclass InvalidAgentError(ValueError):\n    \"\"\"Exception raised when an invalid agent key is used.\"\"\"\n    def __init__(self, agent_id, agents):\n        message = (\n            f'Invalid agent/team ({agent_id}) specified. '",
        "detail": "deps.pufferlib.pufferlib.exceptions",
        "documentation": {}
    },
    {
        "label": "InvalidAgentError",
        "kind": 6,
        "importPath": "deps.pufferlib.pufferlib.exceptions",
        "description": "deps.pufferlib.pufferlib.exceptions",
        "peekOfCode": "class InvalidAgentError(ValueError):\n    \"\"\"Exception raised when an invalid agent key is used.\"\"\"\n    def __init__(self, agent_id, agents):\n        message = (\n            f'Invalid agent/team ({agent_id}) specified. '\n            f'Valid values:\\n{agents}'\n        )\n        super().__init__(message)",
        "detail": "deps.pufferlib.pufferlib.exceptions",
        "documentation": {}
    },
    {
        "label": "Default",
        "kind": 6,
        "importPath": "deps.pufferlib.pufferlib.models",
        "description": "deps.pufferlib.pufferlib.models",
        "peekOfCode": "class Default(nn.Module):\n    '''Default PyTorch policy. Flattens obs and applies a linear layer.\n    PufferLib is not a framework. It does not enforce a base class.\n    You can use any PyTorch policy that returns actions and values.\n    We structure our forward methods as encode_observations and decode_actions\n    to make it easier to wrap policies with LSTMs. You can do that and use\n    our LSTM wrapper or implement your own. To port an existing policy\n    for use with our LSTM wrapper, simply put everything from forward() before\n    the recurrent cell into encode_observations and put everything after\n    into decode_actions.",
        "detail": "deps.pufferlib.pufferlib.models",
        "documentation": {}
    },
    {
        "label": "LSTMWrapper",
        "kind": 6,
        "importPath": "deps.pufferlib.pufferlib.models",
        "description": "deps.pufferlib.pufferlib.models",
        "peekOfCode": "class LSTMWrapper(nn.Module):\n    def __init__(self, env, policy, input_size=128, hidden_size=128, num_layers=1):\n        '''Wraps your policy with an LSTM without letting you shoot yourself in the\n        foot with bad transpose and shape operations. This saves much pain.\n        Requires that your policy define encode_observations and decode_actions.\n        See the Default policy for an example.'''\n        super().__init__()\n        self.obs_shape = env.single_observation_space.shape\n        self.policy = policy\n        self.input_size = input_size",
        "detail": "deps.pufferlib.pufferlib.models",
        "documentation": {}
    },
    {
        "label": "Convolutional",
        "kind": 6,
        "importPath": "deps.pufferlib.pufferlib.models",
        "description": "deps.pufferlib.pufferlib.models",
        "peekOfCode": "class Convolutional(nn.Module):\n    def __init__(self, env, *args, framestack, flat_size,\n            input_size=512, hidden_size=512, output_size=512,\n            channels_last=False, downsample=1, **kwargs):\n        '''The CleanRL default NatureCNN policy used for Atari.\n        It's just a stack of three convolutions followed by a linear layer\n        Takes framestack as a mandatory keyword argument. Suggested default is 1 frame\n        with LSTM or 4 frames without.'''\n        super().__init__()\n        self.channels_last = channels_last",
        "detail": "deps.pufferlib.pufferlib.models",
        "documentation": {}
    },
    {
        "label": "ProcgenResnet",
        "kind": 6,
        "importPath": "deps.pufferlib.pufferlib.models",
        "description": "deps.pufferlib.pufferlib.models",
        "peekOfCode": "class ProcgenResnet(nn.Module):\n    '''Procgen baseline from the AICrowd NeurIPS 2020 competition\n    Based on the ResNet architecture that was used in the Impala paper.'''\n    def __init__(self, env, cnn_width=16, mlp_width=256):\n        super().__init__()\n        h, w, c = env.single_observation_space.shape\n        shape = (c, h, w)\n        conv_seqs = []\n        for out_channels in [cnn_width, 2*cnn_width, 2*cnn_width]:\n            conv_seq = ConvSequence(shape, out_channels)",
        "detail": "deps.pufferlib.pufferlib.models",
        "documentation": {}
    },
    {
        "label": "ResidualBlock",
        "kind": 6,
        "importPath": "deps.pufferlib.pufferlib.models",
        "description": "deps.pufferlib.pufferlib.models",
        "peekOfCode": "class ResidualBlock(nn.Module):\n    def __init__(self, channels):\n        super().__init__()\n        self.conv0 = nn.Conv2d(in_channels=channels, out_channels=channels, kernel_size=3, padding=1)\n        self.conv1 = nn.Conv2d(in_channels=channels, out_channels=channels, kernel_size=3, padding=1)\n    def forward(self, x):\n        inputs = x\n        x = nn.functional.relu(x)\n        x = self.conv0(x)\n        x = nn.functional.relu(x)",
        "detail": "deps.pufferlib.pufferlib.models",
        "documentation": {}
    },
    {
        "label": "ConvSequence",
        "kind": 6,
        "importPath": "deps.pufferlib.pufferlib.models",
        "description": "deps.pufferlib.pufferlib.models",
        "peekOfCode": "class ConvSequence(nn.Module):\n    def __init__(self, input_shape, out_channels):\n        super().__init__()\n        self._input_shape = input_shape\n        self._out_channels = out_channels\n        self.conv = nn.Conv2d(in_channels=self._input_shape[0], out_channels=self._out_channels, kernel_size=3, padding=1)\n        self.res_block0 = ResidualBlock(self._out_channels)\n        self.res_block1 = ResidualBlock(self._out_channels)\n    def forward(self, x):\n        x = self.conv(x)",
        "detail": "deps.pufferlib.pufferlib.models",
        "documentation": {}
    },
    {
        "label": "PufferEnvWrapper",
        "kind": 6,
        "importPath": "deps.pufferlib.pufferlib.multi_env",
        "description": "deps.pufferlib.pufferlib.multi_env",
        "peekOfCode": "class PufferEnvWrapper(pufferlib.environment.PufferEnv):\n    def __init__(self, env_creator: callable = None, env_args: list = [],\n            env_kwargs: dict = {}, n: int = 1, obs_mem=None, rew_mem=None, done_mem=None, trunc_mem=None, mask_mem=None):\n        if n < 1:\n            raise pufferlib.exceptions.APIUsageError('n (environments) must be at least 1')\n        envs = [env_creator(*env_args, **env_kwargs) for _ in range(n)]\n        self.envs = envs\n        # Check that all envs are either Gymnasium or PettingZoo\n        is_gymnasium = all(isinstance(e, pufferlib.emulation.GymnasiumPufferEnv) for e in envs)\n        is_pettingzoo = all(isinstance(e, pufferlib.emulation.PettingZooPufferEnv) for e in envs)",
        "detail": "deps.pufferlib.pufferlib.multi_env",
        "documentation": {}
    },
    {
        "label": "Namespace",
        "kind": 6,
        "importPath": "deps.pufferlib.pufferlib.namespace",
        "description": "deps.pufferlib.pufferlib.namespace",
        "peekOfCode": "class Namespace(SimpleNamespace, Mapping):\n    __getitem__ = __getitem__\n    __iter__ = __iter__\n    __len__ = __len__\n    keys = keys\n    values = values\n    items = items\ndef dataclass(cls):\n    # Safely get annotations\n    annotations = getattr(cls, '__annotations__', {})",
        "detail": "deps.pufferlib.pufferlib.namespace",
        "documentation": {}
    },
    {
        "label": "keys",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.namespace",
        "description": "deps.pufferlib.pufferlib.namespace",
        "peekOfCode": "def keys(self):\n    return self.__dict__.keys()\ndef values(self):\n    return self.__dict__.values()\ndef items(self):\n    return self.__dict__.items()\ndef __iter__(self):\n    return iter(self.__dict__)\ndef __len__(self):\n    return len(self.__dict__)",
        "detail": "deps.pufferlib.pufferlib.namespace",
        "documentation": {}
    },
    {
        "label": "values",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.namespace",
        "description": "deps.pufferlib.pufferlib.namespace",
        "peekOfCode": "def values(self):\n    return self.__dict__.values()\ndef items(self):\n    return self.__dict__.items()\ndef __iter__(self):\n    return iter(self.__dict__)\ndef __len__(self):\n    return len(self.__dict__)\nclass Namespace(SimpleNamespace, Mapping):\n    __getitem__ = __getitem__",
        "detail": "deps.pufferlib.pufferlib.namespace",
        "documentation": {}
    },
    {
        "label": "items",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.namespace",
        "description": "deps.pufferlib.pufferlib.namespace",
        "peekOfCode": "def items(self):\n    return self.__dict__.items()\ndef __iter__(self):\n    return iter(self.__dict__)\ndef __len__(self):\n    return len(self.__dict__)\nclass Namespace(SimpleNamespace, Mapping):\n    __getitem__ = __getitem__\n    __iter__ = __iter__\n    __len__ = __len__",
        "detail": "deps.pufferlib.pufferlib.namespace",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.namespace",
        "description": "deps.pufferlib.pufferlib.namespace",
        "peekOfCode": "def dataclass(cls):\n    # Safely get annotations\n    annotations = getattr(cls, '__annotations__', {})\n    # Combine both annotated and non-annotated fields\n    all_fields = {**{k: None for k in annotations.keys()}, **cls.__dict__}\n    all_fields = {k: v for k, v in all_fields.items() if not callable(v) and not k.startswith('__')}\n    def __init__(self, **kwargs):\n        for field, default_value in all_fields.items():\n            setattr(self, field, kwargs.get(field, default_value))\n    cls.__init__ = __init__",
        "detail": "deps.pufferlib.pufferlib.namespace",
        "documentation": {}
    },
    {
        "label": "namespace",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.namespace",
        "description": "deps.pufferlib.pufferlib.namespace",
        "peekOfCode": "def namespace(self=None, **kwargs):\n    if self is None:\n        return Namespace(**kwargs)\n    self.__dict__.update(kwargs)",
        "detail": "deps.pufferlib.pufferlib.namespace",
        "documentation": {}
    },
    {
        "label": "Ranker",
        "kind": 6,
        "importPath": "deps.pufferlib.pufferlib.policy_ranker",
        "description": "deps.pufferlib.pufferlib.policy_ranker",
        "peekOfCode": "class Ranker:\n    def __init__(self, db_path):\n        self.conn = sqlite3.connect(db_path)\n        with self.conn:\n            self.conn.execute(\"\"\"\n                CREATE TABLE IF NOT EXISTS ratings (\n                    policy TEXT PRIMARY KEY,\n                    elo REAL\n                );\n            \"\"\")",
        "detail": "deps.pufferlib.pufferlib.policy_ranker",
        "documentation": {}
    },
    {
        "label": "win_prob",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.policy_ranker",
        "description": "deps.pufferlib.pufferlib.policy_ranker",
        "peekOfCode": "def win_prob(elo1, elo2):\n    '''Calculate win probability such that a difference of\n    50/100/150 elo corresponds to win probabilitit 68/95/99.7%'''\n    return 1 / (1 + 10 ** ((elo2 - elo1) / 400))\ndef update_elos(elos: np.ndarray, scores: np.ndarray, k: float = 4.0):\n    '''Update elos based on the result of a game\n    The parameter k controls the magnitude of the update.\n    A higher k means that the elo will change more after a game.\n    This means that elos will converge faster but less precisely.\n    In particular, low k cannot distinguish between players of",
        "detail": "deps.pufferlib.pufferlib.policy_ranker",
        "documentation": {}
    },
    {
        "label": "update_elos",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.policy_ranker",
        "description": "deps.pufferlib.pufferlib.policy_ranker",
        "peekOfCode": "def update_elos(elos: np.ndarray, scores: np.ndarray, k: float = 4.0):\n    '''Update elos based on the result of a game\n    The parameter k controls the magnitude of the update.\n    A higher k means that the elo will change more after a game.\n    This means that elos will converge faster but less precisely.\n    In particular, low k cannot distinguish between players of\n    similar skill, while a high k will just take longer to converge.\n    The default is tuned for normally distributed player skill\n    You should lower it if you have very similar players.\n    Raise it if you are evaluating a diverse skill pool.",
        "detail": "deps.pufferlib.pufferlib.policy_ranker",
        "documentation": {}
    },
    {
        "label": "ANCHOR_ELO",
        "kind": 5,
        "importPath": "deps.pufferlib.pufferlib.policy_ranker",
        "description": "deps.pufferlib.pufferlib.policy_ranker",
        "peekOfCode": "ANCHOR_ELO = 1000.0\ndef win_prob(elo1, elo2):\n    '''Calculate win probability such that a difference of\n    50/100/150 elo corresponds to win probabilitit 68/95/99.7%'''\n    return 1 / (1 + 10 ** ((elo2 - elo1) / 400))\ndef update_elos(elos: np.ndarray, scores: np.ndarray, k: float = 4.0):\n    '''Update elos based on the result of a game\n    The parameter k controls the magnitude of the update.\n    A higher k means that the elo will change more after a game.\n    This means that elos will converge faster but less precisely.",
        "detail": "deps.pufferlib.pufferlib.policy_ranker",
        "documentation": {}
    },
    {
        "label": "PolicyStore",
        "kind": 6,
        "importPath": "deps.pufferlib.pufferlib.policy_store",
        "description": "deps.pufferlib.pufferlib.policy_store",
        "peekOfCode": "class PolicyStore:\n    def __init__(self, path: str):\n        self.path = path\n    def policy_names(self) -> list:\n        return get_policy_names(self.path)\n    def get_policy(self, name: str) -> torch.nn.Module:\n        path = os.path.join(self.path, name + '.pt')\n        try:\n            return torch.load(path)\n        except:",
        "detail": "deps.pufferlib.pufferlib.policy_store",
        "documentation": {}
    },
    {
        "label": "get_policy_names",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.policy_store",
        "description": "deps.pufferlib.pufferlib.policy_store",
        "peekOfCode": "def get_policy_names(path: str) -> list:\n    # Assumeing that all pt files other than trainer_state.pt in the path are policy files\n    names = []\n    for file in os.listdir(path):\n        if file.endswith(\".pt\") and file != 'trainer_state.pt':\n            names.append(file[:-3])\n    return sorted(names)\nclass PolicyStore:\n    def __init__(self, path: str):\n        self.path = path",
        "detail": "deps.pufferlib.pufferlib.policy_store",
        "documentation": {}
    },
    {
        "label": "ResizeObservation",
        "kind": 6,
        "importPath": "deps.pufferlib.pufferlib.postprocess",
        "description": "deps.pufferlib.pufferlib.postprocess",
        "peekOfCode": "class ResizeObservation(gymnasium.Wrapper):\n    '''Fixed downscaling wrapper. Do NOT use gym.wrappers.ResizeObservation\n    It uses a laughably slow OpenCV resize. -50% on Atari just from that.'''\n    def __init__(self, env, downscale=2):\n        super().__init__(env)\n        self.downscale = downscale\n        y_size, x_size = env.observation_space.shape\n        assert y_size % downscale == 0 and x_size % downscale == 0\n        y_size = env.observation_space.shape[0] // downscale\n        x_size = env.observation_space.shape[1] // downscale",
        "detail": "deps.pufferlib.pufferlib.postprocess",
        "documentation": {}
    },
    {
        "label": "ClipAction",
        "kind": 6,
        "importPath": "deps.pufferlib.pufferlib.postprocess",
        "description": "deps.pufferlib.pufferlib.postprocess",
        "peekOfCode": "class ClipAction(gymnasium.Wrapper):\n    '''Wrapper for Gymnasium environments that clips actions'''\n    def __init__(self, env):\n        self.env = env\n        assert isinstance(env.action_space, gymnasium.spaces.Box)\n        dtype_info = np.finfo(env.action_space.dtype)\n        self.action_space = gymnasium.spaces.Box(\n            low=dtype_info.min,\n            high=dtype_info.max,\n            shape=env.action_space.shape,",
        "detail": "deps.pufferlib.pufferlib.postprocess",
        "documentation": {}
    },
    {
        "label": "EpisodeStats",
        "kind": 6,
        "importPath": "deps.pufferlib.pufferlib.postprocess",
        "description": "deps.pufferlib.pufferlib.postprocess",
        "peekOfCode": "class EpisodeStats(gymnasium.Wrapper):\n    '''Wrapper for Gymnasium environments that stores\n    episodic returns and lengths in infos'''\n    def __init__(self, env):\n        self.env = env\n        self.observation_space = env.observation_space\n        self.action_space = env.action_space\n        self.reset()\n    def reset(self, seed=None, options=None):\n        self.info = dict(episode_return=[], episode_length=0)",
        "detail": "deps.pufferlib.pufferlib.postprocess",
        "documentation": {}
    },
    {
        "label": "PettingZooWrapper",
        "kind": 6,
        "importPath": "deps.pufferlib.pufferlib.postprocess",
        "description": "deps.pufferlib.pufferlib.postprocess",
        "peekOfCode": "class PettingZooWrapper:\n    '''PettingZoo does not provide a ParallelEnv wrapper. This code is adapted from\n    their AEC wrapper, to prevent unneeded conversions to/from AEC'''\n    def __init__(self, env):\n        self.env = env\n    def __getattr__(self, name):\n        '''Returns an attribute with ``name``, unless ``name`` starts with an underscore.'''\n        if name.startswith('_') and name != '_cumulative_rewards':\n            raise AttributeError(f'accessing private attribute \"{name}\" is prohibited')\n        return getattr(self.env, name)",
        "detail": "deps.pufferlib.pufferlib.postprocess",
        "documentation": {}
    },
    {
        "label": "MeanOverAgents",
        "kind": 6,
        "importPath": "deps.pufferlib.pufferlib.postprocess",
        "description": "deps.pufferlib.pufferlib.postprocess",
        "peekOfCode": "class MeanOverAgents(PettingZooWrapper):\n    '''Averages over agent infos'''\n    def _mean(self, infos):\n        list_infos = {}\n        for agent, info in infos.items():\n            for k, v in info.items():\n                if k not in list_infos:\n                    list_infos[k] = []\n                list_infos[k].append(v)\n        mean_infos = {}",
        "detail": "deps.pufferlib.pufferlib.postprocess",
        "documentation": {}
    },
    {
        "label": "MultiagentEpisodeStats",
        "kind": 6,
        "importPath": "deps.pufferlib.pufferlib.postprocess",
        "description": "deps.pufferlib.pufferlib.postprocess",
        "peekOfCode": "class MultiagentEpisodeStats(PettingZooWrapper):\n    '''Wrapper for PettingZoo environments that stores\n    episodic returns and lengths in infos'''\n    def reset(self, seed=None, options=None):\n        observations, infos = super().reset(seed=seed, options=options)\n        self.infos = {\n            agent: dict(episode_return=[], episode_length=0)\n            for agent in self.possible_agents\n        }\n        return observations, infos",
        "detail": "deps.pufferlib.pufferlib.postprocess",
        "documentation": {}
    },
    {
        "label": "BatchFirstLSTM",
        "kind": 6,
        "importPath": "deps.pufferlib.pufferlib.pytorch",
        "description": "deps.pufferlib.pufferlib.pytorch",
        "peekOfCode": "class BatchFirstLSTM(nn.LSTM):\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, batch_first=True, **kwargs)\n    def forward(self, input, hx):\n        \"\"\"\n        input: B x T x H\n        h&c: B x T x H\n        \"\"\"\n        h, c = hx\n        h = h.transpose(0, 1)",
        "detail": "deps.pufferlib.pufferlib.pytorch",
        "documentation": {}
    },
    {
        "label": "LSTM",
        "kind": 6,
        "importPath": "deps.pufferlib.pufferlib.pytorch",
        "description": "deps.pufferlib.pufferlib.pytorch",
        "peekOfCode": "class LSTM(nn.LSTM):\n    def __init__(self, input_size=128, hidden_size=128, num_layers=1):\n        super().__init__(input_size, hidden_size, num_layers)\n        layer_init(self)\ndef cycle_selector(sample_idx, num_policies):\n    return sample_idx % num_policies\nclass PolicyPool(torch.nn.Module):\n    def __init__(self, vecenv, policies, learner_mask, device,\n            policy_selector=cycle_selector):\n        '''Experimental utility for running multiple different policies'''",
        "detail": "deps.pufferlib.pufferlib.pytorch",
        "documentation": {}
    },
    {
        "label": "PolicyPool",
        "kind": 6,
        "importPath": "deps.pufferlib.pufferlib.pytorch",
        "description": "deps.pufferlib.pufferlib.pytorch",
        "peekOfCode": "class PolicyPool(torch.nn.Module):\n    def __init__(self, vecenv, policies, learner_mask, device,\n            policy_selector=cycle_selector):\n        '''Experimental utility for running multiple different policies'''\n        super().__init__()\n        assert len(learner_mask) == len(policies)\n        self.policy_map = torch.tensor([policy_selector(i, len(policies))\n            for i in range(vecenv.num_agents)])\n        self.learner_mask = learner_mask\n        self.policies = torch.nn.ModuleList(policies)",
        "detail": "deps.pufferlib.pufferlib.pytorch",
        "documentation": {}
    },
    {
        "label": "nativize_dtype",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.pytorch",
        "description": "deps.pufferlib.pufferlib.pytorch",
        "peekOfCode": "def nativize_dtype(emulated: pufferlib.namespace) -> NativeDType:\n    # sample dtype - the dtype of what we obtain from the environment (usually bytes)\n    sample_dtype: np.dtype = emulated.observation_dtype\n    # structured dtype - the gym.Space converted numpy dtype\n    # the observation represents (could be dict, tuple, box, etc.)\n    structured_dtype: np.dtype = emulated.emulated_observation_dtype\n    subviews, dtype, shape, offset, delta = _nativize_dtype(sample_dtype, structured_dtype)\n    if subviews is None:\n        return (dtype, shape, offset, delta)\n    else:",
        "detail": "deps.pufferlib.pufferlib.pytorch",
        "documentation": {}
    },
    {
        "label": "round_to",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.pytorch",
        "description": "deps.pufferlib.pufferlib.pytorch",
        "peekOfCode": "def round_to(x, base):\n    return int(base * np.ceil(x/base))\ndef _nativize_dtype(sample_dtype: np.dtype,\n        structured_dtype: np.dtype,\n        offset: int = 0) -> NativeDType:\n    if structured_dtype.fields is None:\n        if structured_dtype.subdtype is not None:\n            dtype, shape = structured_dtype.subdtype\n        else:\n            dtype = structured_dtype",
        "detail": "deps.pufferlib.pufferlib.pytorch",
        "documentation": {}
    },
    {
        "label": "nativize_tensor",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.pytorch",
        "description": "deps.pufferlib.pufferlib.pytorch",
        "peekOfCode": "def nativize_tensor(\n    observation: torch.Tensor,\n    native_dtype: NativeDType,\n) -> torch.Tensor | dict[str, torch.Tensor]:\n    return _nativize_tensor(observation, native_dtype)\n# torch.view(dtype) does not compile\n# This is a workaround hack\n# @thatguy - can you figure out a more robust way to handle cast?\n# I think it may screw up for non-uint data... so I put a hard .view\n# fallback that breaks compile",
        "detail": "deps.pufferlib.pufferlib.pytorch",
        "documentation": {}
    },
    {
        "label": "compilable_cast",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.pytorch",
        "description": "deps.pufferlib.pufferlib.pytorch",
        "peekOfCode": "def compilable_cast(u8, dtype):\n    if dtype in (torch.uint8, torch.uint16, torch.uint32, torch.uint64):\n        n = dtype.itemsize\n        bytes = [u8[..., i::n].to(dtype) for i in range(n)]\n        if not LITTLE_BYTE_ORDER:\n            bytes = bytes[::-1]\n        bytes = sum(bytes[i] << (i * 8) for i in range(n))\n        return bytes.view(dtype)\n    return u8.view(dtype)  # breaking cast\ndef _nativize_tensor(",
        "detail": "deps.pufferlib.pufferlib.pytorch",
        "documentation": {}
    },
    {
        "label": "nativize_observation",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.pytorch",
        "description": "deps.pufferlib.pufferlib.pytorch",
        "peekOfCode": "def nativize_observation(observation, emulated):\n    # TODO: Any way to check that user has not accidentally cast data to float?\n    # float is natively supported, but only if that is the actual correct type\n    return nativize_tensor(\n        observation,\n        emulated.observation_dtype,\n        emulated.emulated_observation_dtype,\n    )\ndef flattened_tensor_size(native_dtype: tuple[torch.dtype, tuple[int], int, int]):\n    return _flattened_tensor_size(native_dtype)",
        "detail": "deps.pufferlib.pufferlib.pytorch",
        "documentation": {}
    },
    {
        "label": "flattened_tensor_size",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.pytorch",
        "description": "deps.pufferlib.pufferlib.pytorch",
        "peekOfCode": "def flattened_tensor_size(native_dtype: tuple[torch.dtype, tuple[int], int, int]):\n    return _flattened_tensor_size(native_dtype)\ndef _flattened_tensor_size(\n    native_dtype: tuple[torch.dtype, tuple[int], int, int],\n) -> int:\n    if isinstance(native_dtype, tuple):\n        return np.prod(native_dtype[1])  # shape\n    else:\n        res = 0\n        for _, dtype in native_dtype.items():",
        "detail": "deps.pufferlib.pufferlib.pytorch",
        "documentation": {}
    },
    {
        "label": "layer_init",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.pytorch",
        "description": "deps.pufferlib.pufferlib.pytorch",
        "peekOfCode": "def layer_init(layer, std=np.sqrt(2), bias_const=0.0):\n    \"\"\"CleanRL's default layer initialization\"\"\"\n    torch.nn.init.orthogonal_(layer.weight, std)\n    torch.nn.init.constant_(layer.bias, bias_const)\n    return layer\nclass LSTM(nn.LSTM):\n    def __init__(self, input_size=128, hidden_size=128, num_layers=1):\n        super().__init__(input_size, hidden_size, num_layers)\n        layer_init(self)\ndef cycle_selector(sample_idx, num_policies):",
        "detail": "deps.pufferlib.pufferlib.pytorch",
        "documentation": {}
    },
    {
        "label": "cycle_selector",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.pytorch",
        "description": "deps.pufferlib.pufferlib.pytorch",
        "peekOfCode": "def cycle_selector(sample_idx, num_policies):\n    return sample_idx % num_policies\nclass PolicyPool(torch.nn.Module):\n    def __init__(self, vecenv, policies, learner_mask, device,\n            policy_selector=cycle_selector):\n        '''Experimental utility for running multiple different policies'''\n        super().__init__()\n        assert len(learner_mask) == len(policies)\n        self.policy_map = torch.tensor([policy_selector(i, len(policies))\n            for i in range(vecenv.num_agents)])",
        "detail": "deps.pufferlib.pufferlib.pytorch",
        "documentation": {}
    },
    {
        "label": "numpy_to_torch_dtype_dict",
        "kind": 5,
        "importPath": "deps.pufferlib.pufferlib.pytorch",
        "description": "deps.pufferlib.pufferlib.pytorch",
        "peekOfCode": "numpy_to_torch_dtype_dict = {\n    np.dtype(\"float64\"): torch.float64,\n    np.dtype(\"float32\"): torch.float32,\n    np.dtype(\"float16\"): torch.float16,\n    np.dtype(\"uint64\"): torch.uint64,\n    np.dtype(\"uint32\"): torch.uint32,\n    np.dtype(\"uint16\"): torch.uint16,\n    np.dtype(\"uint8\"): torch.uint8,\n    np.dtype(\"int64\"): torch.int64,\n    np.dtype(\"int32\"): torch.int32,",
        "detail": "deps.pufferlib.pufferlib.pytorch",
        "documentation": {}
    },
    {
        "label": "LITTLE_BYTE_ORDER",
        "kind": 5,
        "importPath": "deps.pufferlib.pufferlib.pytorch",
        "description": "deps.pufferlib.pufferlib.pytorch",
        "peekOfCode": "LITTLE_BYTE_ORDER = sys.byteorder == \"little\"\n# USER NOTE: You should not get any errors in nativize.\n# This is a complicated piece of code that attempts to convert\n# flat bytes to structured tensors without breaking torch.compile.\n# If you hit any errors, please post on discord.gg/puffer\n# One exception: make sure you didn't change the dtype of your data\n# ie by doing torch.Tensor(data) instead of torch.from_numpy(data)\n# dtype of the tensor\n# shape of the tensor\n# starting element of the observation",
        "detail": "deps.pufferlib.pufferlib.pytorch",
        "documentation": {}
    },
    {
        "label": "NativeDTypeValue",
        "kind": 5,
        "importPath": "deps.pufferlib.pufferlib.pytorch",
        "description": "deps.pufferlib.pufferlib.pytorch",
        "peekOfCode": "NativeDTypeValue = Tuple[torch.dtype, List[int], int, int]\nNativeDType = Union[NativeDTypeValue, Dict[str, Union[NativeDTypeValue, \"NativeDType\"]]]\n# TODO: handle discrete obs\n# Spend some time trying to break this fn with differnt obs\ndef nativize_dtype(emulated: pufferlib.namespace) -> NativeDType:\n    # sample dtype - the dtype of what we obtain from the environment (usually bytes)\n    sample_dtype: np.dtype = emulated.observation_dtype\n    # structured dtype - the gym.Space converted numpy dtype\n    # the observation represents (could be dict, tuple, box, etc.)\n    structured_dtype: np.dtype = emulated.emulated_observation_dtype",
        "detail": "deps.pufferlib.pufferlib.pytorch",
        "documentation": {}
    },
    {
        "label": "NativeDType",
        "kind": 5,
        "importPath": "deps.pufferlib.pufferlib.pytorch",
        "description": "deps.pufferlib.pufferlib.pytorch",
        "peekOfCode": "NativeDType = Union[NativeDTypeValue, Dict[str, Union[NativeDTypeValue, \"NativeDType\"]]]\n# TODO: handle discrete obs\n# Spend some time trying to break this fn with differnt obs\ndef nativize_dtype(emulated: pufferlib.namespace) -> NativeDType:\n    # sample dtype - the dtype of what we obtain from the environment (usually bytes)\n    sample_dtype: np.dtype = emulated.observation_dtype\n    # structured dtype - the gym.Space converted numpy dtype\n    # the observation represents (could be dict, tuple, box, etc.)\n    structured_dtype: np.dtype = emulated.emulated_observation_dtype\n    subviews, dtype, shape, offset, delta = _nativize_dtype(sample_dtype, structured_dtype)",
        "detail": "deps.pufferlib.pufferlib.pytorch",
        "documentation": {}
    },
    {
        "label": "SharedMemory",
        "kind": 6,
        "importPath": "deps.pufferlib.pufferlib.shared_memory",
        "description": "deps.pufferlib.pufferlib.shared_memory",
        "peekOfCode": "class SharedMemory:\n    \"\"\"Creates a new shared memory block or attaches to an existing\n    shared memory block.\n    Every shared memory block is assigned a unique name.  This enables\n    one process to create a shared memory block with a particular name\n    so that a different process can attach to that same shared memory\n    block using that same name.\n    As a resource for sharing data across processes, shared memory blocks\n    may outlive the original process that created them.  When one process\n    no longer needs access to a shared memory block that might still be",
        "detail": "deps.pufferlib.pufferlib.shared_memory",
        "documentation": {}
    },
    {
        "label": "_O_CREX",
        "kind": 5,
        "importPath": "deps.pufferlib.pufferlib.shared_memory",
        "description": "deps.pufferlib.pufferlib.shared_memory",
        "peekOfCode": "_O_CREX = os.O_CREAT | os.O_EXCL\n# FreeBSD (and perhaps other BSDs) limit names to 14 characters.\n_SHM_SAFE_NAME_LENGTH = 14\n# Shared memory block name prefix\nif _USE_POSIX:\n    _SHM_NAME_PREFIX = '/psm_'\nelse:\n    _SHM_NAME_PREFIX = 'wnsm_'\ndef _make_filename():\n    \"Create a random filename for the shared memory object.\"",
        "detail": "deps.pufferlib.pufferlib.shared_memory",
        "documentation": {}
    },
    {
        "label": "_SHM_SAFE_NAME_LENGTH",
        "kind": 5,
        "importPath": "deps.pufferlib.pufferlib.shared_memory",
        "description": "deps.pufferlib.pufferlib.shared_memory",
        "peekOfCode": "_SHM_SAFE_NAME_LENGTH = 14\n# Shared memory block name prefix\nif _USE_POSIX:\n    _SHM_NAME_PREFIX = '/psm_'\nelse:\n    _SHM_NAME_PREFIX = 'wnsm_'\ndef _make_filename():\n    \"Create a random filename for the shared memory object.\"\n    # number of random bytes to use for name\n    nbytes = (_SHM_SAFE_NAME_LENGTH - len(_SHM_NAME_PREFIX)) // 2",
        "detail": "deps.pufferlib.pufferlib.shared_memory",
        "documentation": {}
    },
    {
        "label": "Box",
        "kind": 5,
        "importPath": "deps.pufferlib.pufferlib.spaces",
        "description": "deps.pufferlib.pufferlib.spaces",
        "peekOfCode": "Box = (gym.spaces.Box, gymnasium.spaces.Box)\nDict = (gym.spaces.Dict, gymnasium.spaces.Dict)\nDiscrete = (gym.spaces.Discrete, gymnasium.spaces.Discrete)\nMultiBinary = (gym.spaces.MultiBinary, gymnasium.spaces.MultiBinary)\nMultiDiscrete = (gym.spaces.MultiDiscrete, gymnasium.spaces.MultiDiscrete)\nTuple = (gym.spaces.Tuple, gymnasium.spaces.Tuple)",
        "detail": "deps.pufferlib.pufferlib.spaces",
        "documentation": {}
    },
    {
        "label": "Dict",
        "kind": 5,
        "importPath": "deps.pufferlib.pufferlib.spaces",
        "description": "deps.pufferlib.pufferlib.spaces",
        "peekOfCode": "Dict = (gym.spaces.Dict, gymnasium.spaces.Dict)\nDiscrete = (gym.spaces.Discrete, gymnasium.spaces.Discrete)\nMultiBinary = (gym.spaces.MultiBinary, gymnasium.spaces.MultiBinary)\nMultiDiscrete = (gym.spaces.MultiDiscrete, gymnasium.spaces.MultiDiscrete)\nTuple = (gym.spaces.Tuple, gymnasium.spaces.Tuple)",
        "detail": "deps.pufferlib.pufferlib.spaces",
        "documentation": {}
    },
    {
        "label": "Discrete",
        "kind": 5,
        "importPath": "deps.pufferlib.pufferlib.spaces",
        "description": "deps.pufferlib.pufferlib.spaces",
        "peekOfCode": "Discrete = (gym.spaces.Discrete, gymnasium.spaces.Discrete)\nMultiBinary = (gym.spaces.MultiBinary, gymnasium.spaces.MultiBinary)\nMultiDiscrete = (gym.spaces.MultiDiscrete, gymnasium.spaces.MultiDiscrete)\nTuple = (gym.spaces.Tuple, gymnasium.spaces.Tuple)",
        "detail": "deps.pufferlib.pufferlib.spaces",
        "documentation": {}
    },
    {
        "label": "MultiBinary",
        "kind": 5,
        "importPath": "deps.pufferlib.pufferlib.spaces",
        "description": "deps.pufferlib.pufferlib.spaces",
        "peekOfCode": "MultiBinary = (gym.spaces.MultiBinary, gymnasium.spaces.MultiBinary)\nMultiDiscrete = (gym.spaces.MultiDiscrete, gymnasium.spaces.MultiDiscrete)\nTuple = (gym.spaces.Tuple, gymnasium.spaces.Tuple)",
        "detail": "deps.pufferlib.pufferlib.spaces",
        "documentation": {}
    },
    {
        "label": "MultiDiscrete",
        "kind": 5,
        "importPath": "deps.pufferlib.pufferlib.spaces",
        "description": "deps.pufferlib.pufferlib.spaces",
        "peekOfCode": "MultiDiscrete = (gym.spaces.MultiDiscrete, gymnasium.spaces.MultiDiscrete)\nTuple = (gym.spaces.Tuple, gymnasium.spaces.Tuple)",
        "detail": "deps.pufferlib.pufferlib.spaces",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "kind": 5,
        "importPath": "deps.pufferlib.pufferlib.spaces",
        "description": "deps.pufferlib.pufferlib.spaces",
        "peekOfCode": "Tuple = (gym.spaces.Tuple, gymnasium.spaces.Tuple)",
        "detail": "deps.pufferlib.pufferlib.spaces",
        "documentation": {}
    },
    {
        "label": "RandomState",
        "kind": 6,
        "importPath": "deps.pufferlib.pufferlib.utils",
        "description": "deps.pufferlib.pufferlib.utils",
        "peekOfCode": "class RandomState:\n    def __init__(self, seed):\n        self.rng = np.random.RandomState(seed)\n    def random(self):\n        return self.rng.random()\n    def probabilistic_round(self, n):\n            frac, integer = np.modf(n)\n            if self.random() < frac:\n                return int(integer) + 1\n            else:",
        "detail": "deps.pufferlib.pufferlib.utils",
        "documentation": {}
    },
    {
        "label": "Profiler",
        "kind": 6,
        "importPath": "deps.pufferlib.pufferlib.utils",
        "description": "deps.pufferlib.pufferlib.utils",
        "peekOfCode": "class Profiler:\n    def __init__(self, elapsed=True, calls=True, memory=False, pytorch_memory=False):\n        self.elapsed = 0 if elapsed else None\n        self.calls = 0 if calls else None\n        self.memory = None\n        self.pytorch_memory = None\n        self.prev = 0\n        self.track_elapsed = elapsed\n        self.track_calls = calls\n        self.track_memory = memory",
        "detail": "deps.pufferlib.pufferlib.utils",
        "documentation": {}
    },
    {
        "label": "Suppress",
        "kind": 6,
        "importPath": "deps.pufferlib.pufferlib.utils",
        "description": "deps.pufferlib.pufferlib.utils",
        "peekOfCode": "class Suppress():\n    def __init__(self):\n        self.f = StringIO()\n        self.null_1 = os.open(os.devnull, os.O_WRONLY | os.O_TRUNC | os.O_CREAT)\n        self.null_2 = os.open(os.devnull, os.O_WRONLY | os.O_TRUNC | os.O_CREAT)\n    def __enter__(self):\n        # Suppress C library outputs\n        self.orig_stdout = os.dup(1)\n        self.orig_stderr = os.dup(2)\n        os.dup2(self.null_1, 1)",
        "detail": "deps.pufferlib.pufferlib.utils",
        "documentation": {}
    },
    {
        "label": "validate_args",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.utils",
        "description": "deps.pufferlib.pufferlib.utils",
        "peekOfCode": "def validate_args(fn, kwargs):\n    fn_kwargs = get_init_args(fn)\n    for param, val in kwargs.items():\n        if param not in fn_kwargs:\n            raise ValueError(\n                f'Invalid argument\\n{param}\\nto\\n{fn}\\n'\n                f'which takes \\n{fn_kwargs}\\n'\n                f'Double check your config'\n            )\ndef get_init_args(fn):",
        "detail": "deps.pufferlib.pufferlib.utils",
        "documentation": {}
    },
    {
        "label": "get_init_args",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.utils",
        "description": "deps.pufferlib.pufferlib.utils",
        "peekOfCode": "def get_init_args(fn):\n    if fn is None:\n        return {}\n    if isinstance(fn, functools.partial):\n        return fn.keywords\n    sig = inspect.signature(fn)\n    kwargs = {}\n    for name, param in sig.parameters.items():\n        if name in ['env', 'policy']:\n            # Hack to avoid duplicate kwargs",
        "detail": "deps.pufferlib.pufferlib.utils",
        "documentation": {}
    },
    {
        "label": "unroll_nested_dict",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.utils",
        "description": "deps.pufferlib.pufferlib.utils",
        "peekOfCode": "def unroll_nested_dict(d):\n    if not isinstance(d, dict):\n        return d\n    for k, v in d.items():\n        if isinstance(v, dict):\n            for k2, v2 in unroll_nested_dict(v):\n                yield f\"{k}/{k2}\", v2\n        else:\n            yield k, v\ndef install_requirements(env):",
        "detail": "deps.pufferlib.pufferlib.utils",
        "documentation": {}
    },
    {
        "label": "install_requirements",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.utils",
        "description": "deps.pufferlib.pufferlib.utils",
        "peekOfCode": "def install_requirements(env):\n    '''Pip install dependencies for specified environment'''\n    pip_install_cmd = [sys.executable, \"-m\", \"pip\", \"install\", \"-e\" f\".[{env}]\"]\n    proc = subprocess.run(pip_install_cmd, capture_output=True, text=True)\n    if proc.returncode != 0:\n        raise RuntimeError(f\"Error installing requirements: {proc.stderr}\")\ndef install_and_import(package):\n    '''Install and import a package'''\n    try:\n        module = importlib.import_module(package)",
        "detail": "deps.pufferlib.pufferlib.utils",
        "documentation": {}
    },
    {
        "label": "install_and_import",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.utils",
        "description": "deps.pufferlib.pufferlib.utils",
        "peekOfCode": "def install_and_import(package):\n    '''Install and import a package'''\n    try:\n        module = importlib.import_module(package)\n    except ImportError:\n        install_requirements(package)\n        module = importlib.import_module(package)\n    return module\ndef silence_warnings(original_func, category=DeprecationWarning):\n    @wraps(original_func)",
        "detail": "deps.pufferlib.pufferlib.utils",
        "documentation": {}
    },
    {
        "label": "silence_warnings",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.utils",
        "description": "deps.pufferlib.pufferlib.utils",
        "peekOfCode": "def silence_warnings(original_func, category=DeprecationWarning):\n    @wraps(original_func)\n    def wrapper(*args, **kwargs):\n        with warnings.catch_warnings():\n            warnings.simplefilter(\"ignore\", category=category)\n            return original_func(*args, **kwargs)\n    return wrapper\ndef check_env(env):\n    #assert issubclass(env_cls, gym.Env), \"Not a gymnasium env (are you on old gym?)\"\n    assert hasattr(env, 'possible_agents')",
        "detail": "deps.pufferlib.pufferlib.utils",
        "documentation": {}
    },
    {
        "label": "check_env",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.utils",
        "description": "deps.pufferlib.pufferlib.utils",
        "peekOfCode": "def check_env(env):\n    #assert issubclass(env_cls, gym.Env), \"Not a gymnasium env (are you on old gym?)\"\n    assert hasattr(env, 'possible_agents')\n    assert len(env.possible_agents)\n    obs_space = env.observation_space(env.possible_agents[0])\n    atn_space = env.action_space(env.possible_agents[0])\n    for e in env.possible_agents:\n        assert env.observation_space(e) == obs_space, 'All agents must have same obs space'\n        assert env.action_space(e) == atn_space, 'All agents must have same atn space'\ndef make_zeros_like(data):",
        "detail": "deps.pufferlib.pufferlib.utils",
        "documentation": {}
    },
    {
        "label": "make_zeros_like",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.utils",
        "description": "deps.pufferlib.pufferlib.utils",
        "peekOfCode": "def make_zeros_like(data):\n    if isinstance(data, dict):\n        return {k: make_zeros_like(v) for k, v in data.items()}\n    elif isinstance(data, (list, tuple)):\n        return [make_zeros_like(v) for v in data]\n    elif isinstance(data, np.ndarray):\n        return np.zeros_like(data)\n    elif isinstance(data, (int, float)):\n        return 0\n    else:",
        "detail": "deps.pufferlib.pufferlib.utils",
        "documentation": {}
    },
    {
        "label": "compare_arrays",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.utils",
        "description": "deps.pufferlib.pufferlib.utils",
        "peekOfCode": "def compare_arrays(array_1, array_2):\n    assert isinstance(array_1, np.ndarray)\n    assert isinstance(array_2, np.ndarray)\n    assert array_1.shape == array_2.shape\n    return np.allclose(array_1, array_2)\ndef compare_dicts(dict_1, dict_2, idx):\n    assert isinstance(dict_1, (dict, OrderedDict))\n    assert isinstance(dict_2, (dict, OrderedDict))\n    if not all(k in dict_2 for k in dict_1):\n        raise ValueError(\"Keys do not match between dictionaries.\")",
        "detail": "deps.pufferlib.pufferlib.utils",
        "documentation": {}
    },
    {
        "label": "compare_dicts",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.utils",
        "description": "deps.pufferlib.pufferlib.utils",
        "peekOfCode": "def compare_dicts(dict_1, dict_2, idx):\n    assert isinstance(dict_1, (dict, OrderedDict))\n    assert isinstance(dict_2, (dict, OrderedDict))\n    if not all(k in dict_2 for k in dict_1):\n        raise ValueError(\"Keys do not match between dictionaries.\")\n    for k, v in dict_1.items():\n        if not compare_space_samples(v, dict_2[k], idx):\n            return False\n    return True\ndef compare_lists(list_1, list_2, idx):",
        "detail": "deps.pufferlib.pufferlib.utils",
        "documentation": {}
    },
    {
        "label": "compare_lists",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.utils",
        "description": "deps.pufferlib.pufferlib.utils",
        "peekOfCode": "def compare_lists(list_1, list_2, idx):\n    assert isinstance(list_1, (list, tuple))\n    assert isinstance(list_2, (list, tuple))\n    if len(list_1) != len(list_2):\n        raise ValueError(\"Lengths do not match between lists/tuples.\")\n    for v1, v2 in zip(list_1, list_2):\n        if not compare_space_samples(v1, v2, idx):\n            return False\n    return True\ndef compare_space_samples(sample_1, sample_2, sample_2_batch_idx=None):",
        "detail": "deps.pufferlib.pufferlib.utils",
        "documentation": {}
    },
    {
        "label": "compare_space_samples",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.utils",
        "description": "deps.pufferlib.pufferlib.utils",
        "peekOfCode": "def compare_space_samples(sample_1, sample_2, sample_2_batch_idx=None):\n    '''Compare two samples from the same space\n    Optionally, sample_2 may be a batch of samples from the same space\n    concatenated along the first dimension of the leaves. In this case,\n    sample_2_batch_idx specifies which sample to compare.\n    '''\n    if isinstance(sample_1, (dict, OrderedDict)):\n        return compare_dicts(sample_1, sample_2, sample_2_batch_idx)\n    elif isinstance(sample_1, (list, tuple)):\n        return compare_lists(sample_1, sample_2, sample_2_batch_idx)",
        "detail": "deps.pufferlib.pufferlib.utils",
        "documentation": {}
    },
    {
        "label": "is_dict_space",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.utils",
        "description": "deps.pufferlib.pufferlib.utils",
        "peekOfCode": "def is_dict_space(space):\n    # Compatible with gym/gymnasium\n    return type(space).__name__ == 'Dict'\ndef is_multiagent(env):\n    import pettingzoo\n    import gym\n    if inspect.isclass(env):\n        env_cls = env\n    else:\n        env_cls = type(env)",
        "detail": "deps.pufferlib.pufferlib.utils",
        "documentation": {}
    },
    {
        "label": "is_multiagent",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.utils",
        "description": "deps.pufferlib.pufferlib.utils",
        "peekOfCode": "def is_multiagent(env):\n    import pettingzoo\n    import gym\n    if inspect.isclass(env):\n        env_cls = env\n    else:\n        env_cls = type(env)\n    if not issubclass(env_cls, pettingzoo.AECEnv) and not issubclass(env_cls, pettingzoo.ParallelEnv):\n        assert issubclass(env_cls, gym.Env), 'Environment must subclass pettingzoo.AECEnv/ParallelEnv or gym.Env'\n        return False",
        "detail": "deps.pufferlib.pufferlib.utils",
        "documentation": {}
    },
    {
        "label": "current_datetime",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.utils",
        "description": "deps.pufferlib.pufferlib.utils",
        "peekOfCode": "def current_datetime():\n    return time.strftime('%Y-%m-%d_%H-%M-%S', time.localtime())\ndef myprint(d):\n    stack = d.items()\n    while stack:\n        k, v = stack.pop()\n        if isinstance(v, dict):\n            stack.extend(v.iteritems())\n        else:\n            print(\"%s: %s\" % (k, v))",
        "detail": "deps.pufferlib.pufferlib.utils",
        "documentation": {}
    },
    {
        "label": "myprint",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.utils",
        "description": "deps.pufferlib.pufferlib.utils",
        "peekOfCode": "def myprint(d):\n    stack = d.items()\n    while stack:\n        k, v = stack.pop()\n        if isinstance(v, dict):\n            stack.extend(v.iteritems())\n        else:\n            print(\"%s: %s\" % (k, v))\nclass RandomState:\n    def __init__(self, seed):",
        "detail": "deps.pufferlib.pufferlib.utils",
        "documentation": {}
    },
    {
        "label": "format_bytes",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.utils",
        "description": "deps.pufferlib.pufferlib.utils",
        "peekOfCode": "def format_bytes(size):\n    if size >= 1024 ** 4:\n        return f'{size / (1024 ** 4):.2f} TB'\n    elif size >= 1024 ** 3:\n        return f'{size / (1024 ** 3):.2f} GB'\n    elif size >= 1024 ** 2:\n        return f'{size / (1024 ** 2):.2f} MB'\n    elif size >= 1024:\n        return f'{size / 1024:.2f} KB'\n    else:",
        "detail": "deps.pufferlib.pufferlib.utils",
        "documentation": {}
    },
    {
        "label": "profile",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.utils",
        "description": "deps.pufferlib.pufferlib.utils",
        "peekOfCode": "def profile(func):\n    name = func.__name__\n    def wrapper(*args, **kwargs):\n        self = args[0]\n        if not hasattr(self, '_timers'):\n            self._timers = {}\n        if name not in self._timers:\n            self._timers[name] = Profiler()\n        timer = self._timers[name]\n        with timer:",
        "detail": "deps.pufferlib.pufferlib.utils",
        "documentation": {}
    },
    {
        "label": "aggregate_profilers",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.utils",
        "description": "deps.pufferlib.pufferlib.utils",
        "peekOfCode": "def aggregate_profilers(profiler_dicts):\n    merged = {}\n    for key in list(profiler_dicts[0].keys()):\n        merged[key] = Profiler()\n        for prof_dict in profiler_dicts:\n            merged[key].elapsed += prof_dict[key].elapsed\n            merged[key].calls += prof_dict[key].calls\n    return merged\nclass Suppress():\n    def __init__(self):",
        "detail": "deps.pufferlib.pufferlib.utils",
        "documentation": {}
    },
    {
        "label": "Native",
        "kind": 6,
        "importPath": "deps.pufferlib.pufferlib.vector",
        "description": "deps.pufferlib.pufferlib.vector",
        "peekOfCode": "class Native:\n    reset = reset\n    step = step\n    @property\n    def num_envs(self):\n        return self.agents_per_batch\n    def __init__(self, env_creators, env_args, env_kwargs, num_envs, **kwargs):\n        assert len(env_creators) == 1\n        assert num_envs == 1\n        self.envs = env_creators[0](*env_args[0], **env_kwargs[0])",
        "detail": "deps.pufferlib.pufferlib.vector",
        "documentation": {}
    },
    {
        "label": "Serial",
        "kind": 6,
        "importPath": "deps.pufferlib.pufferlib.vector",
        "description": "deps.pufferlib.pufferlib.vector",
        "peekOfCode": "class Serial:\n    reset = reset\n    step = step\n    @property\n    def num_envs(self):\n        return self.agents_per_batch\n    def __init__(self, env_creators, env_args, env_kwargs, num_envs, **kwargs):\n        self.envs = [creator(*args, **kwargs) for (creator, args, kwargs)\n            in zip(env_creators, env_args, env_kwargs)]\n        self.driver_env = driver = self.envs[0]",
        "detail": "deps.pufferlib.pufferlib.vector",
        "documentation": {}
    },
    {
        "label": "Multiprocessing",
        "kind": 6,
        "importPath": "deps.pufferlib.pufferlib.vector",
        "description": "deps.pufferlib.pufferlib.vector",
        "peekOfCode": "class Multiprocessing:\n    '''Runs environments in parallel using multiprocessing\n    Use this vectorization module for most applications\n    '''\n    reset = reset\n    step = step\n    @property\n    def num_envs(self):\n        return self.agents_per_batch\n    def __init__(self, env_creators, env_args, env_kwargs,",
        "detail": "deps.pufferlib.pufferlib.vector",
        "documentation": {}
    },
    {
        "label": "Ray",
        "kind": 6,
        "importPath": "deps.pufferlib.pufferlib.vector",
        "description": "deps.pufferlib.pufferlib.vector",
        "peekOfCode": "class Ray():\n    '''Runs environments in parallel on multiple processes using Ray\n    Use this module for distributed simulation on a cluster.\n    '''\n    reset = reset\n    step = step\n    def __init__(self, env_creators, env_args, env_kwargs, num_envs,\n            num_workers=None, batch_size=None, **kwargs):\n        if batch_size is None:\n            batch_size = num_envs",
        "detail": "deps.pufferlib.pufferlib.vector",
        "documentation": {}
    },
    {
        "label": "recv_precheck",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.vector",
        "description": "deps.pufferlib.pufferlib.vector",
        "peekOfCode": "def recv_precheck(vecenv):\n    if vecenv.flag != RECV:\n        raise APIUsageError('Call reset before stepping')\n    vecenv.flag = SEND\ndef send_precheck(vecenv, actions):\n    if vecenv.flag != SEND:\n        raise APIUsageError('Call (async) reset + recv before sending')\n    actions = np.asarray(actions)\n    if not vecenv.initialized:\n        vecenv.initialized = True",
        "detail": "deps.pufferlib.pufferlib.vector",
        "documentation": {}
    },
    {
        "label": "send_precheck",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.vector",
        "description": "deps.pufferlib.pufferlib.vector",
        "peekOfCode": "def send_precheck(vecenv, actions):\n    if vecenv.flag != SEND:\n        raise APIUsageError('Call (async) reset + recv before sending')\n    actions = np.asarray(actions)\n    if not vecenv.initialized:\n        vecenv.initialized = True\n        if not vecenv.action_space.contains(actions):\n            raise APIUsageError('Actions do not match action space')\n    vecenv.flag = RECV\n    return actions",
        "detail": "deps.pufferlib.pufferlib.vector",
        "documentation": {}
    },
    {
        "label": "reset",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.vector",
        "description": "deps.pufferlib.pufferlib.vector",
        "peekOfCode": "def reset(vecenv, seed=42):\n    vecenv.async_reset(seed)\n    obs, rewards, terminals, truncations, infos, env_ids, masks = vecenv.recv()\n    return obs, infos\ndef step(vecenv, actions):\n    actions = np.asarray(actions)\n    vecenv.send(actions)\n    obs, rewards, terminals, truncations, infos, env_ids, masks = vecenv.recv()\n    return obs, rewards, terminals, truncations, infos # include env_ids or no?\ndef joint_space(space, n):",
        "detail": "deps.pufferlib.pufferlib.vector",
        "documentation": {}
    },
    {
        "label": "step",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.vector",
        "description": "deps.pufferlib.pufferlib.vector",
        "peekOfCode": "def step(vecenv, actions):\n    actions = np.asarray(actions)\n    vecenv.send(actions)\n    obs, rewards, terminals, truncations, infos, env_ids, masks = vecenv.recv()\n    return obs, rewards, terminals, truncations, infos # include env_ids or no?\ndef joint_space(space, n):\n    if isinstance(space, pufferlib.spaces.Discrete):\n        return gymnasium.spaces.MultiDiscrete([space.n] * n)\n    elif isinstance(space, pufferlib.spaces.MultiDiscrete):\n        return gymnasium.spaces.MultiDiscrete(np.repeat(space.nvec[None], n, axis=0))",
        "detail": "deps.pufferlib.pufferlib.vector",
        "documentation": {}
    },
    {
        "label": "joint_space",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.vector",
        "description": "deps.pufferlib.pufferlib.vector",
        "peekOfCode": "def joint_space(space, n):\n    if isinstance(space, pufferlib.spaces.Discrete):\n        return gymnasium.spaces.MultiDiscrete([space.n] * n)\n    elif isinstance(space, pufferlib.spaces.MultiDiscrete):\n        return gymnasium.spaces.MultiDiscrete(np.repeat(space.nvec[None], n, axis=0))\n    elif isinstance(space, pufferlib.spaces.Box):\n        return gymnasium.spaces.Box(\n            low=np.repeat(space.low[None], n, axis=0),\n            high=np.repeat(space.high[None], n, axis=0),\n            shape=(n, *space.shape), dtype=space.dtype)",
        "detail": "deps.pufferlib.pufferlib.vector",
        "documentation": {}
    },
    {
        "label": "make",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.vector",
        "description": "deps.pufferlib.pufferlib.vector",
        "peekOfCode": "def make(env_creator_or_creators, env_args=None, env_kwargs=None, backend=Serial, num_envs=1, **kwargs):\n    if num_envs < 1:\n        raise APIUsageError('num_envs must be at least 1')\n    if num_envs != int(num_envs):\n        raise APIUsageError('num_envs must be an integer')\n    if 'num_workers' in kwargs:\n        num_workers = kwargs['num_workers']\n        # TODO: None?\n        envs_per_worker = num_envs / num_workers\n        if envs_per_worker != int(envs_per_worker):",
        "detail": "deps.pufferlib.pufferlib.vector",
        "documentation": {}
    },
    {
        "label": "make_seeds",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.vector",
        "description": "deps.pufferlib.pufferlib.vector",
        "peekOfCode": "def make_seeds(seed, num_envs):\n    if isinstance(seed, int):\n        return [seed + i for i in range(num_envs)]\n    err = f'seed {seed} must be an integer or a list of integers'\n    if isinstance(seed, (list, tuple)):\n        if len(seed) != num_envs:\n            raise APIUsageError(err)\n        return seed\n    raise APIUsageError(err)\ndef check_envs(envs, driver):",
        "detail": "deps.pufferlib.pufferlib.vector",
        "documentation": {}
    },
    {
        "label": "check_envs",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.vector",
        "description": "deps.pufferlib.pufferlib.vector",
        "peekOfCode": "def check_envs(envs, driver):\n    valid = (PufferEnv, GymnasiumPufferEnv, PettingZooPufferEnv)\n    if not isinstance(driver, valid):\n        raise APIUsageError(f'env_creator must be {valid}')\n    driver_obs = driver.single_observation_space\n    driver_atn = driver.single_action_space\n    for env in envs:\n        if not isinstance(env, valid):\n            raise APIUsageError(f'env_creators must be {valid}')\n        obs_space = env.single_observation_space",
        "detail": "deps.pufferlib.pufferlib.vector",
        "documentation": {}
    },
    {
        "label": "autotune",
        "kind": 2,
        "importPath": "deps.pufferlib.pufferlib.vector",
        "description": "deps.pufferlib.pufferlib.vector",
        "peekOfCode": "def autotune(env_creator, batch_size, max_envs=384, model_forward_s=0.0,\n        max_env_ram_gb=32, max_batch_vram_gb=0.05, time_per_test=5):\n    '''Determine the optimal vectorization parameters for your system'''\n    # TODO: fix multiagent\n    if batch_size is None:\n        raise ValueError('batch_size must not be None')\n    if max_envs < batch_size:\n        raise ValueError('max_envs < min_batch_size')\n    num_cores = psutil.cpu_count(logical=False)\n    idle_ram = psutil.Process().memory_info().rss",
        "detail": "deps.pufferlib.pufferlib.vector",
        "documentation": {}
    },
    {
        "label": "RESET",
        "kind": 5,
        "importPath": "deps.pufferlib.pufferlib.vector",
        "description": "deps.pufferlib.pufferlib.vector",
        "peekOfCode": "RESET = 0\nSTEP = 1\nSEND = 2\nRECV = 3\nCLOSE = 4\nMAIN = 5\nINFO = 6\ndef recv_precheck(vecenv):\n    if vecenv.flag != RECV:\n        raise APIUsageError('Call reset before stepping')",
        "detail": "deps.pufferlib.pufferlib.vector",
        "documentation": {}
    },
    {
        "label": "STEP",
        "kind": 5,
        "importPath": "deps.pufferlib.pufferlib.vector",
        "description": "deps.pufferlib.pufferlib.vector",
        "peekOfCode": "STEP = 1\nSEND = 2\nRECV = 3\nCLOSE = 4\nMAIN = 5\nINFO = 6\ndef recv_precheck(vecenv):\n    if vecenv.flag != RECV:\n        raise APIUsageError('Call reset before stepping')\n    vecenv.flag = SEND",
        "detail": "deps.pufferlib.pufferlib.vector",
        "documentation": {}
    },
    {
        "label": "SEND",
        "kind": 5,
        "importPath": "deps.pufferlib.pufferlib.vector",
        "description": "deps.pufferlib.pufferlib.vector",
        "peekOfCode": "SEND = 2\nRECV = 3\nCLOSE = 4\nMAIN = 5\nINFO = 6\ndef recv_precheck(vecenv):\n    if vecenv.flag != RECV:\n        raise APIUsageError('Call reset before stepping')\n    vecenv.flag = SEND\ndef send_precheck(vecenv, actions):",
        "detail": "deps.pufferlib.pufferlib.vector",
        "documentation": {}
    },
    {
        "label": "RECV",
        "kind": 5,
        "importPath": "deps.pufferlib.pufferlib.vector",
        "description": "deps.pufferlib.pufferlib.vector",
        "peekOfCode": "RECV = 3\nCLOSE = 4\nMAIN = 5\nINFO = 6\ndef recv_precheck(vecenv):\n    if vecenv.flag != RECV:\n        raise APIUsageError('Call reset before stepping')\n    vecenv.flag = SEND\ndef send_precheck(vecenv, actions):\n    if vecenv.flag != SEND:",
        "detail": "deps.pufferlib.pufferlib.vector",
        "documentation": {}
    },
    {
        "label": "CLOSE",
        "kind": 5,
        "importPath": "deps.pufferlib.pufferlib.vector",
        "description": "deps.pufferlib.pufferlib.vector",
        "peekOfCode": "CLOSE = 4\nMAIN = 5\nINFO = 6\ndef recv_precheck(vecenv):\n    if vecenv.flag != RECV:\n        raise APIUsageError('Call reset before stepping')\n    vecenv.flag = SEND\ndef send_precheck(vecenv, actions):\n    if vecenv.flag != SEND:\n        raise APIUsageError('Call (async) reset + recv before sending')",
        "detail": "deps.pufferlib.pufferlib.vector",
        "documentation": {}
    },
    {
        "label": "MAIN",
        "kind": 5,
        "importPath": "deps.pufferlib.pufferlib.vector",
        "description": "deps.pufferlib.pufferlib.vector",
        "peekOfCode": "MAIN = 5\nINFO = 6\ndef recv_precheck(vecenv):\n    if vecenv.flag != RECV:\n        raise APIUsageError('Call reset before stepping')\n    vecenv.flag = SEND\ndef send_precheck(vecenv, actions):\n    if vecenv.flag != SEND:\n        raise APIUsageError('Call (async) reset + recv before sending')\n    actions = np.asarray(actions)",
        "detail": "deps.pufferlib.pufferlib.vector",
        "documentation": {}
    },
    {
        "label": "INFO",
        "kind": 5,
        "importPath": "deps.pufferlib.pufferlib.vector",
        "description": "deps.pufferlib.pufferlib.vector",
        "peekOfCode": "INFO = 6\ndef recv_precheck(vecenv):\n    if vecenv.flag != RECV:\n        raise APIUsageError('Call reset before stepping')\n    vecenv.flag = SEND\ndef send_precheck(vecenv, actions):\n    if vecenv.flag != SEND:\n        raise APIUsageError('Call (async) reset + recv before sending')\n    actions = np.asarray(actions)\n    if not vecenv.initialized:",
        "detail": "deps.pufferlib.pufferlib.vector",
        "documentation": {}
    },
    {
        "label": "__version__",
        "kind": 5,
        "importPath": "deps.pufferlib.pufferlib.version",
        "description": "deps.pufferlib.pufferlib.version",
        "peekOfCode": "__version__ = '1.0.0'",
        "detail": "deps.pufferlib.pufferlib.version",
        "documentation": {}
    },
    {
        "label": "GymToGymnasium",
        "kind": 6,
        "importPath": "deps.pufferlib.pufferlib.wrappers",
        "description": "deps.pufferlib.pufferlib.wrappers",
        "peekOfCode": "class GymToGymnasium:\n    def __init__(self, env):\n        self.env = env\n        self.observation_space = env.observation_space\n        self.action_space = env.action_space\n        self.render = env.render\n        self.metadata = env.metadata\n    def reset(self, seed=None, options=None):\n        if seed is not None:\n            ob = self.env.reset(seed=seed)",
        "detail": "deps.pufferlib.pufferlib.wrappers",
        "documentation": {}
    },
    {
        "label": "PettingZooTruncatedWrapper",
        "kind": 6,
        "importPath": "deps.pufferlib.pufferlib.wrappers",
        "description": "deps.pufferlib.pufferlib.wrappers",
        "peekOfCode": "class PettingZooTruncatedWrapper:\n    def __init__(self, env):\n        self.env = env\n        self.observation_space = env.observation_space\n        self.action_space = env.action_space\n        self.render = env.render\n    @property\n    def render_mode(self):\n        return self.env.render_mode\n    @property",
        "detail": "deps.pufferlib.pufferlib.wrappers",
        "documentation": {}
    },
    {
        "label": "n_bars",
        "kind": 5,
        "importPath": "deps.pufferlib.tests.pool.plot_packing",
        "description": "deps.pufferlib.tests.pool.plot_packing",
        "peekOfCode": "n_bars = 24\nmu = 0.002\nstd = 0.002\nbackground = '#061a1a'\nforground = '#f1f1f1'\n# Sampling from the normal distribution\nbar_heights = mu + np.clip(np.random.normal(mu, std, n_bars), 0, np.inf)\n# Creating the bar chart\nfig = go.Figure(go.Bar(\n    x=[i for i in range(n_bars)],",
        "detail": "deps.pufferlib.tests.pool.plot_packing",
        "documentation": {}
    },
    {
        "label": "mu",
        "kind": 5,
        "importPath": "deps.pufferlib.tests.pool.plot_packing",
        "description": "deps.pufferlib.tests.pool.plot_packing",
        "peekOfCode": "mu = 0.002\nstd = 0.002\nbackground = '#061a1a'\nforground = '#f1f1f1'\n# Sampling from the normal distribution\nbar_heights = mu + np.clip(np.random.normal(mu, std, n_bars), 0, np.inf)\n# Creating the bar chart\nfig = go.Figure(go.Bar(\n    x=[i for i in range(n_bars)],\n    y=bar_heights,",
        "detail": "deps.pufferlib.tests.pool.plot_packing",
        "documentation": {}
    },
    {
        "label": "std",
        "kind": 5,
        "importPath": "deps.pufferlib.tests.pool.plot_packing",
        "description": "deps.pufferlib.tests.pool.plot_packing",
        "peekOfCode": "std = 0.002\nbackground = '#061a1a'\nforground = '#f1f1f1'\n# Sampling from the normal distribution\nbar_heights = mu + np.clip(np.random.normal(mu, std, n_bars), 0, np.inf)\n# Creating the bar chart\nfig = go.Figure(go.Bar(\n    x=[i for i in range(n_bars)],\n    y=bar_heights,\n    marker_line_width=0,",
        "detail": "deps.pufferlib.tests.pool.plot_packing",
        "documentation": {}
    },
    {
        "label": "background",
        "kind": 5,
        "importPath": "deps.pufferlib.tests.pool.plot_packing",
        "description": "deps.pufferlib.tests.pool.plot_packing",
        "peekOfCode": "background = '#061a1a'\nforground = '#f1f1f1'\n# Sampling from the normal distribution\nbar_heights = mu + np.clip(np.random.normal(mu, std, n_bars), 0, np.inf)\n# Creating the bar chart\nfig = go.Figure(go.Bar(\n    x=[i for i in range(n_bars)],\n    y=bar_heights,\n    marker_line_width=0,\n    marker_color=forground,",
        "detail": "deps.pufferlib.tests.pool.plot_packing",
        "documentation": {}
    },
    {
        "label": "forground",
        "kind": 5,
        "importPath": "deps.pufferlib.tests.pool.plot_packing",
        "description": "deps.pufferlib.tests.pool.plot_packing",
        "peekOfCode": "forground = '#f1f1f1'\n# Sampling from the normal distribution\nbar_heights = mu + np.clip(np.random.normal(mu, std, n_bars), 0, np.inf)\n# Creating the bar chart\nfig = go.Figure(go.Bar(\n    x=[i for i in range(n_bars)],\n    y=bar_heights,\n    marker_line_width=0,\n    marker_color=forground,\n))",
        "detail": "deps.pufferlib.tests.pool.plot_packing",
        "documentation": {}
    },
    {
        "label": "bar_heights",
        "kind": 5,
        "importPath": "deps.pufferlib.tests.pool.plot_packing",
        "description": "deps.pufferlib.tests.pool.plot_packing",
        "peekOfCode": "bar_heights = mu + np.clip(np.random.normal(mu, std, n_bars), 0, np.inf)\n# Creating the bar chart\nfig = go.Figure(go.Bar(\n    x=[i for i in range(n_bars)],\n    y=bar_heights,\n    marker_line_width=0,\n    marker_color=forground,\n))\n# Updating the layout\nfig.update_layout({",
        "detail": "deps.pufferlib.tests.pool.plot_packing",
        "documentation": {}
    },
    {
        "label": "fig",
        "kind": 5,
        "importPath": "deps.pufferlib.tests.pool.plot_packing",
        "description": "deps.pufferlib.tests.pool.plot_packing",
        "peekOfCode": "fig = go.Figure(go.Bar(\n    x=[i for i in range(n_bars)],\n    y=bar_heights,\n    marker_line_width=0,\n    marker_color=forground,\n))\n# Updating the layout\nfig.update_layout({\n    'plot_bgcolor': background,\n    'paper_bgcolor': background,",
        "detail": "deps.pufferlib.tests.pool.plot_packing",
        "documentation": {}
    },
    {
        "label": "worker_process",
        "kind": 2,
        "importPath": "deps.pufferlib.tests.pool.test_basic_multprocessing",
        "description": "deps.pufferlib.tests.pool.test_basic_multprocessing",
        "peekOfCode": "def worker_process(envs_per_worker, delay_mean, delay_std, send_pipe, recv_pipe):\n    while True:\n        request = recv_pipe.recv()\n        for _ in range(envs_per_worker):\n            start = time.process_time()\n            idx = 0\n            target_time = delay_mean + delay_std*np.random.randn()\n            while time.process_time() - start < target_time:\n                idx += 1\n        send_pipe.send('end')",
        "detail": "deps.pufferlib.tests.pool.test_basic_multprocessing",
        "documentation": {}
    },
    {
        "label": "test_speed",
        "kind": 2,
        "importPath": "deps.pufferlib.tests.pool.test_basic_multprocessing",
        "description": "deps.pufferlib.tests.pool.test_basic_multprocessing",
        "peekOfCode": "def test_speed(envs_per_worker=1, delay_mean=0.01, delay_std=0.001, num_workers=4, batch_size=4, sync=True, timeout=10):\n    main_send_pipes, work_recv_pipes = zip(*[Pipe() for _ in range(num_workers)])\n    work_send_pipes, main_recv_pipes = zip(*[Pipe() for _ in range(num_workers)])\n    processes = [Process(\n        target=worker_process,\n        args=(envs_per_worker, delay_mean, delay_std, work_send_pipes[i], work_recv_pipes[i]))\n        for i in range(num_workers)]\n    for p in processes:\n        p.start()\n    send_idxs = {i for i in range(num_workers)}",
        "detail": "deps.pufferlib.tests.pool.test_basic_multprocessing",
        "documentation": {}
    },
    {
        "label": "PerformanceEnv",
        "kind": 6,
        "importPath": "deps.pufferlib.tests.pool.test_envpool",
        "description": "deps.pufferlib.tests.pool.test_envpool",
        "peekOfCode": "class PerformanceEnv:\n    def __init__(self, delay_mean, delay_std):\n        np.random.seed(time.time_ns() % 2**32)\n        self.observation_space = gymnasium.spaces.Box(\n            low=-2**20, high=2**20,\n            shape=(1,), dtype=np.float32\n        )\n        self.action_space = gymnasium.spaces.Discrete(2)\n        self.observation = self.observation_space.sample()\n        self.delay_mean = delay_mean",
        "detail": "deps.pufferlib.tests.pool.test_envpool",
        "documentation": {}
    },
    {
        "label": "test_performance",
        "kind": 2,
        "importPath": "deps.pufferlib.tests.pool.test_envpool",
        "description": "deps.pufferlib.tests.pool.test_envpool",
        "peekOfCode": "def test_performance(vectorization, workers, envs_per_worker,\n        delay_mean, delay_std, batch_size=None, timeout=1):\n    def make_env():\n        return pufferlib.emulation.GymnasiumPufferEnv(\n            env_creator=PerformanceEnv, env_args=(delay_mean, delay_std))\n    if batch_size is None:\n        batch_size = workers * envs_per_worker\n    actions = np.array([make_env().action_space.sample() for _ in range(batch_size)])\n    if vectorization in (Serial, Multiprocessing, 'SyncMultiprocessing', 'SyncRay', Ray):\n        synchronous = False",
        "detail": "deps.pufferlib.tests.pool.test_envpool",
        "documentation": {}
    },
    {
        "label": "sweep_performance_tests",
        "kind": 2,
        "importPath": "deps.pufferlib.tests.pool.test_envpool",
        "description": "deps.pufferlib.tests.pool.test_envpool",
        "peekOfCode": "def sweep_performance_tests():\n    backends = (\n        gymnasium.vector.SyncVectorEnv, Serial,\n        gymnasium.vector.AsyncVectorEnv, 'SyncMultiprocessing',\n        Multiprocessing, \n        'SyncRay', Ray,\n    )\n    results = {}\n    delay_means = (1e-2, 1e-2, 1e-3, 1e-3, 1e-4, 1e-4)\n    delay_stds = (1e-3, 1e-2, 1e-4, 1e-3, 1e-5, 1e-4)",
        "detail": "deps.pufferlib.tests.pool.test_envpool",
        "documentation": {}
    },
    {
        "label": "plot_performance_tests",
        "kind": 2,
        "importPath": "deps.pufferlib.tests.pool.test_envpool",
        "description": "deps.pufferlib.tests.pool.test_envpool",
        "peekOfCode": "def plot_performance_tests():\n    data = np.load('envpool_results.npy', allow_pickle=True).item()\n    n_envs = len(data)\n    inner_data = list(data.items())[0][1]\n    n_cores, cores = len(inner_data), list(inner_data.keys())\n    inner_inner_data = list(inner_data.items())[0][1]\n    n_backends, backends = len(inner_inner_data), list(inner_inner_data.keys())\n    from matplotlib import pyplot as plt\n    import matplotlib.colors as mcolors\n    # Create figure and axes",
        "detail": "deps.pufferlib.tests.pool.test_envpool",
        "documentation": {}
    },
    {
        "label": "WORK_ITERATIONS",
        "kind": 5,
        "importPath": "deps.pufferlib.tests.pool.test_envpool",
        "description": "deps.pufferlib.tests.pool.test_envpool",
        "peekOfCode": "WORK_ITERATIONS = 150_000_000\nclass PerformanceEnv:\n    def __init__(self, delay_mean, delay_std):\n        np.random.seed(time.time_ns() % 2**32)\n        self.observation_space = gymnasium.spaces.Box(\n            low=-2**20, high=2**20,\n            shape=(1,), dtype=np.float32\n        )\n        self.action_space = gymnasium.spaces.Discrete(2)\n        self.observation = self.observation_space.sample()",
        "detail": "deps.pufferlib.tests.pool.test_envpool",
        "documentation": {}
    },
    {
        "label": "test_envpool",
        "kind": 2,
        "importPath": "deps.pufferlib.tests.pool.test_multiprocessing",
        "description": "deps.pufferlib.tests.pool.test_multiprocessing",
        "peekOfCode": "def test_envpool(num_envs, envs_per_worker, envs_per_batch, steps=1000, env_pool=True):\n    pool = Multiprocessing(pokemon_red.env_creator(), num_envs=num_envs,\n        envs_per_worker=envs_per_worker, envs_per_batch=envs_per_batch,\n        env_pool=True,\n    )\n    pool.async_reset()\n    a = np.array([pool.single_action_space.sample() for _ in range(envs_per_batch)])\n    start = time.time()\n    for s in range(steps):\n        o, r, d, t, i, mask, env_id = pool.recv()",
        "detail": "deps.pufferlib.tests.pool.test_multiprocessing",
        "documentation": {}
    },
    {
        "label": "worker_process",
        "kind": 2,
        "importPath": "deps.pufferlib.tests.mem_test",
        "description": "deps.pufferlib.tests.mem_test",
        "peekOfCode": "def worker_process(envs_per_worker, shared_mem, bandwidth,\n        delay_mean, delay_std, send_pipe, recv_pipe):\n    data = np.random.randn(bandwidth)\n    while True:\n        request = recv_pipe.recv()\n        for _ in range(envs_per_worker):\n            start = time.process_time()\n            idx = 0\n            target_time = delay_mean + delay_std*np.random.randn()\n            while time.process_time() - start < target_time:",
        "detail": "deps.pufferlib.tests.mem_test",
        "documentation": {}
    },
    {
        "label": "test_speed",
        "kind": 2,
        "importPath": "deps.pufferlib.tests.mem_test",
        "description": "deps.pufferlib.tests.mem_test",
        "peekOfCode": "def test_speed(envs_per_worker=1, bandwidth=1, delay_mean=0.01, delay_std=0.001,\n        num_workers=4, batch_size=4, timeout=10):\n    main_send_pipes, work_recv_pipes = zip(*[Pipe() for _ in range(num_workers)])\n    work_send_pipes, main_recv_pipes = zip(*[Pipe() for _ in range(num_workers)])\n    shared_mem = [Array('d', bandwidth) for _ in range(num_workers)]\n    processes = [Process(\n        target=worker_process,\n        args=(envs_per_worker, shared_mem, bandwidth,\n            delay_mean, delay_std, work_send_pipes[i], work_recv_pipes[i]))\n        for i in range(num_workers)]",
        "detail": "deps.pufferlib.tests.mem_test",
        "documentation": {}
    },
    {
        "label": "test_gymnasium_emulation",
        "kind": 2,
        "importPath": "deps.pufferlib.tests.test",
        "description": "deps.pufferlib.tests.test",
        "peekOfCode": "def test_gymnasium_emulation(env_cls, steps=100):\n    raw_env = env_cls()\n    puf_env = pufferlib.emulation.GymnasiumPufferEnv(env_creator=env_cls)\n    raw_done = puf_done = True\n    raw_truncated = puf_truncated = False\n    for i in range(steps):\n        assert puf_done == raw_done\n        assert puf_truncated == raw_truncated\n        if raw_done:\n            puf_ob, _ = puf_env.reset()",
        "detail": "deps.pufferlib.tests.test",
        "documentation": {}
    },
    {
        "label": "test_pettingzoo_emulation",
        "kind": 2,
        "importPath": "deps.pufferlib.tests.test",
        "description": "deps.pufferlib.tests.test",
        "peekOfCode": "def test_pettingzoo_emulation(env_cls, steps=100):\n    raw_env = env_cls()\n    puf_env = pufferlib.emulation.PettingZooPufferEnv(env_creator=env_cls)\n    for i in range(steps):\n        raw_done = len(raw_env.agents) == 0\n        puf_done = len(puf_env.agents) == 0\n        assert puf_done == raw_done\n        if raw_done:\n            puf_obs, _ = puf_env.reset()\n            raw_obs, _ = raw_env.reset()",
        "detail": "deps.pufferlib.tests.test",
        "documentation": {}
    },
    {
        "label": "test_puffer_vectorization",
        "kind": 2,
        "importPath": "deps.pufferlib.tests.test",
        "description": "deps.pufferlib.tests.test",
        "peekOfCode": "def test_puffer_vectorization(env_cls, puffer_cls, steps=100, num_envs=1, **kwargs):\n    raw_envs = [puffer_cls(env_creator=env_cls) for _ in range(num_envs)]\n    vec_envs = pufferlib.vector.make(puffer_cls,\n        env_kwargs={'env_creator': env_cls}, num_envs=num_envs, **kwargs)\n    num_agents = sum(env.num_agents for env in raw_envs)\n    assert num_agents == vec_envs.num_agents\n    raw_obs = [env.reset()[0] for i, env in enumerate(raw_envs)]\n    vec_obs, _ = vec_envs.reset()\n    for _ in range(steps):\n        # PettingZoo dict observations",
        "detail": "deps.pufferlib.tests.test",
        "documentation": {}
    },
    {
        "label": "test_emulation",
        "kind": 2,
        "importPath": "deps.pufferlib.tests.test",
        "description": "deps.pufferlib.tests.test",
        "peekOfCode": "def test_emulation():\n    for env_cls in test.MOCK_SINGLE_AGENT_ENVIRONMENTS:\n        test_gymnasium_emulation(env_cls)\n    print('Gymnasium emulation tests passed')\n    for env_cls in test.MOCK_MULTI_AGENT_ENVIRONMENTS:\n        test_pettingzoo_emulation(env_cls)\n    print('PettingZoo emulation tests passed')\ndef test_vectorization():\n    for vectorization in [\n            pufferlib.vector.Serial,",
        "detail": "deps.pufferlib.tests.test",
        "documentation": {}
    },
    {
        "label": "test_vectorization",
        "kind": 2,
        "importPath": "deps.pufferlib.tests.test",
        "description": "deps.pufferlib.tests.test",
        "peekOfCode": "def test_vectorization():\n    for vectorization in [\n            pufferlib.vector.Serial,\n            pufferlib.vector.Multiprocessing,\n            pufferlib.vector.Ray]:\n        for env_cls in test.MOCK_SINGLE_AGENT_ENVIRONMENTS:\n            test_puffer_vectorization(\n                env_cls,\n                pufferlib.emulation.GymnasiumPufferEnv,\n                steps=10,",
        "detail": "deps.pufferlib.tests.test",
        "documentation": {}
    },
    {
        "label": "print_if",
        "kind": 2,
        "importPath": "deps.pufferlib.tests.test_api",
        "description": "deps.pufferlib.tests.test_api",
        "peekOfCode": "def print_if(e, print_errors):\n    if print_errors:\n        print(type(e).__name__ + ':', e)\n        print('#################')\n        print()\ndef test_gymnasium_api(print_errors=False):\n    env = pufferlib.emulation.GymnasiumPufferEnv(\n        env_creator=test.GymnasiumTestEnv)\n    try:\n        env.step({})",
        "detail": "deps.pufferlib.tests.test_api",
        "documentation": {}
    },
    {
        "label": "test_gymnasium_api",
        "kind": 2,
        "importPath": "deps.pufferlib.tests.test_api",
        "description": "deps.pufferlib.tests.test_api",
        "peekOfCode": "def test_gymnasium_api(print_errors=False):\n    env = pufferlib.emulation.GymnasiumPufferEnv(\n        env_creator=test.GymnasiumTestEnv)\n    try:\n        env.step({})\n    except APIUsageError as e:\n        print_if(e, print_errors)\n    try:\n        env.close()\n    except APIUsageError as e:",
        "detail": "deps.pufferlib.tests.test_api",
        "documentation": {}
    },
    {
        "label": "test_pettingzoo_api_usage",
        "kind": 2,
        "importPath": "deps.pufferlib.tests.test_api",
        "description": "deps.pufferlib.tests.test_api",
        "peekOfCode": "def test_pettingzoo_api_usage(print_errors=False):\n    env = pufferlib.emulation.PettingZooPufferEnv(\n        env_creator=test.PettingZooTestEnv)\n    try:\n        env.step({})\n    except APIUsageError as e:\n        print_if(e, print_errors)\n    try:\n        env.close()\n    except APIUsageError as e:",
        "detail": "deps.pufferlib.tests.test_api",
        "documentation": {}
    },
    {
        "label": "test_vectorization_api",
        "kind": 2,
        "importPath": "deps.pufferlib.tests.test_api",
        "description": "deps.pufferlib.tests.test_api",
        "peekOfCode": "def test_vectorization_api(print_errors=False):\n    gymnasium_creator = lambda: pufferlib.emulation.GymnasiumPufferEnv(\n        env_creator=test.GymnasiumTestEnv)\n    pettingzoo_creator = lambda: pufferlib.emulation.PettingZooPufferEnv(\n        env_creator=test.PettingZooTestEnv)\n    for backend in [\n        pufferlib.vector.Serial,\n        pufferlib.vector.Multiprocessing,\n        pufferlib.vector.Ray]:\n        for creator in [gymnasium_creator, pettingzoo_creator]:",
        "detail": "deps.pufferlib.tests.test_api",
        "documentation": {}
    },
    {
        "label": "test_atari_reset",
        "kind": 2,
        "importPath": "deps.pufferlib.tests.test_atari_reset",
        "description": "deps.pufferlib.tests.test_atari_reset",
        "peekOfCode": "def test_atari_reset():\n    '''Common way to bug the wrappers can be detected\n    by checking that the environment properly resets\n    after hitting 0 lives'''\n    env = atari.env_creator('BreakoutNoFrameskip-v4')(4)\n    obs, info = env.reset()\n    prev_lives = 5\n    lives = []\n    for i in range(1000):\n        action = env.action_space.sample()",
        "detail": "deps.pufferlib.tests.test_atari_reset",
        "documentation": {}
    },
    {
        "label": "SyntheticExperiment",
        "kind": 6,
        "importPath": "deps.pufferlib.tests.test_carbs",
        "description": "deps.pufferlib.tests.test_carbs",
        "peekOfCode": "class SyntheticExperiment:\n    def __init__(self, n_params, noise=0.1):\n        self.n_params = n_params\n        self.noise = noise\n        self.param_optima = np.random.randn(n_params)\n    def optimize(self, params):\n        dist = (params-self.param_optima)**2\n        reward = 2**(-dist)\n        noise = 1 + self.noise*np.random.randn()\n        return noise * np.prod(reward)",
        "detail": "deps.pufferlib.tests.test_carbs",
        "documentation": {}
    },
    {
        "label": "CARBSSearch",
        "kind": 6,
        "importPath": "deps.pufferlib.tests.test_carbs",
        "description": "deps.pufferlib.tests.test_carbs",
        "peekOfCode": "class CARBSSearch:\n    def __init__(self, experiment):\n        self.experiment = experiment\n        self.best_reward = None\n        self.best_params = None\n        param_spaces = [\n            Param(name=str(i),\n                    space=LinearSpace(min=-10, max=10, is_integer=False),\n                    search_center=0.0)\n            for i in range(self.experiment.n_params)",
        "detail": "deps.pufferlib.tests.test_carbs",
        "documentation": {}
    },
    {
        "label": "GeneticAlgorithm",
        "kind": 6,
        "importPath": "deps.pufferlib.tests.test_carbs",
        "description": "deps.pufferlib.tests.test_carbs",
        "peekOfCode": "class GeneticAlgorithm:\n    def __init__(self, experiment, mutation_rate=0.1):\n        self.experiment = experiment\n        self.mutation_rate = mutation_rate\n        self.best_reward = None\n        self.best_params = np.random.randn(self.experiment.n_params)\n    def sample(self):\n        mutation = self.mutation_rate*np.random.randn(self.experiment.n_params)\n        params = self.best_params + mutation\n        reward = self.experiment.optimize(params)",
        "detail": "deps.pufferlib.tests.test_carbs",
        "documentation": {}
    },
    {
        "label": "WandbSearch",
        "kind": 6,
        "importPath": "deps.pufferlib.tests.test_carbs",
        "description": "deps.pufferlib.tests.test_carbs",
        "peekOfCode": "class WandbSearch:\n    def __init__(self, experiment, method='bayes', strategy=None):\n        self.experiment = experiment\n        self.strategy = strategy\n        self.parameters = {f'param_{i}':\n            {'distribution': 'normal', 'mu': 0, 'sigma': 1}\n            for i in range(10)}\n        name = strategy.__class__.__name__ if strategy is not None else method\n        self.sweep_id = wandb.sweep(\n            sweep=dict(",
        "detail": "deps.pufferlib.tests.test_carbs",
        "documentation": {}
    },
    {
        "label": "test_cleanrl_utils",
        "kind": 2,
        "importPath": "deps.pufferlib.tests.test_cleanrl_utils",
        "description": "deps.pufferlib.tests.test_cleanrl_utils",
        "peekOfCode": "def test_cleanrl_utils():\n    envs = pufferlib.vectorization.Serial(\n        env_creator=pufferlib.environments.classic_control.env_creator('cartpole'),\n        num_envs=4, envs_per_worker=2\n    )\n    obs, info, _, _ = envs.reset()\n    policy = pufferlib.models.Default(envs.driver_env)\n    policy = pufferlib.models.LSTMWrapper(envs.driver_env, policy)\n    policy = pufferlib.frameworks.cleanrl.RecurrentPolicy(policy)\n    obs = torch.tensor(obs).unsqueeze(1).float()",
        "detail": "deps.pufferlib.tests.test_cleanrl_utils",
        "documentation": {}
    },
    {
        "label": "shape_check",
        "kind": 2,
        "importPath": "deps.pufferlib.tests.test_cleanrl_utils",
        "description": "deps.pufferlib.tests.test_cleanrl_utils",
        "peekOfCode": "def shape_check(a1, l1, e1, a2, l2, e2):\n    assert a1.shape == a2.shape\n    assert l1.shape == l2.shape\n    assert e1.shape == e2.shape\ndef test_sample_logits():\n    batch = 8\n    d = gym.spaces.Discrete(5)\n    d_logits = torch.randn(batch, 5)\n    d_action = torch.tensor([d.sample() for _ in range(batch)])\n    nvec = [3, 7, 4]",
        "detail": "deps.pufferlib.tests.test_cleanrl_utils",
        "documentation": {}
    },
    {
        "label": "test_sample_logits",
        "kind": 2,
        "importPath": "deps.pufferlib.tests.test_cleanrl_utils",
        "description": "deps.pufferlib.tests.test_cleanrl_utils",
        "peekOfCode": "def test_sample_logits():\n    batch = 8\n    d = gym.spaces.Discrete(5)\n    d_logits = torch.randn(batch, 5)\n    d_action = torch.tensor([d.sample() for _ in range(batch)])\n    nvec = [3, 7, 4]\n    md = gym.spaces.MultiDiscrete(nvec)\n    md_logits = [torch.rand(batch, n) for n in nvec]\n    md_action = torch.tensor(np.array([md.sample() for _ in range(batch)]))\n    a1, l1, e1 = pufferlib.frameworks.cleanrl.sample_logits(d_logits)",
        "detail": "deps.pufferlib.tests.test_cleanrl_utils",
        "documentation": {}
    },
    {
        "label": "correct_sample_logits",
        "kind": 2,
        "importPath": "deps.pufferlib.tests.test_cleanrl_utils",
        "description": "deps.pufferlib.tests.test_cleanrl_utils",
        "peekOfCode": "def correct_sample_logits(logits, action=None):\n    '''A bad but known correct implementation'''\n    if isinstance(logits, torch.Tensor):\n        categorical = Categorical(logits=logits)\n        if action is None:\n            action = categorical.sample()\n        else:\n            action = action.view(-1)\n        logprob = categorical.log_prob(action)\n        entropy = categorical.entropy()",
        "detail": "deps.pufferlib.tests.test_cleanrl_utils",
        "documentation": {}
    },
    {
        "label": "Policy",
        "kind": 6,
        "importPath": "deps.pufferlib.tests.test_docs_nmmo",
        "description": "deps.pufferlib.tests.test_docs_nmmo",
        "peekOfCode": "class Policy(nn.Module):\n    def __init__(self, env):\n        super().__init__()\n        self.encoder = nn.Linear(np.prod(\n            envs.single_observation_space.shape), 128)\n        self.decoders = nn.ModuleList([nn.Linear(128, n)\n            for n in envs.single_action_space.nvec])\n        self.value_head = nn.Linear(128, 1)\n    def forward(self, env_outputs):\n        env_outputs = env_outputs.reshape(env_outputs.shape[0], -1)",
        "detail": "deps.pufferlib.tests.test_docs_nmmo",
        "documentation": {}
    },
    {
        "label": "nmmo_creator",
        "kind": 2,
        "importPath": "deps.pufferlib.tests.test_docs_nmmo",
        "description": "deps.pufferlib.tests.test_docs_nmmo",
        "peekOfCode": "def nmmo_creator():\n    env = nmmo.Env()\n    env = pufferlib.wrappers.PettingZooTruncatedWrapper(env)\n    return pufferlib.emulation.PettingZooPufferEnv(env=env)\ndef nethack_creator():\n    return pufferlib.emulation.GymnasiumPufferEnv(env_creator=nle.env.NLE)\n# Section 2: Vectorization\nimport pufferlib.vector\nbackend = pufferlib.vector.Serial #or Multiprocessing, Ray\nenvs = pufferlib.vector.make(nmmo_creator, backend=backend, num_envs=4)",
        "detail": "deps.pufferlib.tests.test_docs_nmmo",
        "documentation": {}
    },
    {
        "label": "nethack_creator",
        "kind": 2,
        "importPath": "deps.pufferlib.tests.test_docs_nmmo",
        "description": "deps.pufferlib.tests.test_docs_nmmo",
        "peekOfCode": "def nethack_creator():\n    return pufferlib.emulation.GymnasiumPufferEnv(env_creator=nle.env.NLE)\n# Section 2: Vectorization\nimport pufferlib.vector\nbackend = pufferlib.vector.Serial #or Multiprocessing, Ray\nenvs = pufferlib.vector.make(nmmo_creator, backend=backend, num_envs=4)\n# Synchronous API - reset/step\nobs, infos = envs.reset()\n# Asynchronous API - async_reset, send/recv\nenvs.async_reset()",
        "detail": "deps.pufferlib.tests.test_docs_nmmo",
        "documentation": {}
    },
    {
        "label": "backend",
        "kind": 5,
        "importPath": "deps.pufferlib.tests.test_docs_nmmo",
        "description": "deps.pufferlib.tests.test_docs_nmmo",
        "peekOfCode": "backend = pufferlib.vector.Serial #or Multiprocessing, Ray\nenvs = pufferlib.vector.make(nmmo_creator, backend=backend, num_envs=4)\n# Synchronous API - reset/step\nobs, infos = envs.reset()\n# Asynchronous API - async_reset, send/recv\nenvs.async_reset()\nobs, rewards, terminals, truncateds, infos, env_id, mask = envs.recv()\n# Section 3: Policy\nimport torch\nfrom torch import nn",
        "detail": "deps.pufferlib.tests.test_docs_nmmo",
        "documentation": {}
    },
    {
        "label": "envs",
        "kind": 5,
        "importPath": "deps.pufferlib.tests.test_docs_nmmo",
        "description": "deps.pufferlib.tests.test_docs_nmmo",
        "peekOfCode": "envs = pufferlib.vector.make(nmmo_creator, backend=backend, num_envs=4)\n# Synchronous API - reset/step\nobs, infos = envs.reset()\n# Asynchronous API - async_reset, send/recv\nenvs.async_reset()\nobs, rewards, terminals, truncateds, infos, env_id, mask = envs.recv()\n# Section 3: Policy\nimport torch\nfrom torch import nn\nimport numpy as np",
        "detail": "deps.pufferlib.tests.test_docs_nmmo",
        "documentation": {}
    },
    {
        "label": "obs",
        "kind": 5,
        "importPath": "deps.pufferlib.tests.test_docs_nmmo",
        "description": "deps.pufferlib.tests.test_docs_nmmo",
        "peekOfCode": "obs = torch.Tensor(obs)\npolicy = Policy(envs.driver_env)\ncleanrl_policy = pufferlib.frameworks.cleanrl.Policy(policy)\nactions = cleanrl_policy.get_action_and_value(obs)[0].numpy()\nobs, rewards, terminals, truncateds, infos = envs.step(actions)\nenvs.close()\n# Section 4: Registry Full Example\nimport torch\nimport pufferlib.models\nimport pufferlib.vector",
        "detail": "deps.pufferlib.tests.test_docs_nmmo",
        "documentation": {}
    },
    {
        "label": "policy",
        "kind": 5,
        "importPath": "deps.pufferlib.tests.test_docs_nmmo",
        "description": "deps.pufferlib.tests.test_docs_nmmo",
        "peekOfCode": "policy = Policy(envs.driver_env)\ncleanrl_policy = pufferlib.frameworks.cleanrl.Policy(policy)\nactions = cleanrl_policy.get_action_and_value(obs)[0].numpy()\nobs, rewards, terminals, truncateds, infos = envs.step(actions)\nenvs.close()\n# Section 4: Registry Full Example\nimport torch\nimport pufferlib.models\nimport pufferlib.vector\nimport pufferlib.frameworks.cleanrl",
        "detail": "deps.pufferlib.tests.test_docs_nmmo",
        "documentation": {}
    },
    {
        "label": "cleanrl_policy",
        "kind": 5,
        "importPath": "deps.pufferlib.tests.test_docs_nmmo",
        "description": "deps.pufferlib.tests.test_docs_nmmo",
        "peekOfCode": "cleanrl_policy = pufferlib.frameworks.cleanrl.Policy(policy)\nactions = cleanrl_policy.get_action_and_value(obs)[0].numpy()\nobs, rewards, terminals, truncateds, infos = envs.step(actions)\nenvs.close()\n# Section 4: Registry Full Example\nimport torch\nimport pufferlib.models\nimport pufferlib.vector\nimport pufferlib.frameworks.cleanrl\nimport pufferlib.environments.nmmo",
        "detail": "deps.pufferlib.tests.test_docs_nmmo",
        "documentation": {}
    },
    {
        "label": "actions",
        "kind": 5,
        "importPath": "deps.pufferlib.tests.test_docs_nmmo",
        "description": "deps.pufferlib.tests.test_docs_nmmo",
        "peekOfCode": "actions = cleanrl_policy.get_action_and_value(obs)[0].numpy()\nobs, rewards, terminals, truncateds, infos = envs.step(actions)\nenvs.close()\n# Section 4: Registry Full Example\nimport torch\nimport pufferlib.models\nimport pufferlib.vector\nimport pufferlib.frameworks.cleanrl\nimport pufferlib.environments.nmmo\nmake_env = pufferlib.environments.nmmo.env_creator()",
        "detail": "deps.pufferlib.tests.test_docs_nmmo",
        "documentation": {}
    },
    {
        "label": "make_env",
        "kind": 5,
        "importPath": "deps.pufferlib.tests.test_docs_nmmo",
        "description": "deps.pufferlib.tests.test_docs_nmmo",
        "peekOfCode": "make_env = pufferlib.environments.nmmo.env_creator()\nenvs = pufferlib.vector.make(make_env, backend=backend, num_envs=4)\npolicy = pufferlib.environments.nmmo.Policy(envs.driver_env)\ncleanrl_policy = pufferlib.frameworks.cleanrl.Policy(policy)\nenv_outputs = envs.reset()[0]\nobs = torch.from_numpy(env_outputs)\nactions = cleanrl_policy.get_action_and_value(obs)[0].numpy()\nnext_obs, rewards, terminals, truncateds, infos = envs.step(actions)\nenvs.close()\n# Section 5: Unpacking Observations",
        "detail": "deps.pufferlib.tests.test_docs_nmmo",
        "documentation": {}
    },
    {
        "label": "envs",
        "kind": 5,
        "importPath": "deps.pufferlib.tests.test_docs_nmmo",
        "description": "deps.pufferlib.tests.test_docs_nmmo",
        "peekOfCode": "envs = pufferlib.vector.make(make_env, backend=backend, num_envs=4)\npolicy = pufferlib.environments.nmmo.Policy(envs.driver_env)\ncleanrl_policy = pufferlib.frameworks.cleanrl.Policy(policy)\nenv_outputs = envs.reset()[0]\nobs = torch.from_numpy(env_outputs)\nactions = cleanrl_policy.get_action_and_value(obs)[0].numpy()\nnext_obs, rewards, terminals, truncateds, infos = envs.step(actions)\nenvs.close()\n# Section 5: Unpacking Observations\ndtype = pufferlib.pytorch.nativize_dtype(envs.driver_env.emulated)",
        "detail": "deps.pufferlib.tests.test_docs_nmmo",
        "documentation": {}
    },
    {
        "label": "policy",
        "kind": 5,
        "importPath": "deps.pufferlib.tests.test_docs_nmmo",
        "description": "deps.pufferlib.tests.test_docs_nmmo",
        "peekOfCode": "policy = pufferlib.environments.nmmo.Policy(envs.driver_env)\ncleanrl_policy = pufferlib.frameworks.cleanrl.Policy(policy)\nenv_outputs = envs.reset()[0]\nobs = torch.from_numpy(env_outputs)\nactions = cleanrl_policy.get_action_and_value(obs)[0].numpy()\nnext_obs, rewards, terminals, truncateds, infos = envs.step(actions)\nenvs.close()\n# Section 5: Unpacking Observations\ndtype = pufferlib.pytorch.nativize_dtype(envs.driver_env.emulated)\nenv_outputs = pufferlib.pytorch.nativize_tensor(obs, dtype)",
        "detail": "deps.pufferlib.tests.test_docs_nmmo",
        "documentation": {}
    },
    {
        "label": "cleanrl_policy",
        "kind": 5,
        "importPath": "deps.pufferlib.tests.test_docs_nmmo",
        "description": "deps.pufferlib.tests.test_docs_nmmo",
        "peekOfCode": "cleanrl_policy = pufferlib.frameworks.cleanrl.Policy(policy)\nenv_outputs = envs.reset()[0]\nobs = torch.from_numpy(env_outputs)\nactions = cleanrl_policy.get_action_and_value(obs)[0].numpy()\nnext_obs, rewards, terminals, truncateds, infos = envs.step(actions)\nenvs.close()\n# Section 5: Unpacking Observations\ndtype = pufferlib.pytorch.nativize_dtype(envs.driver_env.emulated)\nenv_outputs = pufferlib.pytorch.nativize_tensor(obs, dtype)\nprint('Packed tensor:', obs.shape)",
        "detail": "deps.pufferlib.tests.test_docs_nmmo",
        "documentation": {}
    },
    {
        "label": "env_outputs",
        "kind": 5,
        "importPath": "deps.pufferlib.tests.test_docs_nmmo",
        "description": "deps.pufferlib.tests.test_docs_nmmo",
        "peekOfCode": "env_outputs = envs.reset()[0]\nobs = torch.from_numpy(env_outputs)\nactions = cleanrl_policy.get_action_and_value(obs)[0].numpy()\nnext_obs, rewards, terminals, truncateds, infos = envs.step(actions)\nenvs.close()\n# Section 5: Unpacking Observations\ndtype = pufferlib.pytorch.nativize_dtype(envs.driver_env.emulated)\nenv_outputs = pufferlib.pytorch.nativize_tensor(obs, dtype)\nprint('Packed tensor:', obs.shape)\nprint('Unpacked:', env_outputs.keys())",
        "detail": "deps.pufferlib.tests.test_docs_nmmo",
        "documentation": {}
    },
    {
        "label": "obs",
        "kind": 5,
        "importPath": "deps.pufferlib.tests.test_docs_nmmo",
        "description": "deps.pufferlib.tests.test_docs_nmmo",
        "peekOfCode": "obs = torch.from_numpy(env_outputs)\nactions = cleanrl_policy.get_action_and_value(obs)[0].numpy()\nnext_obs, rewards, terminals, truncateds, infos = envs.step(actions)\nenvs.close()\n# Section 5: Unpacking Observations\ndtype = pufferlib.pytorch.nativize_dtype(envs.driver_env.emulated)\nenv_outputs = pufferlib.pytorch.nativize_tensor(obs, dtype)\nprint('Packed tensor:', obs.shape)\nprint('Unpacked:', env_outputs.keys())\nfrom pdb import set_trace as T; T()",
        "detail": "deps.pufferlib.tests.test_docs_nmmo",
        "documentation": {}
    },
    {
        "label": "actions",
        "kind": 5,
        "importPath": "deps.pufferlib.tests.test_docs_nmmo",
        "description": "deps.pufferlib.tests.test_docs_nmmo",
        "peekOfCode": "actions = cleanrl_policy.get_action_and_value(obs)[0].numpy()\nnext_obs, rewards, terminals, truncateds, infos = envs.step(actions)\nenvs.close()\n# Section 5: Unpacking Observations\ndtype = pufferlib.pytorch.nativize_dtype(envs.driver_env.emulated)\nenv_outputs = pufferlib.pytorch.nativize_tensor(obs, dtype)\nprint('Packed tensor:', obs.shape)\nprint('Unpacked:', env_outputs.keys())\nfrom pdb import set_trace as T; T()\npass",
        "detail": "deps.pufferlib.tests.test_docs_nmmo",
        "documentation": {}
    },
    {
        "label": "dtype",
        "kind": 5,
        "importPath": "deps.pufferlib.tests.test_docs_nmmo",
        "description": "deps.pufferlib.tests.test_docs_nmmo",
        "peekOfCode": "dtype = pufferlib.pytorch.nativize_dtype(envs.driver_env.emulated)\nenv_outputs = pufferlib.pytorch.nativize_tensor(obs, dtype)\nprint('Packed tensor:', obs.shape)\nprint('Unpacked:', env_outputs.keys())\nfrom pdb import set_trace as T; T()\npass",
        "detail": "deps.pufferlib.tests.test_docs_nmmo",
        "documentation": {}
    },
    {
        "label": "env_outputs",
        "kind": 5,
        "importPath": "deps.pufferlib.tests.test_docs_nmmo",
        "description": "deps.pufferlib.tests.test_docs_nmmo",
        "peekOfCode": "env_outputs = pufferlib.pytorch.nativize_tensor(obs, dtype)\nprint('Packed tensor:', obs.shape)\nprint('Unpacked:', env_outputs.keys())\nfrom pdb import set_trace as T; T()\npass",
        "detail": "deps.pufferlib.tests.test_docs_nmmo",
        "documentation": {}
    },
    {
        "label": "test_pack_unpack",
        "kind": 2,
        "importPath": "deps.pufferlib.tests.test_extensions",
        "description": "deps.pufferlib.tests.test_extensions",
        "peekOfCode": "def test_pack_unpack():\n    for space in nested_spaces:\n        sample = space.sample()\n        flat_space = flatten_space(space)\n        flat_sample = flatten(sample)\n        pack_sample = concatenate(flat_sample)\n        sz = [int(np.prod(subspace.shape)) for subspace in flat_space.values()]\n        unpack_sample = split(pack_sample, flat_space, sz, batched=False)\n        unflat_sample = unflatten(unpack_sample, space)\n        assert pufferlib.utils.compare_space_samples(sample, unflat_sample), \"Unflatten failed.\"",
        "detail": "deps.pufferlib.tests.test_extensions",
        "documentation": {}
    },
    {
        "label": "test_flatten_unflatten",
        "kind": 2,
        "importPath": "deps.pufferlib.tests.test_extensions",
        "description": "deps.pufferlib.tests.test_extensions",
        "peekOfCode": "def test_flatten_unflatten(iterations=10_000):\n    flatten_times = []\n    concatenate_times = []\n    split_times = []\n    unflatten_times = []\n    for space in test_cases:\n        data = space.sample()\n        flat = flatten(data)\n        structure = flatten_structure(data)\n        flat_space = flatten_space(space)",
        "detail": "deps.pufferlib.tests.test_extensions",
        "documentation": {}
    },
    {
        "label": "test_cases",
        "kind": 5,
        "importPath": "deps.pufferlib.tests.test_extensions",
        "description": "deps.pufferlib.tests.test_extensions",
        "peekOfCode": "test_cases = [\n    # Nested Dict with Box and Discrete spaces\n    gym.spaces.Dict({\n        \"a\": gym.spaces.Box(low=0, high=1, shape=(3,)),\n        \"b\": gym.spaces.MultiDiscrete([3, 10]),\n        \"c\": gym.spaces.Dict({\n            \"d\": gym.spaces.Box(low=-10, high=10, shape=(100,)),\n            \"e\": gym.spaces.Discrete(1000)\n        })\n    }),",
        "detail": "deps.pufferlib.tests.test_extensions",
        "documentation": {}
    },
    {
        "label": "compare_data",
        "kind": 2,
        "importPath": "deps.pufferlib.tests.test_flatten",
        "description": "deps.pufferlib.tests.test_flatten",
        "peekOfCode": "def compare_data(data, unflat):\n    if isinstance(data, (list, tuple)) and isinstance(unflat, (list, tuple)):\n        if len(data) != len(unflat):\n            return False\n        return all(compare_data(d, f) for d, f in zip(data, unflat))\n    elif isinstance(data, dict) and isinstance(unflat, dict):\n        if len(data) != len(unflat):\n            return False\n        return all(compare_data(data[key], unflat[key]) for key in sorted(data))\n    else:",
        "detail": "deps.pufferlib.tests.test_flatten",
        "documentation": {}
    },
    {
        "label": "test_flatten_unflatten",
        "kind": 2,
        "importPath": "deps.pufferlib.tests.test_flatten",
        "description": "deps.pufferlib.tests.test_flatten",
        "peekOfCode": "def test_flatten_unflatten():\n    for sample in samples:\n        structure = flatten_structure(sample)\n        flat = c.flatten(sample)\n        unflat = c.unflatten(flat, structure)\n        if not compare_data(sample, unflat):\n            print(f\"Sample: {sample}\")\n            print(f\"Flattened: {flat}\")\n            print(f\"Unflattened: {unflat}\")\n            breakpoint()",
        "detail": "deps.pufferlib.tests.test_flatten",
        "documentation": {}
    },
    {
        "label": "test_flatten_performance",
        "kind": 2,
        "importPath": "deps.pufferlib.tests.test_flatten",
        "description": "deps.pufferlib.tests.test_flatten",
        "peekOfCode": "def test_flatten_performance(n=100_000):\n    print(\"\\nFlatten Performance Testing:\")\n    total_calls_per_second = 0\n    num_samples = len(samples)\n    for sample in samples:\n        wrapped = lambda: c.flatten(sample)\n        time_per_call = timeit.timeit(wrapped, number=n) / n\n        calls_per_second_in_k = int(1 / time_per_call / 1000)\n        print(f\"Sample {str(sample)[:10]}... - Average flatten calls per second: {calls_per_second_in_k} K\")\n        total_calls_per_second += calls_per_second_in_k",
        "detail": "deps.pufferlib.tests.test_flatten",
        "documentation": {}
    },
    {
        "label": "test_unflatten_performance",
        "kind": 2,
        "importPath": "deps.pufferlib.tests.test_flatten",
        "description": "deps.pufferlib.tests.test_flatten",
        "peekOfCode": "def test_unflatten_performance(n=100_000):\n    print(\"\\nUnflatten Performance Testing:\")\n    total_calls_per_second = 0\n    num_samples = len(samples)\n    for sample in samples:\n        flat = c.flatten(sample)\n        structure = flatten_structure(sample)\n        wrapped = lambda: c.unflatten(flat, structure)\n        time_per_call = timeit.timeit(wrapped, number=n) / n\n        calls_per_second_in_k = int(1 / time_per_call / 1000)",
        "detail": "deps.pufferlib.tests.test_flatten",
        "documentation": {}
    },
    {
        "label": "samples",
        "kind": 5,
        "importPath": "deps.pufferlib.tests.test_flatten",
        "description": "deps.pufferlib.tests.test_flatten",
        "peekOfCode": "samples = [\n    [1, {'foo': (1, 2, 3)}],\n    {'foo': 1, 'bar': {'baz': 2, 'qux': 3}},\n    1,\n    {'a': [1, 2, {'b': (3, 4)}]},\n    {'x': {'y': {'z': [1, 2, 3]}}},\n    (1, 2, [3, 4], {'a': 5}),\n    {'nested': {'more': {'and_more': (1, 2, [3, {'deep': 4}])}}},\n    [[1, 2], [3, 4], [5, 6]],\n    {'a': 1, 'b': 2, 'c': {'d': 3, 'e': [4, 5]}},",
        "detail": "deps.pufferlib.tests.test_flatten",
        "documentation": {}
    },
    {
        "label": "test_import_speed",
        "kind": 2,
        "importPath": "deps.pufferlib.tests.test_import_performance",
        "description": "deps.pufferlib.tests.test_import_performance",
        "peekOfCode": "def test_import_speed():\n    start = time.time() \n    import pufferlib\n    end = time.time()\n    print(end - start, ' seconds to import pufferlib')\n    assert end - start < 0.25\nif __name__ == '__main__':\n    test_import_speed()",
        "detail": "deps.pufferlib.tests.test_import_performance",
        "documentation": {}
    },
    {
        "label": "TestClass",
        "kind": 6,
        "importPath": "deps.pufferlib.tests.test_namespace",
        "description": "deps.pufferlib.tests.test_namespace",
        "peekOfCode": "class TestClass:\n    a: int\n    b = 1\ndef test_namespace_as_decorator():\n    obj = TestClass(a=4, b=5)\n    assert obj.a == 4\n    assert obj.b == 5\n    assert list(obj.keys()) == ['a', 'b']\n    assert list(obj.values()) == [4, 5]\n    assert list(obj.items()) == [('a', 4), ('b', 5)]",
        "detail": "deps.pufferlib.tests.test_namespace",
        "documentation": {}
    },
    {
        "label": "test_namespace_as_function",
        "kind": 2,
        "importPath": "deps.pufferlib.tests.test_namespace",
        "description": "deps.pufferlib.tests.test_namespace",
        "peekOfCode": "def test_namespace_as_function():\n    ns = namespace(x=1, y=2, z=3)\n    assert ns.x == 1\n    assert ns.y == 2\n    assert ns.z == 3\n    assert list(ns.keys()) == ['x', 'y', 'z']\n    assert list(ns.values()) == [1, 2, 3]\n    assert list(ns.items()) == [('x', 1), ('y', 2), ('z', 3)]\n@dataclass\nclass TestClass:",
        "detail": "deps.pufferlib.tests.test_namespace",
        "documentation": {}
    },
    {
        "label": "test_namespace_as_decorator",
        "kind": 2,
        "importPath": "deps.pufferlib.tests.test_namespace",
        "description": "deps.pufferlib.tests.test_namespace",
        "peekOfCode": "def test_namespace_as_decorator():\n    obj = TestClass(a=4, b=5)\n    assert obj.a == 4\n    assert obj.b == 5\n    assert list(obj.keys()) == ['a', 'b']\n    assert list(obj.values()) == [4, 5]\n    assert list(obj.items()) == [('a', 4), ('b', 5)]\nif __name__ == '__main__':\n    test_namespace_as_function()\n    test_namespace_as_decorator()",
        "detail": "deps.pufferlib.tests.test_namespace",
        "documentation": {}
    },
    {
        "label": "dtype_from_space",
        "kind": 2,
        "importPath": "deps.pufferlib.tests.test_nested",
        "description": "deps.pufferlib.tests.test_nested",
        "peekOfCode": "def dtype_from_space(space):\n    if isinstance(space, pufferlib.spaces.Tuple):\n        dtype = []\n        num_bytes = 0\n        for i, elem in enumerate(space):\n            dtype_ext, bytes_ext = dtype_from_space(elem)\n            dtype.append((f'f{i}', dtype_ext))\n            #dtype.append((dtype_ext,))\n            num_bytes += bytes_ext\n    elif isinstance(space, pufferlib.spaces.Dict):",
        "detail": "deps.pufferlib.tests.test_nested",
        "documentation": {}
    },
    {
        "label": "flat_dtype_from_space",
        "kind": 2,
        "importPath": "deps.pufferlib.tests.test_nested",
        "description": "deps.pufferlib.tests.test_nested",
        "peekOfCode": "def flat_dtype_from_space(space, name=None):\n    dtype = []\n    _flat_dtype_from_space(space, dtype, name)\n    return dtype\ndef _flat_dtype_from_space(space, dtype, name=None):\n    if isinstance(space, pufferlib.spaces.Tuple):\n        for i, elem in enumerate(space):\n            _flat_dtype_from_space(elem, dtype, name=f'f{i}')\n            #_flat_dtype_from_space(elem, dtype, name=None)\n    elif isinstance(space, pufferlib.spaces.Dict):",
        "detail": "deps.pufferlib.tests.test_nested",
        "documentation": {}
    },
    {
        "label": "fill_with_sample",
        "kind": 2,
        "importPath": "deps.pufferlib.tests.test_nested",
        "description": "deps.pufferlib.tests.test_nested",
        "peekOfCode": "def fill_with_sample(arr, sample):\n    if isinstance(sample, dict):\n        for k, v in sample.items():\n            fill_with_sample(arr[k], v)\n    elif isinstance(sample, tuple):\n        for i, v in enumerate(sample):\n            fill_with_sample(arr[f'f{i}'], v)\n    else:\n        arr[()] = sample\nfrom gymnasium.spaces import Tuple, Dict, Box",
        "detail": "deps.pufferlib.tests.test_nested",
        "documentation": {}
    },
    {
        "label": "mkdt",
        "kind": 2,
        "importPath": "deps.pufferlib.tests.test_nested",
        "description": "deps.pufferlib.tests.test_nested",
        "peekOfCode": "def mkdt(d):\n    ll = []\n    sz_bytes = 0\n    for k,v in d.items():\n        if isinstance(v,np.ndarray):\n            ll.append((k,v.dtype))\n            sz_bytes += v.nbytes\n        else:\n            l_ext, sz_ext = mkdt(v)\n            ll.append((k,l_ext))",
        "detail": "deps.pufferlib.tests.test_nested",
        "documentation": {}
    },
    {
        "label": "mkdt_flat",
        "kind": 2,
        "importPath": "deps.pufferlib.tests.test_nested",
        "description": "deps.pufferlib.tests.test_nested",
        "peekOfCode": "def mkdt_flat(d):\n    dtype = []\n    return _mkdt_flat(d, dtype)\ndef _mkdt_flat(d, dtype):\n    for k,v in d.items():\n        if isinstance(v,np.ndarray):\n            dtype.append((k,v.dtype))\n        else:\n            _mkdt_flat(v, dtype)\n    return dtype",
        "detail": "deps.pufferlib.tests.test_nested",
        "documentation": {}
    },
    {
        "label": "test_space",
        "kind": 5,
        "importPath": "deps.pufferlib.tests.test_nested",
        "description": "deps.pufferlib.tests.test_nested",
        "peekOfCode": "test_space = Tuple([\n    Dict({\n        'a': Box(0, 1, shape=(2,)),\n        'b': Box(0, 1, shape=(3,))\n    }),\n    Dict({\n        'c': Box(0, 1, shape=(4,)),\n    })\n])\n# Some notes:",
        "detail": "deps.pufferlib.tests.test_nested",
        "documentation": {}
    },
    {
        "label": "dtype",
        "kind": 5,
        "importPath": "deps.pufferlib.tests.test_nested",
        "description": "deps.pufferlib.tests.test_nested",
        "peekOfCode": "dtype = np.dtype(dtype)\nelem = np.zeros(1, dtype=dtype)\n#flat_dtype = flat_dtype_from_space(test_space)\nsample = test_space.sample()\nfill_with_sample(elem, sample)\nbreakpoint()\n#flat_sample = flatten(sample)\nrec_array = np.rec.array(flat_sample, dtype=flat_dtype)\nrec_array = rec_array.view(dtype)\n'''",
        "detail": "deps.pufferlib.tests.test_nested",
        "documentation": {}
    },
    {
        "label": "elem",
        "kind": 5,
        "importPath": "deps.pufferlib.tests.test_nested",
        "description": "deps.pufferlib.tests.test_nested",
        "peekOfCode": "elem = np.zeros(1, dtype=dtype)\n#flat_dtype = flat_dtype_from_space(test_space)\nsample = test_space.sample()\nfill_with_sample(elem, sample)\nbreakpoint()\n#flat_sample = flatten(sample)\nrec_array = np.rec.array(flat_sample, dtype=flat_dtype)\nrec_array = rec_array.view(dtype)\n'''\ntest_space = Dict({",
        "detail": "deps.pufferlib.tests.test_nested",
        "documentation": {}
    },
    {
        "label": "#flat_dtype",
        "kind": 5,
        "importPath": "deps.pufferlib.tests.test_nested",
        "description": "deps.pufferlib.tests.test_nested",
        "peekOfCode": "#flat_dtype = flat_dtype_from_space(test_space)\nsample = test_space.sample()\nfill_with_sample(elem, sample)\nbreakpoint()\n#flat_sample = flatten(sample)\nrec_array = np.rec.array(flat_sample, dtype=flat_dtype)\nrec_array = rec_array.view(dtype)\n'''\ntest_space = Dict({\n    'a': Box(0, 1, shape=(3,)),",
        "detail": "deps.pufferlib.tests.test_nested",
        "documentation": {}
    },
    {
        "label": "sample",
        "kind": 5,
        "importPath": "deps.pufferlib.tests.test_nested",
        "description": "deps.pufferlib.tests.test_nested",
        "peekOfCode": "sample = test_space.sample()\nfill_with_sample(elem, sample)\nbreakpoint()\n#flat_sample = flatten(sample)\nrec_array = np.rec.array(flat_sample, dtype=flat_dtype)\nrec_array = rec_array.view(dtype)\n'''\ntest_space = Dict({\n    'a': Box(0, 1, shape=(3,)),\n    'b': Dict({",
        "detail": "deps.pufferlib.tests.test_nested",
        "documentation": {}
    },
    {
        "label": "#flat_sample",
        "kind": 5,
        "importPath": "deps.pufferlib.tests.test_nested",
        "description": "deps.pufferlib.tests.test_nested",
        "peekOfCode": "#flat_sample = flatten(sample)\nrec_array = np.rec.array(flat_sample, dtype=flat_dtype)\nrec_array = rec_array.view(dtype)\n'''\ntest_space = Dict({\n    'a': Box(0, 1, shape=(3,)),\n    'b': Dict({\n        'c': Box(0, 1, shape=(4,)),\n        'd': Box(0, 1, shape=(3,))\n    }),",
        "detail": "deps.pufferlib.tests.test_nested",
        "documentation": {}
    },
    {
        "label": "rec_array",
        "kind": 5,
        "importPath": "deps.pufferlib.tests.test_nested",
        "description": "deps.pufferlib.tests.test_nested",
        "peekOfCode": "rec_array = np.rec.array(flat_sample, dtype=flat_dtype)\nrec_array = rec_array.view(dtype)\n'''\ntest_space = Dict({\n    'a': Box(0, 1, shape=(3,)),\n    'b': Dict({\n        'c': Box(0, 1, shape=(4,)),\n        'd': Box(0, 1, shape=(3,))\n    }),\n    'e': Box(0, 1, shape=(3,))",
        "detail": "deps.pufferlib.tests.test_nested",
        "documentation": {}
    },
    {
        "label": "rec_array",
        "kind": 5,
        "importPath": "deps.pufferlib.tests.test_nested",
        "description": "deps.pufferlib.tests.test_nested",
        "peekOfCode": "rec_array = rec_array.view(dtype)\n'''\ntest_space = Dict({\n    'a': Box(0, 1, shape=(3,)),\n    'b': Dict({\n        'c': Box(0, 1, shape=(4,)),\n        'd': Box(0, 1, shape=(3,))\n    }),\n    'e': Box(0, 1, shape=(3,))\n})",
        "detail": "deps.pufferlib.tests.test_nested",
        "documentation": {}
    },
    {
        "label": "test_space",
        "kind": 5,
        "importPath": "deps.pufferlib.tests.test_nested",
        "description": "deps.pufferlib.tests.test_nested",
        "peekOfCode": "test_space = Dict({\n    'a': Box(0, 1, shape=(3,)),\n    'b': Dict({\n        'c': Box(0, 1, shape=(4,)),\n        'd': Box(0, 1, shape=(3,))\n    }),\n    'e': Box(0, 1, shape=(3,))\n})\n'''\nbreakpoint()",
        "detail": "deps.pufferlib.tests.test_nested",
        "documentation": {}
    },
    {
        "label": "#A",
        "kind": 5,
        "importPath": "deps.pufferlib.tests.test_nested",
        "description": "deps.pufferlib.tests.test_nested",
        "peekOfCode": "#A = np.zeros(sz_bytes, dtype=np.uint8)\nflat = flatten(d)\nflat_dtype = mkdt_flat(d)\nrec_array = np.rec.array(flat, dtype=flat_dtype).view(dt)",
        "detail": "deps.pufferlib.tests.test_nested",
        "documentation": {}
    },
    {
        "label": "flat",
        "kind": 5,
        "importPath": "deps.pufferlib.tests.test_nested",
        "description": "deps.pufferlib.tests.test_nested",
        "peekOfCode": "flat = flatten(d)\nflat_dtype = mkdt_flat(d)\nrec_array = np.rec.array(flat, dtype=flat_dtype).view(dt)",
        "detail": "deps.pufferlib.tests.test_nested",
        "documentation": {}
    },
    {
        "label": "flat_dtype",
        "kind": 5,
        "importPath": "deps.pufferlib.tests.test_nested",
        "description": "deps.pufferlib.tests.test_nested",
        "peekOfCode": "flat_dtype = mkdt_flat(d)\nrec_array = np.rec.array(flat, dtype=flat_dtype).view(dt)",
        "detail": "deps.pufferlib.tests.test_nested",
        "documentation": {}
    },
    {
        "label": "rec_array",
        "kind": 5,
        "importPath": "deps.pufferlib.tests.test_nested",
        "description": "deps.pufferlib.tests.test_nested",
        "peekOfCode": "rec_array = np.rec.array(flat, dtype=flat_dtype).view(dt)",
        "detail": "deps.pufferlib.tests.test_nested",
        "documentation": {}
    },
    {
        "label": "fast_decode_map",
        "kind": 2,
        "importPath": "deps.pufferlib.tests.test_nmmo3_compile",
        "description": "deps.pufferlib.tests.test_nmmo3_compile",
        "peekOfCode": "def fast_decode_map(codes, obs, factors, add, div):\n    codes = codes.view(codes.shape[0], 1, -1)\n    dec = add + (codes//div) % factors\n    obs.scatter_(1, dec, 1)\n    return obs\n#@torch.compile(fullgraph=True, mode='reduce-overhead')\ndef decode_map(codes):\n    codes = codes.unsqueeze(1).long()\n    factors = [4, 4, 16, 5, 3, 5, 5, 6, 7, 4]\n    n_channels = sum(factors)",
        "detail": "deps.pufferlib.tests.test_nmmo3_compile",
        "documentation": {}
    },
    {
        "label": "decode_map",
        "kind": 2,
        "importPath": "deps.pufferlib.tests.test_nmmo3_compile",
        "description": "deps.pufferlib.tests.test_nmmo3_compile",
        "peekOfCode": "def decode_map(codes):\n    codes = codes.unsqueeze(1).long()\n    factors = [4, 4, 16, 5, 3, 5, 5, 6, 7, 4]\n    n_channels = sum(factors)\n    obs = torch.zeros(codes.shape[0], n_channels, 11, 15, device='cuda')\n    add, div = 0, 1\n    # TODO: check item/tier order\n    for mod in factors:\n        obs.scatter_(1, add+(codes//div)%mod, 1)\n        add += mod",
        "detail": "deps.pufferlib.tests.test_nmmo3_compile",
        "documentation": {}
    },
    {
        "label": "test_perf",
        "kind": 2,
        "importPath": "deps.pufferlib.tests.test_nmmo3_compile",
        "description": "deps.pufferlib.tests.test_nmmo3_compile",
        "peekOfCode": "def test_perf(n=100, agents=1024):\n    factors = np.array([4, 4, 16, 5, 3, 5, 5, 6, 7, 4])\n    n_channels = sum(factors)\n    add = np.array([0, *np.cumsum(factors).tolist()[:-1]])[None, :, None]\n    div = np.array([1, *np.cumprod(factors).tolist()[:-1]])[None, :, None]\n    factors = torch.tensor(factors)[None, :, None].cuda()\n    add = torch.tensor(add).cuda()\n    div = torch.tensor(div).cuda()\n    codes = torch.randint(0, 4*4*16*5*3*5*5*6*7*4, (agents, 11, 15)).cuda()\n    obs = torch.zeros(agents, n_channels, 11*15, device='cuda')",
        "detail": "deps.pufferlib.tests.test_nmmo3_compile",
        "documentation": {}
    },
    {
        "label": "TimedEnv",
        "kind": 6,
        "importPath": "deps.pufferlib.tests.test_performance",
        "description": "deps.pufferlib.tests.test_performance",
        "peekOfCode": "class TimedEnv:\n    def __init__(self, env):\n        self._env = env\n        self.reset_times = []\n        self.step_times = []\n    def __getattr__(self, name):\n        return getattr(self._env, name)\n    def step(self, *args, **kwargs):\n        start = time.time()\n        result = self._env.step(*args, **kwargs)",
        "detail": "deps.pufferlib.tests.test_performance",
        "documentation": {}
    },
    {
        "label": "profile_emulation",
        "kind": 2,
        "importPath": "deps.pufferlib.tests.test_performance",
        "description": "deps.pufferlib.tests.test_performance",
        "peekOfCode": "def profile_emulation(env_creator, timeout=DEFAULT_TIMEOUT, seed=42):\n    reset_times = []\n    step_times = []\n    agent_step_count = 0\n    terminal = False\n    truncated = False\n    reset = True\n    random.seed(seed)\n    np.random.seed(seed)\n    env = env_creator()",
        "detail": "deps.pufferlib.tests.test_performance",
        "documentation": {}
    },
    {
        "label": "profile_puffer",
        "kind": 2,
        "importPath": "deps.pufferlib.tests.test_performance",
        "description": "deps.pufferlib.tests.test_performance",
        "peekOfCode": "def profile_puffer(env_creator, timeout=DEFAULT_TIMEOUT, **kwargs):\n    vecenv = make(env_creator, **kwargs)\n    actions = [vecenv.action_space.sample() for _ in range(1000)]\n    agent_steps = 0\n    vecenv.reset()\n    start = time.time()\n    while time.time() - start < timeout:\n        vecenv.send(actions[agent_steps%1000])\n        o, r, d, t, i, env_id, mask = vecenv.recv()\n        agent_steps += sum(mask)",
        "detail": "deps.pufferlib.tests.test_performance",
        "documentation": {}
    },
    {
        "label": "profile_gymnasium_vec",
        "kind": 2,
        "importPath": "deps.pufferlib.tests.test_performance",
        "description": "deps.pufferlib.tests.test_performance",
        "peekOfCode": "def profile_gymnasium_vec(env_creator, num_envs, timeout=DEFAULT_TIMEOUT):\n    vecenv = gymnasium.vector.AsyncVectorEnv([env_creator] * num_envs)\n    actions = [vecenv.action_space.sample() for _ in range(1000)]\n    steps = 0\n    vecenv.reset()\n    start = time.time()\n    while time.time() - start < timeout:\n        vecenv.step(actions[steps%1000])\n        steps += 1\n    sps = steps * vecenv.num_envs / (time.time() - start)",
        "detail": "deps.pufferlib.tests.test_performance",
        "documentation": {}
    },
    {
        "label": "profile_sb3_vec",
        "kind": 2,
        "importPath": "deps.pufferlib.tests.test_performance",
        "description": "deps.pufferlib.tests.test_performance",
        "peekOfCode": "def profile_sb3_vec(env_creator, num_envs, timeout=DEFAULT_TIMEOUT):\n    with pufferlib.utils.Suppress():\n        from stable_baselines3.common.vec_env import SubprocVecEnv\n        vecenv = SubprocVecEnv([env_creator] * num_envs)\n        actions = [[vecenv.action_space.sample() for _ in range(num_envs)]\n            for _ in range(1000)]\n        steps = 0\n        vecenv.reset()\n        start = time.time()\n        while time.time() - start < timeout:",
        "detail": "deps.pufferlib.tests.test_performance",
        "documentation": {}
    },
    {
        "label": "profile_all",
        "kind": 2,
        "importPath": "deps.pufferlib.tests.test_performance",
        "description": "deps.pufferlib.tests.test_performance",
        "peekOfCode": "def profile_all(name, env_creator, num_envs, num_workers=24,\n        env_batch_size=None, zero_copy=True, timeout=DEFAULT_TIMEOUT):\n    if env_batch_size is None:\n        env_batch_size = num_envs\n    print(name)\n    profile_emulation(env_creator, timeout=timeout)\n    profile_puffer(env_creator, num_envs=env_batch_size,\n        backend=Multiprocessing, timeout=timeout,\n        num_workers=min(num_workers, env_batch_size),\n    )",
        "detail": "deps.pufferlib.tests.test_performance",
        "documentation": {}
    },
    {
        "label": "DEFAULT_TIMEOUT",
        "kind": 5,
        "importPath": "deps.pufferlib.tests.test_performance",
        "description": "deps.pufferlib.tests.test_performance",
        "peekOfCode": "DEFAULT_TIMEOUT = 10\nimport time\nfrom functools import wraps\nclass TimedEnv:\n    def __init__(self, env):\n        self._env = env\n        self.reset_times = []\n        self.step_times = []\n    def __getattr__(self, name):\n        return getattr(self._env, name)",
        "detail": "deps.pufferlib.tests.test_performance",
        "documentation": {}
    },
    {
        "label": "env",
        "kind": 5,
        "importPath": "deps.pufferlib.tests.test_pokemon_red",
        "description": "deps.pufferlib.tests.test_pokemon_red",
        "peekOfCode": "env = env_creator()()\nob, info = env.reset()\nfor i in range(100):\n    ob, reward, terminal, truncated, info = env.step(env.action_space.sample())\n    print(f'Step: {i}, Info: {info}')\nenv.close()",
        "detail": "deps.pufferlib.tests.test_pokemon_red",
        "documentation": {}
    },
    {
        "label": "MockPolicy",
        "kind": 6,
        "importPath": "deps.pufferlib.tests.test_policy_pool",
        "description": "deps.pufferlib.tests.test_policy_pool",
        "peekOfCode": "class MockPolicy:\n    def __call__(self, obs):\n        batch_size = obs.shape[0]\n        actions = torch.arange(batch_size * ACTION_DIM).view(batch_size, ACTION_DIM)\n        logprobs = torch.arange(batch_size, dtype=torch.float32)\n        values = torch.arange(batch_size, dtype=torch.float32) + 10  # add to make the values different\n        return actions, logprobs, None, values\nclass MockPolicyStore:\n    def __init__(self, num_policies):\n        self._policies = {f'Policy{i+1}': MockPolicy() for i in range(num_policies)}",
        "detail": "deps.pufferlib.tests.test_policy_pool",
        "documentation": {}
    },
    {
        "label": "MockPolicyStore",
        "kind": 6,
        "importPath": "deps.pufferlib.tests.test_policy_pool",
        "description": "deps.pufferlib.tests.test_policy_pool",
        "peekOfCode": "class MockPolicyStore:\n    def __init__(self, num_policies):\n        self._policies = {f'Policy{i+1}': MockPolicy() for i in range(num_policies)}\n        self.path = 'mock_policy_store'\n    def policy_names(self):\n        return list(self._policies.keys())\n    def get_policy(self, name):\n        return self._policies[name]\nclass TestPolicyPool(unittest.TestCase):\n    def setUp(self):",
        "detail": "deps.pufferlib.tests.test_policy_pool",
        "documentation": {}
    },
    {
        "label": "TestPolicyPool",
        "kind": 6,
        "importPath": "deps.pufferlib.tests.test_policy_pool",
        "description": "deps.pufferlib.tests.test_policy_pool",
        "peekOfCode": "class TestPolicyPool(unittest.TestCase):\n    def setUp(self):\n        self.mock_nonrecurrent_policy = MockPolicy()\n        self.mock_nonrecurrent_policy.name = 'BasePolicy1'\n        self.nonrecurrent_policy_pool = pp.PolicyPool(\n            policy=self.mock_nonrecurrent_policy,\n            total_agents=POOL_AGENTS,\n            atn_shape=(ACTION_DIM,),\n            device='cpu',\n            policy_store=MockPolicyStore(3),",
        "detail": "deps.pufferlib.tests.test_policy_pool",
        "documentation": {}
    },
    {
        "label": "NUM_AGENTS",
        "kind": 5,
        "importPath": "deps.pufferlib.tests.test_policy_pool",
        "description": "deps.pufferlib.tests.test_policy_pool",
        "peekOfCode": "NUM_AGENTS = 4\nNUM_ENVS = 2\nPOOL_AGENTS = NUM_AGENTS * NUM_ENVS  # batch size\nOBS_DIM = 3\nACTION_DIM = 5\n# TODO: add test for recurrent policy forward\nBPTT_HORIZON = 16\nLSTM_INPUT_DIM = POOL_AGENTS * BPTT_HORIZON\nLSTM_HIDDEN_DIM = 32\nclass MockPolicy:",
        "detail": "deps.pufferlib.tests.test_policy_pool",
        "documentation": {}
    },
    {
        "label": "NUM_ENVS",
        "kind": 5,
        "importPath": "deps.pufferlib.tests.test_policy_pool",
        "description": "deps.pufferlib.tests.test_policy_pool",
        "peekOfCode": "NUM_ENVS = 2\nPOOL_AGENTS = NUM_AGENTS * NUM_ENVS  # batch size\nOBS_DIM = 3\nACTION_DIM = 5\n# TODO: add test for recurrent policy forward\nBPTT_HORIZON = 16\nLSTM_INPUT_DIM = POOL_AGENTS * BPTT_HORIZON\nLSTM_HIDDEN_DIM = 32\nclass MockPolicy:\n    def __call__(self, obs):",
        "detail": "deps.pufferlib.tests.test_policy_pool",
        "documentation": {}
    },
    {
        "label": "POOL_AGENTS",
        "kind": 5,
        "importPath": "deps.pufferlib.tests.test_policy_pool",
        "description": "deps.pufferlib.tests.test_policy_pool",
        "peekOfCode": "POOL_AGENTS = NUM_AGENTS * NUM_ENVS  # batch size\nOBS_DIM = 3\nACTION_DIM = 5\n# TODO: add test for recurrent policy forward\nBPTT_HORIZON = 16\nLSTM_INPUT_DIM = POOL_AGENTS * BPTT_HORIZON\nLSTM_HIDDEN_DIM = 32\nclass MockPolicy:\n    def __call__(self, obs):\n        batch_size = obs.shape[0]",
        "detail": "deps.pufferlib.tests.test_policy_pool",
        "documentation": {}
    },
    {
        "label": "OBS_DIM",
        "kind": 5,
        "importPath": "deps.pufferlib.tests.test_policy_pool",
        "description": "deps.pufferlib.tests.test_policy_pool",
        "peekOfCode": "OBS_DIM = 3\nACTION_DIM = 5\n# TODO: add test for recurrent policy forward\nBPTT_HORIZON = 16\nLSTM_INPUT_DIM = POOL_AGENTS * BPTT_HORIZON\nLSTM_HIDDEN_DIM = 32\nclass MockPolicy:\n    def __call__(self, obs):\n        batch_size = obs.shape[0]\n        actions = torch.arange(batch_size * ACTION_DIM).view(batch_size, ACTION_DIM)",
        "detail": "deps.pufferlib.tests.test_policy_pool",
        "documentation": {}
    },
    {
        "label": "ACTION_DIM",
        "kind": 5,
        "importPath": "deps.pufferlib.tests.test_policy_pool",
        "description": "deps.pufferlib.tests.test_policy_pool",
        "peekOfCode": "ACTION_DIM = 5\n# TODO: add test for recurrent policy forward\nBPTT_HORIZON = 16\nLSTM_INPUT_DIM = POOL_AGENTS * BPTT_HORIZON\nLSTM_HIDDEN_DIM = 32\nclass MockPolicy:\n    def __call__(self, obs):\n        batch_size = obs.shape[0]\n        actions = torch.arange(batch_size * ACTION_DIM).view(batch_size, ACTION_DIM)\n        logprobs = torch.arange(batch_size, dtype=torch.float32)",
        "detail": "deps.pufferlib.tests.test_policy_pool",
        "documentation": {}
    },
    {
        "label": "BPTT_HORIZON",
        "kind": 5,
        "importPath": "deps.pufferlib.tests.test_policy_pool",
        "description": "deps.pufferlib.tests.test_policy_pool",
        "peekOfCode": "BPTT_HORIZON = 16\nLSTM_INPUT_DIM = POOL_AGENTS * BPTT_HORIZON\nLSTM_HIDDEN_DIM = 32\nclass MockPolicy:\n    def __call__(self, obs):\n        batch_size = obs.shape[0]\n        actions = torch.arange(batch_size * ACTION_DIM).view(batch_size, ACTION_DIM)\n        logprobs = torch.arange(batch_size, dtype=torch.float32)\n        values = torch.arange(batch_size, dtype=torch.float32) + 10  # add to make the values different\n        return actions, logprobs, None, values",
        "detail": "deps.pufferlib.tests.test_policy_pool",
        "documentation": {}
    },
    {
        "label": "LSTM_INPUT_DIM",
        "kind": 5,
        "importPath": "deps.pufferlib.tests.test_policy_pool",
        "description": "deps.pufferlib.tests.test_policy_pool",
        "peekOfCode": "LSTM_INPUT_DIM = POOL_AGENTS * BPTT_HORIZON\nLSTM_HIDDEN_DIM = 32\nclass MockPolicy:\n    def __call__(self, obs):\n        batch_size = obs.shape[0]\n        actions = torch.arange(batch_size * ACTION_DIM).view(batch_size, ACTION_DIM)\n        logprobs = torch.arange(batch_size, dtype=torch.float32)\n        values = torch.arange(batch_size, dtype=torch.float32) + 10  # add to make the values different\n        return actions, logprobs, None, values\nclass MockPolicyStore:",
        "detail": "deps.pufferlib.tests.test_policy_pool",
        "documentation": {}
    },
    {
        "label": "LSTM_HIDDEN_DIM",
        "kind": 5,
        "importPath": "deps.pufferlib.tests.test_policy_pool",
        "description": "deps.pufferlib.tests.test_policy_pool",
        "peekOfCode": "LSTM_HIDDEN_DIM = 32\nclass MockPolicy:\n    def __call__(self, obs):\n        batch_size = obs.shape[0]\n        actions = torch.arange(batch_size * ACTION_DIM).view(batch_size, ACTION_DIM)\n        logprobs = torch.arange(batch_size, dtype=torch.float32)\n        values = torch.arange(batch_size, dtype=torch.float32) + 10  # add to make the values different\n        return actions, logprobs, None, values\nclass MockPolicyStore:\n    def __init__(self, num_policies):",
        "detail": "deps.pufferlib.tests.test_policy_pool",
        "documentation": {}
    },
    {
        "label": "test_nativize_dtype",
        "kind": 2,
        "importPath": "deps.pufferlib.tests.test_pytorch",
        "description": "deps.pufferlib.tests.test_pytorch",
        "peekOfCode": "def test_nativize_dtype(\n    observation_dtype: np.array, emulated_dtype: np.array, expected: NativeDType\n):\n    assert expected == nativize_dtype(\n        pufferlib.namespace(\n            observation_dtype=observation_dtype,\n            emulated_observation_dtype=emulated_dtype,\n        )\n    )\n@pytest.mark.parametrize(",
        "detail": "deps.pufferlib.tests.test_pytorch",
        "documentation": {}
    },
    {
        "label": "test_nativize_tensor",
        "kind": 2,
        "importPath": "deps.pufferlib.tests.test_pytorch",
        "description": "deps.pufferlib.tests.test_pytorch",
        "peekOfCode": "def test_nativize_tensor(space: gym.spaces.Space, sample_dtype: np.dtype):\n    emulated_dtype = pufferlib.emulation.dtype_from_space(space)\n    observation_space, observation_dtype = (\n        pufferlib.emulation.emulate_observation_space(space)\n    )\n    native_dtype = nativize_dtype(\n        pufferlib.namespace(\n            observation_dtype=sample_dtype,\n            emulated_observation_dtype=emulated_dtype,\n        )",
        "detail": "deps.pufferlib.tests.test_pytorch",
        "documentation": {}
    },
    {
        "label": "create_dtype_from_space",
        "kind": 2,
        "importPath": "deps.pufferlib.tests.test_record_array",
        "description": "deps.pufferlib.tests.test_record_array",
        "peekOfCode": "def create_dtype_from_space(space):\n    if isinstance(space, gym.spaces.Dict):\n        dtype_fields = [(name, create_dtype_from_space(subspace)) for name, subspace in space.spaces.items()]\n        return np.dtype(dtype_fields)\n    elif isinstance(space, gym.spaces.Tuple):\n        dtype_fields = [('field' + str(i), create_dtype_from_space(subspace)) for i, subspace in enumerate(space.spaces)]\n        return np.dtype(dtype_fields)\n    elif isinstance(space, gym.spaces.Box):\n        return (space.dtype, space.shape)\n    elif isinstance(space, gym.spaces.Discrete):",
        "detail": "deps.pufferlib.tests.test_record_array",
        "documentation": {}
    },
    {
        "label": "sample_and_convert",
        "kind": 2,
        "importPath": "deps.pufferlib.tests.test_record_array",
        "description": "deps.pufferlib.tests.test_record_array",
        "peekOfCode": "def sample_and_convert(space, dtype):\n    sample = space.sample()\n    flat_sample = {}\n    def flatten(sample, name_prefix=\"\"):\n        for key, item in sample.items():\n            full_key = name_prefix + key if name_prefix == \"\" else name_prefix + \"_\" + key\n            if isinstance(item, dict):\n                flatten(item, full_key)\n            else:\n                flat_sample[full_key] = item",
        "detail": "deps.pufferlib.tests.test_record_array",
        "documentation": {}
    },
    {
        "label": "space",
        "kind": 5,
        "importPath": "deps.pufferlib.tests.test_record_array",
        "description": "deps.pufferlib.tests.test_record_array",
        "peekOfCode": "space = gym.spaces.Dict({\n    \"position\": gym.spaces.Box(low=-1.0, high=1.0, shape=(2,), dtype=np.float32),\n    \"velocity\": gym.spaces.Box(low=-1.0, high=1.0, shape=(2,), dtype=np.float32),\n    \"description\": gym.spaces.Tuple((\n        #gym.spaces.Discrete(10),\n        gym.spaces.Box(low=0, high=100, shape=(), dtype=np.int32),\n        gym.spaces.Box(low=0, high=100, shape=(), dtype=np.int32)\n    ))\n})\nspace = gym.spaces.Dict({",
        "detail": "deps.pufferlib.tests.test_record_array",
        "documentation": {}
    },
    {
        "label": "space",
        "kind": 5,
        "importPath": "deps.pufferlib.tests.test_record_array",
        "description": "deps.pufferlib.tests.test_record_array",
        "peekOfCode": "space = gym.spaces.Dict({\n    \"position\": gym.spaces.Box(low=-1.0, high=1.0, shape=(2,), dtype=np.float32),\n})\n# Define a function to create a dtype from the Gym space\ndef create_dtype_from_space(space):\n    if isinstance(space, gym.spaces.Dict):\n        dtype_fields = [(name, create_dtype_from_space(subspace)) for name, subspace in space.spaces.items()]\n        return np.dtype(dtype_fields)\n    elif isinstance(space, gym.spaces.Tuple):\n        dtype_fields = [('field' + str(i), create_dtype_from_space(subspace)) for i, subspace in enumerate(space.spaces)]",
        "detail": "deps.pufferlib.tests.test_record_array",
        "documentation": {}
    },
    {
        "label": "space_dtype",
        "kind": 5,
        "importPath": "deps.pufferlib.tests.test_record_array",
        "description": "deps.pufferlib.tests.test_record_array",
        "peekOfCode": "space_dtype = create_dtype_from_space(space)\nsample = dict(space.sample())\nbreakpoint()\nnp.rec.array(sample, dtype=space_dtype)\n# Function to sample from the space and convert to a structured numpy array\ndef sample_and_convert(space, dtype):\n    sample = space.sample()\n    flat_sample = {}\n    def flatten(sample, name_prefix=\"\"):\n        for key, item in sample.items():",
        "detail": "deps.pufferlib.tests.test_record_array",
        "documentation": {}
    },
    {
        "label": "sample",
        "kind": 5,
        "importPath": "deps.pufferlib.tests.test_record_array",
        "description": "deps.pufferlib.tests.test_record_array",
        "peekOfCode": "sample = dict(space.sample())\nbreakpoint()\nnp.rec.array(sample, dtype=space_dtype)\n# Function to sample from the space and convert to a structured numpy array\ndef sample_and_convert(space, dtype):\n    sample = space.sample()\n    flat_sample = {}\n    def flatten(sample, name_prefix=\"\"):\n        for key, item in sample.items():\n            full_key = name_prefix + key if name_prefix == \"\" else name_prefix + \"_\" + key",
        "detail": "deps.pufferlib.tests.test_record_array",
        "documentation": {}
    },
    {
        "label": "num_samples",
        "kind": 5,
        "importPath": "deps.pufferlib.tests.test_record_array",
        "description": "deps.pufferlib.tests.test_record_array",
        "peekOfCode": "num_samples = 3\nsamples = [sample_and_convert(space, space_dtype) for _ in range(num_samples)]\nprint(\"Samples:\", samples)\nrecord_array = np.rec.array(samples)\nprint(\"Record Array:\", record_array)\nbytes_array = record_array.tobytes()\nprint(\"Bytes Array:\", bytes_array)\nrecord_array = np.rec.array(bytes_array, dtype=space_dtype)\nprint(\"Record Array from Bytes:\", record_array)",
        "detail": "deps.pufferlib.tests.test_record_array",
        "documentation": {}
    },
    {
        "label": "samples",
        "kind": 5,
        "importPath": "deps.pufferlib.tests.test_record_array",
        "description": "deps.pufferlib.tests.test_record_array",
        "peekOfCode": "samples = [sample_and_convert(space, space_dtype) for _ in range(num_samples)]\nprint(\"Samples:\", samples)\nrecord_array = np.rec.array(samples)\nprint(\"Record Array:\", record_array)\nbytes_array = record_array.tobytes()\nprint(\"Bytes Array:\", bytes_array)\nrecord_array = np.rec.array(bytes_array, dtype=space_dtype)\nprint(\"Record Array from Bytes:\", record_array)",
        "detail": "deps.pufferlib.tests.test_record_array",
        "documentation": {}
    },
    {
        "label": "record_array",
        "kind": 5,
        "importPath": "deps.pufferlib.tests.test_record_array",
        "description": "deps.pufferlib.tests.test_record_array",
        "peekOfCode": "record_array = np.rec.array(samples)\nprint(\"Record Array:\", record_array)\nbytes_array = record_array.tobytes()\nprint(\"Bytes Array:\", bytes_array)\nrecord_array = np.rec.array(bytes_array, dtype=space_dtype)\nprint(\"Record Array from Bytes:\", record_array)",
        "detail": "deps.pufferlib.tests.test_record_array",
        "documentation": {}
    },
    {
        "label": "bytes_array",
        "kind": 5,
        "importPath": "deps.pufferlib.tests.test_record_array",
        "description": "deps.pufferlib.tests.test_record_array",
        "peekOfCode": "bytes_array = record_array.tobytes()\nprint(\"Bytes Array:\", bytes_array)\nrecord_array = np.rec.array(bytes_array, dtype=space_dtype)\nprint(\"Record Array from Bytes:\", record_array)",
        "detail": "deps.pufferlib.tests.test_record_array",
        "documentation": {}
    },
    {
        "label": "record_array",
        "kind": 5,
        "importPath": "deps.pufferlib.tests.test_record_array",
        "description": "deps.pufferlib.tests.test_record_array",
        "peekOfCode": "record_array = np.rec.array(bytes_array, dtype=space_dtype)\nprint(\"Record Array from Bytes:\", record_array)",
        "detail": "deps.pufferlib.tests.test_record_array",
        "documentation": {}
    },
    {
        "label": "env",
        "kind": 5,
        "importPath": "deps.pufferlib.tests.test_record_emulation",
        "description": "deps.pufferlib.tests.test_record_emulation",
        "peekOfCode": "env = env_creator('spaces')()\nenv.reset()\nenv.step([1,0])\nbreakpoint()",
        "detail": "deps.pufferlib.tests.test_record_emulation",
        "documentation": {}
    },
    {
        "label": "Dashboard",
        "kind": 6,
        "importPath": "deps.pufferlib.tests.test_rich",
        "description": "deps.pufferlib.tests.test_rich",
        "peekOfCode": "class Dashboard:\n    def __init__(self):\n        self.console = Console()\n        self.rich = rich\n        layout = Layout()\n        layout.split(\n            Layout(name=\"utilization\", size=5),\n            Layout(name=\"monitoring\"),\n        )\n        self.layout = layout",
        "detail": "deps.pufferlib.tests.test_rich",
        "documentation": {}
    },
    {
        "label": "abbreviate",
        "kind": 2,
        "importPath": "deps.pufferlib.tests.test_rich",
        "description": "deps.pufferlib.tests.test_rich",
        "peekOfCode": "def abbreviate(num):\n    if num < 1e3:\n        return f\"{num:.0f}\"\n    elif num < 1e6:\n        return f\"{num/1e3:.1f}k\"\n    elif num < 1e9:\n        return f\"{num/1e6:.1f}m\"\n    elif num < 1e12:\n        return f\"{num/1e9:.1f}b\"\n    else:",
        "detail": "deps.pufferlib.tests.test_rich",
        "documentation": {}
    },
    {
        "label": "duration",
        "kind": 2,
        "importPath": "deps.pufferlib.tests.test_rich",
        "description": "deps.pufferlib.tests.test_rich",
        "peekOfCode": "def duration(seconds):\n    h = seconds // 3600\n    m = (seconds % 3600) // 60\n    s = seconds % 60\n    return f\"{h}h {m}m {s}s\" if h else f\"{m}m {s}s\" if m else f\"{s}s\"\ndef print_dashboard(performance_data, loss_data, user_data, min_interval=0.25, last_print=[0]):\n    console = Console()\n    util = Table(box=None, expand=True, show_header=False)\n    cpu_percent = psutil.cpu_percent()\n    dram_percent = psutil.virtual_memory().percent",
        "detail": "deps.pufferlib.tests.test_rich",
        "documentation": {}
    },
    {
        "label": "print_dashboard",
        "kind": 2,
        "importPath": "deps.pufferlib.tests.test_rich",
        "description": "deps.pufferlib.tests.test_rich",
        "peekOfCode": "def print_dashboard(performance_data, loss_data, user_data, min_interval=0.25, last_print=[0]):\n    console = Console()\n    util = Table(box=None, expand=True, show_header=False)\n    cpu_percent = psutil.cpu_percent()\n    dram_percent = psutil.virtual_memory().percent\n    gpus = GPUtil.getGPUs()\n    gpu_percent = gpus[0].load * 100 if gpus else 0\n    vram_percent = gpus[0].memoryUtil * 100 if gpus else 0\n    util.add_column(justify=\"left\")\n    util.add_column(justify=\"center\")",
        "detail": "deps.pufferlib.tests.test_rich",
        "documentation": {}
    },
    {
        "label": "ROUND_OPEN",
        "kind": 5,
        "importPath": "deps.pufferlib.tests.test_rich",
        "description": "deps.pufferlib.tests.test_rich",
        "peekOfCode": "ROUND_OPEN = rich.box.Box(\n    \"\\n\"\n    \"  \\n\"\n    \"  \\n\"\n    \"  \\n\"\n    \"  \\n\"\n    \"  \\n\"\n    \"  \\n\"\n    \"\\n\"\n)",
        "detail": "deps.pufferlib.tests.test_rich",
        "documentation": {}
    },
    {
        "label": "c1",
        "kind": 5,
        "importPath": "deps.pufferlib.tests.test_rich",
        "description": "deps.pufferlib.tests.test_rich",
        "peekOfCode": "c1 = '[bright_cyan]'\nc2 = '[white]'\nc3 = '[cyan]'\nb1 = '[bright_cyan]'\nb2 = '[bright_white]'\ndef abbreviate(num):\n    if num < 1e3:\n        return f\"{num:.0f}\"\n    elif num < 1e6:\n        return f\"{num/1e3:.1f}k\"",
        "detail": "deps.pufferlib.tests.test_rich",
        "documentation": {}
    },
    {
        "label": "c2",
        "kind": 5,
        "importPath": "deps.pufferlib.tests.test_rich",
        "description": "deps.pufferlib.tests.test_rich",
        "peekOfCode": "c2 = '[white]'\nc3 = '[cyan]'\nb1 = '[bright_cyan]'\nb2 = '[bright_white]'\ndef abbreviate(num):\n    if num < 1e3:\n        return f\"{num:.0f}\"\n    elif num < 1e6:\n        return f\"{num/1e3:.1f}k\"\n    elif num < 1e9:",
        "detail": "deps.pufferlib.tests.test_rich",
        "documentation": {}
    },
    {
        "label": "c3",
        "kind": 5,
        "importPath": "deps.pufferlib.tests.test_rich",
        "description": "deps.pufferlib.tests.test_rich",
        "peekOfCode": "c3 = '[cyan]'\nb1 = '[bright_cyan]'\nb2 = '[bright_white]'\ndef abbreviate(num):\n    if num < 1e3:\n        return f\"{num:.0f}\"\n    elif num < 1e6:\n        return f\"{num/1e3:.1f}k\"\n    elif num < 1e9:\n        return f\"{num/1e6:.1f}m\"",
        "detail": "deps.pufferlib.tests.test_rich",
        "documentation": {}
    },
    {
        "label": "b1",
        "kind": 5,
        "importPath": "deps.pufferlib.tests.test_rich",
        "description": "deps.pufferlib.tests.test_rich",
        "peekOfCode": "b1 = '[bright_cyan]'\nb2 = '[bright_white]'\ndef abbreviate(num):\n    if num < 1e3:\n        return f\"{num:.0f}\"\n    elif num < 1e6:\n        return f\"{num/1e3:.1f}k\"\n    elif num < 1e9:\n        return f\"{num/1e6:.1f}m\"\n    elif num < 1e12:",
        "detail": "deps.pufferlib.tests.test_rich",
        "documentation": {}
    },
    {
        "label": "b2",
        "kind": 5,
        "importPath": "deps.pufferlib.tests.test_rich",
        "description": "deps.pufferlib.tests.test_rich",
        "peekOfCode": "b2 = '[bright_white]'\ndef abbreviate(num):\n    if num < 1e3:\n        return f\"{num:.0f}\"\n    elif num < 1e6:\n        return f\"{num/1e3:.1f}k\"\n    elif num < 1e9:\n        return f\"{num/1e6:.1f}m\"\n    elif num < 1e12:\n        return f\"{num/1e9:.1f}b\"",
        "detail": "deps.pufferlib.tests.test_rich",
        "documentation": {}
    },
    {
        "label": "#dashboard",
        "kind": 5,
        "importPath": "deps.pufferlib.tests.test_rich",
        "description": "deps.pufferlib.tests.test_rich",
        "peekOfCode": "#dashboard = Dashboard()\n# Update loop\ntry:\n    while True:\n        #dashboard._update_utilization()\n        topline = (5000, 100000, 102332, 1038, 1.3)\n        performance = {\n            'training': 0.7,\n            'evaluation': 0.6,\n            'environment': 0.2,",
        "detail": "deps.pufferlib.tests.test_rich",
        "documentation": {}
    },
    {
        "label": "test_suppress",
        "kind": 2,
        "importPath": "deps.pufferlib.tests.test_utils",
        "description": "deps.pufferlib.tests.test_utils",
        "peekOfCode": "def test_suppress():\n    with pufferlib.utils.Suppress():\n        gym.make('Breakout-v4')\n        print('stdout (you should not see this)', file=sys.stdout)\n        print('stderr (you should not see this)', file=sys.stderr)\nif __name__ == '__main__':\n    test_suppress()",
        "detail": "deps.pufferlib.tests.test_utils",
        "documentation": {}
    },
    {
        "label": "time_zeros",
        "kind": 5,
        "importPath": "deps.pufferlib.tests.time_alloc",
        "description": "deps.pufferlib.tests.time_alloc",
        "peekOfCode": "time_zeros = timeit.timeit('np.zeros((2, 5))', setup='import numpy as np', number=100000)\n# Pre-allocate the array\npreallocated_array = np.zeros((2, 5))\n# Time setting the pre-allocated array to zero for 100000 iterations\ntime_preallocated = timeit.timeit('preallocated_array[:] = 0', setup='import numpy as np; preallocated_array = np.zeros((2, 5))', number=100000)\nprint(f\"Time for np.zeros(2, 5) over 100000 iterations: {time_zeros} seconds\")\nprint(f\"Time for preallocated *= 0 over 100000 iterations: {time_preallocated} seconds\")",
        "detail": "deps.pufferlib.tests.time_alloc",
        "documentation": {}
    },
    {
        "label": "preallocated_array",
        "kind": 5,
        "importPath": "deps.pufferlib.tests.time_alloc",
        "description": "deps.pufferlib.tests.time_alloc",
        "peekOfCode": "preallocated_array = np.zeros((2, 5))\n# Time setting the pre-allocated array to zero for 100000 iterations\ntime_preallocated = timeit.timeit('preallocated_array[:] = 0', setup='import numpy as np; preallocated_array = np.zeros((2, 5))', number=100000)\nprint(f\"Time for np.zeros(2, 5) over 100000 iterations: {time_zeros} seconds\")\nprint(f\"Time for preallocated *= 0 over 100000 iterations: {time_preallocated} seconds\")",
        "detail": "deps.pufferlib.tests.time_alloc",
        "documentation": {}
    },
    {
        "label": "time_preallocated",
        "kind": 5,
        "importPath": "deps.pufferlib.tests.time_alloc",
        "description": "deps.pufferlib.tests.time_alloc",
        "peekOfCode": "time_preallocated = timeit.timeit('preallocated_array[:] = 0', setup='import numpy as np; preallocated_array = np.zeros((2, 5))', number=100000)\nprint(f\"Time for np.zeros(2, 5) over 100000 iterations: {time_zeros} seconds\")\nprint(f\"Time for preallocated *= 0 over 100000 iterations: {time_preallocated} seconds\")",
        "detail": "deps.pufferlib.tests.time_alloc",
        "documentation": {}
    },
    {
        "label": "Profile",
        "kind": 6,
        "importPath": "deps.pufferlib.clean_pufferl",
        "description": "deps.pufferlib.clean_pufferl",
        "peekOfCode": "class Profile:\n    SPS: ... = 0\n    uptime: ... = 0\n    remaining: ... = 0\n    eval_time: ... = 0\n    env_time: ... = 0\n    eval_forward_time: ... = 0\n    eval_misc_time: ... = 0\n    train_time: ... = 0\n    train_forward_time: ... = 0",
        "detail": "deps.pufferlib.clean_pufferl",
        "documentation": {}
    },
    {
        "label": "Experience",
        "kind": 6,
        "importPath": "deps.pufferlib.clean_pufferl",
        "description": "deps.pufferlib.clean_pufferl",
        "peekOfCode": "class Experience:\n    '''Flat tensor storage and array views for faster indexing'''\n    def __init__(self, batch_size, bptt_horizon, minibatch_size, obs_shape, obs_dtype, atn_shape, atn_dtype,\n                 cpu_offload=False, device='cuda', lstm=None, lstm_total_agents=0):\n        if minibatch_size is None:\n            minibatch_size = batch_size\n        obs_dtype = pufferlib.pytorch.numpy_to_torch_dtype_dict[obs_dtype]\n        atn_dtype = pufferlib.pytorch.numpy_to_torch_dtype_dict[atn_dtype]\n        pin = device == 'cuda' and cpu_offload\n        obs_device = device if not pin else 'cpu'",
        "detail": "deps.pufferlib.clean_pufferl",
        "documentation": {}
    },
    {
        "label": "Utilization",
        "kind": 6,
        "importPath": "deps.pufferlib.clean_pufferl",
        "description": "deps.pufferlib.clean_pufferl",
        "peekOfCode": "class Utilization(Thread):\n    def __init__(self, delay=1, maxlen=20):\n        super().__init__()\n        self.cpu_mem = deque(maxlen=maxlen)\n        self.cpu_util = deque(maxlen=maxlen)\n        self.gpu_util = deque(maxlen=maxlen)\n        self.gpu_mem = deque(maxlen=maxlen)\n        self.delay = delay\n        self.stopped = False\n        self.start()",
        "detail": "deps.pufferlib.clean_pufferl",
        "documentation": {}
    },
    {
        "label": "create",
        "kind": 2,
        "importPath": "deps.pufferlib.clean_pufferl",
        "description": "deps.pufferlib.clean_pufferl",
        "peekOfCode": "def create(config, vecenv, policy, optimizer=None, wandb=None):\n    seed_everything(config.seed, config.torch_deterministic)\n    profile = Profile()\n    losses = make_losses()\n    utilization = Utilization()\n    msg = f'Model Size: {abbreviate(count_params(policy))} parameters'\n    print_dashboard(config.env, utilization, 0, 0, profile, losses, {}, msg, clear=True)\n    vecenv.async_reset(config.seed)\n    obs_shape = vecenv.single_observation_space.shape\n    obs_dtype = vecenv.single_observation_space.dtype",
        "detail": "deps.pufferlib.clean_pufferl",
        "documentation": {}
    },
    {
        "label": "evaluate",
        "kind": 2,
        "importPath": "deps.pufferlib.clean_pufferl",
        "description": "deps.pufferlib.clean_pufferl",
        "peekOfCode": "def evaluate(data):\n    config, profile, experience = data.config, data.profile, data.experience\n    with profile.eval_misc:\n        policy = data.policy\n        infos = defaultdict(list)\n        lstm_h, lstm_c = experience.lstm_h, experience.lstm_c\n    while not experience.full:\n        with profile.env:\n            o, r, d, t, info, env_id, mask = data.vecenv.recv()\n            env_id = env_id.tolist()",
        "detail": "deps.pufferlib.clean_pufferl",
        "documentation": {}
    },
    {
        "label": "train",
        "kind": 2,
        "importPath": "deps.pufferlib.clean_pufferl",
        "description": "deps.pufferlib.clean_pufferl",
        "peekOfCode": "def train(data):\n    config, profile, experience = data.config, data.profile, data.experience\n    data.losses = make_losses()\n    losses = data.losses\n    with profile.train_misc:\n        idxs = experience.sort_training_data()\n        dones_np = experience.dones_np[idxs]\n        values_np = experience.values_np[idxs]\n        rewards_np = experience.rewards_np[idxs]\n        # TODO: bootstrap between segment bounds",
        "detail": "deps.pufferlib.clean_pufferl",
        "documentation": {}
    },
    {
        "label": "mean_and_log",
        "kind": 2,
        "importPath": "deps.pufferlib.clean_pufferl",
        "description": "deps.pufferlib.clean_pufferl",
        "peekOfCode": "def mean_and_log(data):\n    for k in list(data.stats.keys()):\n        v = data.stats[k]\n        try:\n            v = np.mean(v)\n        except:\n            del data.stats[k]\n        data.stats[k] = v\n    if data.wandb is None:\n        return",
        "detail": "deps.pufferlib.clean_pufferl",
        "documentation": {}
    },
    {
        "label": "close",
        "kind": 2,
        "importPath": "deps.pufferlib.clean_pufferl",
        "description": "deps.pufferlib.clean_pufferl",
        "peekOfCode": "def close(data):\n    data.vecenv.close()\n    data.utilization.stop()\n    config = data.config\n    if data.wandb is not None:\n        artifact_name = f\"{config.exp_id}_model\"\n        artifact = data.wandb.Artifact(artifact_name, type=\"model\")\n        model_path = save_checkpoint(data)\n        artifact.add_file(model_path)\n        data.wandb.run.log_artifact(artifact)",
        "detail": "deps.pufferlib.clean_pufferl",
        "documentation": {}
    },
    {
        "label": "make_losses",
        "kind": 2,
        "importPath": "deps.pufferlib.clean_pufferl",
        "description": "deps.pufferlib.clean_pufferl",
        "peekOfCode": "def make_losses():\n    return pufferlib.namespace(\n        policy_loss=0,\n        value_loss=0,\n        entropy=0,\n        old_approx_kl=0,\n        approx_kl=0,\n        clipfrac=0,\n        explained_variance=0,\n    )",
        "detail": "deps.pufferlib.clean_pufferl",
        "documentation": {}
    },
    {
        "label": "save_checkpoint",
        "kind": 2,
        "importPath": "deps.pufferlib.clean_pufferl",
        "description": "deps.pufferlib.clean_pufferl",
        "peekOfCode": "def save_checkpoint(data):\n    config = data.config\n    path = os.path.join(config.data_dir, config.exp_id)\n    if not os.path.exists(path):\n        os.makedirs(path)\n    model_name = f'model_{data.epoch:06d}.pt'\n    model_path = os.path.join(path, model_name)\n    if os.path.exists(model_path):\n        return model_path\n    torch.save(data.uncompiled_policy, model_path)",
        "detail": "deps.pufferlib.clean_pufferl",
        "documentation": {}
    },
    {
        "label": "try_load_checkpoint",
        "kind": 2,
        "importPath": "deps.pufferlib.clean_pufferl",
        "description": "deps.pufferlib.clean_pufferl",
        "peekOfCode": "def try_load_checkpoint(data):\n    config = data.config\n    path = os.path.join(config.data_dir, config.exp_id)\n    if not os.path.exists(path):\n        print('No checkpoints found. Assuming new experiment')\n        return\n    trainer_path = os.path.join(path, 'trainer_state.pt')\n    resume_state = torch.load(trainer_path)\n    model_path = os.path.join(path, resume_state['model_name'])\n    data.policy.uncompiled.load_state_dict(model_path, map_location=config.device)",
        "detail": "deps.pufferlib.clean_pufferl",
        "documentation": {}
    },
    {
        "label": "count_params",
        "kind": 2,
        "importPath": "deps.pufferlib.clean_pufferl",
        "description": "deps.pufferlib.clean_pufferl",
        "peekOfCode": "def count_params(policy):\n    return sum(p.numel() for p in policy.parameters() if p.requires_grad)\ndef rollout(env_creator, env_kwargs, policy_cls, rnn_cls, agent_creator, agent_kwargs,\n        backend, render_mode='auto', model_path=None, device='cuda'):\n    if render_mode != 'auto':\n        env_kwargs['render_mode'] = render_mode\n    # We are just using Serial vecenv to give a consistent\n    # single-agent/multi-agent API for evaluation\n    env = pufferlib.vector.make(env_creator, env_kwargs=env_kwargs, backend=backend)\n    if model_path is None:",
        "detail": "deps.pufferlib.clean_pufferl",
        "documentation": {}
    },
    {
        "label": "rollout",
        "kind": 2,
        "importPath": "deps.pufferlib.clean_pufferl",
        "description": "deps.pufferlib.clean_pufferl",
        "peekOfCode": "def rollout(env_creator, env_kwargs, policy_cls, rnn_cls, agent_creator, agent_kwargs,\n        backend, render_mode='auto', model_path=None, device='cuda'):\n    if render_mode != 'auto':\n        env_kwargs['render_mode'] = render_mode\n    # We are just using Serial vecenv to give a consistent\n    # single-agent/multi-agent API for evaluation\n    env = pufferlib.vector.make(env_creator, env_kwargs=env_kwargs, backend=backend)\n    if model_path is None:\n        agent = agent_creator(env, policy_cls, rnn_cls, agent_kwargs).to(device)\n    else:",
        "detail": "deps.pufferlib.clean_pufferl",
        "documentation": {}
    },
    {
        "label": "seed_everything",
        "kind": 2,
        "importPath": "deps.pufferlib.clean_pufferl",
        "description": "deps.pufferlib.clean_pufferl",
        "peekOfCode": "def seed_everything(seed, torch_deterministic):\n    random.seed(seed)\n    np.random.seed(seed)\n    if seed is not None:\n        torch.manual_seed(seed)\n    torch.backends.cudnn.deterministic = torch_deterministic\nROUND_OPEN = rich.box.Box(\n    \"\\n\"\n    \"  \\n\"\n    \"  \\n\"",
        "detail": "deps.pufferlib.clean_pufferl",
        "documentation": {}
    },
    {
        "label": "abbreviate",
        "kind": 2,
        "importPath": "deps.pufferlib.clean_pufferl",
        "description": "deps.pufferlib.clean_pufferl",
        "peekOfCode": "def abbreviate(num):\n    if num < 1e3:\n        return f'{b2}{num:.0f}'\n    elif num < 1e6:\n        return f'{b2}{num/1e3:.1f}{c2}k'\n    elif num < 1e9:\n        return f'{b2}{num/1e6:.1f}{c2}m'\n    elif num < 1e12:\n        return f'{b2}{num/1e9:.1f}{c2}b'\n    else:",
        "detail": "deps.pufferlib.clean_pufferl",
        "documentation": {}
    },
    {
        "label": "duration",
        "kind": 2,
        "importPath": "deps.pufferlib.clean_pufferl",
        "description": "deps.pufferlib.clean_pufferl",
        "peekOfCode": "def duration(seconds):\n    seconds = int(seconds)\n    h = seconds // 3600\n    m = (seconds % 3600) // 60\n    s = seconds % 60\n    return f\"{b2}{h}{c2}h {b2}{m}{c2}m {b2}{s}{c2}s\" if h else f\"{b2}{m}{c2}m {b2}{s}{c2}s\" if m else f\"{b2}{s}{c2}s\"\ndef fmt_perf(name, time, uptime):\n    percent = 0 if uptime == 0 else int(100*time/uptime - 1e-5)\n    return f'{c1}{name}', duration(time), f'{b2}{percent:2d}%'\n# TODO: Add env name to print_dashboard",
        "detail": "deps.pufferlib.clean_pufferl",
        "documentation": {}
    },
    {
        "label": "fmt_perf",
        "kind": 2,
        "importPath": "deps.pufferlib.clean_pufferl",
        "description": "deps.pufferlib.clean_pufferl",
        "peekOfCode": "def fmt_perf(name, time, uptime):\n    percent = 0 if uptime == 0 else int(100*time/uptime - 1e-5)\n    return f'{c1}{name}', duration(time), f'{b2}{percent:2d}%'\n# TODO: Add env name to print_dashboard\ndef print_dashboard(env_name, utilization, global_step, epoch,\n        profile, losses, stats, msg, clear=False, max_stats=[0]):\n    console = Console()\n    if clear:\n        console.clear()\n    dashboard = Table(box=ROUND_OPEN, expand=True,",
        "detail": "deps.pufferlib.clean_pufferl",
        "documentation": {}
    },
    {
        "label": "print_dashboard",
        "kind": 2,
        "importPath": "deps.pufferlib.clean_pufferl",
        "description": "deps.pufferlib.clean_pufferl",
        "peekOfCode": "def print_dashboard(env_name, utilization, global_step, epoch,\n        profile, losses, stats, msg, clear=False, max_stats=[0]):\n    console = Console()\n    if clear:\n        console.clear()\n    dashboard = Table(box=ROUND_OPEN, expand=True,\n        show_header=False, border_style='bright_cyan')\n    table = Table(box=None, expand=True, show_header=False)\n    dashboard.add_row(table)\n    cpu_percent = np.mean(utilization.cpu_util)",
        "detail": "deps.pufferlib.clean_pufferl",
        "documentation": {}
    },
    {
        "label": "ROUND_OPEN",
        "kind": 5,
        "importPath": "deps.pufferlib.clean_pufferl",
        "description": "deps.pufferlib.clean_pufferl",
        "peekOfCode": "ROUND_OPEN = rich.box.Box(\n    \"\\n\"\n    \"  \\n\"\n    \"  \\n\"\n    \"  \\n\"\n    \"  \\n\"\n    \"  \\n\"\n    \"  \\n\"\n    \"\\n\"\n)",
        "detail": "deps.pufferlib.clean_pufferl",
        "documentation": {}
    },
    {
        "label": "c1",
        "kind": 5,
        "importPath": "deps.pufferlib.clean_pufferl",
        "description": "deps.pufferlib.clean_pufferl",
        "peekOfCode": "c1 = '[bright_cyan]'\nc2 = '[white]'\nc3 = '[cyan]'\nb1 = '[bright_cyan]'\nb2 = '[bright_white]'\ndef abbreviate(num):\n    if num < 1e3:\n        return f'{b2}{num:.0f}'\n    elif num < 1e6:\n        return f'{b2}{num/1e3:.1f}{c2}k'",
        "detail": "deps.pufferlib.clean_pufferl",
        "documentation": {}
    },
    {
        "label": "c2",
        "kind": 5,
        "importPath": "deps.pufferlib.clean_pufferl",
        "description": "deps.pufferlib.clean_pufferl",
        "peekOfCode": "c2 = '[white]'\nc3 = '[cyan]'\nb1 = '[bright_cyan]'\nb2 = '[bright_white]'\ndef abbreviate(num):\n    if num < 1e3:\n        return f'{b2}{num:.0f}'\n    elif num < 1e6:\n        return f'{b2}{num/1e3:.1f}{c2}k'\n    elif num < 1e9:",
        "detail": "deps.pufferlib.clean_pufferl",
        "documentation": {}
    },
    {
        "label": "c3",
        "kind": 5,
        "importPath": "deps.pufferlib.clean_pufferl",
        "description": "deps.pufferlib.clean_pufferl",
        "peekOfCode": "c3 = '[cyan]'\nb1 = '[bright_cyan]'\nb2 = '[bright_white]'\ndef abbreviate(num):\n    if num < 1e3:\n        return f'{b2}{num:.0f}'\n    elif num < 1e6:\n        return f'{b2}{num/1e3:.1f}{c2}k'\n    elif num < 1e9:\n        return f'{b2}{num/1e6:.1f}{c2}m'",
        "detail": "deps.pufferlib.clean_pufferl",
        "documentation": {}
    },
    {
        "label": "b1",
        "kind": 5,
        "importPath": "deps.pufferlib.clean_pufferl",
        "description": "deps.pufferlib.clean_pufferl",
        "peekOfCode": "b1 = '[bright_cyan]'\nb2 = '[bright_white]'\ndef abbreviate(num):\n    if num < 1e3:\n        return f'{b2}{num:.0f}'\n    elif num < 1e6:\n        return f'{b2}{num/1e3:.1f}{c2}k'\n    elif num < 1e9:\n        return f'{b2}{num/1e6:.1f}{c2}m'\n    elif num < 1e12:",
        "detail": "deps.pufferlib.clean_pufferl",
        "documentation": {}
    },
    {
        "label": "b2",
        "kind": 5,
        "importPath": "deps.pufferlib.clean_pufferl",
        "description": "deps.pufferlib.clean_pufferl",
        "peekOfCode": "b2 = '[bright_white]'\ndef abbreviate(num):\n    if num < 1e3:\n        return f'{b2}{num:.0f}'\n    elif num < 1e6:\n        return f'{b2}{num/1e3:.1f}{c2}k'\n    elif num < 1e9:\n        return f'{b2}{num/1e6:.1f}{c2}m'\n    elif num < 1e12:\n        return f'{b2}{num/1e9:.1f}{c2}b'",
        "detail": "deps.pufferlib.clean_pufferl",
        "documentation": {}
    },
    {
        "label": "Args",
        "kind": 6,
        "importPath": "deps.pufferlib.cleanrl_ppo_atari",
        "description": "deps.pufferlib.cleanrl_ppo_atari",
        "peekOfCode": "class Args:\n    exp_name: str = 'cleanrl_ppo_atari'\n    \"\"\"the name of this experiment\"\"\"\n    seed: int = 1\n    \"\"\"seed of the experiment\"\"\"\n    torch_deterministic: bool = True\n    \"\"\"if toggled, `torch.backends.cudnn.deterministic=False`\"\"\"\n    cuda: bool = True\n    \"\"\"if toggled, cuda will be enabled by default\"\"\"\n    track: bool = False",
        "detail": "deps.pufferlib.cleanrl_ppo_atari",
        "documentation": {}
    },
    {
        "label": "Agent",
        "kind": 6,
        "importPath": "deps.pufferlib.cleanrl_ppo_atari",
        "description": "deps.pufferlib.cleanrl_ppo_atari",
        "peekOfCode": "class Agent(nn.Module):\n    def __init__(self, envs):\n        super().__init__()\n        self.network = nn.Sequential(\n            layer_init(nn.Conv2d(4, 32, 8, stride=4)),\n            nn.ReLU(),\n            layer_init(nn.Conv2d(32, 64, 4, stride=2)),\n            nn.ReLU(),\n            layer_init(nn.Conv2d(64, 64, 3, stride=1)),\n            nn.ReLU(),",
        "detail": "deps.pufferlib.cleanrl_ppo_atari",
        "documentation": {}
    },
    {
        "label": "make_env",
        "kind": 2,
        "importPath": "deps.pufferlib.cleanrl_ppo_atari",
        "description": "deps.pufferlib.cleanrl_ppo_atari",
        "peekOfCode": "def make_env(env_id, idx, capture_video, run_name):\n    def thunk():\n        if capture_video and idx == 0:\n            env = gym.make(env_id, render_mode=\"rgb_array\")\n            env = gym.wrappers.RecordVideo(env, f\"videos/{run_name}\")\n        else:\n            env = gym.make(env_id)\n        env = gym.wrappers.RecordEpisodeStatistics(env)\n        if capture_video:\n            if idx == 0:",
        "detail": "deps.pufferlib.cleanrl_ppo_atari",
        "documentation": {}
    },
    {
        "label": "layer_init",
        "kind": 2,
        "importPath": "deps.pufferlib.cleanrl_ppo_atari",
        "description": "deps.pufferlib.cleanrl_ppo_atari",
        "peekOfCode": "def layer_init(layer, std=np.sqrt(2), bias_const=0.0):\n    torch.nn.init.orthogonal_(layer.weight, std)\n    torch.nn.init.constant_(layer.bias, bias_const)\n    return layer\nclass Agent(nn.Module):\n    def __init__(self, envs):\n        super().__init__()\n        self.network = nn.Sequential(\n            layer_init(nn.Conv2d(4, 32, 8, stride=4)),\n            nn.ReLU(),",
        "detail": "deps.pufferlib.cleanrl_ppo_atari",
        "documentation": {}
    },
    {
        "label": "make_policy",
        "kind": 2,
        "importPath": "deps.pufferlib.demo",
        "description": "deps.pufferlib.demo",
        "peekOfCode": "def make_policy(env, policy_cls, rnn_cls, args):\n    policy = policy_cls(env, **args['policy'])\n    if rnn_cls is not None:\n        policy = rnn_cls(env, policy, **args['rnn'])\n        policy = pufferlib.frameworks.cleanrl.RecurrentPolicy(policy)\n    else:\n        policy = pufferlib.frameworks.cleanrl.Policy(policy)\n    return policy.to(args['train']['device'])\ndef init_wandb(args, name, id=None, resume=True):\n    import wandb",
        "detail": "deps.pufferlib.demo",
        "documentation": {}
    },
    {
        "label": "init_wandb",
        "kind": 2,
        "importPath": "deps.pufferlib.demo",
        "description": "deps.pufferlib.demo",
        "peekOfCode": "def init_wandb(args, name, id=None, resume=True):\n    import wandb\n    wandb.init(\n        id=id or wandb.util.generate_id(),\n        project=args['wandb_project'],\n        group=args['wandb_group'],\n        allow_val_change=True,\n        save_code=True,\n        resume=resume,\n        config=args,",
        "detail": "deps.pufferlib.demo",
        "documentation": {}
    },
    {
        "label": "sweep",
        "kind": 2,
        "importPath": "deps.pufferlib.demo",
        "description": "deps.pufferlib.demo",
        "peekOfCode": "def sweep(args, env_name, make_env, policy_cls, rnn_cls):\n    import wandb\n    sweep_id = wandb.sweep(sweep=args['sweep'], project=args['wandb_project'])\n    def main():\n        try:\n            wandb = init_wandb(args, env_name, id=args['exp_id'])\n            args['train'].update(wandb.config.train)\n            train(args, make_env, policy_cls, rnn_cls, wandb)\n        except Exception as e:\n            Console().print_exception()",
        "detail": "deps.pufferlib.demo",
        "documentation": {}
    },
    {
        "label": "sweep_carbs",
        "kind": 2,
        "importPath": "deps.pufferlib.demo",
        "description": "deps.pufferlib.demo",
        "peekOfCode": "def sweep_carbs(args, env_name, make_env, policy_cls, rnn_cls):\n    import numpy as np\n    import sys\n    from math import log, ceil, floor\n    from carbs import CARBS\n    from carbs import CARBSParams\n    from carbs import LinearSpace\n    from carbs import LogSpace\n    from carbs import LogitSpace\n    from carbs import ObservationInParam",
        "detail": "deps.pufferlib.demo",
        "documentation": {}
    },
    {
        "label": "train",
        "kind": 2,
        "importPath": "deps.pufferlib.demo",
        "description": "deps.pufferlib.demo",
        "peekOfCode": "def train(args, make_env, policy_cls, rnn_cls, wandb,\n        eval_frac=0.1, elos={'model_random.pt': 1000}, vecenv=None, subprocess=False, queue=None):\n    if subprocess:\n        from multiprocessing import Process, Queue\n        queue = Queue()\n        p = Process(target=train, args=(args, make_env, policy_cls, rnn_cls, wandb,\n            eval_frac, elos, False, queue))\n        p.start()\n        p.join()\n        stats, uptime, elos = queue.get()",
        "detail": "deps.pufferlib.demo",
        "documentation": {}
    },
    {
        "label": "load_policies",
        "kind": 2,
        "importPath": "deps.pufferlib.evaluate_elos",
        "description": "deps.pufferlib.evaluate_elos",
        "peekOfCode": "def load_policies(checkpoint_dir, n, map_location='cuda'):\n    paths = glob.glob(f'{checkpoint_dir}/model_*.pt', recursive=True)\n    # Sample with replacement if not enough models\n    if len(paths) < n:\n        samples = random.choices(paths, k=n)\n    else:\n        samples = random.sample(paths, n)\n    names = [path.split('/')[-1] for path in samples]\n    return {name: torch.load(path, map_location=map_location)\n        for name, path in zip(names, samples)}",
        "detail": "deps.pufferlib.evaluate_elos",
        "documentation": {}
    },
    {
        "label": "rollout",
        "kind": 2,
        "importPath": "deps.pufferlib.evaluate_elos",
        "description": "deps.pufferlib.evaluate_elos",
        "peekOfCode": "def rollout(envs, policy, opponents, num_games, timeout=180, render=False):\n    obs, _ = envs.reset()\n    # Double reset clears randomizations\n    obs, _ = envs.reset()\n    #cenv = envs.c_envs[0]\n    start = time.time()\n    step = 0\n    num_envs = len(envs.c_envs)\n    num_opponents = len(opponents)\n    envs_per_opponent = num_envs // num_opponents",
        "detail": "deps.pufferlib.evaluate_elos",
        "documentation": {}
    },
    {
        "label": "calc_elo",
        "kind": 2,
        "importPath": "deps.pufferlib.evaluate_elos",
        "description": "deps.pufferlib.evaluate_elos",
        "peekOfCode": "def calc_elo(checkpoint, checkpoint_dir, elos, num_envs=128, num_games=128, num_opponents=8, k=24.0):\n    print(f'Calculating ELO for {checkpoint}')\n    make_env = env_creator('moba')\n    envs = make_env(num_envs=num_envs)\n    policy = torch.load(os.path.join(checkpoint_dir, checkpoint), map_location='cuda')\n    print(f'Loaded policy {checkpoint}')\n    paths = glob.glob(f'{checkpoint_dir}/model_*.pt', recursive=True)\n    names = [path.split('/')[-1] for path in paths]\n    print(f'Loaded {len(paths)} models')\n    paths.remove(f'{checkpoint_dir}/{checkpoint}')",
        "detail": "deps.pufferlib.evaluate_elos",
        "documentation": {}
    },
    {
        "label": "test_performance",
        "kind": 2,
        "importPath": "deps.pufferlib.moba_perf",
        "description": "deps.pufferlib.moba_perf",
        "peekOfCode": "def test_performance(env, actions, num_envs, timeout=20):\n    n_actions = actions.shape[0]\n    tick = 0\n    import time\n    start = time.time()\n    while time.time() - start < timeout:\n        atns = actions[tick % n_actions]\n        env.step(atns)\n        tick += 1\n    print(f'SPS: %f', 10 * num_envs * tick / (time.time() - start))",
        "detail": "deps.pufferlib.moba_perf",
        "documentation": {}
    },
    {
        "label": "map_updater",
        "kind": 2,
        "importPath": "deps.pufferlib.pokemon_red_eval",
        "description": "deps.pufferlib.pokemon_red_eval",
        "peekOfCode": "def map_updater():\n    import cv2\n    bg = cv2.imread('kanto_map_dsv.png')\n    return partial(make_pokemon_red_overlay, bg)\ndef make_pokemon_red_overlay(bg, counts):\n    nonzero = np.where(counts > 0, 1, 0)\n    scaled = np.clip(counts, 0, 1000) / 1000.0\n    # Convert counts to hue map\n    hsv = np.zeros((*counts.shape, 3))\n    hsv[..., 0] = 2*(1-scaled)/3",
        "detail": "deps.pufferlib.pokemon_red_eval",
        "documentation": {}
    },
    {
        "label": "make_pokemon_red_overlay",
        "kind": 2,
        "importPath": "deps.pufferlib.pokemon_red_eval",
        "description": "deps.pufferlib.pokemon_red_eval",
        "peekOfCode": "def make_pokemon_red_overlay(bg, counts):\n    nonzero = np.where(counts > 0, 1, 0)\n    scaled = np.clip(counts, 0, 1000) / 1000.0\n    # Convert counts to hue map\n    hsv = np.zeros((*counts.shape, 3))\n    hsv[..., 0] = 2*(1-scaled)/3\n    hsv[..., 1] = nonzero\n    hsv[..., 2] = nonzero\n    # Convert the HSV image to RGB\n    import matplotlib.colors as mcolors",
        "detail": "deps.pufferlib.pokemon_red_eval",
        "documentation": {}
    },
    {
        "label": "rollout",
        "kind": 2,
        "importPath": "deps.pufferlib.pokemon_red_eval",
        "description": "deps.pufferlib.pokemon_red_eval",
        "peekOfCode": "def rollout(env_creator, env_kwargs, agent_creator, agent_kwargs, model_path=None, device='cuda', verbose=True):\n    env = env_creator(**env_kwargs)\n    if model_path is None:\n        agent = agent_creator(env, **agent_kwargs)\n    else:\n        agent = torch.load(model_path, map_location=device)\n    terminal = truncated = True\n    import cv2\n    bg = cv2.imread('kanto_map_dsv.png')\n    while True:",
        "detail": "deps.pufferlib.pokemon_red_eval",
        "documentation": {}
    },
    {
        "label": "make_rllib_tuner",
        "kind": 2,
        "importPath": "deps.pufferlib.rllib_ppo",
        "description": "deps.pufferlib.rllib_ppo",
        "peekOfCode": "def make_rllib_tuner(\n        env_creator,\n        policy_cls,\n        name,\n        *,\n        algorithm='PPO',\n        num_gpus=1,\n        num_workers=1,\n        num_envs_per_worker=1,\n        rollout_fragment_length=16,",
        "detail": "deps.pufferlib.rllib_ppo",
        "documentation": {}
    },
    {
        "label": "FRAMESTACK",
        "kind": 5,
        "importPath": "deps.pufferlib.rllib_ppo",
        "description": "deps.pufferlib.rllib_ppo",
        "peekOfCode": "FRAMESTACK = 4\ndef make_rllib_tuner(\n        env_creator,\n        policy_cls,\n        name,\n        *,\n        algorithm='PPO',\n        num_gpus=1,\n        num_workers=1,\n        num_envs_per_worker=1,",
        "detail": "deps.pufferlib.rllib_ppo",
        "documentation": {}
    },
    {
        "label": "save_model_weights",
        "kind": 2,
        "importPath": "deps.pufferlib.save_net_flat",
        "description": "deps.pufferlib.save_net_flat",
        "peekOfCode": "def save_model_weights(model, filename):\n    weights = []\n    for name, param in model.named_parameters():\n        weights.append(param.data.cpu().numpy().flatten())\n        print(name, param.shape, param.data.cpu().numpy().ravel()[0])\n    weights = np.concatenate(weights)\n    weights.tofile(filename)\n    # Save the model architecture (you may want to adjust this based on your specific model)\n    #with open(filename + \"_architecture.txt\", \"w\") as f:\n    #    for name, param in model.named_parameters():",
        "detail": "deps.pufferlib.save_net_flat",
        "documentation": {}
    },
    {
        "label": "test_model",
        "kind": 2,
        "importPath": "deps.pufferlib.save_net_flat",
        "description": "deps.pufferlib.save_net_flat",
        "peekOfCode": "def test_model(model):\n    model = model.cpu().policy\n    batch_size = 16\n    obs_window = 11\n    obs_window_channels = 4\n    obs_flat = 26\n    x = torch.arange(\n        0, batch_size*(obs_window*obs_window*obs_window_channels + obs_flat)\n        ).reshape(batch_size, -1) % 16\n    cnn_features = x[:, :-obs_flat].view(",
        "detail": "deps.pufferlib.save_net_flat",
        "documentation": {}
    },
    {
        "label": "test_lstm",
        "kind": 2,
        "importPath": "deps.pufferlib.save_net_flat",
        "description": "deps.pufferlib.save_net_flat",
        "peekOfCode": "def test_lstm():\n    batch_size = 16\n    input_size = 128\n    hidden_size = 128\n    input = torch.arange(batch_size*input_size).reshape(1, batch_size, -1).float()/ 100000\n    state = (\n        torch.arange(batch_size*hidden_size).reshape(1, batch_size, -1).float()/ 100000,\n        torch.arange(batch_size*hidden_size).reshape(1, batch_size, -1).float() / 100000\n    )\n    weights_input = torch.arange(4*hidden_size*input_size).reshape(4*hidden_size, -1).float()/ 100000",
        "detail": "deps.pufferlib.save_net_flat",
        "documentation": {}
    },
    {
        "label": "test_model_forward",
        "kind": 2,
        "importPath": "deps.pufferlib.save_net_flat",
        "description": "deps.pufferlib.save_net_flat",
        "peekOfCode": "def test_model_forward(model):\n    data = torch.arange(10*(11*11*4 + 26)) % 16\n    data[(11*11*4 + 26):] = 0\n    data = data.reshape(10, -1).float()\n    output = model(data)\n    breakpoint()\n    pass\nif __name__ == '__main__':\n    #test_lstm()\n    model = torch.load('moba.pt', map_location='cpu')",
        "detail": "deps.pufferlib.save_net_flat",
        "documentation": {}
    },
    {
        "label": "parser",
        "kind": 5,
        "importPath": "deps.pufferlib.sb3_demo",
        "description": "deps.pufferlib.sb3_demo",
        "peekOfCode": "parser = argparse.ArgumentParser()\nparser.add_argument('--env', type=str, default='BreakoutNoFrameskip-v4')\nargs = parser.parse_args()\nenv_creator = atari.env_creator(args.env)\nenvs = make_vec_env(lambda: env_creator(),\n    n_envs=4, seed=0, vec_env_cls=DummyVecEnv)\nmodel = PPO(\"CnnPolicy\", envs, verbose=1)\nmodel.learn(total_timesteps=2000)\n# Demonstrate loading\nmodel.save(f'ppo_{args.env}')",
        "detail": "deps.pufferlib.sb3_demo",
        "documentation": {}
    },
    {
        "label": "args",
        "kind": 5,
        "importPath": "deps.pufferlib.sb3_demo",
        "description": "deps.pufferlib.sb3_demo",
        "peekOfCode": "args = parser.parse_args()\nenv_creator = atari.env_creator(args.env)\nenvs = make_vec_env(lambda: env_creator(),\n    n_envs=4, seed=0, vec_env_cls=DummyVecEnv)\nmodel = PPO(\"CnnPolicy\", envs, verbose=1)\nmodel.learn(total_timesteps=2000)\n# Demonstrate loading\nmodel.save(f'ppo_{args.env}')\nmodel = PPO.load(f'ppo_{args.env}')\n# Watch the agent play",
        "detail": "deps.pufferlib.sb3_demo",
        "documentation": {}
    },
    {
        "label": "env_creator",
        "kind": 5,
        "importPath": "deps.pufferlib.sb3_demo",
        "description": "deps.pufferlib.sb3_demo",
        "peekOfCode": "env_creator = atari.env_creator(args.env)\nenvs = make_vec_env(lambda: env_creator(),\n    n_envs=4, seed=0, vec_env_cls=DummyVecEnv)\nmodel = PPO(\"CnnPolicy\", envs, verbose=1)\nmodel.learn(total_timesteps=2000)\n# Demonstrate loading\nmodel.save(f'ppo_{args.env}')\nmodel = PPO.load(f'ppo_{args.env}')\n# Watch the agent play\nenv = atari.make_env(args.env, render_mode='human')",
        "detail": "deps.pufferlib.sb3_demo",
        "documentation": {}
    },
    {
        "label": "envs",
        "kind": 5,
        "importPath": "deps.pufferlib.sb3_demo",
        "description": "deps.pufferlib.sb3_demo",
        "peekOfCode": "envs = make_vec_env(lambda: env_creator(),\n    n_envs=4, seed=0, vec_env_cls=DummyVecEnv)\nmodel = PPO(\"CnnPolicy\", envs, verbose=1)\nmodel.learn(total_timesteps=2000)\n# Demonstrate loading\nmodel.save(f'ppo_{args.env}')\nmodel = PPO.load(f'ppo_{args.env}')\n# Watch the agent play\nenv = atari.make_env(args.env, render_mode='human')\nterminal = True",
        "detail": "deps.pufferlib.sb3_demo",
        "documentation": {}
    },
    {
        "label": "model",
        "kind": 5,
        "importPath": "deps.pufferlib.sb3_demo",
        "description": "deps.pufferlib.sb3_demo",
        "peekOfCode": "model = PPO(\"CnnPolicy\", envs, verbose=1)\nmodel.learn(total_timesteps=2000)\n# Demonstrate loading\nmodel.save(f'ppo_{args.env}')\nmodel = PPO.load(f'ppo_{args.env}')\n# Watch the agent play\nenv = atari.make_env(args.env, render_mode='human')\nterminal = True\nfor _ in range(1000):\n    if terminal or truncated:",
        "detail": "deps.pufferlib.sb3_demo",
        "documentation": {}
    },
    {
        "label": "model",
        "kind": 5,
        "importPath": "deps.pufferlib.sb3_demo",
        "description": "deps.pufferlib.sb3_demo",
        "peekOfCode": "model = PPO.load(f'ppo_{args.env}')\n# Watch the agent play\nenv = atari.make_env(args.env, render_mode='human')\nterminal = True\nfor _ in range(1000):\n    if terminal or truncated:\n        ob, _ = env.reset()\n    ob = ob.reshape(1, *ob.shape)\n    action, _states = model.predict(ob)\n    ob, reward, terminal, truncated, info = env.step(action[0])",
        "detail": "deps.pufferlib.sb3_demo",
        "documentation": {}
    },
    {
        "label": "env",
        "kind": 5,
        "importPath": "deps.pufferlib.sb3_demo",
        "description": "deps.pufferlib.sb3_demo",
        "peekOfCode": "env = atari.make_env(args.env, render_mode='human')\nterminal = True\nfor _ in range(1000):\n    if terminal or truncated:\n        ob, _ = env.reset()\n    ob = ob.reshape(1, *ob.shape)\n    action, _states = model.predict(ob)\n    ob, reward, terminal, truncated, info = env.step(action[0])\n    env.render()",
        "detail": "deps.pufferlib.sb3_demo",
        "documentation": {}
    },
    {
        "label": "terminal",
        "kind": 5,
        "importPath": "deps.pufferlib.sb3_demo",
        "description": "deps.pufferlib.sb3_demo",
        "peekOfCode": "terminal = True\nfor _ in range(1000):\n    if terminal or truncated:\n        ob, _ = env.reset()\n    ob = ob.reshape(1, *ob.shape)\n    action, _states = model.predict(ob)\n    ob, reward, terminal, truncated, info = env.step(action[0])\n    env.render()",
        "detail": "deps.pufferlib.sb3_demo",
        "documentation": {}
    },
    {
        "label": "VERSION",
        "kind": 5,
        "importPath": "deps.pufferlib.setup",
        "description": "deps.pufferlib.setup",
        "peekOfCode": "VERSION = '1.0.0'\nimport os\nos.environ['CFLAGS'] = '-O3 -march=native -Wall'\n# Default Gym/Gymnasium/PettingZoo versions\n# Gym:\n# - 0.26 still has deprecation warnings and is the last version of the package\n# - 0.25 adds a breaking API change to reset, step, and render_modes\n# - 0.24 is broken\n# - 0.22-0.23 triggers deprecation warnings by calling its own functions\n# - 0.21 is the most stable version",
        "detail": "deps.pufferlib.setup",
        "documentation": {}
    },
    {
        "label": "os.environ['CFLAGS']",
        "kind": 5,
        "importPath": "deps.pufferlib.setup",
        "description": "deps.pufferlib.setup",
        "peekOfCode": "os.environ['CFLAGS'] = '-O3 -march=native -Wall'\n# Default Gym/Gymnasium/PettingZoo versions\n# Gym:\n# - 0.26 still has deprecation warnings and is the last version of the package\n# - 0.25 adds a breaking API change to reset, step, and render_modes\n# - 0.24 is broken\n# - 0.22-0.23 triggers deprecation warnings by calling its own functions\n# - 0.21 is the most stable version\n# - <= 0.20 is missing dict methods for gym.spaces.Dict\n# - 0.18-0.21 require setuptools<=65.5.0",
        "detail": "deps.pufferlib.setup",
        "documentation": {}
    },
    {
        "label": "GYMNASIUM_VERSION",
        "kind": 5,
        "importPath": "deps.pufferlib.setup",
        "description": "deps.pufferlib.setup",
        "peekOfCode": "GYMNASIUM_VERSION = '0.29.1'\nGYM_VERSION = '0.23'\nPETTINGZOO_VERSION = '1.24.1'\ndocs = [\n    'sphinx==5.0.0',\n    'sphinx-rtd-theme==0.5.1',\n    'sphinxcontrib-youtube==1.0.1',\n    'sphinx-rtd-theme==0.5.1',\n    'sphinx-design==0.4.1',\n    'furo==2023.3.27',",
        "detail": "deps.pufferlib.setup",
        "documentation": {}
    },
    {
        "label": "GYM_VERSION",
        "kind": 5,
        "importPath": "deps.pufferlib.setup",
        "description": "deps.pufferlib.setup",
        "peekOfCode": "GYM_VERSION = '0.23'\nPETTINGZOO_VERSION = '1.24.1'\ndocs = [\n    'sphinx==5.0.0',\n    'sphinx-rtd-theme==0.5.1',\n    'sphinxcontrib-youtube==1.0.1',\n    'sphinx-rtd-theme==0.5.1',\n    'sphinx-design==0.4.1',\n    'furo==2023.3.27',\n]",
        "detail": "deps.pufferlib.setup",
        "documentation": {}
    },
    {
        "label": "PETTINGZOO_VERSION",
        "kind": 5,
        "importPath": "deps.pufferlib.setup",
        "description": "deps.pufferlib.setup",
        "peekOfCode": "PETTINGZOO_VERSION = '1.24.1'\ndocs = [\n    'sphinx==5.0.0',\n    'sphinx-rtd-theme==0.5.1',\n    'sphinxcontrib-youtube==1.0.1',\n    'sphinx-rtd-theme==0.5.1',\n    'sphinx-design==0.4.1',\n    'furo==2023.3.27',\n]\ncleanrl = [",
        "detail": "deps.pufferlib.setup",
        "documentation": {}
    },
    {
        "label": "docs",
        "kind": 5,
        "importPath": "deps.pufferlib.setup",
        "description": "deps.pufferlib.setup",
        "peekOfCode": "docs = [\n    'sphinx==5.0.0',\n    'sphinx-rtd-theme==0.5.1',\n    'sphinxcontrib-youtube==1.0.1',\n    'sphinx-rtd-theme==0.5.1',\n    'sphinx-design==0.4.1',\n    'furo==2023.3.27',\n]\ncleanrl = [\n    'stable_baselines3==2.1.0',",
        "detail": "deps.pufferlib.setup",
        "documentation": {}
    },
    {
        "label": "cleanrl",
        "kind": 5,
        "importPath": "deps.pufferlib.setup",
        "description": "deps.pufferlib.setup",
        "peekOfCode": "cleanrl = [\n    'stable_baselines3==2.1.0',\n    'tensorboard==2.11.2',\n    'torch',\n    'tyro==0.8.6',\n    'wandb==0.13.7',\n]\nray = [\n    'ray==2.23.0',\n]",
        "detail": "deps.pufferlib.setup",
        "documentation": {}
    },
    {
        "label": "ray",
        "kind": 5,
        "importPath": "deps.pufferlib.setup",
        "description": "deps.pufferlib.setup",
        "peekOfCode": "ray = [\n    'ray==2.23.0',\n]\nenvironments = {\n    'avalon': [\n        f'gym=={GYM_VERSION}',\n        f'gymnasium=={GYMNASIUM_VERSION}',\n        'avalon-rl==1.0.0',\n    ],\n    'atari': [",
        "detail": "deps.pufferlib.setup",
        "documentation": {}
    },
    {
        "label": "environments",
        "kind": 5,
        "importPath": "deps.pufferlib.setup",
        "description": "deps.pufferlib.setup",
        "peekOfCode": "environments = {\n    'avalon': [\n        f'gym=={GYM_VERSION}',\n        f'gymnasium=={GYMNASIUM_VERSION}',\n        'avalon-rl==1.0.0',\n    ],\n    'atari': [\n        f'gym=={GYM_VERSION}',\n        f'gymnasium[accept-rom-license]=={GYMNASIUM_VERSION}',\n        'ale_py==0.9.0',",
        "detail": "deps.pufferlib.setup",
        "documentation": {}
    },
    {
        "label": "common",
        "kind": 5,
        "importPath": "deps.pufferlib.setup",
        "description": "deps.pufferlib.setup",
        "peekOfCode": "common = cleanrl + [environments[env] for env in [\n    'atari',\n    #'box2d',\n    'bsuite',\n    #'butterfly',\n    'classic_control',\n    'crafter',\n    'dm_control',\n    'dm_lab',\n    'griddly',",
        "detail": "deps.pufferlib.setup",
        "documentation": {}
    },
    {
        "label": "make_policy",
        "kind": 2,
        "importPath": "deps.pufferlib.simple_demo",
        "description": "deps.pufferlib.simple_demo",
        "peekOfCode": "def make_policy(env, use_rnn):\n    '''Make the policy for the environment'''\n    policy = Policy(env)\n    if use_rnn:\n        policy = Recurrent(env, policy)\n        return pufferlib.frameworks.cleanrl.RecurrentPolicy(policy)\n    else:\n        return pufferlib.frameworks.cleanrl.Policy(policy)\ndef train(args):\n    args.wandb = None",
        "detail": "deps.pufferlib.simple_demo",
        "documentation": {}
    },
    {
        "label": "train",
        "kind": 2,
        "importPath": "deps.pufferlib.simple_demo",
        "description": "deps.pufferlib.simple_demo",
        "peekOfCode": "def train(args):\n    args.wandb = None\n    if args.track:\n        args.wandb = init_wandb(args, args.env, id=args.train.exp_id)\n        args.train.__dict__.update(dict(args.wandb.config.train))\n    if args.vec.backend == 'serial':\n        backend = pufferlib.vector.Serial\n    elif args.vec.backend == 'multiprocessing':\n        backend = pufferlib.vector.Multiprocessing\n    elif args.vec == 'ray':",
        "detail": "deps.pufferlib.simple_demo",
        "documentation": {}
    },
    {
        "label": "init_wandb",
        "kind": 2,
        "importPath": "deps.pufferlib.simple_demo",
        "description": "deps.pufferlib.simple_demo",
        "peekOfCode": "def init_wandb(args, name, id=None, resume=True):\n    import wandb\n    wandb.init(\n        id=id or wandb.util.generate_id(),\n        project=args.wandb_project,\n        entity=args.wandb_entity,\n        group=args.wandb_group,\n        config={\n            'train': dict(args.train),\n            'vec': dict(args.vec),",
        "detail": "deps.pufferlib.simple_demo",
        "documentation": {}
    },
    {
        "label": "sweep",
        "kind": 2,
        "importPath": "deps.pufferlib.simple_demo",
        "description": "deps.pufferlib.simple_demo",
        "peekOfCode": "def sweep(args):\n    import wandb\n    sweep_id = wandb.sweep(\n        sweep=dict(\n            method='random',\n            name=sweep,\n            metric=dict(\n                goal='maximize',\n                name='environment/episode_return',\n            ),",
        "detail": "deps.pufferlib.simple_demo",
        "documentation": {}
    },
    {
        "label": "test_performance",
        "kind": 2,
        "importPath": "deps.pufferlib.test_gpudrive",
        "description": "deps.pufferlib.test_gpudrive",
        "peekOfCode": "def test_performance(timeout=20):\n    import time\n    N = actions.shape[0]\n    idx = 0\n    dones = {1: True}\n    start = time.time()\n    while time.time() - start < timeout:\n        _, _, dones, _, _, _, mask = env.step(actions[idx%N])\n        idx += np.sum(mask)\n    sps = idx // timeout",
        "detail": "deps.pufferlib.test_gpudrive",
        "documentation": {}
    },
    {
        "label": "make_dummy_data",
        "kind": 2,
        "importPath": "deps.pufferlib.test_puffernet",
        "description": "deps.pufferlib.test_puffernet",
        "peekOfCode": "def make_dummy_data(*shape, seed=42):\n    np.random.seed(seed)\n    n = np.prod(shape)\n    ary = np.random.rand(*shape).astype(np.float32) - 0.5\n    return np.ascontiguousarray(ary)\ndef make_dummy_int_data(num_classes, *shape):\n    np.random.seed(42)\n    n = np.prod(shape)\n    ary = np.random.randint(0, num_classes, shape).astype(np.int32)\n    return np.ascontiguousarray(ary)",
        "detail": "deps.pufferlib.test_puffernet",
        "documentation": {}
    },
    {
        "label": "make_dummy_int_data",
        "kind": 2,
        "importPath": "deps.pufferlib.test_puffernet",
        "description": "deps.pufferlib.test_puffernet",
        "peekOfCode": "def make_dummy_int_data(num_classes, *shape):\n    np.random.seed(42)\n    n = np.prod(shape)\n    ary = np.random.randint(0, num_classes, shape).astype(np.int32)\n    return np.ascontiguousarray(ary)\ndef assert_near(a, b):\n    assert a.shape == b.shape\n    assert np.all(np.abs(a - b) < 1e-4)\ndef test_puffernet_relu(batch_size=16, input_size=128):\n    input_puffer = make_dummy_data(batch_size, input_size)",
        "detail": "deps.pufferlib.test_puffernet",
        "documentation": {}
    },
    {
        "label": "assert_near",
        "kind": 2,
        "importPath": "deps.pufferlib.test_puffernet",
        "description": "deps.pufferlib.test_puffernet",
        "peekOfCode": "def assert_near(a, b):\n    assert a.shape == b.shape\n    assert np.all(np.abs(a - b) < 1e-4)\ndef test_puffernet_relu(batch_size=16, input_size=128):\n    input_puffer = make_dummy_data(batch_size, input_size)\n    input_torch = torch.from_numpy(input_puffer)\n    output_torch = torch.relu(input_torch).detach()\n    # PufferNet done second because it is in-place on the input\n    puffernet.puf_relu(input_puffer, input_puffer, batch_size*input_size)\n    assert_near(input_puffer, output_torch.numpy())",
        "detail": "deps.pufferlib.test_puffernet",
        "documentation": {}
    },
    {
        "label": "test_puffernet_relu",
        "kind": 2,
        "importPath": "deps.pufferlib.test_puffernet",
        "description": "deps.pufferlib.test_puffernet",
        "peekOfCode": "def test_puffernet_relu(batch_size=16, input_size=128):\n    input_puffer = make_dummy_data(batch_size, input_size)\n    input_torch = torch.from_numpy(input_puffer)\n    output_torch = torch.relu(input_torch).detach()\n    # PufferNet done second because it is in-place on the input\n    puffernet.puf_relu(input_puffer, input_puffer, batch_size*input_size)\n    assert_near(input_puffer, output_torch.numpy())\ndef test_puffernet_sigmoid(n=1024, epsilon=1e-4):\n    input_np = make_dummy_data(n)\n    input_torch = torch.from_numpy(input_np)",
        "detail": "deps.pufferlib.test_puffernet",
        "documentation": {}
    },
    {
        "label": "test_puffernet_sigmoid",
        "kind": 2,
        "importPath": "deps.pufferlib.test_puffernet",
        "description": "deps.pufferlib.test_puffernet",
        "peekOfCode": "def test_puffernet_sigmoid(n=1024, epsilon=1e-4):\n    input_np = make_dummy_data(n)\n    input_torch = torch.from_numpy(input_np)\n    output_torch = torch.sigmoid(input_torch).detach()\n    for i in range(n):\n        out_torch = output_torch[i]\n        out_puffer = puffernet.puf_sigmoid(input_np[i])\n        assert abs(out_puffer - out_torch) < epsilon\ndef test_puffernet_linear_layer(batch_size=16, input_size=128, hidden_size=128):\n    input_np = make_dummy_data(batch_size, input_size, seed=42)",
        "detail": "deps.pufferlib.test_puffernet",
        "documentation": {}
    },
    {
        "label": "test_puffernet_linear_layer",
        "kind": 2,
        "importPath": "deps.pufferlib.test_puffernet",
        "description": "deps.pufferlib.test_puffernet",
        "peekOfCode": "def test_puffernet_linear_layer(batch_size=16, input_size=128, hidden_size=128):\n    input_np = make_dummy_data(batch_size, input_size, seed=42)\n    weights_np = make_dummy_data(hidden_size, input_size, seed=43)\n    bias_np = make_dummy_data(hidden_size, seed=44)\n    output_puffer = np.zeros((batch_size, hidden_size), dtype=np.float32)\n    puffernet.puf_linear_layer(input_np, weights_np, bias_np, output_puffer,\n        batch_size, input_size, hidden_size)\n    input_torch = torch.from_numpy(input_np)\n    weights_torch = torch.from_numpy(weights_np)\n    bias_torch = torch.from_numpy(bias_np)",
        "detail": "deps.pufferlib.test_puffernet",
        "documentation": {}
    },
    {
        "label": "test_puffernet_convolution_layer",
        "kind": 2,
        "importPath": "deps.pufferlib.test_puffernet",
        "description": "deps.pufferlib.test_puffernet",
        "peekOfCode": "def test_puffernet_convolution_layer(batch_size=16, in_width=11, in_height=11,\n        in_channels=19, out_channels=32, kernel_size=5, stride=3):\n    input_np = make_dummy_data(batch_size, in_channels, in_height, in_width)\n    weights_np = make_dummy_data(out_channels, in_channels, kernel_size, kernel_size)\n    bias_np = make_dummy_data(out_channels)\n    out_height = int((in_height - kernel_size)/stride + 1)\n    out_width = int((in_width - kernel_size)/stride + 1)\n    output_puffer = np.zeros((batch_size, out_channels, out_height, out_width), dtype=np.float32)\n    puffernet.puf_convolution_layer(input_np, weights_np, bias_np, output_puffer,\n        batch_size, in_width, in_height, in_channels, out_channels, kernel_size, stride)",
        "detail": "deps.pufferlib.test_puffernet",
        "documentation": {}
    },
    {
        "label": "test_puffernet_lstm",
        "kind": 2,
        "importPath": "deps.pufferlib.test_puffernet",
        "description": "deps.pufferlib.test_puffernet",
        "peekOfCode": "def test_puffernet_lstm(batch_size=16, input_size=128, hidden_size=128):\n    input_np = make_dummy_data(batch_size, input_size, seed=42)\n    state_h_np = make_dummy_data(batch_size, hidden_size, seed=43)\n    state_c_np = make_dummy_data(batch_size, hidden_size, seed=44)\n    weights_input_np = make_dummy_data(4*hidden_size, input_size, seed=45)\n    weights_state_np = make_dummy_data(4*hidden_size, hidden_size, seed=46)\n    bias_input_np = make_dummy_data(4*hidden_size, seed=47)\n    bias_state_np = make_dummy_data(4*hidden_size, seed=48)\n    buffer_np = make_dummy_data(4*batch_size*hidden_size, seed=49)\n    input_torch = torch.from_numpy(input_np).view(1, batch_size, input_size)",
        "detail": "deps.pufferlib.test_puffernet",
        "documentation": {}
    },
    {
        "label": "test_puffernet_one_hot",
        "kind": 2,
        "importPath": "deps.pufferlib.test_puffernet",
        "description": "deps.pufferlib.test_puffernet",
        "peekOfCode": "def test_puffernet_one_hot(batch_size=16, input_size=128, num_classes=10):\n    input_np = make_dummy_int_data(num_classes, batch_size, input_size)\n    output_puffer = np.zeros((batch_size, input_size, num_classes), dtype=np.int32)\n    puffernet.puf_one_hot(input_np, output_puffer, batch_size, input_size, num_classes)\n    input_torch = torch.from_numpy(input_np).long()\n    output_torch = torch.nn.functional.one_hot(input_torch, num_classes).int().detach()\n    assert_near(output_puffer, output_torch.numpy())\ndef test_puffernet_cat_dim1(batch_size=16, x_size=32, y_size=64):\n    x_np = make_dummy_data(batch_size, x_size)\n    y_np = make_dummy_data(batch_size, y_size)",
        "detail": "deps.pufferlib.test_puffernet",
        "documentation": {}
    },
    {
        "label": "test_puffernet_cat_dim1",
        "kind": 2,
        "importPath": "deps.pufferlib.test_puffernet",
        "description": "deps.pufferlib.test_puffernet",
        "peekOfCode": "def test_puffernet_cat_dim1(batch_size=16, x_size=32, y_size=64):\n    x_np = make_dummy_data(batch_size, x_size)\n    y_np = make_dummy_data(batch_size, y_size)\n    output_puffer = np.zeros((batch_size, x_size + y_size), dtype=np.float32)\n    puffernet.puf_cat_dim1(x_np, y_np, output_puffer, batch_size, x_size, y_size)\n    x_torch = torch.from_numpy(x_np)\n    y_torch = torch.from_numpy(y_np)\n    output_torch = torch.cat([x_torch, y_torch], dim=1).detach()\n    assert_near(output_puffer, output_torch.numpy())\ndef test_puffernet_argmax_multidiscrete(batch_size=16, logit_sizes=[5,7,2]):",
        "detail": "deps.pufferlib.test_puffernet",
        "documentation": {}
    },
    {
        "label": "test_puffernet_argmax_multidiscrete",
        "kind": 2,
        "importPath": "deps.pufferlib.test_puffernet",
        "description": "deps.pufferlib.test_puffernet",
        "peekOfCode": "def test_puffernet_argmax_multidiscrete(batch_size=16, logit_sizes=[5,7,2]):\n    logit_sizes = np.array(logit_sizes).astype(np.int32)\n    num_actions = len(logit_sizes)\n    input_np = make_dummy_data(batch_size, logit_sizes.sum())\n    output_puffer = np.zeros((batch_size, num_actions), dtype=np.int32)\n    puffernet.puf_argmax_multidiscrete(input_np, output_puffer, batch_size, logit_sizes, num_actions)\n    input_torch = torch.from_numpy(input_np)\n    action_slices = torch.split(input_torch, logit_sizes.tolist(), dim=1)\n    output_torch = torch.stack([torch.argmax(s, dim=1) for s in action_slices], dim=1).detach()\n    assert_near(output_puffer, output_torch.numpy())",
        "detail": "deps.pufferlib.test_puffernet",
        "documentation": {}
    },
    {
        "label": "SliceMerger",
        "kind": 6,
        "importPath": "deps.sample-factory.sample_factory.algo.learning.batcher",
        "description": "deps.sample-factory.sample_factory.algo.learning.batcher",
        "peekOfCode": "class SliceMerger:\n    def __init__(self):\n        self.slice_starts: Dict[int, slice] = dict()\n        self.slice_stops: Dict[int, slice] = dict()\n        self.total_num = 0\n    def _add_slice(self, s):\n        self.slice_starts[s.start] = s\n        self.slice_stops[s.stop] = s\n        self.total_num += slice_len(s)\n    def _del_slice(self, s: slice):",
        "detail": "deps.sample-factory.sample_factory.algo.learning.batcher",
        "documentation": {}
    },
    {
        "label": "Batcher",
        "kind": 6,
        "importPath": "deps.sample-factory.sample_factory.algo.learning.batcher",
        "description": "deps.sample-factory.sample_factory.algo.learning.batcher",
        "peekOfCode": "class Batcher(HeartbeatStoppableEventLoopObject):\n    def __init__(\n        self, evt_loop: EventLoop, policy_id: PolicyID, buffer_mgr: BufferMgr, cfg: AttrDict, env_info: EnvInfo\n    ):\n        unique_name = f\"{Batcher.__name__}_{policy_id}\"\n        super().__init__(evt_loop, unique_name, cfg.heartbeat_interval)\n        self.timing = Timing(name=f\"Batcher {policy_id} profile\")\n        self.cfg = cfg\n        self.env_info: EnvInfo = env_info\n        self.policy_id = policy_id",
        "detail": "deps.sample-factory.sample_factory.algo.learning.batcher",
        "documentation": {}
    },
    {
        "label": "slice_len",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.algo.learning.batcher",
        "description": "deps.sample-factory.sample_factory.algo.learning.batcher",
        "peekOfCode": "def slice_len(s: slice) -> int:\n    return s.stop - s.start\nclass SliceMerger:\n    def __init__(self):\n        self.slice_starts: Dict[int, slice] = dict()\n        self.slice_stops: Dict[int, slice] = dict()\n        self.total_num = 0\n    def _add_slice(self, s):\n        self.slice_starts[s.start] = s\n        self.slice_stops[s.stop] = s",
        "detail": "deps.sample-factory.sample_factory.algo.learning.batcher",
        "documentation": {}
    },
    {
        "label": "LearningRateScheduler",
        "kind": 6,
        "importPath": "deps.sample-factory.sample_factory.algo.learning.learner",
        "description": "deps.sample-factory.sample_factory.algo.learning.learner",
        "peekOfCode": "class LearningRateScheduler:\n    def update(self, current_lr, recent_kls):\n        return current_lr\n    def invoke_after_each_minibatch(self):\n        return False\n    def invoke_after_each_epoch(self):\n        return False\nclass KlAdaptiveScheduler(LearningRateScheduler, ABC):\n    def __init__(self, cfg: Config):\n        self.lr_schedule_kl_threshold = cfg.lr_schedule_kl_threshold",
        "detail": "deps.sample-factory.sample_factory.algo.learning.learner",
        "documentation": {}
    },
    {
        "label": "KlAdaptiveScheduler",
        "kind": 6,
        "importPath": "deps.sample-factory.sample_factory.algo.learning.learner",
        "description": "deps.sample-factory.sample_factory.algo.learning.learner",
        "peekOfCode": "class KlAdaptiveScheduler(LearningRateScheduler, ABC):\n    def __init__(self, cfg: Config):\n        self.lr_schedule_kl_threshold = cfg.lr_schedule_kl_threshold\n        self.min_lr = cfg.lr_adaptive_min\n        self.max_lr = cfg.lr_adaptive_max\n    @abstractmethod\n    def num_recent_kls_to_use(self) -> int:\n        pass\n    def update(self, current_lr, recent_kls):\n        num_kls_to_use = self.num_recent_kls_to_use()",
        "detail": "deps.sample-factory.sample_factory.algo.learning.learner",
        "documentation": {}
    },
    {
        "label": "KlAdaptiveSchedulerPerMinibatch",
        "kind": 6,
        "importPath": "deps.sample-factory.sample_factory.algo.learning.learner",
        "description": "deps.sample-factory.sample_factory.algo.learning.learner",
        "peekOfCode": "class KlAdaptiveSchedulerPerMinibatch(KlAdaptiveScheduler):\n    def num_recent_kls_to_use(self) -> int:\n        return 1\n    def invoke_after_each_minibatch(self):\n        return True\nclass KlAdaptiveSchedulerPerEpoch(KlAdaptiveScheduler):\n    def __init__(self, cfg):\n        super().__init__(cfg)\n        self.num_minibatches_per_epoch = cfg.num_batches_per_epoch\n    def num_recent_kls_to_use(self) -> int:",
        "detail": "deps.sample-factory.sample_factory.algo.learning.learner",
        "documentation": {}
    },
    {
        "label": "KlAdaptiveSchedulerPerEpoch",
        "kind": 6,
        "importPath": "deps.sample-factory.sample_factory.algo.learning.learner",
        "description": "deps.sample-factory.sample_factory.algo.learning.learner",
        "peekOfCode": "class KlAdaptiveSchedulerPerEpoch(KlAdaptiveScheduler):\n    def __init__(self, cfg):\n        super().__init__(cfg)\n        self.num_minibatches_per_epoch = cfg.num_batches_per_epoch\n    def num_recent_kls_to_use(self) -> int:\n        return self.num_minibatches_per_epoch\n    def invoke_after_each_epoch(self):\n        return True\nclass LinearDecayScheduler(LearningRateScheduler):\n    def __init__(self, cfg):",
        "detail": "deps.sample-factory.sample_factory.algo.learning.learner",
        "documentation": {}
    },
    {
        "label": "LinearDecayScheduler",
        "kind": 6,
        "importPath": "deps.sample-factory.sample_factory.algo.learning.learner",
        "description": "deps.sample-factory.sample_factory.algo.learning.learner",
        "peekOfCode": "class LinearDecayScheduler(LearningRateScheduler):\n    def __init__(self, cfg):\n        num_updates = cfg.train_for_env_steps // cfg.batch_size * cfg.num_epochs\n        self.linear_decay = LinearDecay([(0, cfg.learning_rate), (num_updates, 0)])\n        self.step = 0\n    def invoke_after_each_minibatch(self):\n        return True\n    def update(self, current_lr, recent_kls):\n        self.step += 1\n        lr = self.linear_decay.at(self.step)",
        "detail": "deps.sample-factory.sample_factory.algo.learning.learner",
        "documentation": {}
    },
    {
        "label": "Learner",
        "kind": 6,
        "importPath": "deps.sample-factory.sample_factory.algo.learning.learner",
        "description": "deps.sample-factory.sample_factory.algo.learning.learner",
        "peekOfCode": "class Learner(Configurable):\n    def __init__(\n        self,\n        cfg: Config,\n        env_info: EnvInfo,\n        policy_versions_tensor: Tensor,\n        policy_id: PolicyID,\n        param_server: ParameterServer,\n    ):\n        Configurable.__init__(self, cfg)",
        "detail": "deps.sample-factory.sample_factory.algo.learning.learner",
        "documentation": {}
    },
    {
        "label": "get_lr_scheduler",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.algo.learning.learner",
        "description": "deps.sample-factory.sample_factory.algo.learning.learner",
        "peekOfCode": "def get_lr_scheduler(cfg) -> LearningRateScheduler:\n    if cfg.lr_schedule == \"constant\":\n        return LearningRateScheduler()\n    elif cfg.lr_schedule == \"kl_adaptive_minibatch\":\n        return KlAdaptiveSchedulerPerMinibatch(cfg)\n    elif cfg.lr_schedule == \"kl_adaptive_epoch\":\n        return KlAdaptiveSchedulerPerEpoch(cfg)\n    elif cfg.lr_schedule == \"linear_decay\":\n        return LinearDecayScheduler(cfg)\n    else:",
        "detail": "deps.sample-factory.sample_factory.algo.learning.learner",
        "documentation": {}
    },
    {
        "label": "model_initialization_data",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.algo.learning.learner",
        "description": "deps.sample-factory.sample_factory.algo.learning.learner",
        "peekOfCode": "def model_initialization_data(\n    cfg: Config, policy_id: PolicyID, actor_critic: Module, policy_version: int, device: torch.device\n) -> InitModelData:\n    # in serial mode we will just use the same actor_critic directly\n    state_dict = None if cfg.serial_mode else actor_critic.state_dict()\n    model_state = (policy_id, state_dict, device, policy_version)\n    return model_state\nclass Learner(Configurable):\n    def __init__(\n        self,",
        "detail": "deps.sample-factory.sample_factory.algo.learning.learner",
        "documentation": {}
    },
    {
        "label": "LearnerWorker",
        "kind": 6,
        "importPath": "deps.sample-factory.sample_factory.algo.learning.learner_worker",
        "description": "deps.sample-factory.sample_factory.algo.learning.learner_worker",
        "peekOfCode": "class LearnerWorker(HeartbeatStoppableEventLoopObject, Configurable):\n    def __init__(\n        self,\n        evt_loop: EventLoop,\n        cfg: Config,\n        env_info: EnvInfo,\n        buffer_mgr: BufferMgr,\n        batcher: Batcher,\n        policy_id: PolicyID,\n    ):",
        "detail": "deps.sample-factory.sample_factory.algo.learning.learner_worker",
        "documentation": {}
    },
    {
        "label": "init_learner_process",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.algo.learning.learner_worker",
        "description": "deps.sample-factory.sample_factory.algo.learning.learner_worker",
        "peekOfCode": "def init_learner_process(sf_context: SampleFactoryContext, learner_worker: LearnerWorker):\n    set_global_context(sf_context)\n    log.info(f\"{learner_worker.object_id}\\tpid {os.getpid()}\\tparent {os.getppid()}\")\n    # workers should ignore Ctrl+C because the termination is handled in the event loop by a special msg\n    import signal as os_signal\n    os_signal.signal(os_signal.SIGINT, os_signal.SIG_IGN)\n    cfg = learner_worker.cfg\n    init_file_logger(cfg)\n    try:\n        psutil.Process().nice(cfg.default_niceness)",
        "detail": "deps.sample-factory.sample_factory.algo.learning.learner_worker",
        "documentation": {}
    },
    {
        "label": "build_rnn_inputs",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.algo.learning.rnn_utils",
        "description": "deps.sample-factory.sample_factory.algo.learning.rnn_utils",
        "peekOfCode": "def build_rnn_inputs(x, dones_cpu, rnn_states, T: int):\n    \"\"\"\n    Create a PackedSequence input for an RNN such that each\n    set of steps that are part of the same episode are all part of\n    a batch in the PackedSequence.\n    Use the returned select_inds and build_core_out_from_seq to invert this.\n    :param x: A (N*T, -1) tensor of the data to build the PackedSequence out of\n    :param dones_cpu: A (N*T) tensor where dones[i] == 1.0 indicates an episode is done, a CPU-bound tensor\n    :param rnn_states: A (N*T, -1) tensor of the rnn_hidden_states\n    :param T: The length of the rollout",
        "detail": "deps.sample-factory.sample_factory.algo.learning.rnn_utils",
        "documentation": {}
    },
    {
        "label": "build_core_out_from_seq",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.algo.learning.rnn_utils",
        "description": "deps.sample-factory.sample_factory.algo.learning.rnn_utils",
        "peekOfCode": "def build_core_out_from_seq(x_seq: PackedSequence, inverted_select_inds):\n    return x_seq.data.index_select(0, inverted_select_inds)",
        "detail": "deps.sample-factory.sample_factory.algo.learning.rnn_utils",
        "documentation": {}
    },
    {
        "label": "AlgoObserver",
        "kind": 6,
        "importPath": "deps.sample-factory.sample_factory.algo.runners.runner",
        "description": "deps.sample-factory.sample_factory.algo.runners.runner",
        "peekOfCode": "class AlgoObserver:\n    def on_init(self, runner: Runner) -> None:\n        \"\"\"Called after ctor, but before signal-slots are connected or any processes are started.\"\"\"\n        pass\n    def on_connect_components(self, runner: Runner) -> None:\n        \"\"\"Connect additional signal-slot pairs in the observers if needed.\"\"\"\n        pass\n    def on_start(self, runner: Runner) -> None:\n        \"\"\"Called right after sampling/learning processes are started.\"\"\"\n        pass",
        "detail": "deps.sample-factory.sample_factory.algo.runners.runner",
        "documentation": {}
    },
    {
        "label": "Runner",
        "kind": 6,
        "importPath": "deps.sample-factory.sample_factory.algo.runners.runner",
        "description": "deps.sample-factory.sample_factory.algo.runners.runner",
        "peekOfCode": "class Runner(EventLoopObject, Configurable):\n    def __init__(self, cfg, unique_name=None):\n        Configurable.__init__(self, cfg)\n        unique_name = Runner.__name__ if unique_name is None else unique_name\n        self.event_loop: EventLoop = EventLoop(unique_loop_name=f\"{unique_name}_EvtLoop\", serial_mode=cfg.serial_mode)\n        self.event_loop.owner = self\n        EventLoopObject.__init__(self, self.event_loop, object_id=unique_name)\n        self.status: StatusCode = ExperimentStatus.SUCCESS\n        self.stopped: bool = False\n        self.env_info: Optional[EnvInfo] = None",
        "detail": "deps.sample-factory.sample_factory.algo.runners.runner",
        "documentation": {}
    },
    {
        "label": "MsgHandler",
        "kind": 5,
        "importPath": "deps.sample-factory.sample_factory.algo.runners.runner",
        "description": "deps.sample-factory.sample_factory.algo.runners.runner",
        "peekOfCode": "MsgHandler = Callable[[Any, dict], None]\nPolicyMsgHandler = Callable[[Any, dict, PolicyID], None]\nclass Runner(EventLoopObject, Configurable):\n    def __init__(self, cfg, unique_name=None):\n        Configurable.__init__(self, cfg)\n        unique_name = Runner.__name__ if unique_name is None else unique_name\n        self.event_loop: EventLoop = EventLoop(unique_loop_name=f\"{unique_name}_EvtLoop\", serial_mode=cfg.serial_mode)\n        self.event_loop.owner = self\n        EventLoopObject.__init__(self, self.event_loop, object_id=unique_name)\n        self.status: StatusCode = ExperimentStatus.SUCCESS",
        "detail": "deps.sample-factory.sample_factory.algo.runners.runner",
        "documentation": {}
    },
    {
        "label": "PolicyMsgHandler",
        "kind": 5,
        "importPath": "deps.sample-factory.sample_factory.algo.runners.runner",
        "description": "deps.sample-factory.sample_factory.algo.runners.runner",
        "peekOfCode": "PolicyMsgHandler = Callable[[Any, dict, PolicyID], None]\nclass Runner(EventLoopObject, Configurable):\n    def __init__(self, cfg, unique_name=None):\n        Configurable.__init__(self, cfg)\n        unique_name = Runner.__name__ if unique_name is None else unique_name\n        self.event_loop: EventLoop = EventLoop(unique_loop_name=f\"{unique_name}_EvtLoop\", serial_mode=cfg.serial_mode)\n        self.event_loop.owner = self\n        EventLoopObject.__init__(self, self.event_loop, object_id=unique_name)\n        self.status: StatusCode = ExperimentStatus.SUCCESS\n        self.stopped: bool = False",
        "detail": "deps.sample-factory.sample_factory.algo.runners.runner",
        "documentation": {}
    },
    {
        "label": "ParallelRunner",
        "kind": 6,
        "importPath": "deps.sample-factory.sample_factory.algo.runners.runner_parallel",
        "description": "deps.sample-factory.sample_factory.algo.runners.runner_parallel",
        "peekOfCode": "class ParallelRunner(Runner):\n    def __init__(self, cfg):\n        super().__init__(cfg)\n        self.processes: List[EventLoopProcess] = []\n    def init(self) -> StatusCode:\n        status = super().init()\n        if status != ExperimentStatus.SUCCESS:\n            return status\n        mp_ctx = get_mp_ctx(self.cfg.serial_mode)\n        for policy_id in range(self.cfg.num_policies):",
        "detail": "deps.sample-factory.sample_factory.algo.runners.runner_parallel",
        "documentation": {}
    },
    {
        "label": "SerialRunner",
        "kind": 6,
        "importPath": "deps.sample-factory.sample_factory.algo.runners.runner_serial",
        "description": "deps.sample-factory.sample_factory.algo.runners.runner_serial",
        "peekOfCode": "class SerialRunner(Runner):\n    def __init__(self, cfg):\n        super().__init__(cfg)\n        self.trajectories_per_batch = self.cfg.batch_size // self.cfg.rollout\n    def init(self) -> StatusCode:\n        # in serial mode everything will be happening in the main process, so we need to initialize cuda\n        init_torch_runtime(self.cfg, max_num_threads=None)\n        status = super().init()\n        if status != ExperimentStatus.SUCCESS:\n            return status",
        "detail": "deps.sample-factory.sample_factory.algo.runners.runner_serial",
        "documentation": {}
    },
    {
        "label": "BatchedVectorEnvRunner",
        "kind": 6,
        "importPath": "deps.sample-factory.sample_factory.algo.sampling.batched_sampling",
        "description": "deps.sample-factory.sample_factory.algo.sampling.batched_sampling",
        "peekOfCode": "class BatchedVectorEnvRunner(VectorEnvRunner):\n    # TODO: comment\n    \"\"\"\n    A collection of environments simulated sequentially.\n    With double buffering each actor worker holds two vector runners and switches between them.\n    Without single buffering we only use a single VectorEnvRunner per actor worker.\n    All envs on a single VectorEnvRunner run in unison, e.g. they all do one step at a time together.\n    This also means they all finish their rollouts together. This allows us to minimize the amount of messages\n    passed around.\n    Individual envs (or agents in these envs in case of multi-agent) can potentially be controlled by different",
        "detail": "deps.sample-factory.sample_factory.algo.sampling.batched_sampling",
        "documentation": {}
    },
    {
        "label": "preprocess_actions",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.algo.sampling.batched_sampling",
        "description": "deps.sample-factory.sample_factory.algo.sampling.batched_sampling",
        "peekOfCode": "def preprocess_actions(env_info: EnvInfo, actions: Tensor | np.ndarray) -> Tensor | np.ndarray | List:\n    \"\"\"\n    We expect actions to have shape [num_envs, num_actions].\n    For environments that require only one action per step we just squeeze the second dimension,\n    because in this case the action is usually expected to be a scalar.\n    A potential way to reduce this complexity: demand all environments to have a Tuple action space even if they\n    only have a single Discrete or Box action space.\n    \"\"\"\n    if env_info.all_discrete or isinstance(env_info.action_space, gym.spaces.Discrete):\n        return process_action_space(actions, env_info.gpu_actions, is_discrete=True)",
        "detail": "deps.sample-factory.sample_factory.algo.sampling.batched_sampling",
        "documentation": {}
    },
    {
        "label": "process_action_space",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.algo.sampling.batched_sampling",
        "description": "deps.sample-factory.sample_factory.algo.sampling.batched_sampling",
        "peekOfCode": "def process_action_space(actions: torch.Tensor, gpu_actions: bool, is_discrete: bool):\n    if is_discrete:\n        actions = actions.to(torch.int32)\n    if not gpu_actions:\n        actions = actions.cpu().numpy()\n    # action tensor/array should have two dimensions (num_agents, num_actions) where num_agents is a number of\n    # individual actors in a vectorized environment (whether actually different agents or separate envs - does not\n    # matter)\n    # While continuous action envs generally expect an array/tensor of actions, even when there's just one action,\n    # discrete action envs typically expect to get the action index when there's only one action. So we squeeze the",
        "detail": "deps.sample-factory.sample_factory.algo.sampling.batched_sampling",
        "documentation": {}
    },
    {
        "label": "SamplingLoop",
        "kind": 6,
        "importPath": "deps.sample-factory.sample_factory.algo.sampling.evaluation_sampling_api",
        "description": "deps.sample-factory.sample_factory.algo.sampling.evaluation_sampling_api",
        "peekOfCode": "class SamplingLoop(EventLoopObject, Configurable):\n    def __init__(self, cfg: Config, env_info: EnvInfo, print_episode_info: bool = True):\n        Configurable.__init__(self, cfg_dict(cfg))\n        unique_name = SamplingLoop.__name__\n        self.event_loop: EventLoop = EventLoop(unique_loop_name=f\"{unique_name}_EvtLoop\", serial_mode=cfg.serial_mode)\n        self.event_loop.owner = self\n        EventLoopObject.__init__(self, self.event_loop, object_id=unique_name)\n        # self.event_loop.verbose = True\n        # calculate how many episodes for each environment should be taken into account\n        # we only want to use first N episodes (we don't want to bias ourselves with short episodes)",
        "detail": "deps.sample-factory.sample_factory.algo.sampling.evaluation_sampling_api",
        "documentation": {}
    },
    {
        "label": "EvalSamplingAPI",
        "kind": 6,
        "importPath": "deps.sample-factory.sample_factory.algo.sampling.evaluation_sampling_api",
        "description": "deps.sample-factory.sample_factory.algo.sampling.evaluation_sampling_api",
        "peekOfCode": "class EvalSamplingAPI:\n    def __init__(\n        self,\n        cfg: Config,\n        env_info: EnvInfo,\n    ):\n        self.cfg = cfg\n        self.env_info = env_info\n        self.buffer_mgr = None\n        self.policy_versions_tensor = None",
        "detail": "deps.sample-factory.sample_factory.algo.sampling.evaluation_sampling_api",
        "documentation": {}
    },
    {
        "label": "InferenceWorker",
        "kind": 6,
        "importPath": "deps.sample-factory.sample_factory.algo.sampling.inference_worker",
        "description": "deps.sample-factory.sample_factory.algo.sampling.inference_worker",
        "peekOfCode": "class InferenceWorker(HeartbeatStoppableEventLoopObject, Configurable):\n    def __init__(\n        self,\n        event_loop,\n        policy_id: PolicyID,\n        worker_idx: int,\n        buffer_mgr,\n        param_server: ParameterServer,\n        inference_queue: MpQueue,\n        cfg,",
        "detail": "deps.sample-factory.sample_factory.algo.sampling.inference_worker",
        "documentation": {}
    },
    {
        "label": "init_inference_process",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.algo.sampling.inference_worker",
        "description": "deps.sample-factory.sample_factory.algo.sampling.inference_worker",
        "peekOfCode": "def init_inference_process(sf_context: SampleFactoryContext, worker: InferenceWorker):\n    set_global_context(sf_context)\n    log.info(f\"{worker.object_id}\\tpid {os.getpid()}\\tparent {os.getppid()}\")\n    # workers should ignore Ctrl+C because the termination is handled in the event loop by a special msg\n    import signal as os_signal\n    os_signal.signal(os_signal.SIGINT, os_signal.SIG_IGN)\n    cfg = worker.cfg\n    init_file_logger(cfg)\n    try:\n        if cfg.num_workers > 1:",
        "detail": "deps.sample-factory.sample_factory.algo.sampling.inference_worker",
        "documentation": {}
    },
    {
        "label": "AdvanceRolloutSignals",
        "kind": 5,
        "importPath": "deps.sample-factory.sample_factory.algo.sampling.inference_worker",
        "description": "deps.sample-factory.sample_factory.algo.sampling.inference_worker",
        "peekOfCode": "AdvanceRolloutSignals = Dict[int, List[Tuple[int, PolicyID]]]\nPrepareOutputsFunc = Callable[[int, TensorDict, List], AdvanceRolloutSignals]\ndef init_inference_process(sf_context: SampleFactoryContext, worker: InferenceWorker):\n    set_global_context(sf_context)\n    log.info(f\"{worker.object_id}\\tpid {os.getpid()}\\tparent {os.getppid()}\")\n    # workers should ignore Ctrl+C because the termination is handled in the event loop by a special msg\n    import signal as os_signal\n    os_signal.signal(os_signal.SIGINT, os_signal.SIG_IGN)\n    cfg = worker.cfg\n    init_file_logger(cfg)",
        "detail": "deps.sample-factory.sample_factory.algo.sampling.inference_worker",
        "documentation": {}
    },
    {
        "label": "PrepareOutputsFunc",
        "kind": 5,
        "importPath": "deps.sample-factory.sample_factory.algo.sampling.inference_worker",
        "description": "deps.sample-factory.sample_factory.algo.sampling.inference_worker",
        "peekOfCode": "PrepareOutputsFunc = Callable[[int, TensorDict, List], AdvanceRolloutSignals]\ndef init_inference_process(sf_context: SampleFactoryContext, worker: InferenceWorker):\n    set_global_context(sf_context)\n    log.info(f\"{worker.object_id}\\tpid {os.getpid()}\\tparent {os.getppid()}\")\n    # workers should ignore Ctrl+C because the termination is handled in the event loop by a special msg\n    import signal as os_signal\n    os_signal.signal(os_signal.SIGINT, os_signal.SIG_IGN)\n    cfg = worker.cfg\n    init_file_logger(cfg)\n    try:",
        "detail": "deps.sample-factory.sample_factory.algo.sampling.inference_worker",
        "documentation": {}
    },
    {
        "label": "ActorState",
        "kind": 6,
        "importPath": "deps.sample-factory.sample_factory.algo.sampling.non_batched_sampling",
        "description": "deps.sample-factory.sample_factory.algo.sampling.non_batched_sampling",
        "peekOfCode": "class ActorState:\n    \"\"\"\n    State of a single actor (agent) in a multi-agent environment.\n    Single-agent environments are treated as multi-agent with one agent for simplicity.\n    \"\"\"\n    def __init__(\n        self,\n        cfg: Config,\n        env_info: EnvInfo,\n        env,",
        "detail": "deps.sample-factory.sample_factory.algo.sampling.non_batched_sampling",
        "documentation": {}
    },
    {
        "label": "NonBatchedVectorEnvRunner",
        "kind": 6,
        "importPath": "deps.sample-factory.sample_factory.algo.sampling.non_batched_sampling",
        "description": "deps.sample-factory.sample_factory.algo.sampling.non_batched_sampling",
        "peekOfCode": "class NonBatchedVectorEnvRunner(VectorEnvRunner):\n    \"\"\"\n    A collection of environments simulated sequentially.\n    With double buffering each actor worker holds two vector runners and switches between them.\n    Without double buffering we only use a single VectorEnvRunner per actor worker.\n    All envs on a single VectorEnvRunner run in unison, e.g. they all do one step at a time together.\n    This also means they all finish their rollouts together. This allows us to minimize the amount of messages\n    passed around.\n    Individual envs (or agents in these envs in case of multi-agent) can potentially be controlled by different\n    policies when we're doing PBT. We only start simulating the next step in the environment when",
        "detail": "deps.sample-factory.sample_factory.algo.sampling.non_batched_sampling",
        "documentation": {}
    },
    {
        "label": "RolloutWorker",
        "kind": 6,
        "importPath": "deps.sample-factory.sample_factory.algo.sampling.rollout_worker",
        "description": "deps.sample-factory.sample_factory.algo.sampling.rollout_worker",
        "peekOfCode": "class RolloutWorker(HeartbeatStoppableEventLoopObject, Configurable):\n    def __init__(\n        self, event_loop, worker_idx: int, buffer_mgr, inference_queues: Dict[PolicyID, MpQueue], cfg, env_info: EnvInfo\n    ):\n        Configurable.__init__(self, cfg)\n        unique_name = f\"{RolloutWorker.__name__}_w{worker_idx}\"\n        HeartbeatStoppableEventLoopObject.__init__(self, event_loop, unique_name, cfg.heartbeat_interval)\n        self.timing = Timing(name=f\"{self.object_id} profile\")\n        self.buffer_mgr = buffer_mgr\n        self.inference_queues = inference_queues",
        "detail": "deps.sample-factory.sample_factory.algo.sampling.rollout_worker",
        "documentation": {}
    },
    {
        "label": "init_rollout_worker_process",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.algo.sampling.rollout_worker",
        "description": "deps.sample-factory.sample_factory.algo.sampling.rollout_worker",
        "peekOfCode": "def init_rollout_worker_process(sf_context: SampleFactoryContext, worker: RolloutWorker):\n    log.debug(f\"Rollout worker {worker.worker_idx} starting...\")\n    set_global_context(sf_context)\n    log.info(f\"ROLLOUT worker {worker.worker_idx}\\tpid {os.getpid()}\\tparent {os.getppid()}\")\n    # workers should ignore Ctrl+C because the termination is handled in the event loop by a special msg\n    import signal as os_signal\n    os_signal.signal(os_signal.SIGINT, os_signal.SIG_IGN)\n    cfg = worker.cfg\n    init_file_logger(cfg)\n    # on MacOS, psutil.Process() has no method 'cpu_affinity'",
        "detail": "deps.sample-factory.sample_factory.algo.sampling.rollout_worker",
        "documentation": {}
    },
    {
        "label": "AbstractSampler",
        "kind": 6,
        "importPath": "deps.sample-factory.sample_factory.algo.sampling.sampler",
        "description": "deps.sample-factory.sample_factory.algo.sampling.sampler",
        "peekOfCode": "class AbstractSampler(EventLoopObject, Configurable):\n    def __init__(\n        self,\n        event_loop: EventLoop,\n        buffer_mgr: BufferMgr,\n        param_servers: Dict[PolicyID, ParameterServer],\n        cfg: Config,\n        env_info: EnvInfo,\n        unique_name: str,\n    ):",
        "detail": "deps.sample-factory.sample_factory.algo.sampling.sampler",
        "documentation": {}
    },
    {
        "label": "Sampler",
        "kind": 6,
        "importPath": "deps.sample-factory.sample_factory.algo.sampling.sampler",
        "description": "deps.sample-factory.sample_factory.algo.sampling.sampler",
        "peekOfCode": "class Sampler(AbstractSampler, ABC):\n    def __init__(\n        self,\n        event_loop: EventLoop,\n        buffer_mgr: BufferMgr,\n        param_servers: Dict[PolicyID, ParameterServer],\n        cfg: Config,\n        env_info: EnvInfo,\n    ):\n        unique_name = Sampler.__name__",
        "detail": "deps.sample-factory.sample_factory.algo.sampling.sampler",
        "documentation": {}
    },
    {
        "label": "SerialSampler",
        "kind": 6,
        "importPath": "deps.sample-factory.sample_factory.algo.sampling.sampler",
        "description": "deps.sample-factory.sample_factory.algo.sampling.sampler",
        "peekOfCode": "class SerialSampler(Sampler):\n    def __init__(\n        self,\n        event_loop: EventLoop,\n        buffer_mgr,\n        param_servers: Dict[PolicyID, ParameterServer],\n        cfg: Config,\n        env_info: EnvInfo,\n    ):\n        Sampler.__init__(self, event_loop, buffer_mgr, param_servers, cfg, env_info)",
        "detail": "deps.sample-factory.sample_factory.algo.sampling.sampler",
        "documentation": {}
    },
    {
        "label": "ParallelSampler",
        "kind": 6,
        "importPath": "deps.sample-factory.sample_factory.algo.sampling.sampler",
        "description": "deps.sample-factory.sample_factory.algo.sampling.sampler",
        "peekOfCode": "class ParallelSampler(Sampler):\n    def __init__(\n        self,\n        event_loop: EventLoop,\n        buffer_mgr,\n        param_servers: Dict[PolicyID, ParameterServer],\n        cfg: Config,\n        env_info: EnvInfo,\n    ):\n        Sampler.__init__(self, event_loop, buffer_mgr, param_servers, cfg, env_info)",
        "detail": "deps.sample-factory.sample_factory.algo.sampling.sampler",
        "documentation": {}
    },
    {
        "label": "VectorEnvRunner",
        "kind": 6,
        "importPath": "deps.sample-factory.sample_factory.algo.sampling.sampling_utils",
        "description": "deps.sample-factory.sample_factory.algo.sampling.sampling_utils",
        "peekOfCode": "class VectorEnvRunner(Configurable):\n    def __init__(self, cfg: AttrDict, env_info: EnvInfo, worker_idx, split_idx, buffer_mgr, sampling_device: str):\n        super().__init__(cfg)\n        self.env_info: EnvInfo = env_info\n        self.worker_idx = worker_idx\n        self.split_idx = split_idx\n        self.rollout_step: int = 0  # current position in the rollout across all envs\n        self.env_step_ready = False\n        self.buffer_mgr = buffer_mgr\n        self.traj_buffer_queue = buffer_mgr.traj_buffer_queues[sampling_device]",
        "detail": "deps.sample-factory.sample_factory.algo.sampling.sampling_utils",
        "documentation": {}
    },
    {
        "label": "rollout_worker_device",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.algo.sampling.sampling_utils",
        "description": "deps.sample-factory.sample_factory.algo.sampling.sampling_utils",
        "peekOfCode": "def rollout_worker_device(worker_idx, cfg: AttrDict, env_info: EnvInfo) -> torch.device:\n    # TODO: this should correspond to whichever device we have observations on, not just whether we use this device at all\n    # TODO: test with Megaverse on a multi-GPU system\n    # TODO: actions on a GPU device? Convert to CPU for some envs?\n    if not env_info.gpu_observations:\n        return torch.device(\"cpu\")\n    gpus_to_use = gpus_for_process(worker_idx, num_gpus_per_process=1, gpu_mask=cfg.actor_worker_gpus)\n    assert len(gpus_to_use) <= 1\n    sampling_device = torch.device(\"cuda\", index=gpus_to_use[0]) if gpus_to_use else torch.device(\"cpu\")\n    return sampling_device",
        "detail": "deps.sample-factory.sample_factory.algo.sampling.sampling_utils",
        "documentation": {}
    },
    {
        "label": "record_episode_statistics_wrapper_stats",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.algo.sampling.sampling_utils",
        "description": "deps.sample-factory.sample_factory.algo.sampling.sampling_utils",
        "peekOfCode": "def record_episode_statistics_wrapper_stats(info: Dict) -> Optional[Tuple[float, float]]:\n    \"\"\"\n    Some envs like Atari use a special wrapper gym.wrappers.RecordEpisodeStatistics to record episode stats.\n    This accounts for things like reward clipping in the wrappers or frameskip affecting length.\n    \"\"\"\n    if ep_info := info.get(\"episode\", None):\n        return ep_info[\"r\"], ep_info[\"l\"]\n    return None",
        "detail": "deps.sample-factory.sample_factory.algo.sampling.sampling_utils",
        "documentation": {}
    },
    {
        "label": "timing_msg_handler",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.algo.sampling.stats",
        "description": "deps.sample-factory.sample_factory.algo.sampling.stats",
        "peekOfCode": "def timing_msg_handler(stats_observer: Any, msg: dict) -> None:\n    \"\"\"We use duck typing here, assuming that stats_observer object has avg_stats dict.\"\"\"\n    assert hasattr(stats_observer, \"avg_stats\"), f\"stats_observer object has no avg_stats dict: {stats_observer}\"\n    for k, v in msg[\"timing\"].items():\n        if k not in stats_observer.avg_stats:\n            stats_observer.avg_stats[k] = deque([], maxlen=50)\n        stats_observer.avg_stats[k].append(v)\ndef stats_msg_handler(stats_observer: Any, msg: dict) -> None:\n    \"\"\"We use duck typing here, assuming that stats_observer object has stats dict.\"\"\"\n    assert hasattr(stats_observer, \"stats\"), f\"stats_observer object has no stats dict: {stats_observer}\"",
        "detail": "deps.sample-factory.sample_factory.algo.sampling.stats",
        "documentation": {}
    },
    {
        "label": "stats_msg_handler",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.algo.sampling.stats",
        "description": "deps.sample-factory.sample_factory.algo.sampling.stats",
        "peekOfCode": "def stats_msg_handler(stats_observer: Any, msg: dict) -> None:\n    \"\"\"We use duck typing here, assuming that stats_observer object has stats dict.\"\"\"\n    assert hasattr(stats_observer, \"stats\"), f\"stats_observer object has no stats dict: {stats_observer}\"\n    stats_observer.stats.update(msg[\"stats\"])\ndef samples_stats_handler(stats_observer: Any, msg: dict, policy_id: PolicyID) -> None:\n    stats_observer.samples_collected[policy_id] += msg[SAMPLES_COLLECTED]",
        "detail": "deps.sample-factory.sample_factory.algo.sampling.stats",
        "documentation": {}
    },
    {
        "label": "samples_stats_handler",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.algo.sampling.stats",
        "description": "deps.sample-factory.sample_factory.algo.sampling.stats",
        "peekOfCode": "def samples_stats_handler(stats_observer: Any, msg: dict, policy_id: PolicyID) -> None:\n    stats_observer.samples_collected[policy_id] += msg[SAMPLES_COLLECTED]",
        "detail": "deps.sample-factory.sample_factory.algo.sampling.stats",
        "documentation": {}
    },
    {
        "label": "SyncSamplingAPI",
        "kind": 6,
        "importPath": "deps.sample-factory.sample_factory.algo.sampling.sync_sampling_api",
        "description": "deps.sample-factory.sample_factory.algo.sampling.sync_sampling_api",
        "peekOfCode": "class SyncSamplingAPI:\n    def __init__(\n        self,\n        cfg: Config,\n        env_info: EnvInfo,\n        buffer_mgr: Optional[BufferMgr] = None,\n        param_servers: Optional[Dict[PolicyID, ParameterServer]] = None,\n    ):\n        self.sampling_loop: SamplingLoop = SamplingLoop(cfg, env_info, print_episode_info=False)\n        self.sampling_loop.init(buffer_mgr, param_servers)",
        "detail": "deps.sample-factory.sample_factory.algo.sampling.sync_sampling_api",
        "documentation": {}
    },
    {
        "label": "Discretized",
        "kind": 6,
        "importPath": "deps.sample-factory.sample_factory.algo.utils.spaces.discretized",
        "description": "deps.sample-factory.sample_factory.algo.utils.spaces.discretized",
        "peekOfCode": "class Discretized(Discrete):\n    def __init__(self, n, min_action, max_action):\n        super().__init__(n)\n        self.min_action = min_action\n        self.max_action = max_action\n    def to_continuous(self, discrete_action):\n        step = (self.max_action - self.min_action) / (self.n - 1)  # min=-1, max=1, n=11, step=0.2\n        action = self.min_action + discrete_action * step\n        return action",
        "detail": "deps.sample-factory.sample_factory.algo.utils.spaces.discretized",
        "documentation": {}
    },
    {
        "label": "CategoricalActionDistribution",
        "kind": 6,
        "importPath": "deps.sample-factory.sample_factory.algo.utils.action_distributions",
        "description": "deps.sample-factory.sample_factory.algo.utils.action_distributions",
        "peekOfCode": "class CategoricalActionDistribution:\n    def __init__(self, raw_logits):\n        \"\"\"\n        Ctor.\n        :param raw_logits: unprocessed logits, typically an output of a fully-connected layer\n        \"\"\"\n        self.raw_logits = raw_logits\n        self.log_p = self.p = None\n    @property\n    def probs(self):",
        "detail": "deps.sample-factory.sample_factory.algo.utils.action_distributions",
        "documentation": {}
    },
    {
        "label": "TupleActionDistribution",
        "kind": 6,
        "importPath": "deps.sample-factory.sample_factory.algo.utils.action_distributions",
        "description": "deps.sample-factory.sample_factory.algo.utils.action_distributions",
        "peekOfCode": "class TupleActionDistribution:\n    \"\"\"\n    Basically, a tuple of independent action distributions.\n    Useful when the environment requires multiple independent action heads, e.g.:\n     - moving in the environment\n     - selecting a weapon\n     - jumping\n     - strafing\n    Empirically, it seems to be better to represent such an action distribution as a tuple of independent action\n    distributions, rather than a one-hot over potentially big cartesian product of all action spaces, like it's",
        "detail": "deps.sample-factory.sample_factory.algo.utils.action_distributions",
        "documentation": {}
    },
    {
        "label": "ContinuousActionDistribution",
        "kind": 6,
        "importPath": "deps.sample-factory.sample_factory.algo.utils.action_distributions",
        "description": "deps.sample-factory.sample_factory.algo.utils.action_distributions",
        "peekOfCode": "class ContinuousActionDistribution(Independent):\n    stddev_min: float = 1e-4\n    stddev_max: float = 1e4\n    def __init__(self, params):\n        self.means, self.log_std, self.stddevs = self._init_impl(params, self.stddev_min, self.stddev_max)\n        normal_dist = Normal(self.means, self.stddevs, validate_args=False)\n        super().__init__(normal_dist, 1, validate_args=False)\n    @staticmethod\n    @torch.jit.script\n    def _init_impl(params: Tensor, stddev_min: float, stddev_max: float):",
        "detail": "deps.sample-factory.sample_factory.algo.utils.action_distributions",
        "documentation": {}
    },
    {
        "label": "calc_num_actions",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.algo.utils.action_distributions",
        "description": "deps.sample-factory.sample_factory.algo.utils.action_distributions",
        "peekOfCode": "def calc_num_actions(action_space):\n    if isinstance(action_space, gym.spaces.Discrete):\n        return 1\n    elif isinstance(action_space, gym.spaces.Tuple):\n        return sum([calc_num_actions(a) for a in action_space])\n    elif isinstance(action_space, gym.spaces.Box):\n        if len(action_space.shape) != 1:\n            raise Exception(\"Non-trivial shape Box action spaces not currently supported. Try to flatten the space.\")\n        return action_space.shape[0]\n    else:",
        "detail": "deps.sample-factory.sample_factory.algo.utils.action_distributions",
        "documentation": {}
    },
    {
        "label": "calc_num_action_parameters",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.algo.utils.action_distributions",
        "description": "deps.sample-factory.sample_factory.algo.utils.action_distributions",
        "peekOfCode": "def calc_num_action_parameters(action_space: ActionSpace) -> int:\n    \"\"\"Returns the number of paramaters required to represent the given action space.\"\"\"\n    if isinstance(action_space, gym.spaces.Discrete):\n        return action_space.n\n    elif isinstance(action_space, gym.spaces.Tuple):\n        return sum([calc_num_action_parameters(a) for a in action_space])\n    elif isinstance(action_space, gym.spaces.Box):\n        # one mean and one standard deviation for every action\n        return np.prod(action_space.shape) * 2\n    else:",
        "detail": "deps.sample-factory.sample_factory.algo.utils.action_distributions",
        "documentation": {}
    },
    {
        "label": "is_continuous_action_space",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.algo.utils.action_distributions",
        "description": "deps.sample-factory.sample_factory.algo.utils.action_distributions",
        "peekOfCode": "def is_continuous_action_space(action_space: ActionSpace) -> bool:\n    return isinstance(action_space, gym.spaces.Box)\ndef get_action_distribution(action_space, raw_logits):\n    \"\"\"\n    Create the distribution object based on provided action space and unprocessed logits.\n    :param action_space: Gym action space object\n    :param raw_logits: this function expects unprocessed raw logits (not after log-softmax!)\n    :return: action distribution that you can sample from\n    \"\"\"\n    assert calc_num_action_parameters(action_space) == raw_logits.shape[-1]",
        "detail": "deps.sample-factory.sample_factory.algo.utils.action_distributions",
        "documentation": {}
    },
    {
        "label": "get_action_distribution",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.algo.utils.action_distributions",
        "description": "deps.sample-factory.sample_factory.algo.utils.action_distributions",
        "peekOfCode": "def get_action_distribution(action_space, raw_logits):\n    \"\"\"\n    Create the distribution object based on provided action space and unprocessed logits.\n    :param action_space: Gym action space object\n    :param raw_logits: this function expects unprocessed raw logits (not after log-softmax!)\n    :return: action distribution that you can sample from\n    \"\"\"\n    assert calc_num_action_parameters(action_space) == raw_logits.shape[-1]\n    if isinstance(action_space, gym.spaces.Discrete):\n        return CategoricalActionDistribution(raw_logits)",
        "detail": "deps.sample-factory.sample_factory.algo.utils.action_distributions",
        "documentation": {}
    },
    {
        "label": "sample_actions_log_probs",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.algo.utils.action_distributions",
        "description": "deps.sample-factory.sample_factory.algo.utils.action_distributions",
        "peekOfCode": "def sample_actions_log_probs(distribution):\n    if isinstance(distribution, TupleActionDistribution):\n        return distribution.sample_actions_log_probs()\n    else:\n        actions = distribution.sample()\n        log_prob_actions = distribution.log_prob(actions)\n        return actions, log_prob_actions\ndef argmax_actions(distribution):\n    if isinstance(distribution, TupleActionDistribution):\n        return distribution.argmax()",
        "detail": "deps.sample-factory.sample_factory.algo.utils.action_distributions",
        "documentation": {}
    },
    {
        "label": "argmax_actions",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.algo.utils.action_distributions",
        "description": "deps.sample-factory.sample_factory.algo.utils.action_distributions",
        "peekOfCode": "def argmax_actions(distribution):\n    if isinstance(distribution, TupleActionDistribution):\n        return distribution.argmax()\n    elif hasattr(distribution, \"probs\"):\n        return torch.argmax(distribution.probs, dim=-1)\n    elif hasattr(distribution, \"means\"):\n        return distribution.means\n    else:\n        raise NotImplementedError(f\"Action distribution type {type(distribution)} does not support argmax!\")\n# noinspection PyAbstractClass",
        "detail": "deps.sample-factory.sample_factory.algo.utils.action_distributions",
        "documentation": {}
    },
    {
        "label": "AgentPolicyMapping",
        "kind": 6,
        "importPath": "deps.sample-factory.sample_factory.algo.utils.agent_policy_mapping",
        "description": "deps.sample-factory.sample_factory.algo.utils.agent_policy_mapping",
        "peekOfCode": "class AgentPolicyMapping:\n    \"\"\"\n    This class currently implements the most simple mapping between agents in the envs and their associated policies.\n    We just pick a random policy from the population for every agent at the beginning of the episode.\n    Methods of this class can potentially be overloaded to provide a more clever mapping, e.g. we can minimize the\n    number of different policies per rollout worker thus minimizing the amount of communication required.\n    TODO: would be nice to have a mechanism to provide custom mappings through API.\n    \"\"\"\n    def __init__(self, cfg: Config, env_info: EnvInfo):\n        self.rng = np.random.RandomState(seed=random.randint(0, 2**32 - 1))",
        "detail": "deps.sample-factory.sample_factory.algo.utils.agent_policy_mapping",
        "documentation": {}
    },
    {
        "label": "SampleFactoryContext",
        "kind": 6,
        "importPath": "deps.sample-factory.sample_factory.algo.utils.context",
        "description": "deps.sample-factory.sample_factory.algo.utils.context",
        "peekOfCode": "class SampleFactoryContext:\n    def __init__(self):\n        self.env_registry = dict()\n        self.model_factory = ModelFactory()\nGLOBAL_CONTEXT = None\ndef sf_global_context() -> SampleFactoryContext:\n    global GLOBAL_CONTEXT\n    if GLOBAL_CONTEXT is None:\n        GLOBAL_CONTEXT = SampleFactoryContext()\n    return GLOBAL_CONTEXT",
        "detail": "deps.sample-factory.sample_factory.algo.utils.context",
        "documentation": {}
    },
    {
        "label": "sf_global_context",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.algo.utils.context",
        "description": "deps.sample-factory.sample_factory.algo.utils.context",
        "peekOfCode": "def sf_global_context() -> SampleFactoryContext:\n    global GLOBAL_CONTEXT\n    if GLOBAL_CONTEXT is None:\n        GLOBAL_CONTEXT = SampleFactoryContext()\n    return GLOBAL_CONTEXT\ndef set_global_context(ctx: SampleFactoryContext):\n    global GLOBAL_CONTEXT\n    GLOBAL_CONTEXT = ctx\ndef reset_global_context():\n    global GLOBAL_CONTEXT",
        "detail": "deps.sample-factory.sample_factory.algo.utils.context",
        "documentation": {}
    },
    {
        "label": "set_global_context",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.algo.utils.context",
        "description": "deps.sample-factory.sample_factory.algo.utils.context",
        "peekOfCode": "def set_global_context(ctx: SampleFactoryContext):\n    global GLOBAL_CONTEXT\n    GLOBAL_CONTEXT = ctx\ndef reset_global_context():\n    global GLOBAL_CONTEXT\n    GLOBAL_CONTEXT = SampleFactoryContext()\ndef global_env_registry() -> Dict[str, CreateEnvFunc]:\n    \"\"\"\n    :return: global env registry\n    :rtype: EnvRegistry",
        "detail": "deps.sample-factory.sample_factory.algo.utils.context",
        "documentation": {}
    },
    {
        "label": "reset_global_context",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.algo.utils.context",
        "description": "deps.sample-factory.sample_factory.algo.utils.context",
        "peekOfCode": "def reset_global_context():\n    global GLOBAL_CONTEXT\n    GLOBAL_CONTEXT = SampleFactoryContext()\ndef global_env_registry() -> Dict[str, CreateEnvFunc]:\n    \"\"\"\n    :return: global env registry\n    :rtype: EnvRegistry\n    \"\"\"\n    return sf_global_context().env_registry\ndef global_model_factory() -> ModelFactory:",
        "detail": "deps.sample-factory.sample_factory.algo.utils.context",
        "documentation": {}
    },
    {
        "label": "global_env_registry",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.algo.utils.context",
        "description": "deps.sample-factory.sample_factory.algo.utils.context",
        "peekOfCode": "def global_env_registry() -> Dict[str, CreateEnvFunc]:\n    \"\"\"\n    :return: global env registry\n    :rtype: EnvRegistry\n    \"\"\"\n    return sf_global_context().env_registry\ndef global_model_factory() -> ModelFactory:\n    \"\"\"\n    :return: global model factory\n    :rtype: ModelFactory",
        "detail": "deps.sample-factory.sample_factory.algo.utils.context",
        "documentation": {}
    },
    {
        "label": "global_model_factory",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.algo.utils.context",
        "description": "deps.sample-factory.sample_factory.algo.utils.context",
        "peekOfCode": "def global_model_factory() -> ModelFactory:\n    \"\"\"\n    :return: global model factory\n    :rtype: ModelFactory\n    \"\"\"\n    return sf_global_context().model_factory",
        "detail": "deps.sample-factory.sample_factory.algo.utils.context",
        "documentation": {}
    },
    {
        "label": "GLOBAL_CONTEXT",
        "kind": 5,
        "importPath": "deps.sample-factory.sample_factory.algo.utils.context",
        "description": "deps.sample-factory.sample_factory.algo.utils.context",
        "peekOfCode": "GLOBAL_CONTEXT = None\ndef sf_global_context() -> SampleFactoryContext:\n    global GLOBAL_CONTEXT\n    if GLOBAL_CONTEXT is None:\n        GLOBAL_CONTEXT = SampleFactoryContext()\n    return GLOBAL_CONTEXT\ndef set_global_context(ctx: SampleFactoryContext):\n    global GLOBAL_CONTEXT\n    GLOBAL_CONTEXT = ctx\ndef reset_global_context():",
        "detail": "deps.sample-factory.sample_factory.algo.utils.context",
        "documentation": {}
    },
    {
        "label": "EnvInfo",
        "kind": 6,
        "importPath": "deps.sample-factory.sample_factory.algo.utils.env_info",
        "description": "deps.sample-factory.sample_factory.algo.utils.env_info",
        "peekOfCode": "class EnvInfo:\n    obs_space: gym.Space\n    action_space: gym.Space\n    num_agents: int\n    gpu_actions: bool  # whether actions provided by the agent should be on GPU or not\n    gpu_observations: bool  # whether environment provides data (obs, etc.) on GPU or not\n    action_splits: List[int]  # in the case of tuple actions, the splits for the actions\n    all_discrete: bool  # in the case of tuple actions, whether the actions are all discrete\n    frameskip: int\n    # potentially customizable reward shaping, a map of reward component names to their respective weights",
        "detail": "deps.sample-factory.sample_factory.algo.utils.env_info",
        "documentation": {}
    },
    {
        "label": "extract_env_info",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.algo.utils.env_info",
        "description": "deps.sample-factory.sample_factory.algo.utils.env_info",
        "peekOfCode": "def extract_env_info(env: BatchedVecEnv | NonBatchedVecEnv, cfg: Config) -> EnvInfo:\n    obs_space = env.observation_space\n    action_space = env.action_space\n    num_agents = env.num_agents\n    gpu_actions = cfg.env_gpu_actions\n    gpu_observations = cfg.env_gpu_observations\n    frameskip = cfg.env_frameskip\n    reward_shaping_scheme = get_default_reward_shaping(env)\n    action_splits = None\n    all_discrete = None",
        "detail": "deps.sample-factory.sample_factory.algo.utils.env_info",
        "documentation": {}
    },
    {
        "label": "check_env_info",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.algo.utils.env_info",
        "description": "deps.sample-factory.sample_factory.algo.utils.env_info",
        "peekOfCode": "def check_env_info(env: BatchedVecEnv | NonBatchedVecEnv, env_info: EnvInfo, cfg: Config) -> None:\n    new_env_info = extract_env_info(env, cfg)\n    if new_env_info != env_info:\n        cache_filename = env_info_cache_filename(cfg)\n        log.error(\n            f\"Env info does not match the cached value: {env_info} != {new_env_info}. Deleting the cache entry {cache_filename}\"\n        )\n        try:\n            os.remove(cache_filename)\n        except OSError:",
        "detail": "deps.sample-factory.sample_factory.algo.utils.env_info",
        "documentation": {}
    },
    {
        "label": "spawn_tmp_env_and_get_info",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.algo.utils.env_info",
        "description": "deps.sample-factory.sample_factory.algo.utils.env_info",
        "peekOfCode": "def spawn_tmp_env_and_get_info(sf_context, res_queue, cfg):\n    set_global_context(sf_context)\n    tmp_env = make_env_func_batched(cfg, env_config=None)\n    env_info = extract_env_info(tmp_env, cfg)\n    tmp_env.close()\n    del tmp_env\n    log.debug(\"Env info: %r\", env_info)\n    res_queue.put(env_info)\ndef env_info_cache_filename(cfg: Config) -> str:\n    return join(project_tmp_dir(), f\"env_info_{cfg.env}\")",
        "detail": "deps.sample-factory.sample_factory.algo.utils.env_info",
        "documentation": {}
    },
    {
        "label": "env_info_cache_filename",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.algo.utils.env_info",
        "description": "deps.sample-factory.sample_factory.algo.utils.env_info",
        "peekOfCode": "def env_info_cache_filename(cfg: Config) -> str:\n    return join(project_tmp_dir(), f\"env_info_{cfg.env}\")\ndef obtain_env_info_in_a_separate_process(cfg: Config) -> EnvInfo:\n    cache_filename = env_info_cache_filename(cfg)\n    if cfg.use_env_info_cache and os.path.isfile(cache_filename):\n        log.debug(f\"Loading env info from cache: {cache_filename}\")\n        with open(cache_filename, \"rb\") as fobj:\n            env_info = pickle.load(fobj)\n            if env_info.env_info_protocol_version == ENV_INFO_PROTOCOL_VERSION:\n                return env_info",
        "detail": "deps.sample-factory.sample_factory.algo.utils.env_info",
        "documentation": {}
    },
    {
        "label": "obtain_env_info_in_a_separate_process",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.algo.utils.env_info",
        "description": "deps.sample-factory.sample_factory.algo.utils.env_info",
        "peekOfCode": "def obtain_env_info_in_a_separate_process(cfg: Config) -> EnvInfo:\n    cache_filename = env_info_cache_filename(cfg)\n    if cfg.use_env_info_cache and os.path.isfile(cache_filename):\n        log.debug(f\"Loading env info from cache: {cache_filename}\")\n        with open(cache_filename, \"rb\") as fobj:\n            env_info = pickle.load(fobj)\n            if env_info.env_info_protocol_version == ENV_INFO_PROTOCOL_VERSION:\n                return env_info\n    sf_context = sf_global_context()\n    ctx = multiprocessing.get_context(\"spawn\")",
        "detail": "deps.sample-factory.sample_factory.algo.utils.env_info",
        "documentation": {}
    },
    {
        "label": "ENV_INFO_PROTOCOL_VERSION",
        "kind": 5,
        "importPath": "deps.sample-factory.sample_factory.algo.utils.env_info",
        "description": "deps.sample-factory.sample_factory.algo.utils.env_info",
        "peekOfCode": "ENV_INFO_PROTOCOL_VERSION = 1\n@dataclass\nclass EnvInfo:\n    obs_space: gym.Space\n    action_space: gym.Space\n    num_agents: int\n    gpu_actions: bool  # whether actions provided by the agent should be on GPU or not\n    gpu_observations: bool  # whether environment provides data (obs, etc.) on GPU or not\n    action_splits: List[int]  # in the case of tuple actions, the splits for the actions\n    all_discrete: bool  # in the case of tuple actions, whether the actions are all discrete",
        "detail": "deps.sample-factory.sample_factory.algo.utils.env_info",
        "documentation": {}
    },
    {
        "label": "patch_non_gymnasium_env",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.algo.utils.gymnasium_utils",
        "description": "deps.sample-factory.sample_factory.algo.utils.gymnasium_utils",
        "peekOfCode": "def patch_non_gymnasium_env(env: Union[\"gym.Env\", gymnasium.Env]) -> gymnasium.Env:\n    env = _patch_env(env)\n    try:\n        # patching spaces\n        if not isinstance(env.observation_space, gymnasium.Space):\n            env.observation_space = convert_space(env.observation_space)\n        if not isinstance(env.action_space, gymnasium.Space):\n            env.action_space = convert_space(env.action_space)\n    except AttributeError:\n        # gym.Env does not have observation_space and action_space or they're defined as properties",
        "detail": "deps.sample-factory.sample_factory.algo.utils.gymnasium_utils",
        "documentation": {}
    },
    {
        "label": "convert_space",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.algo.utils.gymnasium_utils",
        "description": "deps.sample-factory.sample_factory.algo.utils.gymnasium_utils",
        "peekOfCode": "def convert_space(space: Union[\"gym.Space\", gymnasium.Space]) -> gymnasium.Space:  # pragma: no cover\n    \"\"\"\n    Takes a space and patches it to return Gymnasium Space.\n    This function takes the space object and returns a patched\n    space, using shimmy wrapper to convert it to Gymnasium,\n    if necessary.\n    :param space: A gym/gymnasium Space\n    :return: Patched space (gymnasium Space)\n    \"\"\"\n    # Gymnasium space, no convertion to be done",
        "detail": "deps.sample-factory.sample_factory.algo.utils.gymnasium_utils",
        "documentation": {}
    },
    {
        "label": "HeartbeatStoppableEventLoopObject",
        "kind": 6,
        "importPath": "deps.sample-factory.sample_factory.algo.utils.heartbeat",
        "description": "deps.sample-factory.sample_factory.algo.utils.heartbeat",
        "peekOfCode": "class HeartbeatStoppableEventLoopObject(EventLoopObject):\n    def __init__(self, evt_loop: EventLoop, unique_name: str, interval_sec: int = 10):\n        EventLoopObject.__init__(self, evt_loop, unique_name)\n        self.heartbeat_timer = Timer(evt_loop, interval_sec)\n        self.heartbeat_timer.timeout.connect(self._report_heartbeat)\n    @signal\n    def heartbeat(self):\n        ...\n    @signal\n    def stop(self):",
        "detail": "deps.sample-factory.sample_factory.algo.utils.heartbeat",
        "documentation": {}
    },
    {
        "label": "_DictObservationsWrapper",
        "kind": 6,
        "importPath": "deps.sample-factory.sample_factory.algo.utils.make_env",
        "description": "deps.sample-factory.sample_factory.algo.utils.make_env",
        "peekOfCode": "class _DictObservationsWrapper(Wrapper):\n    def __init__(self, env):\n        super().__init__(env)\n        is_multiagent, num_agents = get_multiagent_info(env)\n        self.is_multiagent: bool = is_multiagent\n        self.num_agents: int = num_agents\n        self.observation_space: gym.spaces.Dict = gym.spaces.Dict(dict(obs=self.observation_space))\nclass BatchedDictObservationsWrapper(_DictObservationsWrapper):\n    \"\"\"Guarantees that the environment returns observations as dictionaries of lists (batches).\"\"\"\n    def reset(self, **kwargs):",
        "detail": "deps.sample-factory.sample_factory.algo.utils.make_env",
        "documentation": {}
    },
    {
        "label": "BatchedDictObservationsWrapper",
        "kind": 6,
        "importPath": "deps.sample-factory.sample_factory.algo.utils.make_env",
        "description": "deps.sample-factory.sample_factory.algo.utils.make_env",
        "peekOfCode": "class BatchedDictObservationsWrapper(_DictObservationsWrapper):\n    \"\"\"Guarantees that the environment returns observations as dictionaries of lists (batches).\"\"\"\n    def reset(self, **kwargs):\n        obs, info = self.env.reset(**kwargs)\n        return dict(obs=obs), info\n    def step(self, action):\n        obs, rew, terminated, truncated, info = self.env.step(action)\n        return dict(obs=obs), rew, terminated, truncated, info\nclass BatchedMultiAgentWrapper(Wrapper):\n    \"\"\"Assumes wrapped environment has dictionary obs space.\"\"\"",
        "detail": "deps.sample-factory.sample_factory.algo.utils.make_env",
        "documentation": {}
    },
    {
        "label": "BatchedMultiAgentWrapper",
        "kind": 6,
        "importPath": "deps.sample-factory.sample_factory.algo.utils.make_env",
        "description": "deps.sample-factory.sample_factory.algo.utils.make_env",
        "peekOfCode": "class BatchedMultiAgentWrapper(Wrapper):\n    \"\"\"Assumes wrapped environment has dictionary obs space.\"\"\"\n    def __init__(self, env):\n        super().__init__(env)\n        self.num_agents: int = 1\n        self.is_multiagent: bool = True\n        assert isinstance(env.observation_space, spaces.Dict), \"Wrapped environment must have dictionary obs space.\"\n        self.obs_dict = {}\n    def _obs(self, obs: Dict) -> DictOfListsObservations:\n        for key, value in obs.items():",
        "detail": "deps.sample-factory.sample_factory.algo.utils.make_env",
        "documentation": {}
    },
    {
        "label": "NonBatchedMultiAgentWrapper",
        "kind": 6,
        "importPath": "deps.sample-factory.sample_factory.algo.utils.make_env",
        "description": "deps.sample-factory.sample_factory.algo.utils.make_env",
        "peekOfCode": "class NonBatchedMultiAgentWrapper(Wrapper):\n    \"\"\"\n    This wrapper allows us to treat a single-agent environment as multi-agent with 1 agent.\n    That is, the data (obs, rewards, etc.) is converted into lists of length 1\n    \"\"\"\n    def __init__(self, env):\n        super().__init__(env)\n        self.num_agents: int = 1\n        self.is_multiagent: bool = True\n    def reset(self, **kwargs) -> ListObservations:",
        "detail": "deps.sample-factory.sample_factory.algo.utils.make_env",
        "documentation": {}
    },
    {
        "label": "NonBatchedDictObservationsWrapper",
        "kind": 6,
        "importPath": "deps.sample-factory.sample_factory.algo.utils.make_env",
        "description": "deps.sample-factory.sample_factory.algo.utils.make_env",
        "peekOfCode": "class NonBatchedDictObservationsWrapper(_DictObservationsWrapper):\n    \"\"\"Guarantees that the environment returns observations as lists of dictionaries.\"\"\"\n    def reset(self, **kwargs) -> ListOfDictObservations:\n        obs, info = self.env.reset(**kwargs)\n        return [dict(obs=o) for o in obs], info\n    def step(self, action: ListActions) -> Tuple[ListOfDictObservations, Any, Any, Any, Any]:\n        obs, rew, terminated, truncated, info = self.env.step(action)\n        return [dict(obs=o) for o in obs], rew, terminated, truncated, info\nclass BatchedListToDictWrapper(Wrapper):\n    def reset(self, **kwargs):",
        "detail": "deps.sample-factory.sample_factory.algo.utils.make_env",
        "documentation": {}
    },
    {
        "label": "BatchedListToDictWrapper",
        "kind": 6,
        "importPath": "deps.sample-factory.sample_factory.algo.utils.make_env",
        "description": "deps.sample-factory.sample_factory.algo.utils.make_env",
        "peekOfCode": "class BatchedListToDictWrapper(Wrapper):\n    def reset(self, **kwargs):\n        obs, info = self.env.reset(**kwargs)\n        if isinstance(obs, list):\n            return list_of_dicts_to_dict_of_lists(obs), info\n        return obs, info\n    def step(self, action):\n        obs, rew, terminated, truncated, info = self.env.step(action)\n        if isinstance(obs, list):\n            return list_of_dicts_to_dict_of_lists(obs), rew, terminated, truncated, info",
        "detail": "deps.sample-factory.sample_factory.algo.utils.make_env",
        "documentation": {}
    },
    {
        "label": "BatchedVecEnv",
        "kind": 6,
        "importPath": "deps.sample-factory.sample_factory.algo.utils.make_env",
        "description": "deps.sample-factory.sample_factory.algo.utils.make_env",
        "peekOfCode": "class BatchedVecEnv(Wrapper):\n    \"\"\"Ensures that the env returns a dictionary of tensors for observations, and tensors for rewards and dones.\"\"\"\n    ConvertFunc = Callable[[Any], Tensor]\n    def __init__(self, env):\n        if not isinstance(env.observation_space, spaces.Dict):\n            env = BatchedDictObservationsWrapper(env)\n        if not is_multiagent_env(env):\n            env = BatchedMultiAgentWrapper(env)\n        else:\n            env = BatchedListToDictWrapper(env)",
        "detail": "deps.sample-factory.sample_factory.algo.utils.make_env",
        "documentation": {}
    },
    {
        "label": "SequentialVectorizeWrapper",
        "kind": 6,
        "importPath": "deps.sample-factory.sample_factory.algo.utils.make_env",
        "description": "deps.sample-factory.sample_factory.algo.utils.make_env",
        "peekOfCode": "class SequentialVectorizeWrapper(Wrapper, TrainingInfoInterface, RewardShapingInterface):\n    \"\"\"Vector interface for multiple environments simulated sequentially on one worker.\"\"\"\n    def __init__(self, envs: Sequence):\n        Wrapper.__init__(self, envs[0])\n        TrainingInfoInterface.__init__(self)\n        self.single_env_agents = envs[0].num_agents\n        assert all(\n            e.num_agents == self.single_env_agents for e in envs\n        ), f\"Expect all envs to have the same number of agents {self.single_env_agents}\"\n        self.envs = envs",
        "detail": "deps.sample-factory.sample_factory.algo.utils.make_env",
        "documentation": {}
    },
    {
        "label": "NonBatchedVecEnv",
        "kind": 6,
        "importPath": "deps.sample-factory.sample_factory.algo.utils.make_env",
        "description": "deps.sample-factory.sample_factory.algo.utils.make_env",
        "peekOfCode": "class NonBatchedVecEnv(Wrapper):\n    \"\"\"\n    reset() returns a list of dict observations.\n    step(action) returns a list of dict observations, list of rewards, list of dones, list of infos.\n    \"\"\"\n    def __init__(self, env):\n        if not is_multiagent_env(env):\n            env = NonBatchedMultiAgentWrapper(env)\n        if not isinstance(env.observation_space, spaces.Dict):\n            env = NonBatchedDictObservationsWrapper(env)",
        "detail": "deps.sample-factory.sample_factory.algo.utils.make_env",
        "documentation": {}
    },
    {
        "label": "get_multiagent_info",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.algo.utils.make_env",
        "description": "deps.sample-factory.sample_factory.algo.utils.make_env",
        "peekOfCode": "def get_multiagent_info(env: Any) -> Tuple[bool, int]:\n    if hasattr(env, \"unwrapped\"):\n        env = env.unwrapped\n    num_agents = env.num_agents if hasattr(env, \"num_agents\") else 1\n    is_multiagent = env.is_multiagent if hasattr(env, \"is_multiagent\") else num_agents > 1\n    assert is_multiagent or num_agents == 1, f\"Invalid configuration: {is_multiagent=} and {num_agents=}\"\n    return is_multiagent, num_agents\ndef is_multiagent_env(env: Any) -> bool:\n    is_multiagent, num_agents = get_multiagent_info(env)\n    return is_multiagent",
        "detail": "deps.sample-factory.sample_factory.algo.utils.make_env",
        "documentation": {}
    },
    {
        "label": "is_multiagent_env",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.algo.utils.make_env",
        "description": "deps.sample-factory.sample_factory.algo.utils.make_env",
        "peekOfCode": "def is_multiagent_env(env: Any) -> bool:\n    is_multiagent, num_agents = get_multiagent_info(env)\n    return is_multiagent\nclass _DictObservationsWrapper(Wrapper):\n    def __init__(self, env):\n        super().__init__(env)\n        is_multiagent, num_agents = get_multiagent_info(env)\n        self.is_multiagent: bool = is_multiagent\n        self.num_agents: int = num_agents\n        self.observation_space: gym.spaces.Dict = gym.spaces.Dict(dict(obs=self.observation_space))",
        "detail": "deps.sample-factory.sample_factory.algo.utils.make_env",
        "documentation": {}
    },
    {
        "label": "make_env_func_batched",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.algo.utils.make_env",
        "description": "deps.sample-factory.sample_factory.algo.utils.make_env",
        "peekOfCode": "def make_env_func_batched(cfg, env_config, render_mode: Optional[str] = None) -> BatchedVecEnv:\n    \"\"\"\n    This should yield an environment that always returns a dict of PyTorch tensors (CPU- or GPU-side) or\n    a dict of numpy arrays or a dict of lists (depending on what the environment returns in the first place).\n    \"\"\"\n    env = create_env(cfg.env, cfg=cfg, env_config=env_config, render_mode=render_mode)\n    # At this point we can be sure that our environment outputs a dictionary of lists (or numpy arrays or tensors)\n    # containing obs, rewards, etc. for each agent in the environment.\n    # Now we just want the environment to return a tensor dict for observations and tensors for rewards and dones.\n    # We leave infos intact for now, because format of infos isn't really specified and can be inconsistent between",
        "detail": "deps.sample-factory.sample_factory.algo.utils.make_env",
        "documentation": {}
    },
    {
        "label": "make_env_func_non_batched",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.algo.utils.make_env",
        "description": "deps.sample-factory.sample_factory.algo.utils.make_env",
        "peekOfCode": "def make_env_func_non_batched(cfg: Config, env_config, render_mode: Optional[str] = None) -> NonBatchedVecEnv:\n    \"\"\"\n    This should yield an environment that always returns a list of {observations, rewards,\n    dones, etc.}\n    This is for the non-batched sampler which processes each agent's data independently without any vectorization\n    (and therefore enables more sophisticated configurations where agents in the same env can be controlled\n    by different policies and so on).\n    \"\"\"\n    env = create_env(cfg.env, cfg=cfg, env_config=env_config, render_mode=render_mode)\n    env = NonBatchedVecEnv(env)",
        "detail": "deps.sample-factory.sample_factory.algo.utils.make_env",
        "documentation": {}
    },
    {
        "label": "Actions",
        "kind": 5,
        "importPath": "deps.sample-factory.sample_factory.algo.utils.make_env",
        "description": "deps.sample-factory.sample_factory.algo.utils.make_env",
        "peekOfCode": "Actions = Any\nListActions = Sequence[Actions]\nTensorActions = Tensor\nSeqBools = Sequence[bool]\nDictObservations = Dict[str, Any]\nDictOfListsObservations = Dict[str, Sequence[Any]]\nDictOfTensorObservations = Dict[str, Tensor]\nListObservations = Sequence[Any]\nListOfDictObservations = Sequence[DictObservations]\ndef get_multiagent_info(env: Any) -> Tuple[bool, int]:",
        "detail": "deps.sample-factory.sample_factory.algo.utils.make_env",
        "documentation": {}
    },
    {
        "label": "ListActions",
        "kind": 5,
        "importPath": "deps.sample-factory.sample_factory.algo.utils.make_env",
        "description": "deps.sample-factory.sample_factory.algo.utils.make_env",
        "peekOfCode": "ListActions = Sequence[Actions]\nTensorActions = Tensor\nSeqBools = Sequence[bool]\nDictObservations = Dict[str, Any]\nDictOfListsObservations = Dict[str, Sequence[Any]]\nDictOfTensorObservations = Dict[str, Tensor]\nListObservations = Sequence[Any]\nListOfDictObservations = Sequence[DictObservations]\ndef get_multiagent_info(env: Any) -> Tuple[bool, int]:\n    if hasattr(env, \"unwrapped\"):",
        "detail": "deps.sample-factory.sample_factory.algo.utils.make_env",
        "documentation": {}
    },
    {
        "label": "TensorActions",
        "kind": 5,
        "importPath": "deps.sample-factory.sample_factory.algo.utils.make_env",
        "description": "deps.sample-factory.sample_factory.algo.utils.make_env",
        "peekOfCode": "TensorActions = Tensor\nSeqBools = Sequence[bool]\nDictObservations = Dict[str, Any]\nDictOfListsObservations = Dict[str, Sequence[Any]]\nDictOfTensorObservations = Dict[str, Tensor]\nListObservations = Sequence[Any]\nListOfDictObservations = Sequence[DictObservations]\ndef get_multiagent_info(env: Any) -> Tuple[bool, int]:\n    if hasattr(env, \"unwrapped\"):\n        env = env.unwrapped",
        "detail": "deps.sample-factory.sample_factory.algo.utils.make_env",
        "documentation": {}
    },
    {
        "label": "SeqBools",
        "kind": 5,
        "importPath": "deps.sample-factory.sample_factory.algo.utils.make_env",
        "description": "deps.sample-factory.sample_factory.algo.utils.make_env",
        "peekOfCode": "SeqBools = Sequence[bool]\nDictObservations = Dict[str, Any]\nDictOfListsObservations = Dict[str, Sequence[Any]]\nDictOfTensorObservations = Dict[str, Tensor]\nListObservations = Sequence[Any]\nListOfDictObservations = Sequence[DictObservations]\ndef get_multiagent_info(env: Any) -> Tuple[bool, int]:\n    if hasattr(env, \"unwrapped\"):\n        env = env.unwrapped\n    num_agents = env.num_agents if hasattr(env, \"num_agents\") else 1",
        "detail": "deps.sample-factory.sample_factory.algo.utils.make_env",
        "documentation": {}
    },
    {
        "label": "DictObservations",
        "kind": 5,
        "importPath": "deps.sample-factory.sample_factory.algo.utils.make_env",
        "description": "deps.sample-factory.sample_factory.algo.utils.make_env",
        "peekOfCode": "DictObservations = Dict[str, Any]\nDictOfListsObservations = Dict[str, Sequence[Any]]\nDictOfTensorObservations = Dict[str, Tensor]\nListObservations = Sequence[Any]\nListOfDictObservations = Sequence[DictObservations]\ndef get_multiagent_info(env: Any) -> Tuple[bool, int]:\n    if hasattr(env, \"unwrapped\"):\n        env = env.unwrapped\n    num_agents = env.num_agents if hasattr(env, \"num_agents\") else 1\n    is_multiagent = env.is_multiagent if hasattr(env, \"is_multiagent\") else num_agents > 1",
        "detail": "deps.sample-factory.sample_factory.algo.utils.make_env",
        "documentation": {}
    },
    {
        "label": "DictOfListsObservations",
        "kind": 5,
        "importPath": "deps.sample-factory.sample_factory.algo.utils.make_env",
        "description": "deps.sample-factory.sample_factory.algo.utils.make_env",
        "peekOfCode": "DictOfListsObservations = Dict[str, Sequence[Any]]\nDictOfTensorObservations = Dict[str, Tensor]\nListObservations = Sequence[Any]\nListOfDictObservations = Sequence[DictObservations]\ndef get_multiagent_info(env: Any) -> Tuple[bool, int]:\n    if hasattr(env, \"unwrapped\"):\n        env = env.unwrapped\n    num_agents = env.num_agents if hasattr(env, \"num_agents\") else 1\n    is_multiagent = env.is_multiagent if hasattr(env, \"is_multiagent\") else num_agents > 1\n    assert is_multiagent or num_agents == 1, f\"Invalid configuration: {is_multiagent=} and {num_agents=}\"",
        "detail": "deps.sample-factory.sample_factory.algo.utils.make_env",
        "documentation": {}
    },
    {
        "label": "DictOfTensorObservations",
        "kind": 5,
        "importPath": "deps.sample-factory.sample_factory.algo.utils.make_env",
        "description": "deps.sample-factory.sample_factory.algo.utils.make_env",
        "peekOfCode": "DictOfTensorObservations = Dict[str, Tensor]\nListObservations = Sequence[Any]\nListOfDictObservations = Sequence[DictObservations]\ndef get_multiagent_info(env: Any) -> Tuple[bool, int]:\n    if hasattr(env, \"unwrapped\"):\n        env = env.unwrapped\n    num_agents = env.num_agents if hasattr(env, \"num_agents\") else 1\n    is_multiagent = env.is_multiagent if hasattr(env, \"is_multiagent\") else num_agents > 1\n    assert is_multiagent or num_agents == 1, f\"Invalid configuration: {is_multiagent=} and {num_agents=}\"\n    return is_multiagent, num_agents",
        "detail": "deps.sample-factory.sample_factory.algo.utils.make_env",
        "documentation": {}
    },
    {
        "label": "ListObservations",
        "kind": 5,
        "importPath": "deps.sample-factory.sample_factory.algo.utils.make_env",
        "description": "deps.sample-factory.sample_factory.algo.utils.make_env",
        "peekOfCode": "ListObservations = Sequence[Any]\nListOfDictObservations = Sequence[DictObservations]\ndef get_multiagent_info(env: Any) -> Tuple[bool, int]:\n    if hasattr(env, \"unwrapped\"):\n        env = env.unwrapped\n    num_agents = env.num_agents if hasattr(env, \"num_agents\") else 1\n    is_multiagent = env.is_multiagent if hasattr(env, \"is_multiagent\") else num_agents > 1\n    assert is_multiagent or num_agents == 1, f\"Invalid configuration: {is_multiagent=} and {num_agents=}\"\n    return is_multiagent, num_agents\ndef is_multiagent_env(env: Any) -> bool:",
        "detail": "deps.sample-factory.sample_factory.algo.utils.make_env",
        "documentation": {}
    },
    {
        "label": "ListOfDictObservations",
        "kind": 5,
        "importPath": "deps.sample-factory.sample_factory.algo.utils.make_env",
        "description": "deps.sample-factory.sample_factory.algo.utils.make_env",
        "peekOfCode": "ListOfDictObservations = Sequence[DictObservations]\ndef get_multiagent_info(env: Any) -> Tuple[bool, int]:\n    if hasattr(env, \"unwrapped\"):\n        env = env.unwrapped\n    num_agents = env.num_agents if hasattr(env, \"num_agents\") else 1\n    is_multiagent = env.is_multiagent if hasattr(env, \"is_multiagent\") else num_agents > 1\n    assert is_multiagent or num_agents == 1, f\"Invalid configuration: {is_multiagent=} and {num_agents=}\"\n    return is_multiagent, num_agents\ndef is_multiagent_env(env: Any) -> bool:\n    is_multiagent, num_agents = get_multiagent_info(env)",
        "detail": "deps.sample-factory.sample_factory.algo.utils.make_env",
        "documentation": {}
    },
    {
        "label": "ExperimentStatus",
        "kind": 6,
        "importPath": "deps.sample-factory.sample_factory.algo.utils.misc",
        "description": "deps.sample-factory.sample_factory.algo.utils.misc",
        "peekOfCode": "class ExperimentStatus:\n    SUCCESS, FAILURE, INTERRUPTED = range(3)\ndef memory_stats(process, device):\n    memory_mb = memory_consumption_mb()\n    stats = {f\"memory_{process}\": memory_mb}\n    if device.type != \"cpu\":\n        gpu_mem_mb = torch.cuda.memory_allocated(device) / 1e6\n        gpu_cache_mb = torch.cuda.memory_reserved(device) / 1e6\n        stats.update({f\"gpu_mem_{process}\": gpu_mem_mb, f\"gpu_cache_{process}\": gpu_cache_mb})\n    return stats",
        "detail": "deps.sample-factory.sample_factory.algo.utils.misc",
        "documentation": {}
    },
    {
        "label": "new_trajectories_signal",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.algo.utils.misc",
        "description": "deps.sample-factory.sample_factory.algo.utils.misc",
        "peekOfCode": "def new_trajectories_signal(policy_id: PolicyID) -> str:\n    return f\"p{policy_id}_trajectories\"\ndef advance_rollouts_signal(rollout_worker_idx: int) -> str:\n    return f\"advance{rollout_worker_idx}\"\nclass ExperimentStatus:\n    SUCCESS, FAILURE, INTERRUPTED = range(3)\ndef memory_stats(process, device):\n    memory_mb = memory_consumption_mb()\n    stats = {f\"memory_{process}\": memory_mb}\n    if device.type != \"cpu\":",
        "detail": "deps.sample-factory.sample_factory.algo.utils.misc",
        "documentation": {}
    },
    {
        "label": "advance_rollouts_signal",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.algo.utils.misc",
        "description": "deps.sample-factory.sample_factory.algo.utils.misc",
        "peekOfCode": "def advance_rollouts_signal(rollout_worker_idx: int) -> str:\n    return f\"advance{rollout_worker_idx}\"\nclass ExperimentStatus:\n    SUCCESS, FAILURE, INTERRUPTED = range(3)\ndef memory_stats(process, device):\n    memory_mb = memory_consumption_mb()\n    stats = {f\"memory_{process}\": memory_mb}\n    if device.type != \"cpu\":\n        gpu_mem_mb = torch.cuda.memory_allocated(device) / 1e6\n        gpu_cache_mb = torch.cuda.memory_reserved(device) / 1e6",
        "detail": "deps.sample-factory.sample_factory.algo.utils.misc",
        "documentation": {}
    },
    {
        "label": "memory_stats",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.algo.utils.misc",
        "description": "deps.sample-factory.sample_factory.algo.utils.misc",
        "peekOfCode": "def memory_stats(process, device):\n    memory_mb = memory_consumption_mb()\n    stats = {f\"memory_{process}\": memory_mb}\n    if device.type != \"cpu\":\n        gpu_mem_mb = torch.cuda.memory_allocated(device) / 1e6\n        gpu_cache_mb = torch.cuda.memory_reserved(device) / 1e6\n        stats.update({f\"gpu_mem_{process}\": gpu_mem_mb, f\"gpu_cache_{process}\": gpu_cache_mb})\n    return stats",
        "detail": "deps.sample-factory.sample_factory.algo.utils.misc",
        "documentation": {}
    },
    {
        "label": "EPS",
        "kind": 5,
        "importPath": "deps.sample-factory.sample_factory.algo.utils.misc",
        "description": "deps.sample-factory.sample_factory.algo.utils.misc",
        "peekOfCode": "EPS = 1e-8\n# stats dictionary keys\nEPISODIC = \"episodic\"\nLEARNER_ENV_STEPS = \"learner_env_steps\"\nTRAIN_STATS = \"train\"\nTIMING_STATS = \"timing\"\nSTATS_KEY = \"stats\"\nSAMPLES_COLLECTED = \"samples_collected\"\nPOLICY_ID_KEY = \"policy_id\"\nMAGIC_FLOAT = -4242.42",
        "detail": "deps.sample-factory.sample_factory.algo.utils.misc",
        "documentation": {}
    },
    {
        "label": "EPISODIC",
        "kind": 5,
        "importPath": "deps.sample-factory.sample_factory.algo.utils.misc",
        "description": "deps.sample-factory.sample_factory.algo.utils.misc",
        "peekOfCode": "EPISODIC = \"episodic\"\nLEARNER_ENV_STEPS = \"learner_env_steps\"\nTRAIN_STATS = \"train\"\nTIMING_STATS = \"timing\"\nSTATS_KEY = \"stats\"\nSAMPLES_COLLECTED = \"samples_collected\"\nPOLICY_ID_KEY = \"policy_id\"\nMAGIC_FLOAT = -4242.42\nMAGIC_INT = 43\n# custom signal names",
        "detail": "deps.sample-factory.sample_factory.algo.utils.misc",
        "documentation": {}
    },
    {
        "label": "LEARNER_ENV_STEPS",
        "kind": 5,
        "importPath": "deps.sample-factory.sample_factory.algo.utils.misc",
        "description": "deps.sample-factory.sample_factory.algo.utils.misc",
        "peekOfCode": "LEARNER_ENV_STEPS = \"learner_env_steps\"\nTRAIN_STATS = \"train\"\nTIMING_STATS = \"timing\"\nSTATS_KEY = \"stats\"\nSAMPLES_COLLECTED = \"samples_collected\"\nPOLICY_ID_KEY = \"policy_id\"\nMAGIC_FLOAT = -4242.42\nMAGIC_INT = 43\n# custom signal names\ndef new_trajectories_signal(policy_id: PolicyID) -> str:",
        "detail": "deps.sample-factory.sample_factory.algo.utils.misc",
        "documentation": {}
    },
    {
        "label": "TRAIN_STATS",
        "kind": 5,
        "importPath": "deps.sample-factory.sample_factory.algo.utils.misc",
        "description": "deps.sample-factory.sample_factory.algo.utils.misc",
        "peekOfCode": "TRAIN_STATS = \"train\"\nTIMING_STATS = \"timing\"\nSTATS_KEY = \"stats\"\nSAMPLES_COLLECTED = \"samples_collected\"\nPOLICY_ID_KEY = \"policy_id\"\nMAGIC_FLOAT = -4242.42\nMAGIC_INT = 43\n# custom signal names\ndef new_trajectories_signal(policy_id: PolicyID) -> str:\n    return f\"p{policy_id}_trajectories\"",
        "detail": "deps.sample-factory.sample_factory.algo.utils.misc",
        "documentation": {}
    },
    {
        "label": "TIMING_STATS",
        "kind": 5,
        "importPath": "deps.sample-factory.sample_factory.algo.utils.misc",
        "description": "deps.sample-factory.sample_factory.algo.utils.misc",
        "peekOfCode": "TIMING_STATS = \"timing\"\nSTATS_KEY = \"stats\"\nSAMPLES_COLLECTED = \"samples_collected\"\nPOLICY_ID_KEY = \"policy_id\"\nMAGIC_FLOAT = -4242.42\nMAGIC_INT = 43\n# custom signal names\ndef new_trajectories_signal(policy_id: PolicyID) -> str:\n    return f\"p{policy_id}_trajectories\"\ndef advance_rollouts_signal(rollout_worker_idx: int) -> str:",
        "detail": "deps.sample-factory.sample_factory.algo.utils.misc",
        "documentation": {}
    },
    {
        "label": "STATS_KEY",
        "kind": 5,
        "importPath": "deps.sample-factory.sample_factory.algo.utils.misc",
        "description": "deps.sample-factory.sample_factory.algo.utils.misc",
        "peekOfCode": "STATS_KEY = \"stats\"\nSAMPLES_COLLECTED = \"samples_collected\"\nPOLICY_ID_KEY = \"policy_id\"\nMAGIC_FLOAT = -4242.42\nMAGIC_INT = 43\n# custom signal names\ndef new_trajectories_signal(policy_id: PolicyID) -> str:\n    return f\"p{policy_id}_trajectories\"\ndef advance_rollouts_signal(rollout_worker_idx: int) -> str:\n    return f\"advance{rollout_worker_idx}\"",
        "detail": "deps.sample-factory.sample_factory.algo.utils.misc",
        "documentation": {}
    },
    {
        "label": "SAMPLES_COLLECTED",
        "kind": 5,
        "importPath": "deps.sample-factory.sample_factory.algo.utils.misc",
        "description": "deps.sample-factory.sample_factory.algo.utils.misc",
        "peekOfCode": "SAMPLES_COLLECTED = \"samples_collected\"\nPOLICY_ID_KEY = \"policy_id\"\nMAGIC_FLOAT = -4242.42\nMAGIC_INT = 43\n# custom signal names\ndef new_trajectories_signal(policy_id: PolicyID) -> str:\n    return f\"p{policy_id}_trajectories\"\ndef advance_rollouts_signal(rollout_worker_idx: int) -> str:\n    return f\"advance{rollout_worker_idx}\"\nclass ExperimentStatus:",
        "detail": "deps.sample-factory.sample_factory.algo.utils.misc",
        "documentation": {}
    },
    {
        "label": "POLICY_ID_KEY",
        "kind": 5,
        "importPath": "deps.sample-factory.sample_factory.algo.utils.misc",
        "description": "deps.sample-factory.sample_factory.algo.utils.misc",
        "peekOfCode": "POLICY_ID_KEY = \"policy_id\"\nMAGIC_FLOAT = -4242.42\nMAGIC_INT = 43\n# custom signal names\ndef new_trajectories_signal(policy_id: PolicyID) -> str:\n    return f\"p{policy_id}_trajectories\"\ndef advance_rollouts_signal(rollout_worker_idx: int) -> str:\n    return f\"advance{rollout_worker_idx}\"\nclass ExperimentStatus:\n    SUCCESS, FAILURE, INTERRUPTED = range(3)",
        "detail": "deps.sample-factory.sample_factory.algo.utils.misc",
        "documentation": {}
    },
    {
        "label": "MAGIC_FLOAT",
        "kind": 5,
        "importPath": "deps.sample-factory.sample_factory.algo.utils.misc",
        "description": "deps.sample-factory.sample_factory.algo.utils.misc",
        "peekOfCode": "MAGIC_FLOAT = -4242.42\nMAGIC_INT = 43\n# custom signal names\ndef new_trajectories_signal(policy_id: PolicyID) -> str:\n    return f\"p{policy_id}_trajectories\"\ndef advance_rollouts_signal(rollout_worker_idx: int) -> str:\n    return f\"advance{rollout_worker_idx}\"\nclass ExperimentStatus:\n    SUCCESS, FAILURE, INTERRUPTED = range(3)\ndef memory_stats(process, device):",
        "detail": "deps.sample-factory.sample_factory.algo.utils.misc",
        "documentation": {}
    },
    {
        "label": "MAGIC_INT",
        "kind": 5,
        "importPath": "deps.sample-factory.sample_factory.algo.utils.misc",
        "description": "deps.sample-factory.sample_factory.algo.utils.misc",
        "peekOfCode": "MAGIC_INT = 43\n# custom signal names\ndef new_trajectories_signal(policy_id: PolicyID) -> str:\n    return f\"p{policy_id}_trajectories\"\ndef advance_rollouts_signal(rollout_worker_idx: int) -> str:\n    return f\"advance{rollout_worker_idx}\"\nclass ExperimentStatus:\n    SUCCESS, FAILURE, INTERRUPTED = range(3)\ndef memory_stats(process, device):\n    memory_mb = memory_consumption_mb()",
        "detail": "deps.sample-factory.sample_factory.algo.utils.misc",
        "documentation": {}
    },
    {
        "label": "ParameterServer",
        "kind": 6,
        "importPath": "deps.sample-factory.sample_factory.algo.utils.model_sharing",
        "description": "deps.sample-factory.sample_factory.algo.utils.model_sharing",
        "peekOfCode": "class ParameterServer:\n    def __init__(self, policy_id, policy_versions: Tensor, serial_mode: bool):\n        self.policy_id = policy_id\n        self.actor_critic = None\n        self.policy_versions = policy_versions\n        self.device: Optional[torch.device] = None\n        mp_ctx = get_mp_ctx(serial_mode)\n        self._policy_lock = get_lock(serial_mode, mp_ctx)\n    @property\n    def policy_lock(self):",
        "detail": "deps.sample-factory.sample_factory.algo.utils.model_sharing",
        "documentation": {}
    },
    {
        "label": "ParameterClient",
        "kind": 6,
        "importPath": "deps.sample-factory.sample_factory.algo.utils.model_sharing",
        "description": "deps.sample-factory.sample_factory.algo.utils.model_sharing",
        "peekOfCode": "class ParameterClient:\n    def __init__(self, param_server: ParameterServer, cfg, env_info, timing: Timing):\n        self.server = param_server\n        self.policy_id = param_server.policy_id\n        self.policy_versions = param_server.policy_versions\n        self.cfg = cfg\n        self.env_info = env_info\n        self.latest_policy_version = -1\n        self._actor_critic = None\n        self._policy_lock = param_server.policy_lock",
        "detail": "deps.sample-factory.sample_factory.algo.utils.model_sharing",
        "documentation": {}
    },
    {
        "label": "ParameterClientSerial",
        "kind": 6,
        "importPath": "deps.sample-factory.sample_factory.algo.utils.model_sharing",
        "description": "deps.sample-factory.sample_factory.algo.utils.model_sharing",
        "peekOfCode": "class ParameterClientSerial(ParameterClient):\n    def on_weights_initialized(self, state_dict, device: torch.device, policy_version: int) -> None:\n        \"\"\"\n        Literally just save the reference to actor critic since we're in the same process.\n        Model should be fully initialized at this point.\n        \"\"\"\n        super().on_weights_initialized(state_dict, device, policy_version)\n        self._actor_critic = self.server.actor_critic\n    def ensure_weights_updated(self):\n        \"\"\"In serial case we don't need to do anything.\"\"\"",
        "detail": "deps.sample-factory.sample_factory.algo.utils.model_sharing",
        "documentation": {}
    },
    {
        "label": "ParameterClientAsync",
        "kind": 6,
        "importPath": "deps.sample-factory.sample_factory.algo.utils.model_sharing",
        "description": "deps.sample-factory.sample_factory.algo.utils.model_sharing",
        "peekOfCode": "class ParameterClientAsync(ParameterClient):\n    def __init__(self, param_server: ParameterServer, cfg, env_info, timing: Timing):\n        super().__init__(param_server, cfg, env_info, timing)\n        self._shared_model_weights = None\n        self.num_policy_updates = 0\n    @property\n    def actor_critic(self):\n        assert self.latest_policy_version >= 0, \"Trying to access actor critic before it is initialized\"\n        return self._actor_critic\n    def _init_local_copy(self, device, cfg, obs_space, action_space):",
        "detail": "deps.sample-factory.sample_factory.algo.utils.model_sharing",
        "documentation": {}
    },
    {
        "label": "make_parameter_client",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.algo.utils.model_sharing",
        "description": "deps.sample-factory.sample_factory.algo.utils.model_sharing",
        "peekOfCode": "def make_parameter_client(is_serial_mode, parameter_server, cfg, env_info, timing: Timing) -> ParameterClient:\n    \"\"\"Parameter client factory.\"\"\"\n    cls = ParameterClientSerial if is_serial_mode else ParameterClientAsync\n    return cls(parameter_server, cfg, env_info, timing)",
        "detail": "deps.sample-factory.sample_factory.algo.utils.model_sharing",
        "documentation": {}
    },
    {
        "label": "FakeLock",
        "kind": 6,
        "importPath": "deps.sample-factory.sample_factory.algo.utils.multiprocessing_utils",
        "description": "deps.sample-factory.sample_factory.algo.utils.multiprocessing_utils",
        "peekOfCode": "class FakeLock:\n    def acquire(self, *args, **kwargs):\n        pass\n    def release(self, *args, **kwargs):\n        pass\n    def __enter__(self):\n        pass\n    def __exit__(self, *args):\n        pass",
        "detail": "deps.sample-factory.sample_factory.algo.utils.multiprocessing_utils",
        "documentation": {}
    },
    {
        "label": "get_mp_ctx",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.algo.utils.multiprocessing_utils",
        "description": "deps.sample-factory.sample_factory.algo.utils.multiprocessing_utils",
        "peekOfCode": "def get_mp_ctx(serial: bool) -> Optional[BaseContext]:\n    if serial:\n        return None\n    if get_mp_ctx.mp_ctx is None:\n        get_mp_ctx.mp_ctx = multiprocessing.get_context(\"spawn\")\n    return get_mp_ctx.mp_ctx\ndef get_lock(serial=False, mp_ctx=None):\n    if serial:\n        return FakeLock()\n    else:",
        "detail": "deps.sample-factory.sample_factory.algo.utils.multiprocessing_utils",
        "documentation": {}
    },
    {
        "label": "get_lock",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.algo.utils.multiprocessing_utils",
        "description": "deps.sample-factory.sample_factory.algo.utils.multiprocessing_utils",
        "peekOfCode": "def get_lock(serial=False, mp_ctx=None):\n    if serial:\n        return FakeLock()\n    else:\n        return get_mp_lock(mp_ctx)\ndef get_mp_lock(mp_ctx: Optional[BaseContext] = None):\n    lock_cls = multiprocessing.Lock if mp_ctx is None else mp_ctx.Lock\n    return lock_cls()\nclass FakeLock:\n    def acquire(self, *args, **kwargs):",
        "detail": "deps.sample-factory.sample_factory.algo.utils.multiprocessing_utils",
        "documentation": {}
    },
    {
        "label": "get_mp_lock",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.algo.utils.multiprocessing_utils",
        "description": "deps.sample-factory.sample_factory.algo.utils.multiprocessing_utils",
        "peekOfCode": "def get_mp_lock(mp_ctx: Optional[BaseContext] = None):\n    lock_cls = multiprocessing.Lock if mp_ctx is None else mp_ctx.Lock\n    return lock_cls()\nclass FakeLock:\n    def acquire(self, *args, **kwargs):\n        pass\n    def release(self, *args, **kwargs):\n        pass\n    def __enter__(self):\n        pass",
        "detail": "deps.sample-factory.sample_factory.algo.utils.multiprocessing_utils",
        "documentation": {}
    },
    {
        "label": "Lamb",
        "kind": 6,
        "importPath": "deps.sample-factory.sample_factory.algo.utils.optimizers",
        "description": "deps.sample-factory.sample_factory.algo.utils.optimizers",
        "peekOfCode": "class Lamb(Optimizer):\n    def __init__(\n        self,\n        params,\n        bias_correction=True,\n        lr=1e-3,\n        betas=(0.9, 0.999),\n        eps=1e-6,\n        weight_decay=1e-4,\n        min_trust=0.01,",
        "detail": "deps.sample-factory.sample_factory.algo.utils.optimizers",
        "documentation": {}
    },
    {
        "label": "trajectories_per_minibatch",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.algo.utils.rl_utils",
        "description": "deps.sample-factory.sample_factory.algo.utils.rl_utils",
        "peekOfCode": "def trajectories_per_minibatch(cfg: Config) -> int:\n    return cfg.batch_size // cfg.rollout\ndef trajectories_per_training_iteration(cfg: Config) -> int:\n    return cfg.num_batches_per_epoch * trajectories_per_minibatch(cfg)\ndef total_num_envs(cfg: Config) -> int:\n    return cfg.num_workers * cfg.num_envs_per_worker\ndef total_num_agents(cfg: Config, env_info: EnvInfo) -> int:\n    return total_num_envs(cfg) * env_info.num_agents\ndef num_agents_per_worker(cfg: Config, env_info: EnvInfo) -> int:\n    return cfg.num_envs_per_worker * env_info.num_agents",
        "detail": "deps.sample-factory.sample_factory.algo.utils.rl_utils",
        "documentation": {}
    },
    {
        "label": "trajectories_per_training_iteration",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.algo.utils.rl_utils",
        "description": "deps.sample-factory.sample_factory.algo.utils.rl_utils",
        "peekOfCode": "def trajectories_per_training_iteration(cfg: Config) -> int:\n    return cfg.num_batches_per_epoch * trajectories_per_minibatch(cfg)\ndef total_num_envs(cfg: Config) -> int:\n    return cfg.num_workers * cfg.num_envs_per_worker\ndef total_num_agents(cfg: Config, env_info: EnvInfo) -> int:\n    return total_num_envs(cfg) * env_info.num_agents\ndef num_agents_per_worker(cfg: Config, env_info: EnvInfo) -> int:\n    return cfg.num_envs_per_worker * env_info.num_agents\ndef prepare_and_normalize_obs(model: Module, obs: TensorDict | Dict[str, Tensor]) -> TensorDict | Dict[str, Tensor]:\n    for key, x in obs.items():",
        "detail": "deps.sample-factory.sample_factory.algo.utils.rl_utils",
        "documentation": {}
    },
    {
        "label": "total_num_envs",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.algo.utils.rl_utils",
        "description": "deps.sample-factory.sample_factory.algo.utils.rl_utils",
        "peekOfCode": "def total_num_envs(cfg: Config) -> int:\n    return cfg.num_workers * cfg.num_envs_per_worker\ndef total_num_agents(cfg: Config, env_info: EnvInfo) -> int:\n    return total_num_envs(cfg) * env_info.num_agents\ndef num_agents_per_worker(cfg: Config, env_info: EnvInfo) -> int:\n    return cfg.num_envs_per_worker * env_info.num_agents\ndef prepare_and_normalize_obs(model: Module, obs: TensorDict | Dict[str, Tensor]) -> TensorDict | Dict[str, Tensor]:\n    for key, x in obs.items():\n        obs[key] = ensure_torch_tensor(x).to(model.device_for_input_tensor(key))\n    normalized_obs = model.normalize_obs(obs)",
        "detail": "deps.sample-factory.sample_factory.algo.utils.rl_utils",
        "documentation": {}
    },
    {
        "label": "total_num_agents",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.algo.utils.rl_utils",
        "description": "deps.sample-factory.sample_factory.algo.utils.rl_utils",
        "peekOfCode": "def total_num_agents(cfg: Config, env_info: EnvInfo) -> int:\n    return total_num_envs(cfg) * env_info.num_agents\ndef num_agents_per_worker(cfg: Config, env_info: EnvInfo) -> int:\n    return cfg.num_envs_per_worker * env_info.num_agents\ndef prepare_and_normalize_obs(model: Module, obs: TensorDict | Dict[str, Tensor]) -> TensorDict | Dict[str, Tensor]:\n    for key, x in obs.items():\n        obs[key] = ensure_torch_tensor(x).to(model.device_for_input_tensor(key))\n    normalized_obs = model.normalize_obs(obs)\n    for key, x in normalized_obs.items():\n        normalized_obs[key] = x.type(model.type_for_input_tensor(key))",
        "detail": "deps.sample-factory.sample_factory.algo.utils.rl_utils",
        "documentation": {}
    },
    {
        "label": "num_agents_per_worker",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.algo.utils.rl_utils",
        "description": "deps.sample-factory.sample_factory.algo.utils.rl_utils",
        "peekOfCode": "def num_agents_per_worker(cfg: Config, env_info: EnvInfo) -> int:\n    return cfg.num_envs_per_worker * env_info.num_agents\ndef prepare_and_normalize_obs(model: Module, obs: TensorDict | Dict[str, Tensor]) -> TensorDict | Dict[str, Tensor]:\n    for key, x in obs.items():\n        obs[key] = ensure_torch_tensor(x).to(model.device_for_input_tensor(key))\n    normalized_obs = model.normalize_obs(obs)\n    for key, x in normalized_obs.items():\n        normalized_obs[key] = x.type(model.type_for_input_tensor(key))\n    return normalized_obs\ndef samples_per_trajectory(trajectory: TensorDict) -> int:",
        "detail": "deps.sample-factory.sample_factory.algo.utils.rl_utils",
        "documentation": {}
    },
    {
        "label": "prepare_and_normalize_obs",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.algo.utils.rl_utils",
        "description": "deps.sample-factory.sample_factory.algo.utils.rl_utils",
        "peekOfCode": "def prepare_and_normalize_obs(model: Module, obs: TensorDict | Dict[str, Tensor]) -> TensorDict | Dict[str, Tensor]:\n    for key, x in obs.items():\n        obs[key] = ensure_torch_tensor(x).to(model.device_for_input_tensor(key))\n    normalized_obs = model.normalize_obs(obs)\n    for key, x in normalized_obs.items():\n        normalized_obs[key] = x.type(model.type_for_input_tensor(key))\n    return normalized_obs\ndef samples_per_trajectory(trajectory: TensorDict) -> int:\n    shape = trajectory[\"rewards\"].shape\n    batch, rollout = shape[0], shape[1]",
        "detail": "deps.sample-factory.sample_factory.algo.utils.rl_utils",
        "documentation": {}
    },
    {
        "label": "samples_per_trajectory",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.algo.utils.rl_utils",
        "description": "deps.sample-factory.sample_factory.algo.utils.rl_utils",
        "peekOfCode": "def samples_per_trajectory(trajectory: TensorDict) -> int:\n    shape = trajectory[\"rewards\"].shape\n    batch, rollout = shape[0], shape[1]\n    return batch * rollout\n@torch.jit.script\ndef calculate_discounted_sum_torch(\n    x: Tensor, dones: Tensor, valids: Tensor, discount: float, x_last: Optional[Tensor] = None\n) -> Tensor:\n    \"\"\"\n    Computing cumulative sum (of something) for the trajectory, taking episode termination into consideration.",
        "detail": "deps.sample-factory.sample_factory.algo.utils.rl_utils",
        "documentation": {}
    },
    {
        "label": "calculate_discounted_sum_torch",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.algo.utils.rl_utils",
        "description": "deps.sample-factory.sample_factory.algo.utils.rl_utils",
        "peekOfCode": "def calculate_discounted_sum_torch(\n    x: Tensor, dones: Tensor, valids: Tensor, discount: float, x_last: Optional[Tensor] = None\n) -> Tensor:\n    \"\"\"\n    Computing cumulative sum (of something) for the trajectory, taking episode termination into consideration.\n    \"\"\"\n    if x_last is None:\n        x_last = x[-1].clone().fill_(0.0)\n    cumulative = x_last\n    discounted_sum = torch.zeros_like(x)",
        "detail": "deps.sample-factory.sample_factory.algo.utils.rl_utils",
        "documentation": {}
    },
    {
        "label": "gae_advantages",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.algo.utils.rl_utils",
        "description": "deps.sample-factory.sample_factory.algo.utils.rl_utils",
        "peekOfCode": "def gae_advantages(rewards: Tensor, dones: Tensor, values: Tensor, valids: Tensor, : float, : float) -> Tensor:\n    rewards = rewards.transpose(0, 1)  # [E, T] -> [T, E]\n    dones = dones.transpose(0, 1).float()  # [E, T] -> [T, E]\n    values = values.transpose(0, 1)  # [E, T+1] -> [T+1, E]\n    valids = valids.transpose(0, 1).float()  # [E, T+1] -> [T+1, E]\n    assert len(rewards) == len(dones)\n    assert len(rewards) + 1 == len(values)\n    # section 3 in GAE paper: calculating advantages\n    deltas = (rewards - values[:-1]) * valids[:-1] + (1 - dones) * ( * values[1:] * valids[1:])\n    advantages = calculate_discounted_sum_torch(deltas, dones, valids[:-1],  * )",
        "detail": "deps.sample-factory.sample_factory.algo.utils.rl_utils",
        "documentation": {}
    },
    {
        "label": "make_dones",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.algo.utils.rl_utils",
        "description": "deps.sample-factory.sample_factory.algo.utils.rl_utils",
        "peekOfCode": "def make_dones(terminated: DonesType, truncated: DonesType) -> DonesType:\n    \"\"\"\n    Make dones from terminated/truncated (gym 0.26.0 changes).\n    Assumes that terminated and truncated are the same type and shape.\n    \"\"\"\n    if isinstance(terminated, (bool, np.ndarray, Tensor)):\n        return terminated | truncated\n    elif isinstance(terminated, Sequence):\n        return [t | truncated[i] for i, t in enumerate(terminated)]\n    raise ValueError(f\"Unknown {type(terminated)=}\")",
        "detail": "deps.sample-factory.sample_factory.algo.utils.rl_utils",
        "documentation": {}
    },
    {
        "label": "DonesType",
        "kind": 5,
        "importPath": "deps.sample-factory.sample_factory.algo.utils.rl_utils",
        "description": "deps.sample-factory.sample_factory.algo.utils.rl_utils",
        "peekOfCode": "DonesType = Union[bool, np.ndarray, Tensor, Sequence[bool]]\ndef make_dones(terminated: DonesType, truncated: DonesType) -> DonesType:\n    \"\"\"\n    Make dones from terminated/truncated (gym 0.26.0 changes).\n    Assumes that terminated and truncated are the same type and shape.\n    \"\"\"\n    if isinstance(terminated, (bool, np.ndarray, Tensor)):\n        return terminated | truncated\n    elif isinstance(terminated, Sequence):\n        return [t | truncated[i] for i, t in enumerate(terminated)]",
        "detail": "deps.sample-factory.sample_factory.algo.utils.rl_utils",
        "documentation": {}
    },
    {
        "label": "RunningMeanStdInPlace",
        "kind": 6,
        "importPath": "deps.sample-factory.sample_factory.algo.utils.running_mean_std",
        "description": "deps.sample-factory.sample_factory.algo.utils.running_mean_std",
        "peekOfCode": "class RunningMeanStdInPlace(nn.Module):\n    def __init__(self, input_shape, epsilon=_NORM_EPS, clip=_DEFAULT_CLIP, per_channel=False, norm_only=False):\n        super().__init__()\n        log.debug(\"RunningMeanStd input shape: %r\", input_shape)\n        self.input_shape: Final = input_shape\n        self.eps: Final[float] = epsilon\n        self.clip: Final[float] = clip\n        self.norm_only: Final[bool] = norm_only\n        self.per_channel: Final[bool] = per_channel\n        if per_channel:",
        "detail": "deps.sample-factory.sample_factory.algo.utils.running_mean_std",
        "documentation": {}
    },
    {
        "label": "RunningMeanStdDictInPlace",
        "kind": 6,
        "importPath": "deps.sample-factory.sample_factory.algo.utils.running_mean_std",
        "description": "deps.sample-factory.sample_factory.algo.utils.running_mean_std",
        "peekOfCode": "class RunningMeanStdDictInPlace(nn.Module):\n    def __init__(\n        self,\n        obs_space: gym.spaces.Dict,\n        keys_to_normalize: Optional[List[str]] = None,\n        epsilon=_NORM_EPS,\n        clip=_DEFAULT_CLIP,\n        per_channel=False,\n        norm_only=False,\n    ):",
        "detail": "deps.sample-factory.sample_factory.algo.utils.running_mean_std",
        "documentation": {}
    },
    {
        "label": "running_mean_std_summaries",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.algo.utils.running_mean_std",
        "description": "deps.sample-factory.sample_factory.algo.utils.running_mean_std",
        "peekOfCode": "def running_mean_std_summaries(running_mean_std_module: Union[nn.Module, ScriptModule, RecursiveScriptModule]):\n    m = running_mean_std_module\n    res = dict()\n    for name, buf in m.named_buffers():\n        # converts MODULE_NAME.running_mean_std.obs.running_mean to obs.running_mean\n        name = \"_\".join(name.split(\".\")[-2:])\n        if name.endswith(\"running_mean\"):\n            res[name] = buf.float().mean()\n        elif name.endswith(\"running_var\"):\n            res[name.replace(\"_var\", \"_std\")] = torch.sqrt(buf.float() + _NORM_EPS).mean()",
        "detail": "deps.sample-factory.sample_factory.algo.utils.running_mean_std",
        "documentation": {}
    },
    {
        "label": "_NORM_EPS",
        "kind": 5,
        "importPath": "deps.sample-factory.sample_factory.algo.utils.running_mean_std",
        "description": "deps.sample-factory.sample_factory.algo.utils.running_mean_std",
        "peekOfCode": "_NORM_EPS = 1e-5\n_DEFAULT_CLIP = 5.0\n# noinspection PyAttributeOutsideInit,NonAsciiCharacters\nclass RunningMeanStdInPlace(nn.Module):\n    def __init__(self, input_shape, epsilon=_NORM_EPS, clip=_DEFAULT_CLIP, per_channel=False, norm_only=False):\n        super().__init__()\n        log.debug(\"RunningMeanStd input shape: %r\", input_shape)\n        self.input_shape: Final = input_shape\n        self.eps: Final[float] = epsilon\n        self.clip: Final[float] = clip",
        "detail": "deps.sample-factory.sample_factory.algo.utils.running_mean_std",
        "documentation": {}
    },
    {
        "label": "_DEFAULT_CLIP",
        "kind": 5,
        "importPath": "deps.sample-factory.sample_factory.algo.utils.running_mean_std",
        "description": "deps.sample-factory.sample_factory.algo.utils.running_mean_std",
        "peekOfCode": "_DEFAULT_CLIP = 5.0\n# noinspection PyAttributeOutsideInit,NonAsciiCharacters\nclass RunningMeanStdInPlace(nn.Module):\n    def __init__(self, input_shape, epsilon=_NORM_EPS, clip=_DEFAULT_CLIP, per_channel=False, norm_only=False):\n        super().__init__()\n        log.debug(\"RunningMeanStd input shape: %r\", input_shape)\n        self.input_shape: Final = input_shape\n        self.eps: Final[float] = epsilon\n        self.clip: Final[float] = clip\n        self.norm_only: Final[bool] = norm_only",
        "detail": "deps.sample-factory.sample_factory.algo.utils.running_mean_std",
        "documentation": {}
    },
    {
        "label": "BufferMgr",
        "kind": 6,
        "importPath": "deps.sample-factory.sample_factory.algo.utils.shared_buffers",
        "description": "deps.sample-factory.sample_factory.algo.utils.shared_buffers",
        "peekOfCode": "class BufferMgr(Configurable):\n    def __init__(self, cfg, env_info: EnvInfo):\n        super().__init__(cfg)\n        self.env_info = env_info\n        self.buffers_per_device: Dict[Device, int] = dict()\n        for i in range(cfg.num_workers):\n            # TODO: this should take into account whether we just need a GPU for sampling, or we actually receive observations on the GPU\n            # otherwise it will not work for things like Megaverse or GPU-rendered DMLab\n            sampling_device = str(rollout_worker_device(i, cfg, self.env_info))\n            log.debug(f\"Rollout worker {i} uses device {sampling_device}\")",
        "detail": "deps.sample-factory.sample_factory.algo.utils.shared_buffers",
        "documentation": {}
    },
    {
        "label": "policy_device",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.algo.utils.shared_buffers",
        "description": "deps.sample-factory.sample_factory.algo.utils.shared_buffers",
        "peekOfCode": "def policy_device(cfg: AttrDict, policy_id: PolicyID) -> torch.device:\n    \"\"\"Inference/Learning device for the given policy.\"\"\"\n    if cfg.device == \"cpu\":\n        return torch.device(\"cpu\")\n    else:\n        return torch.device(\"cuda\", index=gpus_for_process(policy_id, 1)[0])\ndef init_tensor(leading_dimensions: List, tensor_type, tensor_shape, device: torch.device, share: bool) -> Tensor:\n    if not isinstance(tensor_type, torch.dtype):\n        tensor_type = to_torch_dtype(tensor_type)\n    # filter out dimensions with size 0",
        "detail": "deps.sample-factory.sample_factory.algo.utils.shared_buffers",
        "documentation": {}
    },
    {
        "label": "init_tensor",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.algo.utils.shared_buffers",
        "description": "deps.sample-factory.sample_factory.algo.utils.shared_buffers",
        "peekOfCode": "def init_tensor(leading_dimensions: List, tensor_type, tensor_shape, device: torch.device, share: bool) -> Tensor:\n    if not isinstance(tensor_type, torch.dtype):\n        tensor_type = to_torch_dtype(tensor_type)\n    # filter out dimensions with size 0\n    tensor_shape = [x for x in tensor_shape if x]\n    final_shape = leading_dimensions + list(tensor_shape)\n    t = torch.zeros(final_shape, dtype=tensor_type)\n    # fill with magic values to make it easy to spot if we ever use unintialized data\n    if t.is_floating_point():\n        t.fill_(MAGIC_FLOAT)",
        "detail": "deps.sample-factory.sample_factory.algo.utils.shared_buffers",
        "documentation": {}
    },
    {
        "label": "action_info",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.algo.utils.shared_buffers",
        "description": "deps.sample-factory.sample_factory.algo.utils.shared_buffers",
        "peekOfCode": "def action_info(env_info: EnvInfo) -> Tuple[int, int]:\n    action_space = env_info.action_space\n    num_actions = calc_num_actions(action_space)\n    num_action_distribution_parameters = calc_num_action_parameters(action_space)\n    return num_actions, num_action_distribution_parameters\ndef policy_output_shapes(num_actions, num_action_distribution_parameters) -> List[Tuple[str, List]]:\n    # policy outputs, this matches the expected output of the actor-critic\n    policy_outputs = [\n        (\"actions\", [num_actions]),\n        (\"action_logits\", [num_action_distribution_parameters]),",
        "detail": "deps.sample-factory.sample_factory.algo.utils.shared_buffers",
        "documentation": {}
    },
    {
        "label": "policy_output_shapes",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.algo.utils.shared_buffers",
        "description": "deps.sample-factory.sample_factory.algo.utils.shared_buffers",
        "peekOfCode": "def policy_output_shapes(num_actions, num_action_distribution_parameters) -> List[Tuple[str, List]]:\n    # policy outputs, this matches the expected output of the actor-critic\n    policy_outputs = [\n        (\"actions\", [num_actions]),\n        (\"action_logits\", [num_action_distribution_parameters]),\n        (\"log_prob_actions\", []),\n        (\"values\", []),\n        (\"policy_version\", []),\n    ]\n    return policy_outputs",
        "detail": "deps.sample-factory.sample_factory.algo.utils.shared_buffers",
        "documentation": {}
    },
    {
        "label": "alloc_trajectory_tensors",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.algo.utils.shared_buffers",
        "description": "deps.sample-factory.sample_factory.algo.utils.shared_buffers",
        "peekOfCode": "def alloc_trajectory_tensors(env_info: EnvInfo, num_traj, rollout, rnn_size, device, share) -> TensorDict:\n    obs_space = env_info.obs_space\n    tensors = TensorDict()\n    # policy inputs\n    tensors[\"obs\"] = TensorDict()\n    if not isinstance(obs_space, spaces.Dict):\n        raise Exception(\"Only Dict observations spaces are supported\")\n    # we need to allocate an extra rollout step here to calculate the value estimates for the last step\n    for space_name, space in obs_space.spaces.items():\n        tensors[\"obs\"][space_name] = init_tensor([num_traj, rollout + 1], space.dtype, space.shape, device, share)",
        "detail": "deps.sample-factory.sample_factory.algo.utils.shared_buffers",
        "documentation": {}
    },
    {
        "label": "alloc_policy_output_tensors",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.algo.utils.shared_buffers",
        "description": "deps.sample-factory.sample_factory.algo.utils.shared_buffers",
        "peekOfCode": "def alloc_policy_output_tensors(cfg, env_info: EnvInfo, rnn_size, device, share):\n    num_agents = env_info.num_agents\n    envs_per_split = cfg.num_envs_per_worker // cfg.worker_num_splits\n    policy_outputs_shape = [cfg.num_workers, cfg.worker_num_splits]\n    if cfg.batched_sampling:\n        policy_outputs_shape += [envs_per_split * num_agents]\n    else:\n        policy_outputs_shape += [envs_per_split, num_agents]\n    num_actions, num_action_distribution_parameters = action_info(env_info)\n    policy_outputs = policy_output_shapes(num_actions, num_action_distribution_parameters)",
        "detail": "deps.sample-factory.sample_factory.algo.utils.shared_buffers",
        "documentation": {}
    },
    {
        "label": "TensorDict",
        "kind": 6,
        "importPath": "deps.sample-factory.sample_factory.algo.utils.tensor_dict",
        "description": "deps.sample-factory.sample_factory.algo.utils.tensor_dict",
        "peekOfCode": "class TensorDict(dict):\n    dict_key_type = str\n    def __getitem__(self, key):\n        if isinstance(key, self.dict_key_type):\n            # if key is string assume we're accessing dict's interface\n            return dict.__getitem__(self, key)\n        else:\n            # otherwise we want to index/slice into tensors themselves\n            return self._index_func(self, key)\n    def _index_func(self, x, indices):",
        "detail": "deps.sample-factory.sample_factory.algo.utils.tensor_dict",
        "documentation": {}
    },
    {
        "label": "clone_tensordict",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.algo.utils.tensor_dict",
        "description": "deps.sample-factory.sample_factory.algo.utils.tensor_dict",
        "peekOfCode": "def clone_tensordict(d: TensorDict) -> TensorDict:\n    \"\"\"Returns a cloned tensordict.\"\"\"\n    d_clone = copy_dict_structure(d)\n    for d1, d2, key, v1, v2 in iter_dicts_recursively(d, d_clone):\n        d2[key] = v1.clone().detach()\n    return d_clone\ndef shallow_recursive_copy(d: TensorDict) -> TensorDict:\n    \"\"\"\n    Returns a shallow copy of the tensordict. Different dictionary object (recursively) but referencing\n    the same tensors.",
        "detail": "deps.sample-factory.sample_factory.algo.utils.tensor_dict",
        "documentation": {}
    },
    {
        "label": "shallow_recursive_copy",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.algo.utils.tensor_dict",
        "description": "deps.sample-factory.sample_factory.algo.utils.tensor_dict",
        "peekOfCode": "def shallow_recursive_copy(d: TensorDict) -> TensorDict:\n    \"\"\"\n    Returns a shallow copy of the tensordict. Different dictionary object (recursively) but referencing\n    the same tensors.\n    \"\"\"\n    d_copy = copy_dict_structure(d)\n    for d1, d2, key, v1, v2 in iter_dicts_recursively(d, d_copy):\n        d2[key] = v1\n    return d_copy\ndef tensor_dict_to_numpy(d: TensorDict) -> TensorDict:",
        "detail": "deps.sample-factory.sample_factory.algo.utils.tensor_dict",
        "documentation": {}
    },
    {
        "label": "tensor_dict_to_numpy",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.algo.utils.tensor_dict",
        "description": "deps.sample-factory.sample_factory.algo.utils.tensor_dict",
        "peekOfCode": "def tensor_dict_to_numpy(d: TensorDict) -> TensorDict:\n    numpy_dict = copy_dict_structure(d)\n    for d1, d2, key, curr_t, value2 in iter_dicts_recursively(d, numpy_dict):\n        assert isinstance(curr_t, torch.Tensor)\n        assert value2 is None\n        d2[key] = curr_t.numpy()\n        assert isinstance(d2[key], np.ndarray)\n    return numpy_dict\ndef to_numpy(t: Tensor | TensorDict) -> Tensor | TensorDict:\n    if isinstance(t, TensorDict):",
        "detail": "deps.sample-factory.sample_factory.algo.utils.tensor_dict",
        "documentation": {}
    },
    {
        "label": "to_numpy",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.algo.utils.tensor_dict",
        "description": "deps.sample-factory.sample_factory.algo.utils.tensor_dict",
        "peekOfCode": "def to_numpy(t: Tensor | TensorDict) -> Tensor | TensorDict:\n    if isinstance(t, TensorDict):\n        return tensor_dict_to_numpy(t)\n    else:\n        return t.numpy()  # only going to work for cpu tensors\ndef cat_tensordicts(lst: List[TensorDict]) -> TensorDict:\n    \"\"\"\n    Concatenates a list of tensordicts.\n    \"\"\"\n    if not lst:",
        "detail": "deps.sample-factory.sample_factory.algo.utils.tensor_dict",
        "documentation": {}
    },
    {
        "label": "cat_tensordicts",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.algo.utils.tensor_dict",
        "description": "deps.sample-factory.sample_factory.algo.utils.tensor_dict",
        "peekOfCode": "def cat_tensordicts(lst: List[TensorDict]) -> TensorDict:\n    \"\"\"\n    Concatenates a list of tensordicts.\n    \"\"\"\n    if not lst:\n        return TensorDict()\n    res = list_of_dicts_to_dict_of_lists(lst)\n    # iterate res recursively and concatenate tensors\n    for d, k, v in iterate_recursively(res):\n        if isinstance(v[0], torch.Tensor):",
        "detail": "deps.sample-factory.sample_factory.algo.utils.tensor_dict",
        "documentation": {}
    },
    {
        "label": "find_invalid_data",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.algo.utils.tensor_dict",
        "description": "deps.sample-factory.sample_factory.algo.utils.tensor_dict",
        "peekOfCode": "def find_invalid_data(\n    t: TensorDict, msg: Optional[str] = None, keys: Optional[Iterable[str]] = None\n) -> Optional[Dict[str, Tensor]]:\n    res = {}\n    msg = msg or \"Check\"\n    for d, k, v in iterate_recursively(t):\n        if keys is not None and k not in keys:\n            continue\n        if isinstance(v, torch.Tensor):\n            invalid_idx = None",
        "detail": "deps.sample-factory.sample_factory.algo.utils.tensor_dict",
        "documentation": {}
    },
    {
        "label": "clone_tensor",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.algo.utils.tensor_utils",
        "description": "deps.sample-factory.sample_factory.algo.utils.tensor_utils",
        "peekOfCode": "def clone_tensor(t: Tensor | np.ndarray) -> Tensor | np.ndarray:\n    if isinstance(t, Tensor):\n        return t.clone().detach()\n    else:\n        return np.copy(t)\ndef unsqueeze_tensor(t: Tensor | np.ndarray, dim: int) -> Tensor | np.ndarray:\n    if isinstance(t, Tensor):\n        return t.unsqueeze(dim)\n    else:\n        return np.expand_dims(t, dim)",
        "detail": "deps.sample-factory.sample_factory.algo.utils.tensor_utils",
        "documentation": {}
    },
    {
        "label": "unsqueeze_tensor",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.algo.utils.tensor_utils",
        "description": "deps.sample-factory.sample_factory.algo.utils.tensor_utils",
        "peekOfCode": "def unsqueeze_tensor(t: Tensor | np.ndarray, dim: int) -> Tensor | np.ndarray:\n    if isinstance(t, Tensor):\n        return t.unsqueeze(dim)\n    else:\n        return np.expand_dims(t, dim)\ndef cat_tensors(lt: List[Tensor | np.ndarray]) -> Tensor | np.ndarray:\n    if isinstance(lt[0], Tensor):\n        return torch.cat(lt)\n    else:\n        return np.concatenate(lt)",
        "detail": "deps.sample-factory.sample_factory.algo.utils.tensor_utils",
        "documentation": {}
    },
    {
        "label": "cat_tensors",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.algo.utils.tensor_utils",
        "description": "deps.sample-factory.sample_factory.algo.utils.tensor_utils",
        "peekOfCode": "def cat_tensors(lt: List[Tensor | np.ndarray]) -> Tensor | np.ndarray:\n    if isinstance(lt[0], Tensor):\n        return torch.cat(lt)\n    else:\n        return np.concatenate(lt)\ndef dict_of_lists_cat(d: Dict[Any, List | Tensor]):\n    for key, x in d.items():\n        d[key] = cat_tensors(x)\ndef ensure_torch_tensor(t: Tensor | np.ndarray) -> Tensor:\n    if isinstance(t, Tensor):",
        "detail": "deps.sample-factory.sample_factory.algo.utils.tensor_utils",
        "documentation": {}
    },
    {
        "label": "dict_of_lists_cat",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.algo.utils.tensor_utils",
        "description": "deps.sample-factory.sample_factory.algo.utils.tensor_utils",
        "peekOfCode": "def dict_of_lists_cat(d: Dict[Any, List | Tensor]):\n    for key, x in d.items():\n        d[key] = cat_tensors(x)\ndef ensure_torch_tensor(t: Tensor | np.ndarray) -> Tensor:\n    if isinstance(t, Tensor):\n        return t\n    else:\n        return torch.from_numpy(t)\ndef ensure_numpy_array(t: Tensor | np.ndarray) -> np.ndarray:\n    if isinstance(t, Tensor):",
        "detail": "deps.sample-factory.sample_factory.algo.utils.tensor_utils",
        "documentation": {}
    },
    {
        "label": "ensure_torch_tensor",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.algo.utils.tensor_utils",
        "description": "deps.sample-factory.sample_factory.algo.utils.tensor_utils",
        "peekOfCode": "def ensure_torch_tensor(t: Tensor | np.ndarray) -> Tensor:\n    if isinstance(t, Tensor):\n        return t\n    else:\n        return torch.from_numpy(t)\ndef ensure_numpy_array(t: Tensor | np.ndarray) -> np.ndarray:\n    if isinstance(t, Tensor):\n        return t.numpy()\n    else:\n        return t",
        "detail": "deps.sample-factory.sample_factory.algo.utils.tensor_utils",
        "documentation": {}
    },
    {
        "label": "ensure_numpy_array",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.algo.utils.tensor_utils",
        "description": "deps.sample-factory.sample_factory.algo.utils.tensor_utils",
        "peekOfCode": "def ensure_numpy_array(t: Tensor | np.ndarray) -> np.ndarray:\n    if isinstance(t, Tensor):\n        return t.numpy()\n    else:\n        return t",
        "detail": "deps.sample-factory.sample_factory.algo.utils.tensor_utils",
        "documentation": {}
    },
    {
        "label": "init_torch_runtime",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.algo.utils.torch_utils",
        "description": "deps.sample-factory.sample_factory.algo.utils.torch_utils",
        "peekOfCode": "def init_torch_runtime(cfg: AttrDict, max_num_threads: Optional[int] = 1):\n    torch.multiprocessing.set_sharing_strategy(\"file_system\")\n    if max_num_threads is not None:\n        torch.set_num_threads(max_num_threads)\n    if cfg.device == \"gpu\":\n        # noinspection PyUnresolvedReferences\n        torch.backends.cudnn.benchmark = True\ndef inference_context(is_serial):\n    if is_serial:\n        # in serial mode we use the same tensors on sampler and learner",
        "detail": "deps.sample-factory.sample_factory.algo.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "inference_context",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.algo.utils.torch_utils",
        "description": "deps.sample-factory.sample_factory.algo.utils.torch_utils",
        "peekOfCode": "def inference_context(is_serial):\n    if is_serial:\n        # in serial mode we use the same tensors on sampler and learner\n        return torch.no_grad()\n    else:\n        return torch.inference_mode()\ndef to_torch_dtype(numpy_dtype):\n    \"\"\"from_numpy automatically infers type, so we leverage that.\"\"\"\n    x = np.zeros([1], dtype=numpy_dtype)\n    t = torch.from_numpy(x)",
        "detail": "deps.sample-factory.sample_factory.algo.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "to_torch_dtype",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.algo.utils.torch_utils",
        "description": "deps.sample-factory.sample_factory.algo.utils.torch_utils",
        "peekOfCode": "def to_torch_dtype(numpy_dtype):\n    \"\"\"from_numpy automatically infers type, so we leverage that.\"\"\"\n    x = np.zeros([1], dtype=numpy_dtype)\n    t = torch.from_numpy(x)\n    return t.dtype\ndef calc_num_elements(module, module_input_shape):\n    shape_with_batch_dim = (1,) + module_input_shape\n    some_input = torch.rand(shape_with_batch_dim)\n    num_elements = module(some_input).numel()\n    return num_elements",
        "detail": "deps.sample-factory.sample_factory.algo.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "calc_num_elements",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.algo.utils.torch_utils",
        "description": "deps.sample-factory.sample_factory.algo.utils.torch_utils",
        "peekOfCode": "def calc_num_elements(module, module_input_shape):\n    shape_with_batch_dim = (1,) + module_input_shape\n    some_input = torch.rand(shape_with_batch_dim)\n    num_elements = module(some_input).numel()\n    return num_elements\ndef to_scalar(value):\n    if isinstance(value, torch.Tensor):\n        return value.item()\n    else:\n        return value",
        "detail": "deps.sample-factory.sample_factory.algo.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "to_scalar",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.algo.utils.torch_utils",
        "description": "deps.sample-factory.sample_factory.algo.utils.torch_utils",
        "peekOfCode": "def to_scalar(value):\n    if isinstance(value, torch.Tensor):\n        return value.item()\n    else:\n        return value\n@torch.jit.script\ndef masked_select(x: torch.Tensor, mask: torch.Tensor, num_non_mask: int) -> torch.Tensor:\n    if num_non_mask == 0:\n        return x\n    else:",
        "detail": "deps.sample-factory.sample_factory.algo.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "masked_select",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.algo.utils.torch_utils",
        "description": "deps.sample-factory.sample_factory.algo.utils.torch_utils",
        "peekOfCode": "def masked_select(x: torch.Tensor, mask: torch.Tensor, num_non_mask: int) -> torch.Tensor:\n    if num_non_mask == 0:\n        return x\n    else:\n        return torch.masked_select(x, mask)\ndef synchronize(cfg: Config, device: torch.device | str) -> None:\n    if cfg.serial_mode:\n        return\n    if isinstance(device, str):\n        device = torch.device(device)",
        "detail": "deps.sample-factory.sample_factory.algo.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "synchronize",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.algo.utils.torch_utils",
        "description": "deps.sample-factory.sample_factory.algo.utils.torch_utils",
        "peekOfCode": "def synchronize(cfg: Config, device: torch.device | str) -> None:\n    if cfg.serial_mode:\n        return\n    if isinstance(device, str):\n        device = torch.device(device)\n    if device.type == \"cuda\":\n        torch.cuda.synchronize(device)",
        "detail": "deps.sample-factory.sample_factory.algo.utils.torch_utils",
        "documentation": {}
    },
    {
        "label": "parse_sf_args",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.cfg.arguments",
        "description": "deps.sample-factory.sample_factory.cfg.arguments",
        "peekOfCode": "def parse_sf_args(\n    argv: Optional[List[str]] = None, evaluation: bool = False\n) -> Tuple[argparse.ArgumentParser, argparse.Namespace]:\n    \"\"\"\n    Create a parser and parse the known arguments (default SF configuration, see cfg.py).\n    Returns a parser that can be further extended with additional arguments before a final pass is made.\n    This allows custom scripts to add any additional arguments they need depending on partially known configuration,\n    such as the environment name.\n    argv: list of arguments to parse. If None, use sys.argv.\n    evaluation: if True, also add evaluation-only arguments.",
        "detail": "deps.sample-factory.sample_factory.cfg.arguments",
        "documentation": {}
    },
    {
        "label": "parse_full_cfg",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.cfg.arguments",
        "description": "deps.sample-factory.sample_factory.cfg.arguments",
        "peekOfCode": "def parse_full_cfg(parser: argparse.ArgumentParser, argv: Optional[List[str]] = None) -> argparse.Namespace:\n    \"\"\"Given a parser, parse all arguments and return the final configuration.\"\"\"\n    if argv is None:\n        argv = sys.argv[1:]\n    args = parser.parse_args(argv)\n    args = postprocess_args(args, argv, parser)\n    return args\ndef postprocess_args(args, argv, parser) -> argparse.Namespace:\n    \"\"\"\n    Postprocessing after parse_args is called.",
        "detail": "deps.sample-factory.sample_factory.cfg.arguments",
        "documentation": {}
    },
    {
        "label": "postprocess_args",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.cfg.arguments",
        "description": "deps.sample-factory.sample_factory.cfg.arguments",
        "peekOfCode": "def postprocess_args(args, argv, parser) -> argparse.Namespace:\n    \"\"\"\n    Postprocessing after parse_args is called.\n    Makes it easy to use SF within another codebase which might have its own parse_args call.\n    \"\"\"\n    if args.help:\n        parser.print_help()\n        sys.exit(0)\n    args.command_line = \" \".join(argv)\n    # following is the trick to get only the args passed from the command line",
        "detail": "deps.sample-factory.sample_factory.cfg.arguments",
        "documentation": {}
    },
    {
        "label": "preprocess_cfg",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.cfg.arguments",
        "description": "deps.sample-factory.sample_factory.cfg.arguments",
        "peekOfCode": "def preprocess_cfg(cfg: Config, env_info: EnvInfo) -> bool:\n    if cfg.recurrence == -1:\n        cfg.recurrence = cfg.rollout if cfg.use_rnn else 1\n        log.debug(f\"Automatically setting recurrence to {cfg.recurrence}\")\n    return verify_cfg(cfg, env_info)\ndef verify_cfg(cfg: Config, env_info: EnvInfo) -> bool:\n    \"\"\"\n    Do some checks to make sure this is a viable configuration.\n    The fact that configuration passes these checks does not guarantee that it is 100% valid,\n    there are more checks sprinkled throughout the codebase.",
        "detail": "deps.sample-factory.sample_factory.cfg.arguments",
        "documentation": {}
    },
    {
        "label": "verify_cfg",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.cfg.arguments",
        "description": "deps.sample-factory.sample_factory.cfg.arguments",
        "peekOfCode": "def verify_cfg(cfg: Config, env_info: EnvInfo) -> bool:\n    \"\"\"\n    Do some checks to make sure this is a viable configuration.\n    The fact that configuration passes these checks does not guarantee that it is 100% valid,\n    there are more checks sprinkled throughout the codebase.\n    It is better to add new checks here if possible since we check only once instead of doing this over and\n    over again in the training loop.\n    cfg: the configuration to verify\n    returns: True if the configuration is valid, False otherwise.\n    \"\"\"",
        "detail": "deps.sample-factory.sample_factory.cfg.arguments",
        "documentation": {}
    },
    {
        "label": "cfg_dict",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.cfg.arguments",
        "description": "deps.sample-factory.sample_factory.cfg.arguments",
        "peekOfCode": "def cfg_dict(cfg: Config) -> AttrDict:\n    if isinstance(cfg, dict):\n        return AttrDict(cfg)\n    else:\n        return AttrDict(vars(cfg))\ndef cfg_str(cfg: Config) -> str:\n    cfg = cfg_dict(cfg)\n    cfg_lines = []\n    for k, v in cfg.items():\n        cfg_lines.append(f\"{k}={v}\")",
        "detail": "deps.sample-factory.sample_factory.cfg.arguments",
        "documentation": {}
    },
    {
        "label": "cfg_str",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.cfg.arguments",
        "description": "deps.sample-factory.sample_factory.cfg.arguments",
        "peekOfCode": "def cfg_str(cfg: Config) -> str:\n    cfg = cfg_dict(cfg)\n    cfg_lines = []\n    for k, v in cfg.items():\n        cfg_lines.append(f\"{k}={v}\")\n    return \"\\n\".join(cfg_lines)\ndef default_cfg(algo=\"APPO\", env=\"env\", experiment=\"test\"):\n    \"\"\"Useful for tests.\"\"\"\n    argv = [f\"--algo={algo}\", f\"--env={env}\", f\"--experiment={experiment}\"]\n    parser, args = parse_sf_args(argv)",
        "detail": "deps.sample-factory.sample_factory.cfg.arguments",
        "documentation": {}
    },
    {
        "label": "default_cfg",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.cfg.arguments",
        "description": "deps.sample-factory.sample_factory.cfg.arguments",
        "peekOfCode": "def default_cfg(algo=\"APPO\", env=\"env\", experiment=\"test\"):\n    \"\"\"Useful for tests.\"\"\"\n    argv = [f\"--algo={algo}\", f\"--env={env}\", f\"--experiment={experiment}\"]\n    parser, args = parse_sf_args(argv)\n    args = parse_full_cfg(parser, argv)\n    return args\ndef load_from_checkpoint(cfg: Config) -> AttrDict:\n    cfg_filename = cfg_file(cfg)\n    cfg_filename_old = cfg_file_old(cfg)\n    if not os.path.isfile(cfg_filename) and os.path.isfile(cfg_filename_old):",
        "detail": "deps.sample-factory.sample_factory.cfg.arguments",
        "documentation": {}
    },
    {
        "label": "load_from_checkpoint",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.cfg.arguments",
        "description": "deps.sample-factory.sample_factory.cfg.arguments",
        "peekOfCode": "def load_from_checkpoint(cfg: Config) -> AttrDict:\n    cfg_filename = cfg_file(cfg)\n    cfg_filename_old = cfg_file_old(cfg)\n    if not os.path.isfile(cfg_filename) and os.path.isfile(cfg_filename_old):\n        # rename old config file\n        log.warning(f\"Loading legacy config file {cfg_filename_old} instead of {cfg_filename}\")\n        os.rename(cfg_filename_old, cfg_filename)\n    if not os.path.isfile(cfg_filename):\n        raise Exception(\n            f\"Could not load saved parameters for experiment {cfg.experiment} \"",
        "detail": "deps.sample-factory.sample_factory.cfg.arguments",
        "documentation": {}
    },
    {
        "label": "maybe_load_from_checkpoint",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.cfg.arguments",
        "description": "deps.sample-factory.sample_factory.cfg.arguments",
        "peekOfCode": "def maybe_load_from_checkpoint(cfg: Config) -> AttrDict:\n    \"\"\"\n    Will attempt to load experiment configuration from the checkpoint while preserving any new overrides passed\n    from command line.\n    \"\"\"\n    filename = cfg_file(cfg)\n    if not os.path.isfile(filename):\n        log.warning(\"Saved parameter configuration for experiment %s not found!\", cfg.experiment)\n        log.warning(\"Starting experiment from scratch!\")\n        return AttrDict(vars(cfg))",
        "detail": "deps.sample-factory.sample_factory.cfg.arguments",
        "documentation": {}
    },
    {
        "label": "checkpoint_override_defaults",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.cfg.arguments",
        "description": "deps.sample-factory.sample_factory.cfg.arguments",
        "peekOfCode": "def checkpoint_override_defaults(cfg: Config, parser) -> AttrDict:\n    cfg_filename = cfg_file(cfg)\n    if not os.path.isfile(cfg_filename):\n        raise Exception(\n            f\"Could not load saved parameters for experiment {cfg.experiment} \"\n            f\"(file {cfg_filename} not found). Check that you have the correct experiment name \"\n            f\"and --train_dir is set correctly.\"\n        )\n    with open(cfg_filename, \"r\") as json_file:\n        json_params = json.load(json_file)",
        "detail": "deps.sample-factory.sample_factory.cfg.arguments",
        "documentation": {}
    },
    {
        "label": "add_basic_cli_args",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.cfg.cfg",
        "description": "deps.sample-factory.sample_factory.cfg.cfg",
        "peekOfCode": "def add_basic_cli_args(p: ArgumentParser):\n    p.add_argument(\"-h\", \"--help\", action=\"store_true\", help=\"Print the help message\", required=False)\n    p.add_argument(\"--algo\", type=str, default=\"APPO\", help=\"Algorithm to use\")\n    p.add_argument(\"--env\", type=str, default=None, required=True, help=\"Name of the environment to use\")\n    p.add_argument(\n        \"--experiment\",\n        type=str,\n        default=\"default_experiment\",\n        help=\"Unique experiment name. This will also be the name for the experiment folder in the train dir.\"\n        \"If the experiment folder with this name aleady exists the experiment will be RESUMED!\"",
        "detail": "deps.sample-factory.sample_factory.cfg.cfg",
        "documentation": {}
    },
    {
        "label": "add_rl_args",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.cfg.cfg",
        "description": "deps.sample-factory.sample_factory.cfg.cfg",
        "peekOfCode": "def add_rl_args(p: ArgumentParser):\n    \"\"\"Arguments not specific to any particular RL algorithm.\"\"\"\n    # RL training system configuration (i.e. whether sync or async, etc.)\n    p.add_argument(\n        \"--num_policies\",\n        default=1,\n        type=int,\n        help=\"Number of policies to train jointly, i.e. for multi-agent environments\",\n    )\n    p.add_argument(",
        "detail": "deps.sample-factory.sample_factory.cfg.cfg",
        "documentation": {}
    },
    {
        "label": "add_model_args",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.cfg.cfg",
        "description": "deps.sample-factory.sample_factory.cfg.cfg",
        "peekOfCode": "def add_model_args(p: ArgumentParser):\n    \"\"\"\n    Policy size, configuration, etc.\n    Model builder automatically detects whether we should use conv or MLP encoder, then we use parameters to spectify\n    settings for one or the other. If we're using MLP encoder, conv encoder settings will be ignored.\n    \"\"\"\n    # policy with vector observations - encoder options\n    p.add_argument(\n        \"--encoder_mlp_layers\",\n        default=[512, 512],",
        "detail": "deps.sample-factory.sample_factory.cfg.cfg",
        "documentation": {}
    },
    {
        "label": "add_default_env_args",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.cfg.cfg",
        "description": "deps.sample-factory.sample_factory.cfg.cfg",
        "peekOfCode": "def add_default_env_args(p: ArgumentParser):\n    \"\"\"Configuration related to the environments, i.e. things that might be difficult to query from an environment instance.\"\"\"\n    p.add_argument(\"--use_env_info_cache\", default=False, type=str2bool, help=\"Whether to use cached env info\")\n    p.add_argument(\n        \"--env_gpu_actions\",\n        default=False,\n        type=str2bool,\n        help=\"Set to true if environment expects actions on GPU (i.e. as a GPU-side PyTorch tensor)\",\n    )\n    p.add_argument(",
        "detail": "deps.sample-factory.sample_factory.cfg.cfg",
        "documentation": {}
    },
    {
        "label": "add_eval_args",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.cfg.cfg",
        "description": "deps.sample-factory.sample_factory.cfg.cfg",
        "peekOfCode": "def add_eval_args(parser):\n    \"\"\"Evaluation-related arguments, i.e. only used when testing/visualizing policies rather than training them.\"\"\"\n    parser.add_argument(\n        \"--fps\",\n        default=0,\n        type=int,\n        help=\"Enable rendering with adjustable FPS. Default (0) means default, e.g. for Doom its FPS (~35), or unlimited if not specified by env. Leave at 0 for Doom multiplayer evaluation\",\n    )\n    parser.add_argument(\n        \"--eval_env_frameskip\",",
        "detail": "deps.sample-factory.sample_factory.cfg.cfg",
        "documentation": {}
    },
    {
        "label": "add_wandb_args",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.cfg.cfg",
        "description": "deps.sample-factory.sample_factory.cfg.cfg",
        "peekOfCode": "def add_wandb_args(p: ArgumentParser):\n    \"\"\"Weights and Biases experiment monitoring.\"\"\"\n    p.add_argument(\"--with_wandb\", default=False, type=str2bool, help=\"Enables Weights and Biases integration\")\n    p.add_argument(\n        \"--wandb_user\",\n        default=None,\n        type=str,\n        help=\"WandB username (entity). Must be specified from command line! Also see https://docs.wandb.ai/quickstart#1.-set-up-wandb\",\n    )\n    p.add_argument(\"--wandb_project\", default=\"sample_factory\", type=str, help='WandB \"Project\"')",
        "detail": "deps.sample-factory.sample_factory.cfg.cfg",
        "documentation": {}
    },
    {
        "label": "add_pbt_args",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.cfg.cfg",
        "description": "deps.sample-factory.sample_factory.cfg.cfg",
        "peekOfCode": "def add_pbt_args(p: ArgumentParser):\n    \"\"\"Population-based training (PBT) arguments.\"\"\"\n    p.add_argument(\"--with_pbt\", default=False, type=str2bool, help=\"Enables population-based training (PBT)\")\n    p.add_argument(\n        \"--pbt_mix_policies_in_one_env\",\n        default=True,\n        type=str2bool,\n        help=\"For multi-agent envs, whether we mix different policies in one env.\",\n    )\n    p.add_argument(",
        "detail": "deps.sample-factory.sample_factory.cfg.cfg",
        "documentation": {}
    },
    {
        "label": "Configurable",
        "kind": 6,
        "importPath": "deps.sample-factory.sample_factory.cfg.configurable",
        "description": "deps.sample-factory.sample_factory.cfg.configurable",
        "peekOfCode": "class Configurable:\n    def __init__(self, cfg: AttrDict):\n        self.cfg: AttrDict = cfg",
        "detail": "deps.sample-factory.sample_factory.cfg.configurable",
        "documentation": {}
    },
    {
        "label": "create_env",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.envs.create_env",
        "description": "deps.sample-factory.sample_factory.envs.create_env",
        "peekOfCode": "def create_env(\n    full_env_name: str,\n    cfg: Optional[Config] = None,\n    env_config: Optional[AttrDict] = None,\n    render_mode: Optional[str] = None,\n):\n    \"\"\"\n    Factory function that creates environment instances.\n    :param full_env_name: complete name of the environment\n    :param cfg: namespace with full system configuration, output of argparser (or AttrDict when loaded from JSON)",
        "detail": "deps.sample-factory.sample_factory.envs.create_env",
        "documentation": {}
    },
    {
        "label": "EnvCriticalError",
        "kind": 6,
        "importPath": "deps.sample-factory.sample_factory.envs.env_utils",
        "description": "deps.sample-factory.sample_factory.envs.env_utils",
        "peekOfCode": "class EnvCriticalError(Exception):\n    pass\n# TODO: move to their respective folders\ndef vizdoom_available():\n    return is_module_available(\"vizdoom\")\ndef retry(exception_class=Exception, num_attempts=3, sleep_time=1):\n    def decorator(func):\n        @wraps(func)\n        def wrapper(*args, **kwargs):\n            for i in range(num_attempts):",
        "detail": "deps.sample-factory.sample_factory.envs.env_utils",
        "documentation": {}
    },
    {
        "label": "RewardShapingInterface",
        "kind": 6,
        "importPath": "deps.sample-factory.sample_factory.envs.env_utils",
        "description": "deps.sample-factory.sample_factory.envs.env_utils",
        "peekOfCode": "class RewardShapingInterface:\n    def get_default_reward_shaping(self) -> Optional[Dict[str, Any]]:\n        \"\"\"Should return a dictionary of string:float key-value pairs defining the current reward shaping scheme.\"\"\"\n        raise NotImplementedError\n    def set_reward_shaping(self, reward_shaping: Dict[str, Any], agent_idx: int | slice) -> None:\n        \"\"\"\n        Sets the new reward shaping scheme.\n        :param reward_shaping dictionary of string-float key-value pairs\n        :param agent_idx: integer agent index (for multi-agent envs). Can be a slice if we're training in batched mode\n        (set a single reward shaping scheme for a range of agents)",
        "detail": "deps.sample-factory.sample_factory.envs.env_utils",
        "documentation": {}
    },
    {
        "label": "TrainingInfoInterface",
        "kind": 6,
        "importPath": "deps.sample-factory.sample_factory.envs.env_utils",
        "description": "deps.sample-factory.sample_factory.envs.env_utils",
        "peekOfCode": "class TrainingInfoInterface:\n    def __init__(self):\n        self.training_info: Dict[str, Any] = dict()\n    def set_training_info(self, training_info):\n        \"\"\"\n        Send the training information to the environment, i.e. number of training steps so far.\n        Some environments rely on that i.e. to implement curricula.\n        :param training_info: dictionary containing information about the current training session. Guaranteed to\n        contain 'approx_total_training_steps' (approx because it lags a bit behind due to multiprocess synchronization)\n        \"\"\"",
        "detail": "deps.sample-factory.sample_factory.envs.env_utils",
        "documentation": {}
    },
    {
        "label": "register_env",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.envs.env_utils",
        "description": "deps.sample-factory.sample_factory.envs.env_utils",
        "peekOfCode": "def register_env(env_name: str, make_env_func: CreateEnvFunc) -> None:\n    \"\"\"\n    Register a callable that creates an environment.\n    This callable is called like:\n        make_env_func(full_env_name, cfg, env_config)\n        Where full_env_name is the name of the environment to be created, cfg is a namespace or AttrDict containing\n        necessary configuration parameters and env_config is an auxiliary dictionary containing information such as worker index on which the environment lives\n        (some envs may require this information)\n    env_name: name of the environment\n    make_env_func: callable that creates an environment",
        "detail": "deps.sample-factory.sample_factory.envs.env_utils",
        "documentation": {}
    },
    {
        "label": "vizdoom_available",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.envs.env_utils",
        "description": "deps.sample-factory.sample_factory.envs.env_utils",
        "peekOfCode": "def vizdoom_available():\n    return is_module_available(\"vizdoom\")\ndef retry(exception_class=Exception, num_attempts=3, sleep_time=1):\n    def decorator(func):\n        @wraps(func)\n        def wrapper(*args, **kwargs):\n            for i in range(num_attempts):\n                try:\n                    return func(*args, **kwargs)\n                except exception_class as e:",
        "detail": "deps.sample-factory.sample_factory.envs.env_utils",
        "documentation": {}
    },
    {
        "label": "retry",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.envs.env_utils",
        "description": "deps.sample-factory.sample_factory.envs.env_utils",
        "peekOfCode": "def retry(exception_class=Exception, num_attempts=3, sleep_time=1):\n    def decorator(func):\n        @wraps(func)\n        def wrapper(*args, **kwargs):\n            for i in range(num_attempts):\n                try:\n                    return func(*args, **kwargs)\n                except exception_class as e:\n                    if i == num_attempts - 1:\n                        raise",
        "detail": "deps.sample-factory.sample_factory.envs.env_utils",
        "documentation": {}
    },
    {
        "label": "find_wrapper_interface",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.envs.env_utils",
        "description": "deps.sample-factory.sample_factory.envs.env_utils",
        "peekOfCode": "def find_wrapper_interface(env, interface_type):\n    \"\"\"Unwrap the env until we find the wrapper that implements interface_type.\"\"\"\n    unwrapped = env.unwrapped\n    while True:\n        if isinstance(env, interface_type):\n            return env\n        elif env == unwrapped:\n            return None  # unwrapped all the way and didn't find the interface\n        else:\n            env = env.env  # unwrap by one layer",
        "detail": "deps.sample-factory.sample_factory.envs.env_utils",
        "documentation": {}
    },
    {
        "label": "get_default_reward_shaping",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.envs.env_utils",
        "description": "deps.sample-factory.sample_factory.envs.env_utils",
        "peekOfCode": "def get_default_reward_shaping(env) -> Optional[Dict[str, Any]]:\n    \"\"\"\n    The current convention is that when the environment supports reward shaping, the env.unwrapped should contain\n    a reference to the object implementing RewardShapingInterface.\n    We use this object to get/set reward shaping schemes generated by PBT.\n    \"\"\"\n    reward_shaping_interface = find_wrapper_interface(env, RewardShapingInterface)\n    if reward_shaping_interface:\n        return reward_shaping_interface.get_default_reward_shaping()\n    return None",
        "detail": "deps.sample-factory.sample_factory.envs.env_utils",
        "documentation": {}
    },
    {
        "label": "set_reward_shaping",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.envs.env_utils",
        "description": "deps.sample-factory.sample_factory.envs.env_utils",
        "peekOfCode": "def set_reward_shaping(env, reward_shaping: Optional[Dict], agent_idx: int | slice) -> None:\n    if reward_shaping is None:\n        return\n    reward_shaping_interface = find_wrapper_interface(env, RewardShapingInterface)\n    if reward_shaping_interface:\n        reward_shaping_interface.set_reward_shaping(reward_shaping, agent_idx)\nclass TrainingInfoInterface:\n    def __init__(self):\n        self.training_info: Dict[str, Any] = dict()\n    def set_training_info(self, training_info):",
        "detail": "deps.sample-factory.sample_factory.envs.env_utils",
        "documentation": {}
    },
    {
        "label": "find_training_info_interface",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.envs.env_utils",
        "description": "deps.sample-factory.sample_factory.envs.env_utils",
        "peekOfCode": "def find_training_info_interface(env):\n    \"\"\"Unwrap the env until we find the wrapper that implements TrainingInfoInterface.\"\"\"\n    return find_wrapper_interface(env, TrainingInfoInterface)\ndef set_training_info(training_info_interface: Optional[TrainingInfoInterface], training_info: Dict[str, Any]) -> None:\n    if training_info_interface:\n        training_info_interface.set_training_info(training_info)\ndef num_env_steps(infos):\n    \"\"\"Calculate number of environment frames in a batch of experience.\"\"\"\n    total_num_frames = 0\n    for info in infos:",
        "detail": "deps.sample-factory.sample_factory.envs.env_utils",
        "documentation": {}
    },
    {
        "label": "set_training_info",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.envs.env_utils",
        "description": "deps.sample-factory.sample_factory.envs.env_utils",
        "peekOfCode": "def set_training_info(training_info_interface: Optional[TrainingInfoInterface], training_info: Dict[str, Any]) -> None:\n    if training_info_interface:\n        training_info_interface.set_training_info(training_info)\ndef num_env_steps(infos):\n    \"\"\"Calculate number of environment frames in a batch of experience.\"\"\"\n    total_num_frames = 0\n    for info in infos:\n        total_num_frames += info.get(\"num_frames\", 1)\n    return total_num_frames",
        "detail": "deps.sample-factory.sample_factory.envs.env_utils",
        "documentation": {}
    },
    {
        "label": "num_env_steps",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.envs.env_utils",
        "description": "deps.sample-factory.sample_factory.envs.env_utils",
        "peekOfCode": "def num_env_steps(infos):\n    \"\"\"Calculate number of environment frames in a batch of experience.\"\"\"\n    total_num_frames = 0\n    for info in infos:\n        total_num_frames += info.get(\"num_frames\", 1)\n    return total_num_frames",
        "detail": "deps.sample-factory.sample_factory.envs.env_utils",
        "documentation": {}
    },
    {
        "label": "ResizeWrapper",
        "kind": 6,
        "importPath": "deps.sample-factory.sample_factory.envs.env_wrappers",
        "description": "deps.sample-factory.sample_factory.envs.env_wrappers",
        "peekOfCode": "class ResizeWrapper(gym.core.Wrapper):\n    \"\"\"Resize observation frames to specified (w,h) and convert to grayscale.\"\"\"\n    def __init__(self, env, w, h, grayscale=True, add_channel_dim=False, area_interpolation=False):\n        super(ResizeWrapper, self).__init__(env)\n        self.w = w\n        self.h = h\n        self.grayscale = grayscale\n        self.add_channel_dim = add_channel_dim\n        self.interpolation = cv2.INTER_AREA if area_interpolation else cv2.INTER_NEAREST\n        if isinstance(env.observation_space, spaces.Dict):",
        "detail": "deps.sample-factory.sample_factory.envs.env_wrappers",
        "documentation": {}
    },
    {
        "label": "RewardScalingWrapper",
        "kind": 6,
        "importPath": "deps.sample-factory.sample_factory.envs.env_wrappers",
        "description": "deps.sample-factory.sample_factory.envs.env_wrappers",
        "peekOfCode": "class RewardScalingWrapper(RewardWrapper):\n    def __init__(self, env, scaling_factor):\n        super(RewardScalingWrapper, self).__init__(env)\n        self._scaling = scaling_factor\n        self.reward_range = (r * scaling_factor for r in self.reward_range)\n    def reward(self, reward):\n        return reward * self._scaling\nclass TimeLimitWrapper(gym.core.Wrapper):\n    def __init__(self, env, limit, random_variation_steps=0):\n        super(TimeLimitWrapper, self).__init__(env)",
        "detail": "deps.sample-factory.sample_factory.envs.env_wrappers",
        "documentation": {}
    },
    {
        "label": "TimeLimitWrapper",
        "kind": 6,
        "importPath": "deps.sample-factory.sample_factory.envs.env_wrappers",
        "description": "deps.sample-factory.sample_factory.envs.env_wrappers",
        "peekOfCode": "class TimeLimitWrapper(gym.core.Wrapper):\n    def __init__(self, env, limit, random_variation_steps=0):\n        super(TimeLimitWrapper, self).__init__(env)\n        self._limit = limit\n        self._variation_steps = random_variation_steps\n        self._num_steps = 0\n        self._terminate_in = self._random_limit()\n    def _random_limit(self):\n        return np.random.randint(-self._variation_steps, self._variation_steps + 1) + self._limit\n    def reset(self, **kwargs):",
        "detail": "deps.sample-factory.sample_factory.envs.env_wrappers",
        "documentation": {}
    },
    {
        "label": "PixelFormatChwWrapper",
        "kind": 6,
        "importPath": "deps.sample-factory.sample_factory.envs.env_wrappers",
        "description": "deps.sample-factory.sample_factory.envs.env_wrappers",
        "peekOfCode": "class PixelFormatChwWrapper(ObservationWrapper):\n    \"\"\"TODO? This can be optimized for VizDoom, can we query CHW directly from VizDoom?\"\"\"\n    def __init__(self, env):\n        super().__init__(env)\n        if isinstance(env.observation_space, gym.spaces.Dict):\n            img_obs_space = env.observation_space[\"obs\"]\n            self.dict_obs_space = True\n        else:\n            img_obs_space = env.observation_space\n            self.dict_obs_space = False",
        "detail": "deps.sample-factory.sample_factory.envs.env_wrappers",
        "documentation": {}
    },
    {
        "label": "RecordingWrapper",
        "kind": 6,
        "importPath": "deps.sample-factory.sample_factory.envs.env_wrappers",
        "description": "deps.sample-factory.sample_factory.envs.env_wrappers",
        "peekOfCode": "class RecordingWrapper(gym.core.Wrapper):\n    def __init__(self, env, record_to, player_id):\n        super().__init__(env)\n        self._record_to = record_to\n        self._episode_recording_dir = None\n        self._record_id = 0\n        self._frame_id = 0\n        self._player_id = player_id\n        self._recorded_episode_reward = 0\n        self._recorded_episode_shaping_reward = 0",
        "detail": "deps.sample-factory.sample_factory.envs.env_wrappers",
        "documentation": {}
    },
    {
        "label": "NoopResetEnv",
        "kind": 6,
        "importPath": "deps.sample-factory.sample_factory.envs.env_wrappers",
        "description": "deps.sample-factory.sample_factory.envs.env_wrappers",
        "peekOfCode": "class NoopResetEnv(gym.Wrapper):\n    \"\"\"\n    Sample initial states by taking random number of no-ops on reset.\n    No-op is assumed to be action 0.\n    :param env: the environment to wrap\n    :param noop_max: the maximum value of no-ops to run\n    \"\"\"\n    def __init__(self, env: gym.Env, noop_max: int = 30):\n        gym.Wrapper.__init__(self, env)\n        self.noop_max = noop_max",
        "detail": "deps.sample-factory.sample_factory.envs.env_wrappers",
        "documentation": {}
    },
    {
        "label": "FireResetEnv",
        "kind": 6,
        "importPath": "deps.sample-factory.sample_factory.envs.env_wrappers",
        "description": "deps.sample-factory.sample_factory.envs.env_wrappers",
        "peekOfCode": "class FireResetEnv(gym.Wrapper):\n    \"\"\"\n    Take action on reset for environments that are fixed until firing.\n    :param env: the environment to wrap\n    \"\"\"\n    def __init__(self, env: gym.Env):\n        gym.Wrapper.__init__(self, env)\n        assert env.unwrapped.get_action_meanings()[1] == \"FIRE\"\n        assert len(env.unwrapped.get_action_meanings()) >= 3\n    def reset(self, **kwargs) -> Tuple[np.ndarray, Dict]:",
        "detail": "deps.sample-factory.sample_factory.envs.env_wrappers",
        "documentation": {}
    },
    {
        "label": "EpisodicLifeEnv",
        "kind": 6,
        "importPath": "deps.sample-factory.sample_factory.envs.env_wrappers",
        "description": "deps.sample-factory.sample_factory.envs.env_wrappers",
        "peekOfCode": "class EpisodicLifeEnv(gym.Wrapper):\n    \"\"\"\n    Make end-of-life == end-of-episode, but only reset on true game over.\n    Done by DeepMind for the DQN and co. since it helps value estimation.\n    :param env: the environment to wrap\n    \"\"\"\n    def __init__(self, env: gym.Env):\n        gym.Wrapper.__init__(self, env)\n        self.lives = 0\n        self.was_real_done = True",
        "detail": "deps.sample-factory.sample_factory.envs.env_wrappers",
        "documentation": {}
    },
    {
        "label": "MaxAndSkipEnv",
        "kind": 6,
        "importPath": "deps.sample-factory.sample_factory.envs.env_wrappers",
        "description": "deps.sample-factory.sample_factory.envs.env_wrappers",
        "peekOfCode": "class MaxAndSkipEnv(gym.Wrapper):\n    \"\"\"\n    Return only every ``skip``-th frame (frameskipping)\n    :param env: the environment\n    :param skip: number of ``skip``-th frame\n    \"\"\"\n    def __init__(self, env: gym.Env, skip: int = 4):\n        gym.Wrapper.__init__(self, env)\n        # most recent raw observations (for max pooling across time steps)\n        self._obs_buffer = np.zeros((2,) + env.observation_space.shape, dtype=env.observation_space.dtype)",
        "detail": "deps.sample-factory.sample_factory.envs.env_wrappers",
        "documentation": {}
    },
    {
        "label": "ClipRewardEnv",
        "kind": 6,
        "importPath": "deps.sample-factory.sample_factory.envs.env_wrappers",
        "description": "deps.sample-factory.sample_factory.envs.env_wrappers",
        "peekOfCode": "class ClipRewardEnv(gym.RewardWrapper):\n    \"\"\"\n    Clips the reward to {+1, 0, -1} by its sign.\n    :param env: the environment\n    \"\"\"\n    def __init__(self, env: gym.Env):\n        gym.RewardWrapper.__init__(self, env)\n    def reward(self, reward: float) -> float:\n        \"\"\"\n        Bin reward to {+1, 0, -1} by its sign.",
        "detail": "deps.sample-factory.sample_factory.envs.env_wrappers",
        "documentation": {}
    },
    {
        "label": "NumpyObsWrapper",
        "kind": 6,
        "importPath": "deps.sample-factory.sample_factory.envs.env_wrappers",
        "description": "deps.sample-factory.sample_factory.envs.env_wrappers",
        "peekOfCode": "class NumpyObsWrapper(gym.ObservationWrapper):\n    \"\"\"\n    RL algorithm generally expects numpy arrays or Tensors as observations. Atari envs for example return\n    LazyFrames which need to be converted to numpy arrays before we actually use them.\n    \"\"\"\n    def observation(self, observation: Any) -> np.ndarray:\n        return np.array(observation)\nclass EpisodeCounterWrapper(gym.Wrapper):\n    def __init__(self, env):\n        gym.Wrapper.__init__(self, env)",
        "detail": "deps.sample-factory.sample_factory.envs.env_wrappers",
        "documentation": {}
    },
    {
        "label": "EpisodeCounterWrapper",
        "kind": 6,
        "importPath": "deps.sample-factory.sample_factory.envs.env_wrappers",
        "description": "deps.sample-factory.sample_factory.envs.env_wrappers",
        "peekOfCode": "class EpisodeCounterWrapper(gym.Wrapper):\n    def __init__(self, env):\n        gym.Wrapper.__init__(self, env)\n        self.episode_count = 0\n    def reset(self, **kwargs) -> Tuple[GymObs, Dict]:\n        return self.env.reset(**kwargs)\n    def step(self, action: int) -> GymStepReturn:\n        obs, reward, terminated, truncated, info = self.env.step(action)\n        if terminated | truncated:\n            extra_stats = info.get(\"episode_extra_stats\", {})",
        "detail": "deps.sample-factory.sample_factory.envs.env_wrappers",
        "documentation": {}
    },
    {
        "label": "has_image_observations",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.envs.env_wrappers",
        "description": "deps.sample-factory.sample_factory.envs.env_wrappers",
        "peekOfCode": "def has_image_observations(observation_space):\n    \"\"\"It's a heuristic.\"\"\"\n    return len(observation_space.shape) >= 2\nclass ResizeWrapper(gym.core.Wrapper):\n    \"\"\"Resize observation frames to specified (w,h) and convert to grayscale.\"\"\"\n    def __init__(self, env, w, h, grayscale=True, add_channel_dim=False, area_interpolation=False):\n        super(ResizeWrapper, self).__init__(env)\n        self.w = w\n        self.h = h\n        self.grayscale = grayscale",
        "detail": "deps.sample-factory.sample_factory.envs.env_wrappers",
        "documentation": {}
    },
    {
        "label": "GymObs",
        "kind": 5,
        "importPath": "deps.sample-factory.sample_factory.envs.env_wrappers",
        "description": "deps.sample-factory.sample_factory.envs.env_wrappers",
        "peekOfCode": "GymObs = Union[Tuple, Dict[str, Any], np.ndarray, int]\nGymStepReturn = Tuple[GymObs, float, bool, bool, Dict]\n# wrapper from CleanRL / Stable Baselines\nclass NoopResetEnv(gym.Wrapper):\n    \"\"\"\n    Sample initial states by taking random number of no-ops on reset.\n    No-op is assumed to be action 0.\n    :param env: the environment to wrap\n    :param noop_max: the maximum value of no-ops to run\n    \"\"\"",
        "detail": "deps.sample-factory.sample_factory.envs.env_wrappers",
        "documentation": {}
    },
    {
        "label": "GymStepReturn",
        "kind": 5,
        "importPath": "deps.sample-factory.sample_factory.envs.env_wrappers",
        "description": "deps.sample-factory.sample_factory.envs.env_wrappers",
        "peekOfCode": "GymStepReturn = Tuple[GymObs, float, bool, bool, Dict]\n# wrapper from CleanRL / Stable Baselines\nclass NoopResetEnv(gym.Wrapper):\n    \"\"\"\n    Sample initial states by taking random number of no-ops on reset.\n    No-op is assumed to be action 0.\n    :param env: the environment to wrap\n    :param noop_max: the maximum value of no-ops to run\n    \"\"\"\n    def __init__(self, env: gym.Env, noop_max: int = 30):",
        "detail": "deps.sample-factory.sample_factory.envs.env_wrappers",
        "documentation": {}
    },
    {
        "label": "generate_replay_video",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.huggingface.huggingface_utils",
        "description": "deps.sample-factory.sample_factory.huggingface.huggingface_utils",
        "peekOfCode": "def generate_replay_video(dir_path: str, frames: list, fps: int, cfg: Config):\n    video_fname = \"replay.mp4\" if cfg.video_name is None else cfg.video_name\n    if not video_fname.endswith(\".mp4\"):\n        video_fname += \".mp4\"\n    tmp_name = os.path.join(project_tmp_dir(), video_fname)\n    video_name = os.path.join(dir_path, video_fname)\n    if frames[0].shape[0] == 3:\n        frame_size = (frames[0].shape[2], frames[0].shape[1])\n    else:\n        frame_size = (frames[0].shape[1], frames[0].shape[0])",
        "detail": "deps.sample-factory.sample_factory.huggingface.huggingface_utils",
        "documentation": {}
    },
    {
        "label": "generate_model_card",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.huggingface.huggingface_utils",
        "description": "deps.sample-factory.sample_factory.huggingface.huggingface_utils",
        "peekOfCode": "def generate_model_card(\n    dir_path: str,\n    algo: str,\n    env: str,\n    repo_id: str,\n    rewards: list = None,\n    enjoy_name: str = None,\n    train_name: str = None,\n):\n    readme_path = os.path.join(dir_path, \"README.md\")",
        "detail": "deps.sample-factory.sample_factory.huggingface.huggingface_utils",
        "documentation": {}
    },
    {
        "label": "push_to_hf",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.huggingface.huggingface_utils",
        "description": "deps.sample-factory.sample_factory.huggingface.huggingface_utils",
        "peekOfCode": "def push_to_hf(dir_path: str, repo_name: str):\n    repo_url = HfApi().create_repo(\n        repo_id=repo_name,\n        private=False,\n        exist_ok=True,\n    )\n    upload_folder(\n        repo_id=repo_name,\n        folder_path=dir_path,\n        path_in_repo=\".\",",
        "detail": "deps.sample-factory.sample_factory.huggingface.huggingface_utils",
        "documentation": {}
    },
    {
        "label": "load_from_hf",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.huggingface.huggingface_utils",
        "description": "deps.sample-factory.sample_factory.huggingface.huggingface_utils",
        "peekOfCode": "def load_from_hf(dir_path: str, repo_id: str):\n    temp = repo_id.split(\"/\")\n    repo_name = temp[1]\n    local_dir = os.path.join(dir_path, repo_name)\n    Repository(local_dir, repo_id)\n    log.info(f\"The repository {repo_id} has been cloned to {local_dir}\")",
        "detail": "deps.sample-factory.sample_factory.huggingface.huggingface_utils",
        "documentation": {}
    },
    {
        "label": "MIN_FRAME_SIZE",
        "kind": 5,
        "importPath": "deps.sample-factory.sample_factory.huggingface.huggingface_utils",
        "description": "deps.sample-factory.sample_factory.huggingface.huggingface_utils",
        "peekOfCode": "MIN_FRAME_SIZE = 180\ndef generate_replay_video(dir_path: str, frames: list, fps: int, cfg: Config):\n    video_fname = \"replay.mp4\" if cfg.video_name is None else cfg.video_name\n    if not video_fname.endswith(\".mp4\"):\n        video_fname += \".mp4\"\n    tmp_name = os.path.join(project_tmp_dir(), video_fname)\n    video_name = os.path.join(dir_path, video_fname)\n    if frames[0].shape[0] == 3:\n        frame_size = (frames[0].shape[2], frames[0].shape[1])\n    else:",
        "detail": "deps.sample-factory.sample_factory.huggingface.huggingface_utils",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.huggingface.load_from_hub",
        "description": "deps.sample-factory.sample_factory.huggingface.load_from_hub",
        "peekOfCode": "def main():\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\n        \"-r\",\n        \"--hf_repository\",\n        help=\"Repo id of the model repository from the Hugging Face Hub in the form user_name/repo_name\",\n        type=str,\n    )\n    parser.add_argument(\n        \"-d\",",
        "detail": "deps.sample-factory.sample_factory.huggingface.load_from_hub",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.huggingface.push_to_hub",
        "description": "deps.sample-factory.sample_factory.huggingface.push_to_hub",
        "peekOfCode": "def main():\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\n        \"-r\",\n        \"--hf_repository\",\n        help=\"The full repo_id to push to on the HuggingFace Hub. Must be of the form <username>/<repo_name>\",\n        type=str,\n    )\n    parser.add_argument(\"-d\", \"--experiment_dir\", help=\"Path to your experiment directory\", type=str)\n    parser.add_argument(",
        "detail": "deps.sample-factory.sample_factory.huggingface.push_to_hub",
        "documentation": {}
    },
    {
        "label": "seeds",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.launcher.launcher_utils",
        "description": "deps.sample-factory.sample_factory.launcher.launcher_utils",
        "peekOfCode": "def seeds(num_seeds: int) -> List[int]:\n    return [random.randrange(1000000, 9999999) for _ in range(num_seeds)]",
        "detail": "deps.sample-factory.sample_factory.launcher.launcher_utils",
        "documentation": {}
    },
    {
        "label": "launcher_argparser",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.launcher.run",
        "description": "deps.sample-factory.sample_factory.launcher.run",
        "peekOfCode": "def launcher_argparser(args) -> argparse.ArgumentParser:\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"--train_dir\", default=\"./train_dir\", type=str, help=\"Directory for sub-experiments\")\n    parser.add_argument(\n        \"--run\",\n        default=None,\n        type=str,\n        help=\"Name of the python module that describes the run, e.g. sf_examples.vizdoom.experiments.paper_doom_all_basic_envs.py \"\n        \"Run module must be importable in your Python environment. It must define a global variable RUN_DESCRIPTION (see existing run modules for examples).\",\n    )",
        "detail": "deps.sample-factory.sample_factory.launcher.run",
        "documentation": {}
    },
    {
        "label": "parse_args",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.launcher.run",
        "description": "deps.sample-factory.sample_factory.launcher.run",
        "peekOfCode": "def parse_args() -> Config:\n    args = launcher_argparser(sys.argv[1:]).parse_args(sys.argv[1:])\n    return args\ndef main():\n    launcher_cfg = parse_args()\n    try:\n        # assuming we're given the full name of the module\n        run_module = importlib.import_module(f\"{launcher_cfg.run}\")\n    except ImportError as exc:\n        log.error(f\"Could not import the run module {exc}\")",
        "detail": "deps.sample-factory.sample_factory.launcher.run",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.launcher.run",
        "description": "deps.sample-factory.sample_factory.launcher.run",
        "peekOfCode": "def main():\n    launcher_cfg = parse_args()\n    try:\n        # assuming we're given the full name of the module\n        run_module = importlib.import_module(f\"{launcher_cfg.run}\")\n    except ImportError as exc:\n        log.error(f\"Could not import the run module {exc}\")\n        return ExperimentStatus.FAILURE\n    run_description = run_module.RUN_DESCRIPTION\n    run_description.experiment_suffix = launcher_cfg.experiment_suffix",
        "detail": "deps.sample-factory.sample_factory.launcher.run",
        "documentation": {}
    },
    {
        "label": "ParamGenerator",
        "kind": 6,
        "importPath": "deps.sample-factory.sample_factory.launcher.run_description",
        "description": "deps.sample-factory.sample_factory.launcher.run_description",
        "peekOfCode": "class ParamGenerator:\n    def __init__(self):\n        pass\n    def generate_params(self, randomize=True):\n        \"\"\"Supposed to be a generator (so should yield dicts of parameters).\"\"\"\n        pass\nclass ParamList(ParamGenerator):\n    \"\"\"The most simple kind of generator, represents just the list of parameter combinations.\"\"\"\n    def __init__(self, combinations):\n        super(ParamList, self).__init__()",
        "detail": "deps.sample-factory.sample_factory.launcher.run_description",
        "documentation": {}
    },
    {
        "label": "ParamList",
        "kind": 6,
        "importPath": "deps.sample-factory.sample_factory.launcher.run_description",
        "description": "deps.sample-factory.sample_factory.launcher.run_description",
        "peekOfCode": "class ParamList(ParamGenerator):\n    \"\"\"The most simple kind of generator, represents just the list of parameter combinations.\"\"\"\n    def __init__(self, combinations):\n        super(ParamList, self).__init__()\n        self.combinations = combinations\n    def generate_params(self, randomize=True):\n        if randomize:\n            combinations = np.random.permutation(self.combinations)\n        else:\n            combinations = self.combinations",
        "detail": "deps.sample-factory.sample_factory.launcher.run_description",
        "documentation": {}
    },
    {
        "label": "ParamGrid",
        "kind": 6,
        "importPath": "deps.sample-factory.sample_factory.launcher.run_description",
        "description": "deps.sample-factory.sample_factory.launcher.run_description",
        "peekOfCode": "class ParamGrid(ParamGenerator):\n    \"\"\"Parameter generator for grid search.\"\"\"\n    def __init__(self, grid_tuples):\n        \"\"\"Uses OrderedDict, so must be initialized with the list of tuples if you want to preserve order.\"\"\"\n        super(ParamGrid, self).__init__()\n        self.grid = OrderedDict(grid_tuples)\n    def _generate_combinations(self, param_idx, params):\n        \"\"\"Recursively generate all parameter combinations in a grid.\"\"\"\n        if param_idx == len(self.grid) - 1:\n            # last parameter, just return list of values for this parameter",
        "detail": "deps.sample-factory.sample_factory.launcher.run_description",
        "documentation": {}
    },
    {
        "label": "Experiment",
        "kind": 6,
        "importPath": "deps.sample-factory.sample_factory.launcher.run_description",
        "description": "deps.sample-factory.sample_factory.launcher.run_description",
        "peekOfCode": "class Experiment:\n    def __init__(self, name, cmd, param_generator=(), env_vars=None):\n        \"\"\"\n        :param cmd: base command to append the parameters to\n        :param param_generator: iterable of parameter dicts\n        \"\"\"\n        self.base_name = name\n        self.cmd = cmd\n        self.params = list(param_generator)\n        self.env_vars = env_vars",
        "detail": "deps.sample-factory.sample_factory.launcher.run_description",
        "documentation": {}
    },
    {
        "label": "RunDescription",
        "kind": 6,
        "importPath": "deps.sample-factory.sample_factory.launcher.run_description",
        "description": "deps.sample-factory.sample_factory.launcher.run_description",
        "peekOfCode": "class RunDescription:\n    def __init__(\n        self,\n        run_name,\n        experiments,\n        experiment_arg_name=\"--experiment\",\n        experiment_dir_arg_name=\"--train_dir\",\n        customize_experiment_name=True,\n        param_prefix=\"--\",\n    ):",
        "detail": "deps.sample-factory.sample_factory.launcher.run_description",
        "documentation": {}
    },
    {
        "label": "add_ngc_args",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.launcher.run_ngc",
        "description": "deps.sample-factory.sample_factory.launcher.run_ngc",
        "peekOfCode": "def add_ngc_args(parser):\n    parser.add_argument(\n        \"--ngc_job_template\",\n        default=None,\n        type=str,\n        help=\"NGC command line template, specifying instance type, docker container, etc.\",\n    )\n    parser.add_argument(\n        \"--ngc_print_only\", default=False, type=str2bool, help=\"Just print commands to the console without executing\"\n    )",
        "detail": "deps.sample-factory.sample_factory.launcher.run_ngc",
        "documentation": {}
    },
    {
        "label": "run_ngc",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.launcher.run_ngc",
        "description": "deps.sample-factory.sample_factory.launcher.run_ngc",
        "peekOfCode": "def run_ngc(run_description, args):\n    pause_between = args.pause_between\n    experiments = run_description.experiments\n    log.info(\"Starting processes with base cmds: %r\", [e.cmd for e in experiments])\n    if args.ngc_job_template is not None:\n        with open(args.ngc_job_template, \"r\") as template_file:\n            ngc_template = template_file.read()\n    ngc_template = ngc_template.replace(\"\\\\\", \" \")\n    ngc_template = \" \".join(ngc_template.split())\n    log.info(\"NGC template: %s\", ngc_template)",
        "detail": "deps.sample-factory.sample_factory.launcher.run_ngc",
        "documentation": {}
    },
    {
        "label": "add_os_parallelism_args",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.launcher.run_processes",
        "description": "deps.sample-factory.sample_factory.launcher.run_processes",
        "peekOfCode": "def add_os_parallelism_args(parser: argparse.ArgumentParser) -> argparse.ArgumentParser:\n    parser.add_argument(\"--num_gpus\", default=1, type=int, help=\"How many local GPUs to use\")\n    parser.add_argument(\"--max_parallel\", default=4, type=int, help=\"Maximum simultaneous experiments\")\n    parser.add_argument(\n        \"--experiments_per_gpu\",\n        default=-1,\n        type=int,\n        help=\"How many experiments can we squeeze on a single GPU. \"\n        \"Specify this option if and only if you are using launcher to run several experiments using OS-level\"\n        \"parallelism (--backend=processes).\"",
        "detail": "deps.sample-factory.sample_factory.launcher.run_processes",
        "documentation": {}
    },
    {
        "label": "run",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.launcher.run_processes",
        "description": "deps.sample-factory.sample_factory.launcher.run_processes",
        "peekOfCode": "def run(run_description, args):\n    experiments = run_description.experiments\n    max_parallel = args.max_parallel\n    log.info(\"Starting processes with base cmds: %r\", [e.cmd for e in experiments])\n    log.info(\"Max parallel processes is %d\", max_parallel)\n    log.info(\"Monitor log files using\\n\\n\\ttail -f train_dir/%s/**/**/sf_log.txt\\n\\n\", run_description.run_name)\n    processes = []\n    processes_per_gpu = {g: [] for g in range(args.num_gpus)}\n    experiments = run_description.generate_experiments(args.train_dir)\n    next_experiment = next(experiments, None)",
        "detail": "deps.sample-factory.sample_factory.launcher.run_processes",
        "documentation": {}
    },
    {
        "label": "add_slurm_args",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.launcher.run_slurm",
        "description": "deps.sample-factory.sample_factory.launcher.run_slurm",
        "peekOfCode": "def add_slurm_args(parser):\n    parser.add_argument(\"--slurm_gpus_per_job\", default=1, type=int, help=\"GPUs in a single SLURM process\")\n    parser.add_argument(\n        \"--slurm_cpus_per_gpu\", default=14, type=int, help=\"Max allowed number of CPU cores per allocated GPU\"\n    )\n    parser.add_argument(\n        \"--slurm_print_only\", default=False, type=str2bool, help=\"Just print commands to the console without executing\"\n    )\n    parser.add_argument(\n        \"--slurm_workdir\",",
        "detail": "deps.sample-factory.sample_factory.launcher.run_slurm",
        "documentation": {}
    },
    {
        "label": "run_slurm",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.launcher.run_slurm",
        "description": "deps.sample-factory.sample_factory.launcher.run_slurm",
        "peekOfCode": "def run_slurm(run_description, args):\n    workdir = args.slurm_workdir\n    pause_between = args.pause_between\n    experiments = run_description.experiments\n    log.info(\"Starting processes with base cmds: %r\", [e.cmd for e in experiments])\n    if not os.path.exists(workdir):\n        log.info(\"Creating %s...\", workdir)\n        os.makedirs(workdir)\n    if args.slurm_sbatch_template is not None:\n        with open(args.slurm_sbatch_template, \"r\") as template_file:",
        "detail": "deps.sample-factory.sample_factory.launcher.run_slurm",
        "documentation": {}
    },
    {
        "label": "SBATCH_TEMPLATE_DEFAULT",
        "kind": 5,
        "importPath": "deps.sample-factory.sample_factory.launcher.run_slurm",
        "description": "deps.sample-factory.sample_factory.launcher.run_slurm",
        "peekOfCode": "SBATCH_TEMPLATE_DEFAULT = (\n    \"#!/bin/bash\\n\"\n    # \"source /homes/petrenko/miniconda3/etc/profile.d/conda.sh\\n\"\n    \"conda activate sf2\\n\"\n    \"cd ~/sample-factory\\n\"\n)\ndef add_slurm_args(parser):\n    parser.add_argument(\"--slurm_gpus_per_job\", default=1, type=int, help=\"GPUs in a single SLURM process\")\n    parser.add_argument(\n        \"--slurm_cpus_per_gpu\", default=14, type=int, help=\"Max allowed number of CPU cores per allocated GPU\"",
        "detail": "deps.sample-factory.sample_factory.launcher.run_slurm",
        "documentation": {}
    },
    {
        "label": "ActionsParameterization",
        "kind": 6,
        "importPath": "deps.sample-factory.sample_factory.model.action_parameterization",
        "description": "deps.sample-factory.sample_factory.model.action_parameterization",
        "peekOfCode": "class ActionsParameterization(nn.Module):\n    def __init__(self, cfg, action_space):\n        super().__init__()\n        self.cfg = cfg\n        self.action_space = action_space\nclass ActionParameterizationDefault(ActionsParameterization):\n    \"\"\"\n    A single fully-connected layer to output all parameters of the action distribution. Suitable for\n    categorical action distributions, as well as continuous actions with learned state-dependent stddev.\n    \"\"\"",
        "detail": "deps.sample-factory.sample_factory.model.action_parameterization",
        "documentation": {}
    },
    {
        "label": "ActionParameterizationDefault",
        "kind": 6,
        "importPath": "deps.sample-factory.sample_factory.model.action_parameterization",
        "description": "deps.sample-factory.sample_factory.model.action_parameterization",
        "peekOfCode": "class ActionParameterizationDefault(ActionsParameterization):\n    \"\"\"\n    A single fully-connected layer to output all parameters of the action distribution. Suitable for\n    categorical action distributions, as well as continuous actions with learned state-dependent stddev.\n    \"\"\"\n    def __init__(self, cfg, core_out_size, action_space):\n        super().__init__(cfg, action_space)\n        num_action_outputs = calc_num_action_parameters(action_space)\n        self.distribution_linear = nn.Linear(core_out_size, num_action_outputs)\n    def forward(self, actor_core_output):",
        "detail": "deps.sample-factory.sample_factory.model.action_parameterization",
        "documentation": {}
    },
    {
        "label": "ActionParameterizationContinuousNonAdaptiveStddev",
        "kind": 6,
        "importPath": "deps.sample-factory.sample_factory.model.action_parameterization",
        "description": "deps.sample-factory.sample_factory.model.action_parameterization",
        "peekOfCode": "class ActionParameterizationContinuousNonAdaptiveStddev(ActionsParameterization):\n    \"\"\"Use a single learned parameter for action stddevs.\"\"\"\n    def __init__(self, cfg, core_out_size, action_space):\n        super().__init__(cfg, action_space)\n        assert not cfg.adaptive_stddev\n        assert is_continuous_action_space(\n            self.action_space\n        ), \"Non-adaptive stddev makes sense only for continuous action spaces\"\n        num_action_outputs = calc_num_action_parameters(action_space)\n        # calculate only action means using the policy neural network",
        "detail": "deps.sample-factory.sample_factory.model.action_parameterization",
        "documentation": {}
    },
    {
        "label": "ActorCritic",
        "kind": 6,
        "importPath": "deps.sample-factory.sample_factory.model.actor_critic",
        "description": "deps.sample-factory.sample_factory.model.actor_critic",
        "peekOfCode": "class ActorCritic(nn.Module, Configurable):\n    def __init__(self, obs_space: ObsSpace, action_space: ActionSpace, cfg: Config):\n        nn.Module.__init__(self)\n        Configurable.__init__(self, cfg)\n        self.action_space = action_space\n        self.encoders = []\n        # we make normalizers a part of the model, so we can use the same infrastructure\n        # to load/save the state of the normalizer (running mean and stddev statistics)\n        self.obs_normalizer: ObservationNormalizer = ObservationNormalizer(obs_space, cfg)\n        self.returns_normalizer: Optional[RunningMeanStdInPlace] = None",
        "detail": "deps.sample-factory.sample_factory.model.actor_critic",
        "documentation": {}
    },
    {
        "label": "ActorCriticSharedWeights",
        "kind": 6,
        "importPath": "deps.sample-factory.sample_factory.model.actor_critic",
        "description": "deps.sample-factory.sample_factory.model.actor_critic",
        "peekOfCode": "class ActorCriticSharedWeights(ActorCritic):\n    def __init__(\n        self,\n        model_factory,\n        obs_space: ObsSpace,\n        action_space: ActionSpace,\n        cfg: Config,\n    ):\n        super().__init__(obs_space, action_space, cfg)\n        # in case of shared weights we're using only a single encoder and a single core",
        "detail": "deps.sample-factory.sample_factory.model.actor_critic",
        "documentation": {}
    },
    {
        "label": "ActorCriticSeparateWeights",
        "kind": 6,
        "importPath": "deps.sample-factory.sample_factory.model.actor_critic",
        "description": "deps.sample-factory.sample_factory.model.actor_critic",
        "peekOfCode": "class ActorCriticSeparateWeights(ActorCritic):\n    def __init__(\n        self,\n        model_factory,\n        obs_space: ObsSpace,\n        action_space: ActionSpace,\n        cfg: Config,\n    ):\n        super().__init__(obs_space, action_space, cfg)\n        self.actor_encoder = model_factory.make_model_encoder_func(cfg, obs_space)",
        "detail": "deps.sample-factory.sample_factory.model.actor_critic",
        "documentation": {}
    },
    {
        "label": "default_make_actor_critic_func",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.model.actor_critic",
        "description": "deps.sample-factory.sample_factory.model.actor_critic",
        "peekOfCode": "def default_make_actor_critic_func(cfg: Config, obs_space: ObsSpace, action_space: ActionSpace) -> ActorCritic:\n    from sample_factory.algo.utils.context import global_model_factory\n    model_factory = global_model_factory()\n    if cfg.actor_critic_share_weights:\n        return ActorCriticSharedWeights(model_factory, obs_space, action_space, cfg)\n    else:\n        return ActorCriticSeparateWeights(model_factory, obs_space, action_space, cfg)\ndef create_actor_critic(cfg: Config, obs_space: ObsSpace, action_space: ActionSpace) -> ActorCritic:\n    # check if user specified custom actor/critic creation function\n    from sample_factory.algo.utils.context import global_model_factory",
        "detail": "deps.sample-factory.sample_factory.model.actor_critic",
        "documentation": {}
    },
    {
        "label": "create_actor_critic",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.model.actor_critic",
        "description": "deps.sample-factory.sample_factory.model.actor_critic",
        "peekOfCode": "def create_actor_critic(cfg: Config, obs_space: ObsSpace, action_space: ActionSpace) -> ActorCritic:\n    # check if user specified custom actor/critic creation function\n    from sample_factory.algo.utils.context import global_model_factory\n    make_actor_critic_func = global_model_factory().make_actor_critic_func\n    return make_actor_critic_func(cfg, obs_space, action_space)",
        "detail": "deps.sample-factory.sample_factory.model.actor_critic",
        "documentation": {}
    },
    {
        "label": "ModelCore",
        "kind": 6,
        "importPath": "deps.sample-factory.sample_factory.model.core",
        "description": "deps.sample-factory.sample_factory.model.core",
        "peekOfCode": "class ModelCore(ModelModule, ABC):\n    def __init__(self, cfg: Config):\n        super().__init__(cfg)\n        self.core_output_size = -1  # to be overridden in derived classes\n    def get_out_size(self) -> int:\n        return self.core_output_size\nclass ModelCoreRNN(ModelCore):\n    def __init__(self, cfg, input_size):\n        super().__init__(cfg)\n        self.cfg = cfg",
        "detail": "deps.sample-factory.sample_factory.model.core",
        "documentation": {}
    },
    {
        "label": "ModelCoreRNN",
        "kind": 6,
        "importPath": "deps.sample-factory.sample_factory.model.core",
        "description": "deps.sample-factory.sample_factory.model.core",
        "peekOfCode": "class ModelCoreRNN(ModelCore):\n    def __init__(self, cfg, input_size):\n        super().__init__(cfg)\n        self.cfg = cfg\n        self.is_gru = False\n        if cfg.rnn_type == \"gru\":\n            self.core = nn.GRU(input_size, cfg.rnn_size, cfg.rnn_num_layers)\n            self.is_gru = True\n        elif cfg.rnn_type == \"lstm\":\n            self.core = nn.LSTM(input_size, cfg.rnn_size, cfg.rnn_num_layers)",
        "detail": "deps.sample-factory.sample_factory.model.core",
        "documentation": {}
    },
    {
        "label": "ModelCoreIdentity",
        "kind": 6,
        "importPath": "deps.sample-factory.sample_factory.model.core",
        "description": "deps.sample-factory.sample_factory.model.core",
        "peekOfCode": "class ModelCoreIdentity(ModelCore):\n    \"\"\"A noop core (no recurrency).\"\"\"\n    def __init__(self, cfg, input_size):\n        super().__init__(cfg)\n        self.cfg = cfg\n        self.core_output_size = input_size\n    # noinspection PyMethodMayBeStatic\n    def forward(self, head_output, fake_rnn_states):\n        return head_output, fake_rnn_states\ndef default_make_core_func(cfg: Config, core_input_size: int) -> ModelCore:",
        "detail": "deps.sample-factory.sample_factory.model.core",
        "documentation": {}
    },
    {
        "label": "default_make_core_func",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.model.core",
        "description": "deps.sample-factory.sample_factory.model.core",
        "peekOfCode": "def default_make_core_func(cfg: Config, core_input_size: int) -> ModelCore:\n    if cfg.use_rnn:\n        core = ModelCoreRNN(cfg, core_input_size)\n    else:\n        core = ModelCoreIdentity(cfg, core_input_size)\n    return core",
        "detail": "deps.sample-factory.sample_factory.model.core",
        "documentation": {}
    },
    {
        "label": "Decoder",
        "kind": 6,
        "importPath": "deps.sample-factory.sample_factory.model.decoder",
        "description": "deps.sample-factory.sample_factory.model.decoder",
        "peekOfCode": "class Decoder(ModelModule, ABC):\n    pass\nclass MlpDecoder(Decoder):\n    def __init__(self, cfg: Config, decoder_input_size: int):\n        super().__init__(cfg)\n        self.core_input_size = decoder_input_size\n        decoder_layers: List[int] = cfg.decoder_mlp_layers\n        activation = nonlinearity(cfg)\n        self.mlp = create_mlp(decoder_layers, decoder_input_size, activation)\n        if len(decoder_layers) > 0:",
        "detail": "deps.sample-factory.sample_factory.model.decoder",
        "documentation": {}
    },
    {
        "label": "MlpDecoder",
        "kind": 6,
        "importPath": "deps.sample-factory.sample_factory.model.decoder",
        "description": "deps.sample-factory.sample_factory.model.decoder",
        "peekOfCode": "class MlpDecoder(Decoder):\n    def __init__(self, cfg: Config, decoder_input_size: int):\n        super().__init__(cfg)\n        self.core_input_size = decoder_input_size\n        decoder_layers: List[int] = cfg.decoder_mlp_layers\n        activation = nonlinearity(cfg)\n        self.mlp = create_mlp(decoder_layers, decoder_input_size, activation)\n        if len(decoder_layers) > 0:\n            self.mlp = torch.jit.script(self.mlp)\n        self.decoder_out_size = calc_num_elements(self.mlp, (decoder_input_size,))",
        "detail": "deps.sample-factory.sample_factory.model.decoder",
        "documentation": {}
    },
    {
        "label": "default_make_decoder_func",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.model.decoder",
        "description": "deps.sample-factory.sample_factory.model.decoder",
        "peekOfCode": "def default_make_decoder_func(cfg: Config, core_input_size: int) -> Decoder:\n    return MlpDecoder(cfg, core_input_size)",
        "detail": "deps.sample-factory.sample_factory.model.decoder",
        "documentation": {}
    },
    {
        "label": "Encoder",
        "kind": 6,
        "importPath": "deps.sample-factory.sample_factory.model.encoder",
        "description": "deps.sample-factory.sample_factory.model.encoder",
        "peekOfCode": "class Encoder(ModelModule):\n    def __init__(self, cfg: Config):\n        super().__init__(cfg)\n    def get_out_size(self) -> int:\n        raise NotImplementedError()\n    def model_to_device(self, device):\n        \"\"\"Default implementation, can be overridden in derived classes.\"\"\"\n        self.to(device)\n    def device_for_input_tensor(self, input_tensor_name: str) -> Optional[torch.device]:\n        return model_device(self)",
        "detail": "deps.sample-factory.sample_factory.model.encoder",
        "documentation": {}
    },
    {
        "label": "MultiInputEncoder",
        "kind": 6,
        "importPath": "deps.sample-factory.sample_factory.model.encoder",
        "description": "deps.sample-factory.sample_factory.model.encoder",
        "peekOfCode": "class MultiInputEncoder(Encoder):\n    def __init__(self, cfg: Config, obs_space: ObsSpace):\n        super().__init__(cfg)\n        self.obs_keys = list(sorted(obs_space.keys()))  # always the same order\n        self.encoders = nn.ModuleDict()\n        out_size = 0\n        for obs_key in self.obs_keys:\n            shape = obs_space[obs_key].shape\n            if len(shape) == 1:\n                encoder_fn = MlpEncoder",
        "detail": "deps.sample-factory.sample_factory.model.encoder",
        "documentation": {}
    },
    {
        "label": "MlpEncoder",
        "kind": 6,
        "importPath": "deps.sample-factory.sample_factory.model.encoder",
        "description": "deps.sample-factory.sample_factory.model.encoder",
        "peekOfCode": "class MlpEncoder(Encoder):\n    def __init__(self, cfg: Config, obs_space: ObsSpace):\n        super().__init__(cfg)\n        mlp_layers: List[int] = cfg.encoder_mlp_layers\n        self.mlp_head = create_mlp(mlp_layers, obs_space.shape[0], nonlinearity(cfg))\n        if len(mlp_layers) > 0:\n            self.mlp_head = torch.jit.script(self.mlp_head)\n        self.encoder_out_size = calc_num_elements(self.mlp_head, obs_space.shape)\n    def forward(self, obs: Tensor):\n        x = self.mlp_head(obs)",
        "detail": "deps.sample-factory.sample_factory.model.encoder",
        "documentation": {}
    },
    {
        "label": "ConvEncoderImpl",
        "kind": 6,
        "importPath": "deps.sample-factory.sample_factory.model.encoder",
        "description": "deps.sample-factory.sample_factory.model.encoder",
        "peekOfCode": "class ConvEncoderImpl(nn.Module):\n    \"\"\"\n    After we parse all the configuration and figure out the exact architecture of the model,\n    we devote a separate module to it to be able to use torch.jit.script (hopefully benefit from some layer\n    fusion).\n    \"\"\"\n    def __init__(self, obs_shape: AttrDict, conv_filters: List, extra_mlp_layers: List[int], activation: nn.Module):\n        super().__init__()\n        conv_layers = []\n        for layer in conv_filters:",
        "detail": "deps.sample-factory.sample_factory.model.encoder",
        "documentation": {}
    },
    {
        "label": "ConvEncoder",
        "kind": 6,
        "importPath": "deps.sample-factory.sample_factory.model.encoder",
        "description": "deps.sample-factory.sample_factory.model.encoder",
        "peekOfCode": "class ConvEncoder(Encoder):\n    def __init__(self, cfg: Config, obs_space: ObsSpace):\n        super().__init__(cfg)\n        input_channels = obs_space.shape[0]\n        log.debug(f\"{ConvEncoder.__name__}: {input_channels=}\")\n        if cfg.encoder_conv_architecture == \"convnet_simple\":\n            conv_filters = [[input_channels, 32, 8, 4], [32, 64, 4, 2], [64, 128, 3, 2]]\n        elif cfg.encoder_conv_architecture == \"convnet_impala\":\n            conv_filters = [[input_channels, 16, 8, 4], [16, 32, 4, 2]]\n        elif cfg.encoder_conv_architecture == \"convnet_atari\":",
        "detail": "deps.sample-factory.sample_factory.model.encoder",
        "documentation": {}
    },
    {
        "label": "ResBlock",
        "kind": 6,
        "importPath": "deps.sample-factory.sample_factory.model.encoder",
        "description": "deps.sample-factory.sample_factory.model.encoder",
        "peekOfCode": "class ResBlock(nn.Module):\n    def __init__(self, cfg, input_ch, output_ch):\n        super().__init__()\n        layers = [\n            nonlinearity(cfg),\n            nn.Conv2d(input_ch, output_ch, kernel_size=3, stride=1, padding=1),  # padding SAME\n            nonlinearity(cfg),\n            nn.Conv2d(output_ch, output_ch, kernel_size=3, stride=1, padding=1),  # padding SAME\n        ]\n        self.res_block_core = nn.Sequential(*layers)",
        "detail": "deps.sample-factory.sample_factory.model.encoder",
        "documentation": {}
    },
    {
        "label": "ResnetEncoder",
        "kind": 6,
        "importPath": "deps.sample-factory.sample_factory.model.encoder",
        "description": "deps.sample-factory.sample_factory.model.encoder",
        "peekOfCode": "class ResnetEncoder(Encoder):\n    def __init__(self, cfg, obs_space):\n        super().__init__(cfg)\n        input_ch = obs_space.shape[0]\n        log.debug(\"Num input channels: %d\", input_ch)\n        if cfg.encoder_conv_architecture == \"resnet_impala\":\n            # configuration from the IMPALA paper\n            resnet_conf = [[16, 2], [32, 2], [32, 2]]\n        else:\n            raise NotImplementedError(f\"Unknown resnet architecture {cfg.encode_conv_architecture}\")",
        "detail": "deps.sample-factory.sample_factory.model.encoder",
        "documentation": {}
    },
    {
        "label": "make_img_encoder",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.model.encoder",
        "description": "deps.sample-factory.sample_factory.model.encoder",
        "peekOfCode": "def make_img_encoder(cfg: Config, obs_space: ObsSpace) -> Encoder:\n    \"\"\"Make (most likely convolutional) encoder for image-based observations.\"\"\"\n    if cfg.encoder_conv_architecture.startswith(\"convnet\"):\n        return ConvEncoder(cfg, obs_space)\n    elif cfg.encoder_conv_architecture.startswith(\"resnet\"):\n        return ResnetEncoder(cfg, obs_space)\n    else:\n        raise NotImplementedError(f\"Unknown convolutional architecture {cfg.encoder_conv_architecture}\")\ndef default_make_encoder_func(cfg: Config, obs_space: ObsSpace) -> Encoder:\n    \"\"\"",
        "detail": "deps.sample-factory.sample_factory.model.encoder",
        "documentation": {}
    },
    {
        "label": "default_make_encoder_func",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.model.encoder",
        "description": "deps.sample-factory.sample_factory.model.encoder",
        "peekOfCode": "def default_make_encoder_func(cfg: Config, obs_space: ObsSpace) -> Encoder:\n    \"\"\"\n    Analyze the observation space and create either a convolutional or an MLP encoder depending on\n    whether this is an image-based environment or environment with vector observations.\n    \"\"\"\n    # we only support dict observation spaces - envs with non-dict obs spaces use a wrapper\n    # main subspace used to determine the encoder type is called \"obs\". For envs with multiple subspaces,\n    # this function needs to be overridden (see vizdoom or dmlab encoders for example)\n    return MultiInputEncoder(cfg, obs_space)",
        "detail": "deps.sample-factory.sample_factory.model.encoder",
        "documentation": {}
    },
    {
        "label": "ModelFactory",
        "kind": 6,
        "importPath": "deps.sample-factory.sample_factory.model.model_factory",
        "description": "deps.sample-factory.sample_factory.model.model_factory",
        "peekOfCode": "class ModelFactory:\n    def __init__(self):\n        \"\"\"\n        Optional custom functions for creating parts of the model (encoders, decoders, etc.), or\n        even overriding the entire actor-critic with a custom model.\n        \"\"\"\n        self.make_actor_critic_func: MakeActorCriticFunc = default_make_actor_critic_func\n        # callables user can specify to generate parts of the policy\n        # the computational graph structure is:\n        # observations -> encoder -> core -> decoder -> actions",
        "detail": "deps.sample-factory.sample_factory.model.model_factory",
        "documentation": {}
    },
    {
        "label": "MakeActorCriticFunc",
        "kind": 5,
        "importPath": "deps.sample-factory.sample_factory.model.model_factory",
        "description": "deps.sample-factory.sample_factory.model.model_factory",
        "peekOfCode": "MakeActorCriticFunc = Callable[[Config, ObsSpace, ActionSpace], ActorCritic]\nMakeEncoderFunc = Callable[[Config, ObsSpace], Encoder]\nMakeCoreFunc = Callable[[Config, int], ModelCore]\nMakeDecoderFunc = Callable[[Config, int], Decoder]\nclass ModelFactory:\n    def __init__(self):\n        \"\"\"\n        Optional custom functions for creating parts of the model (encoders, decoders, etc.), or\n        even overriding the entire actor-critic with a custom model.\n        \"\"\"",
        "detail": "deps.sample-factory.sample_factory.model.model_factory",
        "documentation": {}
    },
    {
        "label": "MakeEncoderFunc",
        "kind": 5,
        "importPath": "deps.sample-factory.sample_factory.model.model_factory",
        "description": "deps.sample-factory.sample_factory.model.model_factory",
        "peekOfCode": "MakeEncoderFunc = Callable[[Config, ObsSpace], Encoder]\nMakeCoreFunc = Callable[[Config, int], ModelCore]\nMakeDecoderFunc = Callable[[Config, int], Decoder]\nclass ModelFactory:\n    def __init__(self):\n        \"\"\"\n        Optional custom functions for creating parts of the model (encoders, decoders, etc.), or\n        even overriding the entire actor-critic with a custom model.\n        \"\"\"\n        self.make_actor_critic_func: MakeActorCriticFunc = default_make_actor_critic_func",
        "detail": "deps.sample-factory.sample_factory.model.model_factory",
        "documentation": {}
    },
    {
        "label": "MakeCoreFunc",
        "kind": 5,
        "importPath": "deps.sample-factory.sample_factory.model.model_factory",
        "description": "deps.sample-factory.sample_factory.model.model_factory",
        "peekOfCode": "MakeCoreFunc = Callable[[Config, int], ModelCore]\nMakeDecoderFunc = Callable[[Config, int], Decoder]\nclass ModelFactory:\n    def __init__(self):\n        \"\"\"\n        Optional custom functions for creating parts of the model (encoders, decoders, etc.), or\n        even overriding the entire actor-critic with a custom model.\n        \"\"\"\n        self.make_actor_critic_func: MakeActorCriticFunc = default_make_actor_critic_func\n        # callables user can specify to generate parts of the policy",
        "detail": "deps.sample-factory.sample_factory.model.model_factory",
        "documentation": {}
    },
    {
        "label": "MakeDecoderFunc",
        "kind": 5,
        "importPath": "deps.sample-factory.sample_factory.model.model_factory",
        "description": "deps.sample-factory.sample_factory.model.model_factory",
        "peekOfCode": "MakeDecoderFunc = Callable[[Config, int], Decoder]\nclass ModelFactory:\n    def __init__(self):\n        \"\"\"\n        Optional custom functions for creating parts of the model (encoders, decoders, etc.), or\n        even overriding the entire actor-critic with a custom model.\n        \"\"\"\n        self.make_actor_critic_func: MakeActorCriticFunc = default_make_actor_critic_func\n        # callables user can specify to generate parts of the policy\n        # the computational graph structure is:",
        "detail": "deps.sample-factory.sample_factory.model.model_factory",
        "documentation": {}
    },
    {
        "label": "Mish",
        "kind": 6,
        "importPath": "deps.sample-factory.sample_factory.model.model_utils",
        "description": "deps.sample-factory.sample_factory.model.model_utils",
        "peekOfCode": "class Mish(nn.Module):\n    def forward(self, x):\n        return x * torch.tanh(F.softplus(x))\ndef nonlinearity(cfg: Config, inplace: bool = False) -> nn.Module:\n    if cfg.nonlinearity == \"elu\":\n        return nn.ELU(inplace=inplace)\n    if cfg.nonlinearity == \"mish\":\n        return Mish()\n    elif cfg.nonlinearity == \"relu\":\n        return nn.ReLU(inplace=inplace)",
        "detail": "deps.sample-factory.sample_factory.model.model_utils",
        "documentation": {}
    },
    {
        "label": "ModelModule",
        "kind": 6,
        "importPath": "deps.sample-factory.sample_factory.model.model_utils",
        "description": "deps.sample-factory.sample_factory.model.model_utils",
        "peekOfCode": "class ModelModule(nn.Module, Configurable):\n    def __init__(self, cfg: Config):\n        nn.Module.__init__(self)\n        Configurable.__init__(self, cfg)\n    def get_out_size(self):\n        raise NotImplementedError()\ndef model_device(model: nn.Module) -> Optional[torch.device]:\n    try:\n        return next(model.parameters()).device\n    except StopIteration:",
        "detail": "deps.sample-factory.sample_factory.model.model_utils",
        "documentation": {}
    },
    {
        "label": "get_rnn_size",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.model.model_utils",
        "description": "deps.sample-factory.sample_factory.model.model_utils",
        "peekOfCode": "def get_rnn_size(cfg):\n    if cfg.use_rnn:\n        size = cfg.rnn_size * cfg.rnn_num_layers\n    else:\n        size = 1\n    if cfg.rnn_type == \"lstm\":\n        size *= 2\n    if not cfg.actor_critic_share_weights:\n        # actor and critic need separate states\n        size *= 2",
        "detail": "deps.sample-factory.sample_factory.model.model_utils",
        "documentation": {}
    },
    {
        "label": "nonlinearity",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.model.model_utils",
        "description": "deps.sample-factory.sample_factory.model.model_utils",
        "peekOfCode": "def nonlinearity(cfg: Config, inplace: bool = False) -> nn.Module:\n    if cfg.nonlinearity == \"elu\":\n        return nn.ELU(inplace=inplace)\n    if cfg.nonlinearity == \"mish\":\n        return Mish()\n    elif cfg.nonlinearity == \"relu\":\n        return nn.ReLU(inplace=inplace)\n    elif cfg.nonlinearity == \"tanh\":\n        return nn.Tanh()\n    else:",
        "detail": "deps.sample-factory.sample_factory.model.model_utils",
        "documentation": {}
    },
    {
        "label": "fc_layer",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.model.model_utils",
        "description": "deps.sample-factory.sample_factory.model.model_utils",
        "peekOfCode": "def fc_layer(in_features: int, out_features: int, bias=True, spec_norm=False) -> nn.Module:\n    layer = nn.Linear(in_features, out_features, bias)\n    if spec_norm:\n        layer = spectral_norm(layer)\n    return layer\ndef create_mlp(layer_sizes: List[int], input_size: int, activation: nn.Module) -> nn.Module:\n    \"\"\"Sequential fully connected layers.\"\"\"\n    layers = []\n    for i, size in enumerate(layer_sizes):\n        layers.extend([fc_layer(input_size, size), activation])",
        "detail": "deps.sample-factory.sample_factory.model.model_utils",
        "documentation": {}
    },
    {
        "label": "create_mlp",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.model.model_utils",
        "description": "deps.sample-factory.sample_factory.model.model_utils",
        "peekOfCode": "def create_mlp(layer_sizes: List[int], input_size: int, activation: nn.Module) -> nn.Module:\n    \"\"\"Sequential fully connected layers.\"\"\"\n    layers = []\n    for i, size in enumerate(layer_sizes):\n        layers.extend([fc_layer(input_size, size), activation])\n        input_size = size\n    if len(layers) > 0:\n        return nn.Sequential(*layers)\n    else:\n        return nn.Identity()",
        "detail": "deps.sample-factory.sample_factory.model.model_utils",
        "documentation": {}
    },
    {
        "label": "model_device",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.model.model_utils",
        "description": "deps.sample-factory.sample_factory.model.model_utils",
        "peekOfCode": "def model_device(model: nn.Module) -> Optional[torch.device]:\n    try:\n        return next(model.parameters()).device\n    except StopIteration:\n        return None",
        "detail": "deps.sample-factory.sample_factory.model.model_utils",
        "documentation": {}
    },
    {
        "label": "PopulationBasedTraining",
        "kind": 6,
        "importPath": "deps.sample-factory.sample_factory.pbt.population_based_training",
        "description": "deps.sample-factory.sample_factory.pbt.population_based_training",
        "peekOfCode": "class PopulationBasedTraining(AlgoObserver, EventLoopObject):\n    def __init__(self, cfg: Config, runner: Runner):\n        EventLoopObject.__init__(self, runner.event_loop, \"PBT\")\n        self.cfg: Config = cfg\n        self.env_info: Optional[EnvInfo] = None\n        self.runner: Runner = runner\n        # currently not supported, would require changes on the batcher\n        # if cfg.pbt_optimize_batch_size:\n        #     HYPERPARAMS_TO_TUNE.add(\"batch_size\")\n        if cfg.pbt_optimize_gamma:",
        "detail": "deps.sample-factory.sample_factory.pbt.population_based_training",
        "documentation": {}
    },
    {
        "label": "perturb_float",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.pbt.population_based_training",
        "description": "deps.sample-factory.sample_factory.pbt.population_based_training",
        "peekOfCode": "def perturb_float(x, perturb_amount=1.2):\n    # mutation direction\n    new_value = x / perturb_amount if random.random() < 0.5 else x * perturb_amount\n    return new_value\ndef perturb_vtrace(x, _cfg):\n    return perturb_float(x, perturb_amount=1.005)\ndef perturb_exponential_decay(x, _cfg, perturb_amount_min=1.01, perturb_amount_max=1.2):\n    # very conservative values, things like gamma should not change quickly\n    perturb_amount = random.uniform(perturb_amount_min, perturb_amount_max)\n    perturbed = perturb_float(1.0 - x, perturb_amount=perturb_amount)",
        "detail": "deps.sample-factory.sample_factory.pbt.population_based_training",
        "documentation": {}
    },
    {
        "label": "perturb_vtrace",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.pbt.population_based_training",
        "description": "deps.sample-factory.sample_factory.pbt.population_based_training",
        "peekOfCode": "def perturb_vtrace(x, _cfg):\n    return perturb_float(x, perturb_amount=1.005)\ndef perturb_exponential_decay(x, _cfg, perturb_amount_min=1.01, perturb_amount_max=1.2):\n    # very conservative values, things like gamma should not change quickly\n    perturb_amount = random.uniform(perturb_amount_min, perturb_amount_max)\n    perturbed = perturb_float(1.0 - x, perturb_amount=perturb_amount)\n    new_value = 1.0 - perturbed\n    new_value = max(EPS, new_value)\n    return new_value\ndef perturb_batch_size(x, cfg):",
        "detail": "deps.sample-factory.sample_factory.pbt.population_based_training",
        "documentation": {}
    },
    {
        "label": "perturb_exponential_decay",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.pbt.population_based_training",
        "description": "deps.sample-factory.sample_factory.pbt.population_based_training",
        "peekOfCode": "def perturb_exponential_decay(x, _cfg, perturb_amount_min=1.01, perturb_amount_max=1.2):\n    # very conservative values, things like gamma should not change quickly\n    perturb_amount = random.uniform(perturb_amount_min, perturb_amount_max)\n    perturbed = perturb_float(1.0 - x, perturb_amount=perturb_amount)\n    new_value = 1.0 - perturbed\n    new_value = max(EPS, new_value)\n    return new_value\ndef perturb_batch_size(x, cfg):\n    new_value = perturb_float(x, perturb_amount=1.2)\n    initial_batch_size = cfg.batch_size",
        "detail": "deps.sample-factory.sample_factory.pbt.population_based_training",
        "documentation": {}
    },
    {
        "label": "perturb_batch_size",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.pbt.population_based_training",
        "description": "deps.sample-factory.sample_factory.pbt.population_based_training",
        "peekOfCode": "def perturb_batch_size(x, cfg):\n    new_value = perturb_float(x, perturb_amount=1.2)\n    initial_batch_size = cfg.batch_size\n    max_batch_size = initial_batch_size * 1.5\n    min_batch_size = cfg.rollout\n    new_value = min(new_value, max_batch_size)\n    # round down to whole number of rollouts\n    new_value = (int(new_value) // cfg.rollout) * cfg.rollout\n    new_value = max(new_value, min_batch_size)\n    return new_value",
        "detail": "deps.sample-factory.sample_factory.pbt.population_based_training",
        "documentation": {}
    },
    {
        "label": "policy_cfg_file",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.pbt.population_based_training",
        "description": "deps.sample-factory.sample_factory.pbt.population_based_training",
        "peekOfCode": "def policy_cfg_file(cfg, policy_id):\n    return join(experiment_dir(cfg=cfg), f\"policy_{policy_id:02d}_cfg.json\")\ndef policy_reward_shaping_file(cfg, policy_id):\n    return join(experiment_dir(cfg=cfg), f\"policy_{policy_id:02d}_reward_shaping.json\")\ndef update_cfg_signal(policy_id: PolicyID) -> str:\n    return f\"update_cfg{policy_id}\"\ndef save_model_signal(policy_id: PolicyID) -> str:\n    return f\"save_model{policy_id}\"\ndef load_model_signal(policy_id: PolicyID) -> str:\n    return f\"load_model{policy_id}\"",
        "detail": "deps.sample-factory.sample_factory.pbt.population_based_training",
        "documentation": {}
    },
    {
        "label": "policy_reward_shaping_file",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.pbt.population_based_training",
        "description": "deps.sample-factory.sample_factory.pbt.population_based_training",
        "peekOfCode": "def policy_reward_shaping_file(cfg, policy_id):\n    return join(experiment_dir(cfg=cfg), f\"policy_{policy_id:02d}_reward_shaping.json\")\ndef update_cfg_signal(policy_id: PolicyID) -> str:\n    return f\"update_cfg{policy_id}\"\ndef save_model_signal(policy_id: PolicyID) -> str:\n    return f\"save_model{policy_id}\"\ndef load_model_signal(policy_id: PolicyID) -> str:\n    return f\"load_model{policy_id}\"\nclass PopulationBasedTraining(AlgoObserver, EventLoopObject):\n    def __init__(self, cfg: Config, runner: Runner):",
        "detail": "deps.sample-factory.sample_factory.pbt.population_based_training",
        "documentation": {}
    },
    {
        "label": "update_cfg_signal",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.pbt.population_based_training",
        "description": "deps.sample-factory.sample_factory.pbt.population_based_training",
        "peekOfCode": "def update_cfg_signal(policy_id: PolicyID) -> str:\n    return f\"update_cfg{policy_id}\"\ndef save_model_signal(policy_id: PolicyID) -> str:\n    return f\"save_model{policy_id}\"\ndef load_model_signal(policy_id: PolicyID) -> str:\n    return f\"load_model{policy_id}\"\nclass PopulationBasedTraining(AlgoObserver, EventLoopObject):\n    def __init__(self, cfg: Config, runner: Runner):\n        EventLoopObject.__init__(self, runner.event_loop, \"PBT\")\n        self.cfg: Config = cfg",
        "detail": "deps.sample-factory.sample_factory.pbt.population_based_training",
        "documentation": {}
    },
    {
        "label": "save_model_signal",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.pbt.population_based_training",
        "description": "deps.sample-factory.sample_factory.pbt.population_based_training",
        "peekOfCode": "def save_model_signal(policy_id: PolicyID) -> str:\n    return f\"save_model{policy_id}\"\ndef load_model_signal(policy_id: PolicyID) -> str:\n    return f\"load_model{policy_id}\"\nclass PopulationBasedTraining(AlgoObserver, EventLoopObject):\n    def __init__(self, cfg: Config, runner: Runner):\n        EventLoopObject.__init__(self, runner.event_loop, \"PBT\")\n        self.cfg: Config = cfg\n        self.env_info: Optional[EnvInfo] = None\n        self.runner: Runner = runner",
        "detail": "deps.sample-factory.sample_factory.pbt.population_based_training",
        "documentation": {}
    },
    {
        "label": "load_model_signal",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.pbt.population_based_training",
        "description": "deps.sample-factory.sample_factory.pbt.population_based_training",
        "peekOfCode": "def load_model_signal(policy_id: PolicyID) -> str:\n    return f\"load_model{policy_id}\"\nclass PopulationBasedTraining(AlgoObserver, EventLoopObject):\n    def __init__(self, cfg: Config, runner: Runner):\n        EventLoopObject.__init__(self, runner.event_loop, \"PBT\")\n        self.cfg: Config = cfg\n        self.env_info: Optional[EnvInfo] = None\n        self.runner: Runner = runner\n        # currently not supported, would require changes on the batcher\n        # if cfg.pbt_optimize_batch_size:",
        "detail": "deps.sample-factory.sample_factory.pbt.population_based_training",
        "documentation": {}
    },
    {
        "label": "HYPERPARAMS_TO_TUNE",
        "kind": 5,
        "importPath": "deps.sample-factory.sample_factory.pbt.population_based_training",
        "description": "deps.sample-factory.sample_factory.pbt.population_based_training",
        "peekOfCode": "HYPERPARAMS_TO_TUNE = {\n    \"learning_rate\",\n    \"exploration_loss_coeff\",\n    \"value_loss_coeff\",\n    \"max_grad_norm\",\n    \"ppo_clip_ratio\",\n    \"ppo_clip_value\",\n    # gamma can be added with a CLI parameter (--pbt_optimize_gamma=True)\n}\n# if not specified then tune all rewards",
        "detail": "deps.sample-factory.sample_factory.pbt.population_based_training",
        "documentation": {}
    },
    {
        "label": "REWARD_CATEGORIES_TO_TUNE",
        "kind": 5,
        "importPath": "deps.sample-factory.sample_factory.pbt.population_based_training",
        "description": "deps.sample-factory.sample_factory.pbt.population_based_training",
        "peekOfCode": "REWARD_CATEGORIES_TO_TUNE = {\n    \"doom_\": [\"delta\", \"selected_weapon\"],\n}\n# HYPERPARAMS_TO_TUNE_EXTENDED = {\n#     'learning_rate', 'exploration_loss_coeff', 'value_loss_coeff', 'adam_beta1', 'max_grad_norm',\n#     'ppo_clip_ratio', 'ppo_clip_value', 'vtrace_rho', 'vtrace_c',\n# }\nSPECIAL_PERTURBATION = dict(\n    gamma=perturb_exponential_decay,\n    adam_beta1=perturb_exponential_decay,",
        "detail": "deps.sample-factory.sample_factory.pbt.population_based_training",
        "documentation": {}
    },
    {
        "label": "SPECIAL_PERTURBATION",
        "kind": 5,
        "importPath": "deps.sample-factory.sample_factory.pbt.population_based_training",
        "description": "deps.sample-factory.sample_factory.pbt.population_based_training",
        "peekOfCode": "SPECIAL_PERTURBATION = dict(\n    gamma=perturb_exponential_decay,\n    adam_beta1=perturb_exponential_decay,\n    vtrace_rho=perturb_vtrace,\n    vtrace_c=perturb_vtrace,\n    batch_size=perturb_batch_size,\n)\ndef policy_cfg_file(cfg, policy_id):\n    return join(experiment_dir(cfg=cfg), f\"policy_{policy_id:02d}_cfg.json\")\ndef policy_reward_shaping_file(cfg, policy_id):",
        "detail": "deps.sample-factory.sample_factory.pbt.population_based_training",
        "documentation": {}
    },
    {
        "label": "ALGO_VERSION",
        "kind": 5,
        "importPath": "deps.sample-factory.sample_factory.utils.algo_version",
        "description": "deps.sample-factory.sample_factory.utils.algo_version",
        "peekOfCode": "ALGO_VERSION = 83",
        "detail": "deps.sample-factory.sample_factory.utils.algo_version",
        "documentation": {}
    },
    {
        "label": "AttrDict",
        "kind": 6,
        "importPath": "deps.sample-factory.sample_factory.utils.attr_dict",
        "description": "deps.sample-factory.sample_factory.utils.attr_dict",
        "peekOfCode": "class AttrDict(dict):\n    __setattr__ = dict.__setitem__\n    def __getattribute__(self, item):\n        if item in self:\n            return self[item]\n        else:\n            return super().__getattribute__(item)",
        "detail": "deps.sample-factory.sample_factory.utils.attr_dict",
        "documentation": {}
    },
    {
        "label": "LinearDecay",
        "kind": 6,
        "importPath": "deps.sample-factory.sample_factory.utils.decay",
        "description": "deps.sample-factory.sample_factory.utils.decay",
        "peekOfCode": "class LinearDecay:\n    def __init__(self, milestones, staircase=None):\n        \"\"\"\n        Linear decay of some value according to schedule.\n        See tests for usage sf_examples.\n        :param milestones: list\n        List of tuples (step, desired_value)\n        E.g. [(0, 100), (1000, 50)] means for step <= 0 use value 100, between step 0 and 1000 interpolate the value\n        between 100 and 50, then keep at 50 forever.\n        :param staircase: int",
        "detail": "deps.sample-factory.sample_factory.utils.decay",
        "documentation": {}
    },
    {
        "label": "dict_of_lists_append",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.utils.dicts",
        "description": "deps.sample-factory.sample_factory.utils.dicts",
        "peekOfCode": "def dict_of_lists_append(d: Dict[Any, List], new_data):\n    for key, x in new_data.items():\n        if key in d:\n            d[key].append(x)\n        else:\n            d[key] = [x]\ndef dict_of_lists_append_idx(d: Dict[Any, List], new_data, index):\n    for key, x in new_data.items():\n        if key in d:\n            d[key].append(x[index])",
        "detail": "deps.sample-factory.sample_factory.utils.dicts",
        "documentation": {}
    },
    {
        "label": "dict_of_lists_append_idx",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.utils.dicts",
        "description": "deps.sample-factory.sample_factory.utils.dicts",
        "peekOfCode": "def dict_of_lists_append_idx(d: Dict[Any, List], new_data, index):\n    for key, x in new_data.items():\n        if key in d:\n            d[key].append(x[index])\n        else:\n            d[key] = [x[index]]\ndef iterate_recursively(d):\n    \"\"\"\n    Generator for a dictionary that can potentially include other dictionaries.\n    Yields tuples of (dict, key, value), where key, value are \"leaf\" elements of the \"dict\".",
        "detail": "deps.sample-factory.sample_factory.utils.dicts",
        "documentation": {}
    },
    {
        "label": "iterate_recursively",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.utils.dicts",
        "description": "deps.sample-factory.sample_factory.utils.dicts",
        "peekOfCode": "def iterate_recursively(d):\n    \"\"\"\n    Generator for a dictionary that can potentially include other dictionaries.\n    Yields tuples of (dict, key, value), where key, value are \"leaf\" elements of the \"dict\".\n    \"\"\"\n    for k, v in d.items():\n        if isinstance(v, (dict, OrderedDict)):\n            yield from iterate_recursively(v)\n        else:\n            yield d, k, v",
        "detail": "deps.sample-factory.sample_factory.utils.dicts",
        "documentation": {}
    },
    {
        "label": "iterate_recursively_with_prefix",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.utils.dicts",
        "description": "deps.sample-factory.sample_factory.utils.dicts",
        "peekOfCode": "def iterate_recursively_with_prefix(d: Dict, prefix=None):\n    \"\"\"\n    Generator for a dictionary that can potentially include other dictionaries.\n    Yields tuples of (dict, key, value, prefix), where key, value are \"leaf\" elements of the \"dict\" and prefix is a\n    list of keys that lead to the current element (exluding the current key).\n    \"\"\"\n    if prefix is None:\n        prefix = []\n    for k, v in d.items():\n        if isinstance(v, (dict, OrderedDict)):",
        "detail": "deps.sample-factory.sample_factory.utils.dicts",
        "documentation": {}
    },
    {
        "label": "copy_dict_structure",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.utils.dicts",
        "description": "deps.sample-factory.sample_factory.utils.dicts",
        "peekOfCode": "def copy_dict_structure(d):\n    \"\"\"Copy dictionary layout without copying the actual values (populated with Nones).\"\"\"\n    d_copy = type(d)()\n    _copy_dict_structure_func(d, d_copy)\n    return d_copy\ndef _copy_dict_structure_func(d, d_copy):\n    for key, value in d.items():\n        if isinstance(value, (dict, OrderedDict)):\n            d_copy[key] = type(value)()\n            _copy_dict_structure_func(value, d_copy[key])",
        "detail": "deps.sample-factory.sample_factory.utils.dicts",
        "documentation": {}
    },
    {
        "label": "iter_dicts_recursively",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.utils.dicts",
        "description": "deps.sample-factory.sample_factory.utils.dicts",
        "peekOfCode": "def iter_dicts_recursively(d1, d2):\n    \"\"\"\n    Assuming structure of d1 is strictly included into d2.\n    I.e. each key at each recursion level is also present in d2. This is also true when d1 and d2 have the same\n    structure.\n    \"\"\"\n    for k, v in d1.items():\n        assert k in d2\n        if isinstance(v, (dict, OrderedDict)):\n            yield from iter_dicts_recursively(d1[k], d2[k])",
        "detail": "deps.sample-factory.sample_factory.utils.dicts",
        "documentation": {}
    },
    {
        "label": "list_of_dicts_to_dict_of_lists",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.utils.dicts",
        "description": "deps.sample-factory.sample_factory.utils.dicts",
        "peekOfCode": "def list_of_dicts_to_dict_of_lists(list_of_dicts: List[Dict]) -> Dict[Any, List]:\n    if not list_of_dicts:\n        return dict()\n    res = copy_dict_structure(list_of_dicts[0])\n    for d in list_of_dicts:\n        for d1, d2, key, v1, v2 in iter_dicts_recursively(d, res):\n            if v2 is None:\n                d2[key] = [v1]\n            else:\n                d2[key].append(v1)",
        "detail": "deps.sample-factory.sample_factory.utils.dicts",
        "documentation": {}
    },
    {
        "label": "get_first_present",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.utils.dicts",
        "description": "deps.sample-factory.sample_factory.utils.dicts",
        "peekOfCode": "def get_first_present(d: Dict, keys: Iterable, default: Optional[Any] = None) -> Optional[Any]:\n    for key in keys:\n        if key in d:\n            return d[key]\n    return default",
        "detail": "deps.sample-factory.sample_factory.utils.dicts",
        "documentation": {}
    },
    {
        "label": "get_gpus_without_triggering_pytorch_cuda_initialization",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.utils.get_available_gpus",
        "description": "deps.sample-factory.sample_factory.utils.get_available_gpus",
        "peekOfCode": "def get_gpus_without_triggering_pytorch_cuda_initialization(envvars=None):\n    if envvars is None:\n        envvars = os.environ\n    import subprocess\n    out = subprocess.run(\n        [sys.executable, \"-m\", \"sample_factory.utils.get_available_gpus\"], capture_output=True, env=envvars\n    )\n    text_output = out.stdout.decode()\n    err_output = out.stderr.decode()\n    returncode = out.returncode",
        "detail": "deps.sample-factory.sample_factory.utils.get_available_gpus",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.utils.get_available_gpus",
        "description": "deps.sample-factory.sample_factory.utils.get_available_gpus",
        "peekOfCode": "def main():\n    import torch\n    device_count = torch.cuda.device_count()\n    available_gpus = \",\".join(str(g) for g in range(device_count))\n    print(available_gpus)\n    return 0\nif __name__ == \"__main__\":\n    sys.exit(main())",
        "detail": "deps.sample-factory.sample_factory.utils.get_available_gpus",
        "documentation": {}
    },
    {
        "label": "encode_gif",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.utils.gifs",
        "description": "deps.sample-factory.sample_factory.utils.gifs",
        "peekOfCode": "def encode_gif(images, fps):\n    if len(images[0].shape) == 3:\n        h, w, c = images[0].shape\n    else:\n        h, w = images[0].shape\n        c = 1\n    cmd = [\n        \"ffmpeg\",\n        \"-y\",\n        \"-f\",",
        "detail": "deps.sample-factory.sample_factory.utils.gifs",
        "documentation": {}
    },
    {
        "label": "set_global_cuda_envvars",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.utils.gpu_utils",
        "description": "deps.sample-factory.sample_factory.utils.gpu_utils",
        "peekOfCode": "def set_global_cuda_envvars(cfg):\n    if CUDA_ENVVAR not in os.environ:\n        if cfg.device == \"cpu\":\n            available_gpus = \"\"\n        else:\n            available_gpus = get_gpus_without_triggering_pytorch_cuda_initialization(os.environ)\n        os.environ[CUDA_ENVVAR] = available_gpus\n    log.info(f\"Environment var {CUDA_ENVVAR} is {os.environ[CUDA_ENVVAR]}\")\ndef get_available_gpus() -> List[int]:\n    \"\"\"",
        "detail": "deps.sample-factory.sample_factory.utils.gpu_utils",
        "documentation": {}
    },
    {
        "label": "get_available_gpus",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.utils.gpu_utils",
        "description": "deps.sample-factory.sample_factory.utils.gpu_utils",
        "peekOfCode": "def get_available_gpus() -> List[int]:\n    \"\"\"\n    Returns indices of GPUs specified by CUDA_VISIBLE_DEVICES.\n    \"\"\"\n    orig_visible_devices = os.environ[f\"{CUDA_ENVVAR}\"]\n    available_gpus = [int(g.strip()) for g in orig_visible_devices.split(\",\") if g and not g.isspace()]\n    return available_gpus\ndef gpus_for_process(process_idx: int, num_gpus_per_process: int, gpu_mask: Optional[List[int]] = None) -> List[int]:\n    \"\"\"\n    Returns indices of GPUs to use for a process. These indices already respect the CUDA_VISIBLE_DEVICES envvar.",
        "detail": "deps.sample-factory.sample_factory.utils.gpu_utils",
        "documentation": {}
    },
    {
        "label": "gpus_for_process",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.utils.gpu_utils",
        "description": "deps.sample-factory.sample_factory.utils.gpu_utils",
        "peekOfCode": "def gpus_for_process(process_idx: int, num_gpus_per_process: int, gpu_mask: Optional[List[int]] = None) -> List[int]:\n    \"\"\"\n    Returns indices of GPUs to use for a process. These indices already respect the CUDA_VISIBLE_DEVICES envvar.\n    I.e. if CUDA_VISIBLE_DEVICES is '1,2,3', then from torch's there are three visible GPUs\n    with indices 0, 1, and 2.\n    Therefore, in this case gpus_for_process(0, 1) returns [0], gpus_for_process(1, 1) returns [1], etc.\n    \"\"\"\n    available_gpus = get_available_gpus()\n    if gpu_mask is not None:\n        assert len(available_gpus) >= len(",
        "detail": "deps.sample-factory.sample_factory.utils.gpu_utils",
        "documentation": {}
    },
    {
        "label": "set_gpus_for_process",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.utils.gpu_utils",
        "description": "deps.sample-factory.sample_factory.utils.gpu_utils",
        "peekOfCode": "def set_gpus_for_process(process_idx, num_gpus_per_process, process_type, gpu_mask=None):\n    # in this function we want to limit the number of GPUs visible to the process, i.e. if\n    # CUDA_VISIBLE_DEVICES is '1,2,3' and we want to use GPU index 2, then we want to set\n    # CUDA_VISIBLE_DEVICES to '3' for this process\n    gpus_to_use = gpus_for_process(process_idx, num_gpus_per_process, gpu_mask)\n    if not gpus_to_use:\n        os.environ[CUDA_ENVVAR] = \"\"\n        log.debug(\"Not using GPUs for %s process %d\", process_type, process_idx)\n    else:\n        available_gpus = get_available_gpus()",
        "detail": "deps.sample-factory.sample_factory.utils.gpu_utils",
        "documentation": {}
    },
    {
        "label": "cuda_envvars_for_policy",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.utils.gpu_utils",
        "description": "deps.sample-factory.sample_factory.utils.gpu_utils",
        "peekOfCode": "def cuda_envvars_for_policy(policy_id, process_type):\n    set_gpus_for_process(policy_id, 1, process_type)",
        "detail": "deps.sample-factory.sample_factory.utils.gpu_utils",
        "documentation": {}
    },
    {
        "label": "CUDA_ENVVAR",
        "kind": 5,
        "importPath": "deps.sample-factory.sample_factory.utils.gpu_utils",
        "description": "deps.sample-factory.sample_factory.utils.gpu_utils",
        "peekOfCode": "CUDA_ENVVAR = \"CUDA_VISIBLE_DEVICES\"\ndef set_global_cuda_envvars(cfg):\n    if CUDA_ENVVAR not in os.environ:\n        if cfg.device == \"cpu\":\n            available_gpus = \"\"\n        else:\n            available_gpus = get_gpus_without_triggering_pytorch_cuda_initialization(os.environ)\n        os.environ[CUDA_ENVVAR] = available_gpus\n    log.info(f\"Environment var {CUDA_ENVVAR} is {os.environ[CUDA_ENVVAR]}\")\ndef get_available_gpus() -> List[int]:",
        "detail": "deps.sample-factory.sample_factory.utils.gpu_utils",
        "documentation": {}
    },
    {
        "label": "is_udp_port_available",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.utils.network",
        "description": "deps.sample-factory.sample_factory.utils.network",
        "peekOfCode": "def is_udp_port_available(port):\n    try:\n        sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n        sock.bind((\"\", port))\n        sock.close()\n    except OSError as exc:\n        log.warning(f\"UDP port {port} cannot be used {str(exc)}\")\n        return False\n    else:\n        return True",
        "detail": "deps.sample-factory.sample_factory.utils.network",
        "documentation": {}
    },
    {
        "label": "ObservationNormalizer",
        "kind": 6,
        "importPath": "deps.sample-factory.sample_factory.utils.normalize",
        "description": "deps.sample-factory.sample_factory.utils.normalize",
        "peekOfCode": "class ObservationNormalizer(nn.Module):\n    def __init__(self, obs_space, cfg):\n        super().__init__()\n        self.sub_mean = cfg.obs_subtract_mean\n        self.scale = cfg.obs_scale\n        self.running_mean_std = None\n        if cfg.normalize_input:\n            self.running_mean_std = RunningMeanStdDictInPlace(obs_space, cfg.normalize_input_keys)\n        self.should_sub_mean = abs(self.sub_mean) > EPS\n        self.should_scale = abs(self.scale - 1.0) > EPS",
        "detail": "deps.sample-factory.sample_factory.utils.normalize",
        "documentation": {}
    },
    {
        "label": "tb_version",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.utils.tb",
        "description": "deps.sample-factory.sample_factory.utils.tb",
        "peekOfCode": "def tb_version():\n    tb_version_proc = subprocess.Popen([\"tensorboard\", \"--version\"], stdout=subprocess.PIPE)\n    proc_output = tb_version_proc.communicate()\n    version_str = None\n    for line in proc_output:\n        if line is not None:\n            line = str(line.decode(\"utf-8\")).rstrip().lstrip()\n            if \".\" in line:\n                version_str = line\n    major, minor, *rest = version_str.split(\".\")",
        "detail": "deps.sample-factory.sample_factory.utils.tb",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.utils.tb",
        "description": "deps.sample-factory.sample_factory.utils.tb",
        "peekOfCode": "def main():\n    parser = argparse.ArgumentParser(description=r\"Launch tensorboard on multiple directories in an easy way.\")\n    parser.add_argument(\"--dir\", default=\"./train_dir\", help=\"Base folder with summaries\")\n    parser.add_argument(\"--port\", default=6006, type=int, help=\"The port to use for tensorboard\")\n    parser.add_argument(\"--quiet\", \"-q\", action=\"store_true\", help=\"Run in silent mode\")\n    parser.add_argument(\n        \"--refresh_every\",\n        \"-r\",\n        dest=\"refresh\",\n        type=int,",
        "detail": "deps.sample-factory.sample_factory.utils.tb",
        "documentation": {}
    },
    {
        "label": "AvgTime",
        "kind": 6,
        "importPath": "deps.sample-factory.sample_factory.utils.timing",
        "description": "deps.sample-factory.sample_factory.utils.timing",
        "peekOfCode": "class AvgTime:\n    def __init__(self, num_values_to_avg):\n        self.values = deque([], maxlen=num_values_to_avg)\n    def __str__(self):\n        avg_time = sum(self.values) / max(1, len(self.values))\n        return f\"{avg_time:.4f}\"\n@dataclass\nclass TimingTreeNode:\n    self_time: Union[float, AvgTime] = 0\n    timing: typing.OrderedDict[str, Any] = dataclasses.field(default_factory=collections.OrderedDict)",
        "detail": "deps.sample-factory.sample_factory.utils.timing",
        "documentation": {}
    },
    {
        "label": "TimingTreeNode",
        "kind": 6,
        "importPath": "deps.sample-factory.sample_factory.utils.timing",
        "description": "deps.sample-factory.sample_factory.utils.timing",
        "peekOfCode": "class TimingTreeNode:\n    self_time: Union[float, AvgTime] = 0\n    timing: typing.OrderedDict[str, Any] = dataclasses.field(default_factory=collections.OrderedDict)\n# noinspection PyProtectedMember\nclass TimingContext:\n    def __init__(self, timing, key: str, additive=False, average=None):\n        super().__init__()\n        self.timing_tree_node: Optional[TimingTreeNode] = None\n        self._timing = timing\n        self._key = key",
        "detail": "deps.sample-factory.sample_factory.utils.timing",
        "documentation": {}
    },
    {
        "label": "TimingContext",
        "kind": 6,
        "importPath": "deps.sample-factory.sample_factory.utils.timing",
        "description": "deps.sample-factory.sample_factory.utils.timing",
        "peekOfCode": "class TimingContext:\n    def __init__(self, timing, key: str, additive=False, average=None):\n        super().__init__()\n        self.timing_tree_node: Optional[TimingTreeNode] = None\n        self._timing = timing\n        self._key = key\n        self._additive = additive\n        self._average = average\n        self._time_enter = None\n        self._time = 0",
        "detail": "deps.sample-factory.sample_factory.utils.timing",
        "documentation": {}
    },
    {
        "label": "Timing",
        "kind": 6,
        "importPath": "deps.sample-factory.sample_factory.utils.timing",
        "description": "deps.sample-factory.sample_factory.utils.timing",
        "peekOfCode": "class Timing(AttrDict):\n    def __init__(self, name=\"Profile\", *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self._name = name\n        self._root_context = TimingContext(self, \"~\")\n        self._root_context.set_tree_node(TimingTreeNode())\n        self._open_contexts_stack = [self._root_context]\n    def _push_context(self, ctx):\n        self._open_contexts_stack.append(ctx)\n        return ctx",
        "detail": "deps.sample-factory.sample_factory.utils.timing",
        "documentation": {}
    },
    {
        "label": "init_global_profiler",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.utils.timing",
        "description": "deps.sample-factory.sample_factory.utils.timing",
        "peekOfCode": "def init_global_profiler(t):\n    \"\"\"This is for debugging purposes. Normally prefer to pass it around.\"\"\"\n    global TIMING\n    log.info(\"Setting global profiler in process %r\", psutil.Process())\n    TIMING = t",
        "detail": "deps.sample-factory.sample_factory.utils.timing",
        "documentation": {}
    },
    {
        "label": "Config",
        "kind": 5,
        "importPath": "deps.sample-factory.sample_factory.utils.typing",
        "description": "deps.sample-factory.sample_factory.utils.typing",
        "peekOfCode": "Config = Union[argparse.Namespace, AttrDict]\nStatusCode = int\nPolicyID = int\nDevice = str\n# these can be fake wrapper classes if we're in serial mode, so using Any\nMpQueue = Any\nMpLock = Any\nEnv = Any\nObsSpace = Union[spaces.Space, spaces.Dict]\nActionSpace = spaces.Space",
        "detail": "deps.sample-factory.sample_factory.utils.typing",
        "documentation": {}
    },
    {
        "label": "StatusCode",
        "kind": 5,
        "importPath": "deps.sample-factory.sample_factory.utils.typing",
        "description": "deps.sample-factory.sample_factory.utils.typing",
        "peekOfCode": "StatusCode = int\nPolicyID = int\nDevice = str\n# these can be fake wrapper classes if we're in serial mode, so using Any\nMpQueue = Any\nMpLock = Any\nEnv = Any\nObsSpace = Union[spaces.Space, spaces.Dict]\nActionSpace = spaces.Space\nCreateEnvFunc = Callable[[str, Optional[Config], Optional[AttrDict], Optional[str]], Env]",
        "detail": "deps.sample-factory.sample_factory.utils.typing",
        "documentation": {}
    },
    {
        "label": "PolicyID",
        "kind": 5,
        "importPath": "deps.sample-factory.sample_factory.utils.typing",
        "description": "deps.sample-factory.sample_factory.utils.typing",
        "peekOfCode": "PolicyID = int\nDevice = str\n# these can be fake wrapper classes if we're in serial mode, so using Any\nMpQueue = Any\nMpLock = Any\nEnv = Any\nObsSpace = Union[spaces.Space, spaces.Dict]\nActionSpace = spaces.Space\nCreateEnvFunc = Callable[[str, Optional[Config], Optional[AttrDict], Optional[str]], Env]\n# there currenly isn't a single class all distributions derive from, but we gotta use something for the type hint",
        "detail": "deps.sample-factory.sample_factory.utils.typing",
        "documentation": {}
    },
    {
        "label": "Device",
        "kind": 5,
        "importPath": "deps.sample-factory.sample_factory.utils.typing",
        "description": "deps.sample-factory.sample_factory.utils.typing",
        "peekOfCode": "Device = str\n# these can be fake wrapper classes if we're in serial mode, so using Any\nMpQueue = Any\nMpLock = Any\nEnv = Any\nObsSpace = Union[spaces.Space, spaces.Dict]\nActionSpace = spaces.Space\nCreateEnvFunc = Callable[[str, Optional[Config], Optional[AttrDict], Optional[str]], Env]\n# there currenly isn't a single class all distributions derive from, but we gotta use something for the type hint\nActionDistribution = Any",
        "detail": "deps.sample-factory.sample_factory.utils.typing",
        "documentation": {}
    },
    {
        "label": "MpQueue",
        "kind": 5,
        "importPath": "deps.sample-factory.sample_factory.utils.typing",
        "description": "deps.sample-factory.sample_factory.utils.typing",
        "peekOfCode": "MpQueue = Any\nMpLock = Any\nEnv = Any\nObsSpace = Union[spaces.Space, spaces.Dict]\nActionSpace = spaces.Space\nCreateEnvFunc = Callable[[str, Optional[Config], Optional[AttrDict], Optional[str]], Env]\n# there currenly isn't a single class all distributions derive from, but we gotta use something for the type hint\nActionDistribution = Any\nInitModelData = Tuple[PolicyID, Dict, torch.device, int]",
        "detail": "deps.sample-factory.sample_factory.utils.typing",
        "documentation": {}
    },
    {
        "label": "MpLock",
        "kind": 5,
        "importPath": "deps.sample-factory.sample_factory.utils.typing",
        "description": "deps.sample-factory.sample_factory.utils.typing",
        "peekOfCode": "MpLock = Any\nEnv = Any\nObsSpace = Union[spaces.Space, spaces.Dict]\nActionSpace = spaces.Space\nCreateEnvFunc = Callable[[str, Optional[Config], Optional[AttrDict], Optional[str]], Env]\n# there currenly isn't a single class all distributions derive from, but we gotta use something for the type hint\nActionDistribution = Any\nInitModelData = Tuple[PolicyID, Dict, torch.device, int]",
        "detail": "deps.sample-factory.sample_factory.utils.typing",
        "documentation": {}
    },
    {
        "label": "Env",
        "kind": 5,
        "importPath": "deps.sample-factory.sample_factory.utils.typing",
        "description": "deps.sample-factory.sample_factory.utils.typing",
        "peekOfCode": "Env = Any\nObsSpace = Union[spaces.Space, spaces.Dict]\nActionSpace = spaces.Space\nCreateEnvFunc = Callable[[str, Optional[Config], Optional[AttrDict], Optional[str]], Env]\n# there currenly isn't a single class all distributions derive from, but we gotta use something for the type hint\nActionDistribution = Any\nInitModelData = Tuple[PolicyID, Dict, torch.device, int]",
        "detail": "deps.sample-factory.sample_factory.utils.typing",
        "documentation": {}
    },
    {
        "label": "ObsSpace",
        "kind": 5,
        "importPath": "deps.sample-factory.sample_factory.utils.typing",
        "description": "deps.sample-factory.sample_factory.utils.typing",
        "peekOfCode": "ObsSpace = Union[spaces.Space, spaces.Dict]\nActionSpace = spaces.Space\nCreateEnvFunc = Callable[[str, Optional[Config], Optional[AttrDict], Optional[str]], Env]\n# there currenly isn't a single class all distributions derive from, but we gotta use something for the type hint\nActionDistribution = Any\nInitModelData = Tuple[PolicyID, Dict, torch.device, int]",
        "detail": "deps.sample-factory.sample_factory.utils.typing",
        "documentation": {}
    },
    {
        "label": "ActionSpace",
        "kind": 5,
        "importPath": "deps.sample-factory.sample_factory.utils.typing",
        "description": "deps.sample-factory.sample_factory.utils.typing",
        "peekOfCode": "ActionSpace = spaces.Space\nCreateEnvFunc = Callable[[str, Optional[Config], Optional[AttrDict], Optional[str]], Env]\n# there currenly isn't a single class all distributions derive from, but we gotta use something for the type hint\nActionDistribution = Any\nInitModelData = Tuple[PolicyID, Dict, torch.device, int]",
        "detail": "deps.sample-factory.sample_factory.utils.typing",
        "documentation": {}
    },
    {
        "label": "CreateEnvFunc",
        "kind": 5,
        "importPath": "deps.sample-factory.sample_factory.utils.typing",
        "description": "deps.sample-factory.sample_factory.utils.typing",
        "peekOfCode": "CreateEnvFunc = Callable[[str, Optional[Config], Optional[AttrDict], Optional[str]], Env]\n# there currenly isn't a single class all distributions derive from, but we gotta use something for the type hint\nActionDistribution = Any\nInitModelData = Tuple[PolicyID, Dict, torch.device, int]",
        "detail": "deps.sample-factory.sample_factory.utils.typing",
        "documentation": {}
    },
    {
        "label": "ActionDistribution",
        "kind": 5,
        "importPath": "deps.sample-factory.sample_factory.utils.typing",
        "description": "deps.sample-factory.sample_factory.utils.typing",
        "peekOfCode": "ActionDistribution = Any\nInitModelData = Tuple[PolicyID, Dict, torch.device, int]",
        "detail": "deps.sample-factory.sample_factory.utils.typing",
        "documentation": {}
    },
    {
        "label": "InitModelData",
        "kind": 5,
        "importPath": "deps.sample-factory.sample_factory.utils.typing",
        "description": "deps.sample-factory.sample_factory.utils.typing",
        "peekOfCode": "InitModelData = Tuple[PolicyID, Dict, torch.device, int]",
        "detail": "deps.sample-factory.sample_factory.utils.typing",
        "documentation": {}
    },
    {
        "label": "has_file_handler",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.utils.utils",
        "description": "deps.sample-factory.sample_factory.utils.utils",
        "peekOfCode": "def has_file_handler() -> bool:\n    for handler in log.handlers:\n        if isinstance(handler, logging.FileHandler):\n            return True\n    return False\ndef init_file_logger(cfg: Config) -> None:\n    if not cfg.log_to_file:\n        return\n    if has_file_handler():\n        return",
        "detail": "deps.sample-factory.sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "init_file_logger",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.utils.utils",
        "description": "deps.sample-factory.sample_factory.utils.utils",
        "peekOfCode": "def init_file_logger(cfg: Config) -> None:\n    if not cfg.log_to_file:\n        return\n    if has_file_handler():\n        return\n    experiment_dir_ = experiment_dir(cfg)\n    file_handler = logging.FileHandler(join(experiment_dir_, \"sf_log.txt\"))\n    file_handler.setLevel(log_level)\n    file_formatter = logging.Formatter(fmt=\"[%(asctime)s][%(process)05d] %(message)s\", datefmt=None, style=\"%\")\n    file_handler.setFormatter(file_formatter)",
        "detail": "deps.sample-factory.sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "is_module_available",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.utils.utils",
        "description": "deps.sample-factory.sample_factory.utils.utils",
        "peekOfCode": "def is_module_available(module_name):\n    try:\n        importlib.import_module(module_name)\n        return True\n    except ImportError:\n        return False\ndef set_attr_if_exists(obj, attr_name, attr_value):\n    if hasattr(obj, attr_name):\n        setattr(obj, attr_name, attr_value)\ndef scale_to_range(np_array, min_, max_):",
        "detail": "deps.sample-factory.sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "set_attr_if_exists",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.utils.utils",
        "description": "deps.sample-factory.sample_factory.utils.utils",
        "peekOfCode": "def set_attr_if_exists(obj, attr_name, attr_value):\n    if hasattr(obj, attr_name):\n        setattr(obj, attr_name, attr_value)\ndef scale_to_range(np_array, min_, max_):\n    min_arr = np.min(np_array)\n    max_arr = np.max(np_array)\n    ret_array = (np_array - min_arr) / (max_arr - min_arr)  # scale to (0,1)\n    ret_array = ret_array * (max_ - min_) + min_  # scale to (min, max)\n    return ret_array\ndef op_with_idx(x, op):",
        "detail": "deps.sample-factory.sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "scale_to_range",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.utils.utils",
        "description": "deps.sample-factory.sample_factory.utils.utils",
        "peekOfCode": "def scale_to_range(np_array, min_, max_):\n    min_arr = np.min(np_array)\n    max_arr = np.max(np_array)\n    ret_array = (np_array - min_arr) / (max_arr - min_arr)  # scale to (0,1)\n    ret_array = ret_array * (max_ - min_) + min_  # scale to (min, max)\n    return ret_array\ndef op_with_idx(x, op):\n    assert len(x) > 0\n    best_idx = 0\n    best_x = x[best_idx]",
        "detail": "deps.sample-factory.sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "op_with_idx",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.utils.utils",
        "description": "deps.sample-factory.sample_factory.utils.utils",
        "peekOfCode": "def op_with_idx(x, op):\n    assert len(x) > 0\n    best_idx = 0\n    best_x = x[best_idx]\n    for i, item in enumerate(x):\n        if op(item, best_x):\n            best_x = item\n            best_idx = i\n    return best_x, best_idx\ndef min_with_idx(x):",
        "detail": "deps.sample-factory.sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "min_with_idx",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.utils.utils",
        "description": "deps.sample-factory.sample_factory.utils.utils",
        "peekOfCode": "def min_with_idx(x):\n    return op_with_idx(x, operator.lt)\ndef max_with_idx(x):\n    return op_with_idx(x, operator.gt)\ndef static_vars(**kwargs):\n    def decorate(func):\n        for k in kwargs:\n            setattr(func, k, kwargs[k])\n        return func\n    return decorate",
        "detail": "deps.sample-factory.sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "max_with_idx",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.utils.utils",
        "description": "deps.sample-factory.sample_factory.utils.utils",
        "peekOfCode": "def max_with_idx(x):\n    return op_with_idx(x, operator.gt)\ndef static_vars(**kwargs):\n    def decorate(func):\n        for k in kwargs:\n            setattr(func, k, kwargs[k])\n        return func\n    return decorate\ndef safe_get(q, timeout=1e6, msg=\"Queue timeout\"):\n    \"\"\"Using queue.get() with timeout is necessary, otherwise KeyboardInterrupt is not handled.\"\"\"",
        "detail": "deps.sample-factory.sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "static_vars",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.utils.utils",
        "description": "deps.sample-factory.sample_factory.utils.utils",
        "peekOfCode": "def static_vars(**kwargs):\n    def decorate(func):\n        for k in kwargs:\n            setattr(func, k, kwargs[k])\n        return func\n    return decorate\ndef safe_get(q, timeout=1e6, msg=\"Queue timeout\"):\n    \"\"\"Using queue.get() with timeout is necessary, otherwise KeyboardInterrupt is not handled.\"\"\"\n    while True:\n        try:",
        "detail": "deps.sample-factory.sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "safe_get",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.utils.utils",
        "description": "deps.sample-factory.sample_factory.utils.utils",
        "peekOfCode": "def safe_get(q, timeout=1e6, msg=\"Queue timeout\"):\n    \"\"\"Using queue.get() with timeout is necessary, otherwise KeyboardInterrupt is not handled.\"\"\"\n    while True:\n        try:\n            return q.get(timeout=timeout)\n        except Empty:\n            log.info(\"Queue timed out (%s), timeout %.3f\", msg, timeout)\ndef safe_put(q, msg, attempts=3, queue_name=\"\"):\n    safe_put_many(q, [msg], attempts, queue_name)\ndef safe_put_many(q, msgs, attempts=3, queue_name=\"\"):",
        "detail": "deps.sample-factory.sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "safe_put",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.utils.utils",
        "description": "deps.sample-factory.sample_factory.utils.utils",
        "peekOfCode": "def safe_put(q, msg, attempts=3, queue_name=\"\"):\n    safe_put_many(q, [msg], attempts, queue_name)\ndef safe_put_many(q, msgs, attempts=3, queue_name=\"\"):\n    for attempt in range(attempts):\n        try:\n            q.put_many(msgs)\n            return\n        except Full:\n            log.warning(\"Could not put msgs to queue, the queue %s is full! Attempt %d\", queue_name, attempt)\n    log.error(\"Failed to put msgs to queue %s after %d attempts. Messages are lost!\", queue_name, attempts)",
        "detail": "deps.sample-factory.sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "safe_put_many",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.utils.utils",
        "description": "deps.sample-factory.sample_factory.utils.utils",
        "peekOfCode": "def safe_put_many(q, msgs, attempts=3, queue_name=\"\"):\n    for attempt in range(attempts):\n        try:\n            q.put_many(msgs)\n            return\n        except Full:\n            log.warning(\"Could not put msgs to queue, the queue %s is full! Attempt %d\", queue_name, attempt)\n    log.error(\"Failed to put msgs to queue %s after %d attempts. Messages are lost!\", queue_name, attempts)\ndef retry(times, exceptions):\n    \"\"\"",
        "detail": "deps.sample-factory.sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "retry",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.utils.utils",
        "description": "deps.sample-factory.sample_factory.utils.utils",
        "peekOfCode": "def retry(times, exceptions):\n    \"\"\"\n    Retry Decorator https://stackoverflow.com/a/64030200/1645784\n    Retries the wrapped function/method `times` times if the exceptions listed\n    in ``exceptions`` are thrown\n    :param times: The number of times to repeat the wrapped function/method\n    :type times: Int\n    :param exceptions: Lists of exceptions that trigger a retry attempt\n    :type exceptions: Tuple of Exceptions\n    \"\"\"",
        "detail": "deps.sample-factory.sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "str2bool",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.utils.utils",
        "description": "deps.sample-factory.sample_factory.utils.utils",
        "peekOfCode": "def str2bool(v):\n    if isinstance(v, bool):\n        return v\n    if isinstance(v, str) and v.lower() in (\"true\",):\n        return True\n    elif isinstance(v, str) and v.lower() in (\"false\",):\n        return False\n    else:\n        raise argparse.ArgumentTypeError(\"Boolean value expected\")\n# numpy stuff",
        "detail": "deps.sample-factory.sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "numpy_all_the_way",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.utils.utils",
        "description": "deps.sample-factory.sample_factory.utils.utils",
        "peekOfCode": "def numpy_all_the_way(list_of_arrays):\n    \"\"\"Turn a list of numpy arrays into a 2D numpy array.\"\"\"\n    shape = list(list_of_arrays[0].shape)\n    shape[:0] = [len(list_of_arrays)]\n    arr = np.concatenate(list_of_arrays).reshape(shape)\n    return arr\ndef numpy_flatten(list_of_arrays):\n    \"\"\"Turn a list of numpy arrays into a 1D numpy array (flattened).\"\"\"\n    return np.concatenate(list_of_arrays, axis=0)\ndef ensure_contigious(x):",
        "detail": "deps.sample-factory.sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "numpy_flatten",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.utils.utils",
        "description": "deps.sample-factory.sample_factory.utils.utils",
        "peekOfCode": "def numpy_flatten(list_of_arrays):\n    \"\"\"Turn a list of numpy arrays into a 1D numpy array (flattened).\"\"\"\n    return np.concatenate(list_of_arrays, axis=0)\ndef ensure_contigious(x):\n    if not x.flags[\"C_CONTIGUOUS\"]:\n        x = np.ascontiguousarray(x)\n    return x\n# matplotlib\ndef figure_to_numpy(figure):\n    \"\"\"",
        "detail": "deps.sample-factory.sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "ensure_contigious",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.utils.utils",
        "description": "deps.sample-factory.sample_factory.utils.utils",
        "peekOfCode": "def ensure_contigious(x):\n    if not x.flags[\"C_CONTIGUOUS\"]:\n        x = np.ascontiguousarray(x)\n    return x\n# matplotlib\ndef figure_to_numpy(figure):\n    \"\"\"\n    @brief Convert a Matplotlib figure to a 4D numpy array with RGBA channels and return it\n    @param figure a matplotlib figure\n    @return a numpy 3D array of RGBA values",
        "detail": "deps.sample-factory.sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "figure_to_numpy",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.utils.utils",
        "description": "deps.sample-factory.sample_factory.utils.utils",
        "peekOfCode": "def figure_to_numpy(figure):\n    \"\"\"\n    @brief Convert a Matplotlib figure to a 4D numpy array with RGBA channels and return it\n    @param figure a matplotlib figure\n    @return a numpy 3D array of RGBA values\n    \"\"\"\n    # draw the renderer\n    figure.canvas.draw()\n    # Get the RGBA buffer from the figure\n    w, h = figure.canvas.get_width_height()",
        "detail": "deps.sample-factory.sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "get_free_disk_space_mb",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.utils.utils",
        "description": "deps.sample-factory.sample_factory.utils.utils",
        "peekOfCode": "def get_free_disk_space_mb(cfg):\n    statvfs = os.statvfs(experiments_dir(cfg))\n    return statvfs.f_frsize * statvfs.f_bfree / (1024 * 1024)\ndef memory_consumption_mb():\n    \"\"\"Memory consumption of the current process.\"\"\"\n    process = psutil.Process(os.getpid())\n    return process.memory_info().rss / (1024 * 1024)\ndef kill(proc_pid):\n    process = psutil.Process(proc_pid)\n    for proc in process.children(recursive=True):",
        "detail": "deps.sample-factory.sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "memory_consumption_mb",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.utils.utils",
        "description": "deps.sample-factory.sample_factory.utils.utils",
        "peekOfCode": "def memory_consumption_mb():\n    \"\"\"Memory consumption of the current process.\"\"\"\n    process = psutil.Process(os.getpid())\n    return process.memory_info().rss / (1024 * 1024)\ndef kill(proc_pid):\n    process = psutil.Process(proc_pid)\n    for proc in process.children(recursive=True):\n        proc.kill()\n    process.kill()\ndef join_or_kill(process, timeout=1.0):",
        "detail": "deps.sample-factory.sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "kill",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.utils.utils",
        "description": "deps.sample-factory.sample_factory.utils.utils",
        "peekOfCode": "def kill(proc_pid):\n    process = psutil.Process(proc_pid)\n    for proc in process.children(recursive=True):\n        proc.kill()\n    process.kill()\ndef join_or_kill(process, timeout=1.0):\n    process.join(timeout)\n    if process.is_alive():\n        log.warning(\"Process %r could not join, kill it with fire!\", process)\n        process.kill()",
        "detail": "deps.sample-factory.sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "join_or_kill",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.utils.utils",
        "description": "deps.sample-factory.sample_factory.utils.utils",
        "peekOfCode": "def join_or_kill(process, timeout=1.0):\n    process.join(timeout)\n    if process.is_alive():\n        log.warning(\"Process %r could not join, kill it with fire!\", process)\n        process.kill()\n        log.warning(\"Process %r is dead (%r)\", process, process.is_alive())\ndef list_child_processes():\n    current_process = psutil.Process()\n    children = current_process.children(recursive=True)\n    is_alive = []",
        "detail": "deps.sample-factory.sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "list_child_processes",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.utils.utils",
        "description": "deps.sample-factory.sample_factory.utils.utils",
        "peekOfCode": "def list_child_processes():\n    current_process = psutil.Process()\n    children = current_process.children(recursive=True)\n    is_alive = []\n    for child in children:\n        try:\n            child_process = psutil.Process(child.pid)\n            if child_process.is_running():\n                is_alive.append(child_process)\n        except psutil.NoSuchProcess:",
        "detail": "deps.sample-factory.sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "kill_processes",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.utils.utils",
        "description": "deps.sample-factory.sample_factory.utils.utils",
        "peekOfCode": "def kill_processes(processes):\n    # do not kill to avoid permanent memleaks\n    # https://pytorch.org/docs/stable/multiprocessing.html#file-system-file-system\n    processes_to_save = [\"torch_shm\", \"resource_tracker\", \"semaphore_tracker\"]\n    for p in processes:\n        try:\n            kill_proc = True\n            for proc_to_save in processes_to_save:\n                if any(proc_to_save in s for s in [p.name()] + p.cmdline()):\n                    kill_proc = False",
        "detail": "deps.sample-factory.sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "cores_for_worker_process",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.utils.utils",
        "description": "deps.sample-factory.sample_factory.utils.utils",
        "peekOfCode": "def cores_for_worker_process(worker_idx, num_workers, cpu_count):\n    \"\"\"\n    Returns core indices, assuming available cores are [0, ..., cpu_count).\n    If this is not the case (e.g. SLURM) use these as indices in the array of actual available cores.\n    \"\"\"\n    worker_idx_modulo = worker_idx % cpu_count\n    # trying to optimally assign workers to CPU cores to minimize context switching\n    # logic here is best illustrated with an example\n    # 20 cores, 44 workers (why? I don't know, someone wanted 44 workers)\n    # first 40 are assigned to a single core each, remaining 4 get 5 cores each",
        "detail": "deps.sample-factory.sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "set_process_cpu_affinity",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.utils.utils",
        "description": "deps.sample-factory.sample_factory.utils.utils",
        "peekOfCode": "def set_process_cpu_affinity(worker_idx, num_workers):\n    if platform == \"darwin\":\n        log.debug(\"On MacOS, not setting affinity\")\n        return\n    curr_process = psutil.Process()\n    available_cores = curr_process.cpu_affinity()\n    cpu_count = len(available_cores)\n    core_indices = cores_for_worker_process(worker_idx, num_workers, cpu_count)\n    if core_indices is not None:\n        curr_process_cores = [available_cores[c] for c in core_indices]",
        "detail": "deps.sample-factory.sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "ensure_dir_exists",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.utils.utils",
        "description": "deps.sample-factory.sample_factory.utils.utils",
        "peekOfCode": "def ensure_dir_exists(path) -> str:\n    if not os.path.exists(path):\n        os.makedirs(path, exist_ok=True)\n    return path\ndef maybe_ensure_dir_exists(path, mkdir: bool) -> str:\n    if mkdir:\n        return ensure_dir_exists(path)\n    else:\n        return path\ndef safe_ensure_dir_exists(path):",
        "detail": "deps.sample-factory.sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "maybe_ensure_dir_exists",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.utils.utils",
        "description": "deps.sample-factory.sample_factory.utils.utils",
        "peekOfCode": "def maybe_ensure_dir_exists(path, mkdir: bool) -> str:\n    if mkdir:\n        return ensure_dir_exists(path)\n    else:\n        return path\ndef safe_ensure_dir_exists(path):\n    \"\"\"Should be safer in multi-treaded environment.\"\"\"\n    try:\n        return ensure_dir_exists(path)\n    except FileExistsError:",
        "detail": "deps.sample-factory.sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "safe_ensure_dir_exists",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.utils.utils",
        "description": "deps.sample-factory.sample_factory.utils.utils",
        "peekOfCode": "def safe_ensure_dir_exists(path):\n    \"\"\"Should be safer in multi-treaded environment.\"\"\"\n    try:\n        return ensure_dir_exists(path)\n    except FileExistsError:\n        return path\ndef remove_if_exists(file):\n    if os.path.isfile(file):\n        os.remove(file)\ndef get_username():",
        "detail": "deps.sample-factory.sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "remove_if_exists",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.utils.utils",
        "description": "deps.sample-factory.sample_factory.utils.utils",
        "peekOfCode": "def remove_if_exists(file):\n    if os.path.isfile(file):\n        os.remove(file)\ndef get_username():\n    uid = os.getuid()\n    try:\n        return pwd.getpwuid(uid).pw_name\n    except KeyError:\n        # worst case scenario - let's just use uid\n        return str(uid)",
        "detail": "deps.sample-factory.sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "get_username",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.utils.utils",
        "description": "deps.sample-factory.sample_factory.utils.utils",
        "peekOfCode": "def get_username():\n    uid = os.getuid()\n    try:\n        return pwd.getpwuid(uid).pw_name\n    except KeyError:\n        # worst case scenario - let's just use uid\n        return str(uid)\ndef project_tmp_dir(mkdir: bool = True) -> str:\n    tmp_dir_name = f\"sf2_{get_username()}\"\n    return maybe_ensure_dir_exists(join(tempfile.gettempdir(), tmp_dir_name), mkdir)",
        "detail": "deps.sample-factory.sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "project_tmp_dir",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.utils.utils",
        "description": "deps.sample-factory.sample_factory.utils.utils",
        "peekOfCode": "def project_tmp_dir(mkdir: bool = True) -> str:\n    tmp_dir_name = f\"sf2_{get_username()}\"\n    return maybe_ensure_dir_exists(join(tempfile.gettempdir(), tmp_dir_name), mkdir)\ndef experiments_dir(cfg, mkdir=True) -> str:\n    return maybe_ensure_dir_exists(cfg.train_dir, mkdir)\ndef experiment_dir(cfg, mkdir=True) -> str:\n    experiment = cfg.experiment\n    experiments_root = experiments_dir(cfg, mkdir)\n    return maybe_ensure_dir_exists(join(experiments_root, experiment), mkdir)\ndef summaries_dir(experiment_dir_, mkdir=True) -> str:",
        "detail": "deps.sample-factory.sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "experiments_dir",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.utils.utils",
        "description": "deps.sample-factory.sample_factory.utils.utils",
        "peekOfCode": "def experiments_dir(cfg, mkdir=True) -> str:\n    return maybe_ensure_dir_exists(cfg.train_dir, mkdir)\ndef experiment_dir(cfg, mkdir=True) -> str:\n    experiment = cfg.experiment\n    experiments_root = experiments_dir(cfg, mkdir)\n    return maybe_ensure_dir_exists(join(experiments_root, experiment), mkdir)\ndef summaries_dir(experiment_dir_, mkdir=True) -> str:\n    return maybe_ensure_dir_exists(join(experiment_dir_, \".summary\"), mkdir)\ndef cfg_file(cfg: Config) -> str:\n    return join(experiment_dir(cfg=cfg), \"config.json\")",
        "detail": "deps.sample-factory.sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "experiment_dir",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.utils.utils",
        "description": "deps.sample-factory.sample_factory.utils.utils",
        "peekOfCode": "def experiment_dir(cfg, mkdir=True) -> str:\n    experiment = cfg.experiment\n    experiments_root = experiments_dir(cfg, mkdir)\n    return maybe_ensure_dir_exists(join(experiments_root, experiment), mkdir)\ndef summaries_dir(experiment_dir_, mkdir=True) -> str:\n    return maybe_ensure_dir_exists(join(experiment_dir_, \".summary\"), mkdir)\ndef cfg_file(cfg: Config) -> str:\n    return join(experiment_dir(cfg=cfg), \"config.json\")\ndef cfg_file_old(cfg: Config) -> str:\n    \"\"\"Filename used before SF 2.0.2. Keep for compatibility.\"\"\"",
        "detail": "deps.sample-factory.sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "summaries_dir",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.utils.utils",
        "description": "deps.sample-factory.sample_factory.utils.utils",
        "peekOfCode": "def summaries_dir(experiment_dir_, mkdir=True) -> str:\n    return maybe_ensure_dir_exists(join(experiment_dir_, \".summary\"), mkdir)\ndef cfg_file(cfg: Config) -> str:\n    return join(experiment_dir(cfg=cfg), \"config.json\")\ndef cfg_file_old(cfg: Config) -> str:\n    \"\"\"Filename used before SF 2.0.2. Keep for compatibility.\"\"\"\n    return join(experiment_dir(cfg=cfg), \"cfg.json\")\ndef git_root():\n    \"\"\":returns None if we're not in the git repo, otherwise full path to the root of the repo.\"\"\"\n    cwd = os.getcwd()",
        "detail": "deps.sample-factory.sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "cfg_file",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.utils.utils",
        "description": "deps.sample-factory.sample_factory.utils.utils",
        "peekOfCode": "def cfg_file(cfg: Config) -> str:\n    return join(experiment_dir(cfg=cfg), \"config.json\")\ndef cfg_file_old(cfg: Config) -> str:\n    \"\"\"Filename used before SF 2.0.2. Keep for compatibility.\"\"\"\n    return join(experiment_dir(cfg=cfg), \"cfg.json\")\ndef git_root():\n    \"\"\":returns None if we're not in the git repo, otherwise full path to the root of the repo.\"\"\"\n    cwd = os.getcwd()\n    # check if we're inside a git repository\n    curr_dir = cwd",
        "detail": "deps.sample-factory.sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "cfg_file_old",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.utils.utils",
        "description": "deps.sample-factory.sample_factory.utils.utils",
        "peekOfCode": "def cfg_file_old(cfg: Config) -> str:\n    \"\"\"Filename used before SF 2.0.2. Keep for compatibility.\"\"\"\n    return join(experiment_dir(cfg=cfg), \"cfg.json\")\ndef git_root():\n    \"\"\":returns None if we're not in the git repo, otherwise full path to the root of the repo.\"\"\"\n    cwd = os.getcwd()\n    # check if we're inside a git repository\n    curr_dir = cwd\n    max_depth = 20\n    for _ in range(max_depth):",
        "detail": "deps.sample-factory.sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "git_root",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.utils.utils",
        "description": "deps.sample-factory.sample_factory.utils.utils",
        "peekOfCode": "def git_root():\n    \"\"\":returns None if we're not in the git repo, otherwise full path to the root of the repo.\"\"\"\n    cwd = os.getcwd()\n    # check if we're inside a git repository\n    curr_dir = cwd\n    max_depth = 20\n    for _ in range(max_depth):\n        if \".git\" in os.listdir(curr_dir):\n            return curr_dir\n        parent_dir = os.path.dirname(curr_dir)",
        "detail": "deps.sample-factory.sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "get_git_commit_hash",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.utils.utils",
        "description": "deps.sample-factory.sample_factory.utils.utils",
        "peekOfCode": "def get_git_commit_hash():\n    git_hash = \"unknown\"\n    git_repo_name = \"not a git repository\"\n    git_root_dir = git_root()\n    if git_root_dir:\n        try:\n            git_hash = check_output([\"git\", \"rev-parse\", \"HEAD\"], cwd=git_root_dir, timeout=1).strip().decode(\"ascii\")\n            git_repo_name = (\n                check_output([\"git\", \"config\", \"--get\", \"remote.origin.url\"], cwd=git_root_dir, timeout=1)\n                .strip()",
        "detail": "deps.sample-factory.sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "save_git_diff",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.utils.utils",
        "description": "deps.sample-factory.sample_factory.utils.utils",
        "peekOfCode": "def save_git_diff(directory):\n    git_root_dir = git_root()\n    if git_root_dir:\n        try:\n            with open(join(directory, \"git.diff\"), \"w\") as outfile:\n                run([\"git\", \"diff\"], stdout=outfile, cwd=git_root_dir, timeout=1)\n        except SubprocessError:\n            pass\n# more logging\n@static_vars(history=dict())",
        "detail": "deps.sample-factory.sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "log_every_n",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.utils.utils",
        "description": "deps.sample-factory.sample_factory.utils.utils",
        "peekOfCode": "def log_every_n(n, _level, msg, *args, **kwargs):\n    \"\"\"\n    Log message `msg` once in n calls to this function to avoid log spam.\n    Use only msg to count the calls, not args and kwargs.\n    \"\"\"\n    if msg not in log_every_n.history:\n        log_every_n.history[msg] = 0\n    num_msgs = log_every_n.history[msg]\n    if num_msgs % n == 0:\n        msg_with_ntimes = f\"{msg} ({num_msgs} times)\" if num_msgs > 1 else msg",
        "detail": "deps.sample-factory.sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "debug_log_every_n",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.utils.utils",
        "description": "deps.sample-factory.sample_factory.utils.utils",
        "peekOfCode": "def debug_log_every_n(n, msg, *args, **kwargs):\n    log_every_n(n, logging.DEBUG, msg, *args, **kwargs)",
        "detail": "deps.sample-factory.sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 5,
        "importPath": "deps.sample-factory.sample_factory.utils.utils",
        "description": "deps.sample-factory.sample_factory.utils.utils",
        "peekOfCode": "log = logging.getLogger(\"rl\")\nlog.setLevel(logging.DEBUG)\nlog.handlers = []  # No duplicated handlers\nlog.propagate = False  # workaround for duplicated logs in ipython\nlog_level = logging.DEBUG\nstream_handler = logging.StreamHandler()\nstream_handler.setLevel(log_level)\ncolor_logging = os.getenv('COLOR_LOGGING', 'true').lower() == 'true'\nif color_logging:\n    stream_formatter = ColoredFormatter(",
        "detail": "deps.sample-factory.sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "log.handlers",
        "kind": 5,
        "importPath": "deps.sample-factory.sample_factory.utils.utils",
        "description": "deps.sample-factory.sample_factory.utils.utils",
        "peekOfCode": "log.handlers = []  # No duplicated handlers\nlog.propagate = False  # workaround for duplicated logs in ipython\nlog_level = logging.DEBUG\nstream_handler = logging.StreamHandler()\nstream_handler.setLevel(log_level)\ncolor_logging = os.getenv('COLOR_LOGGING', 'true').lower() == 'true'\nif color_logging:\n    stream_formatter = ColoredFormatter(\n        \"%(log_color)s[%(asctime)s][%(process)05d] %(message)s\",\n        datefmt=None,",
        "detail": "deps.sample-factory.sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "log.propagate",
        "kind": 5,
        "importPath": "deps.sample-factory.sample_factory.utils.utils",
        "description": "deps.sample-factory.sample_factory.utils.utils",
        "peekOfCode": "log.propagate = False  # workaround for duplicated logs in ipython\nlog_level = logging.DEBUG\nstream_handler = logging.StreamHandler()\nstream_handler.setLevel(log_level)\ncolor_logging = os.getenv('COLOR_LOGGING', 'true').lower() == 'true'\nif color_logging:\n    stream_formatter = ColoredFormatter(\n        \"%(log_color)s[%(asctime)s][%(process)05d] %(message)s\",\n        datefmt=None,\n        reset=True,",
        "detail": "deps.sample-factory.sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "log_level",
        "kind": 5,
        "importPath": "deps.sample-factory.sample_factory.utils.utils",
        "description": "deps.sample-factory.sample_factory.utils.utils",
        "peekOfCode": "log_level = logging.DEBUG\nstream_handler = logging.StreamHandler()\nstream_handler.setLevel(log_level)\ncolor_logging = os.getenv('COLOR_LOGGING', 'true').lower() == 'true'\nif color_logging:\n    stream_formatter = ColoredFormatter(\n        \"%(log_color)s[%(asctime)s][%(process)05d] %(message)s\",\n        datefmt=None,\n        reset=True,\n        log_colors={",
        "detail": "deps.sample-factory.sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "stream_handler",
        "kind": 5,
        "importPath": "deps.sample-factory.sample_factory.utils.utils",
        "description": "deps.sample-factory.sample_factory.utils.utils",
        "peekOfCode": "stream_handler = logging.StreamHandler()\nstream_handler.setLevel(log_level)\ncolor_logging = os.getenv('COLOR_LOGGING', 'true').lower() == 'true'\nif color_logging:\n    stream_formatter = ColoredFormatter(\n        \"%(log_color)s[%(asctime)s][%(process)05d] %(message)s\",\n        datefmt=None,\n        reset=True,\n        log_colors={\n            \"DEBUG\": \"cyan\",",
        "detail": "deps.sample-factory.sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "color_logging",
        "kind": 5,
        "importPath": "deps.sample-factory.sample_factory.utils.utils",
        "description": "deps.sample-factory.sample_factory.utils.utils",
        "peekOfCode": "color_logging = os.getenv('COLOR_LOGGING', 'true').lower() == 'true'\nif color_logging:\n    stream_formatter = ColoredFormatter(\n        \"%(log_color)s[%(asctime)s][%(process)05d] %(message)s\",\n        datefmt=None,\n        reset=True,\n        log_colors={\n            \"DEBUG\": \"cyan\",\n            \"INFO\": \"white,bold\",\n            \"INFOV\": \"cyan,bold\",",
        "detail": "deps.sample-factory.sample_factory.utils.utils",
        "documentation": {}
    },
    {
        "label": "init_wandb",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.utils.wandb_utils",
        "description": "deps.sample-factory.sample_factory.utils.wandb_utils",
        "peekOfCode": "def init_wandb(cfg):\n    \"\"\"\n    Must call initialization of Wandb before summary writer is initialized, otherwise\n    sync_tensorboard does not work.\n    \"\"\"\n    if not cfg.with_wandb:\n        log.debug(\"Weights and Biases integration disabled\")\n        return\n    if \"wandb_unique_id\" not in cfg:\n        # if we're going to restart the experiment, this will be saved to a json file",
        "detail": "deps.sample-factory.sample_factory.utils.wandb_utils",
        "documentation": {}
    },
    {
        "label": "finish_wandb",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.utils.wandb_utils",
        "description": "deps.sample-factory.sample_factory.utils.wandb_utils",
        "peekOfCode": "def finish_wandb(cfg):\n    if cfg.with_wandb:\n        import wandb\n        wandb.run.finish()",
        "detail": "deps.sample-factory.sample_factory.utils.wandb_utils",
        "documentation": {}
    },
    {
        "label": "visualize_policy_inputs",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.enjoy",
        "description": "deps.sample-factory.sample_factory.enjoy",
        "peekOfCode": "def visualize_policy_inputs(normalized_obs: Dict[str, Tensor]) -> None:\n    \"\"\"\n    Display actual policy inputs after all wrappers and normalizations using OpenCV imshow.\n    \"\"\"\n    import cv2\n    if \"obs\" not in normalized_obs.keys():\n        return\n    obs = normalized_obs[\"obs\"]\n    # visualize obs only for the 1st agent\n    obs = obs[0]",
        "detail": "deps.sample-factory.sample_factory.enjoy",
        "documentation": {}
    },
    {
        "label": "render_frame",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.enjoy",
        "description": "deps.sample-factory.sample_factory.enjoy",
        "peekOfCode": "def render_frame(cfg, env, video_frames, num_episodes, last_render_start) -> float:\n    render_start = time.time()\n    need_video_frame = len(video_frames) < cfg.video_frames or cfg.video_frames < 0 and num_episodes == 0\n    if need_video_frame:\n        frame = env.render()\n        if frame is not None:\n            video_frames.append(frame.copy())\n    return render_start\ndef enjoy(cfg: Config, render_mode=\"human\") -> Tuple[StatusCode, float]:\n    verbose = False",
        "detail": "deps.sample-factory.sample_factory.enjoy",
        "documentation": {}
    },
    {
        "label": "enjoy",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.enjoy",
        "description": "deps.sample-factory.sample_factory.enjoy",
        "peekOfCode": "def enjoy(cfg: Config, render_mode=\"human\") -> Tuple[StatusCode, float]:\n    verbose = False\n    cfg = load_from_checkpoint(cfg)\n    eval_env_frameskip: int = cfg.env_frameskip if cfg.eval_env_frameskip is None else cfg.eval_env_frameskip\n    assert (\n        cfg.env_frameskip % eval_env_frameskip == 0\n    ), f\"{cfg.env_frameskip=} must be divisible by {eval_env_frameskip=}\"\n    render_action_repeat: int = cfg.env_frameskip // eval_env_frameskip\n    cfg.env_frameskip = cfg.eval_env_frameskip = eval_env_frameskip\n    log.debug(f\"Using frameskip {cfg.env_frameskip} and {render_action_repeat=} for evaluation\")",
        "detail": "deps.sample-factory.sample_factory.enjoy",
        "documentation": {}
    },
    {
        "label": "generate_trajectories",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.eval",
        "description": "deps.sample-factory.sample_factory.eval",
        "peekOfCode": "def generate_trajectories(cfg: Config, env_info: EnvInfo, sample_env_episodes: int = 1024) -> StatusCode:\n    sampler = EvalSamplingAPI(cfg, env_info)\n    sampler.init()\n    sampler.start()\n    print_interval_sec = 1.0\n    fps_stats = deque([(time.time(), 0, 0)], maxlen=10)\n    episodes_sampled = 0\n    last_print = time.time()\n    while episodes_sampled < sample_env_episodes:\n        try:",
        "detail": "deps.sample-factory.sample_factory.eval",
        "documentation": {}
    },
    {
        "label": "do_eval",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.eval",
        "description": "deps.sample-factory.sample_factory.eval",
        "peekOfCode": "def do_eval(cfg: Config) -> StatusCode:\n    # should always be set to True for this script\n    cfg.episode_counter = True\n    # decorrelation isn't needed in eval, it only slows us down\n    cfg.decorrelate_envs_on_one_worker = False\n    env_info = obtain_env_info_in_a_separate_process(cfg)\n    return generate_trajectories(cfg, env_info, cfg.sample_env_episodes)",
        "detail": "deps.sample-factory.sample_factory.eval",
        "documentation": {}
    },
    {
        "label": "make_runner",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.train",
        "description": "deps.sample-factory.sample_factory.train",
        "peekOfCode": "def make_runner(cfg: Config) -> Tuple[Config, Runner]:\n    if cfg.restart_behavior == \"resume\":\n        # if we're resuming from checkpoint, we load all of the config parameters from the checkpoint\n        # unless they're explicitly specified in the command line\n        cfg = maybe_load_from_checkpoint(cfg)\n    if cfg.serial_mode:\n        runner_cls = SerialRunner\n    else:\n        runner_cls = ParallelRunner\n    runner = runner_cls(cfg)",
        "detail": "deps.sample-factory.sample_factory.train",
        "documentation": {}
    },
    {
        "label": "run_rl",
        "kind": 2,
        "importPath": "deps.sample-factory.sample_factory.train",
        "description": "deps.sample-factory.sample_factory.train",
        "peekOfCode": "def run_rl(cfg: Config):\n    cfg, runner = make_runner(cfg)\n    # here we can register additional message or summary handlers\n    # see sf_examples/dmlab/train_dmlab.py for example\n    status = runner.init()\n    if status == ExperimentStatus.SUCCESS:\n        status = runner.run()\n    return status",
        "detail": "deps.sample-factory.sample_factory.train",
        "documentation": {}
    },
    {
        "label": "_params",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.atari.experiments.atari_envs",
        "description": "deps.sample-factory.sf_examples.atari.experiments.atari_envs",
        "peekOfCode": "_params = ParamGrid(\n    [\n        (\"seed\", [00, 11, 22, 33]),\n        (\n            \"env\",\n            [\n                \"atari_breakout\",\n                \"atari_pong\",\n                \"atari_beamrider\",\n            ],",
        "detail": "deps.sample-factory.sf_examples.atari.experiments.atari_envs",
        "documentation": {}
    },
    {
        "label": "_experiments",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.atari.experiments.atari_envs",
        "description": "deps.sample-factory.sf_examples.atari.experiments.atari_envs",
        "peekOfCode": "_experiments = [\n    Experiment(\n        \"atari_envs\",\n        \"python -m sf_examples.atari.train_atari --algo=APPO --with_wandb=True --wandb_project=atari-benchmark --wandb_group=atari_all --wandb_tags run6\",\n        _params.generate_params(randomize=False),\n    ),\n]\nRUN_DESCRIPTION = RunDescription(\"atari_envs\", experiments=_experiments)\n# python -m sample_factory.launcher.run --run=sf_examples.atari.experiments.atari_envs --backend=processes --max_parallel=8  --pause_between=1 --experiments_per_gpu=10000 --num_gpus=1",
        "detail": "deps.sample-factory.sf_examples.atari.experiments.atari_envs",
        "documentation": {}
    },
    {
        "label": "RUN_DESCRIPTION",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.atari.experiments.atari_envs",
        "description": "deps.sample-factory.sf_examples.atari.experiments.atari_envs",
        "peekOfCode": "RUN_DESCRIPTION = RunDescription(\"atari_envs\", experiments=_experiments)\n# python -m sample_factory.launcher.run --run=sf_examples.atari.experiments.atari_envs --backend=processes --max_parallel=8  --pause_between=1 --experiments_per_gpu=10000 --num_gpus=1",
        "detail": "deps.sample-factory.sf_examples.atari.experiments.atari_envs",
        "documentation": {}
    },
    {
        "label": "atari_override_defaults",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.atari.atari_params",
        "description": "deps.sample-factory.sf_examples.atari.atari_params",
        "peekOfCode": "def atari_override_defaults(_env, parser):\n    \"\"\"RL params specific to Atari envs.\"\"\"\n    parser.set_defaults(\n        # let's set this to True by default so it's consistent with how we report results for other envs\n        # (i.e. VizDoom or DMLab). When running evaluations for reports or to compare with other frameworks we can\n        # set this to false in command line\n        summaries_use_frameskip=True,\n        use_record_episode_statistics=True,\n        encoder_conv_architecture=\"convnet_atari\",\n        obs_scale=255.0,",
        "detail": "deps.sample-factory.sf_examples.atari.atari_params",
        "documentation": {}
    },
    {
        "label": "AtariSpec",
        "kind": 6,
        "importPath": "deps.sample-factory.sf_examples.atari.atari_utils",
        "description": "deps.sample-factory.sf_examples.atari.atari_utils",
        "peekOfCode": "class AtariSpec:\n    def __init__(self, name, env_id, default_timeout=None):\n        self.name = name\n        self.env_id = env_id\n        self.default_timeout = default_timeout\n        self.has_timer = False\nATARI_ENVS = [\n    AtariSpec(\"atari_alien\", \"AlienNoFrameskip-v4\"),\n    AtariSpec(\"atari_amidar\", \"AmidarNoFrameskip-v4\"),\n    AtariSpec(\"atari_assault\", \"AssaultNoFrameskip-v4\"),",
        "detail": "deps.sample-factory.sf_examples.atari.atari_utils",
        "documentation": {}
    },
    {
        "label": "atari_env_by_name",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.atari.atari_utils",
        "description": "deps.sample-factory.sf_examples.atari.atari_utils",
        "peekOfCode": "def atari_env_by_name(name):\n    for cfg in ATARI_ENVS:\n        if cfg.name == name:\n            return cfg\n    raise Exception(\"Unknown Atari env\")\ndef make_atari_env(env_name, cfg, env_config, render_mode: Optional[str] = None):\n    atari_spec = atari_env_by_name(env_name)\n    env = gym.make(atari_spec.env_id, render_mode=render_mode)\n    if atari_spec.default_timeout is not None:\n        env._max_episode_steps = atari_spec.default_timeout",
        "detail": "deps.sample-factory.sf_examples.atari.atari_utils",
        "documentation": {}
    },
    {
        "label": "make_atari_env",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.atari.atari_utils",
        "description": "deps.sample-factory.sf_examples.atari.atari_utils",
        "peekOfCode": "def make_atari_env(env_name, cfg, env_config, render_mode: Optional[str] = None):\n    atari_spec = atari_env_by_name(env_name)\n    env = gym.make(atari_spec.env_id, render_mode=render_mode)\n    if atari_spec.default_timeout is not None:\n        env._max_episode_steps = atari_spec.default_timeout\n    # these are chosen to match Stable-Baselines3 and CleanRL implementations as precisely as possible\n    env = gym.wrappers.RecordEpisodeStatistics(env)\n    env = NoopResetEnv(env, noop_max=30)\n    env = MaxAndSkipEnv(env, skip=cfg.env_frameskip)\n    env = EpisodicLifeEnv(env)",
        "detail": "deps.sample-factory.sf_examples.atari.atari_utils",
        "documentation": {}
    },
    {
        "label": "ATARI_W",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.atari.atari_utils",
        "description": "deps.sample-factory.sf_examples.atari.atari_utils",
        "peekOfCode": "ATARI_W = ATARI_H = 84\nclass AtariSpec:\n    def __init__(self, name, env_id, default_timeout=None):\n        self.name = name\n        self.env_id = env_id\n        self.default_timeout = default_timeout\n        self.has_timer = False\nATARI_ENVS = [\n    AtariSpec(\"atari_alien\", \"AlienNoFrameskip-v4\"),\n    AtariSpec(\"atari_amidar\", \"AmidarNoFrameskip-v4\"),",
        "detail": "deps.sample-factory.sf_examples.atari.atari_utils",
        "documentation": {}
    },
    {
        "label": "ATARI_ENVS",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.atari.atari_utils",
        "description": "deps.sample-factory.sf_examples.atari.atari_utils",
        "peekOfCode": "ATARI_ENVS = [\n    AtariSpec(\"atari_alien\", \"AlienNoFrameskip-v4\"),\n    AtariSpec(\"atari_amidar\", \"AmidarNoFrameskip-v4\"),\n    AtariSpec(\"atari_assault\", \"AssaultNoFrameskip-v4\"),\n    AtariSpec(\"atari_asterix\", \"AsterixNoFrameskip-v4\"),\n    AtariSpec(\"atari_asteroid\", \"AsteroidsNoFrameskip-v4\"),\n    AtariSpec(\"atari_atlantis\", \"AtlantisNoFrameskip-v4\"),\n    AtariSpec(\"atari_bankheist\", \"BankHeistNoFrameskip-v4\"),\n    AtariSpec(\"atari_battlezone\", \"BattleZoneNoFrameskip-v4\"),\n    AtariSpec(\"atari_beamrider\", \"BeamRiderNoFrameskip-v4\"),",
        "detail": "deps.sample-factory.sf_examples.atari.atari_utils",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.atari.enjoy_atari",
        "description": "deps.sample-factory.sf_examples.atari.enjoy_atari",
        "peekOfCode": "def main():\n    \"\"\"Script entry point.\"\"\"\n    register_atari_components()\n    cfg = parse_atari_args(evaluation=True)\n    status = enjoy(cfg)\n    return status\nif __name__ == \"__main__\":\n    sys.exit(main())",
        "detail": "deps.sample-factory.sf_examples.atari.enjoy_atari",
        "documentation": {}
    },
    {
        "label": "register_atari_envs",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.atari.train_atari",
        "description": "deps.sample-factory.sf_examples.atari.train_atari",
        "peekOfCode": "def register_atari_envs():\n    for env in ATARI_ENVS:\n        register_env(env.name, make_atari_env)\ndef register_atari_components():\n    register_atari_envs()\ndef parse_atari_args(argv=None, evaluation=False):\n    parser, partial_cfg = parse_sf_args(argv=argv, evaluation=evaluation)\n    atari_override_defaults(partial_cfg.env, parser)\n    final_cfg = parse_full_cfg(parser, argv)\n    return final_cfg",
        "detail": "deps.sample-factory.sf_examples.atari.train_atari",
        "documentation": {}
    },
    {
        "label": "register_atari_components",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.atari.train_atari",
        "description": "deps.sample-factory.sf_examples.atari.train_atari",
        "peekOfCode": "def register_atari_components():\n    register_atari_envs()\ndef parse_atari_args(argv=None, evaluation=False):\n    parser, partial_cfg = parse_sf_args(argv=argv, evaluation=evaluation)\n    atari_override_defaults(partial_cfg.env, parser)\n    final_cfg = parse_full_cfg(parser, argv)\n    return final_cfg\ndef main():  # pragma: no cover\n    \"\"\"Script entry point.\"\"\"\n    register_atari_components()",
        "detail": "deps.sample-factory.sf_examples.atari.train_atari",
        "documentation": {}
    },
    {
        "label": "parse_atari_args",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.atari.train_atari",
        "description": "deps.sample-factory.sf_examples.atari.train_atari",
        "peekOfCode": "def parse_atari_args(argv=None, evaluation=False):\n    parser, partial_cfg = parse_sf_args(argv=argv, evaluation=evaluation)\n    atari_override_defaults(partial_cfg.env, parser)\n    final_cfg = parse_full_cfg(parser, argv)\n    return final_cfg\ndef main():  # pragma: no cover\n    \"\"\"Script entry point.\"\"\"\n    register_atari_components()\n    cfg = parse_atari_args()\n    status = run_rl(cfg)",
        "detail": "deps.sample-factory.sf_examples.atari.train_atari",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.atari.train_atari",
        "description": "deps.sample-factory.sf_examples.atari.train_atari",
        "peekOfCode": "def main():  # pragma: no cover\n    \"\"\"Script entry point.\"\"\"\n    register_atari_components()\n    cfg = parse_atari_args()\n    status = run_rl(cfg)\n    return status\nif __name__ == \"__main__\":  # pragma: no cover\n    sys.exit(main())",
        "detail": "deps.sample-factory.sf_examples.atari.train_atari",
        "documentation": {}
    },
    {
        "label": "_params",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.brax.experiments.brax_basic_envs",
        "description": "deps.sample-factory.sf_examples.brax.experiments.brax_basic_envs",
        "peekOfCode": "_params = ParamGrid(\n    [\n        (\"seed\", seeds(5)),\n        (\"env\", [\"ant\", \"humanoid\", \"halfcheetah\", \"walker2d\"]),\n        (\"use_rnn\", [False, True]),  # train recurrent and non-recurrent models\n        (\"num_epochs\", [5]),\n    ]\n)\nvstr = f\"v{ALGO_VERSION:03d}_brax_basic_benchmark\"\ncli = \"python -m sf_examples.brax.train_brax --actor_worker_gpus 0 --wandb_project=sample_factory --with_wandb=True\"",
        "detail": "deps.sample-factory.sf_examples.brax.experiments.brax_basic_envs",
        "documentation": {}
    },
    {
        "label": "vstr",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.brax.experiments.brax_basic_envs",
        "description": "deps.sample-factory.sf_examples.brax.experiments.brax_basic_envs",
        "peekOfCode": "vstr = f\"v{ALGO_VERSION:03d}_brax_basic_benchmark\"\ncli = \"python -m sf_examples.brax.train_brax --actor_worker_gpus 0 --wandb_project=sample_factory --with_wandb=True\"\n_experiments = [Experiment(vstr, cli, _params.generate_params())]\nRUN_DESCRIPTION = RunDescription(vstr, experiments=_experiments)\n# Run locally: python -m sample_factory.launcher.run --run=sf_examples.brax.experiments.brax_basic_envs --backend=processes --max_parallel=1 --experiments_per_gpu=1 --num_gpus=1\n# Run on Slurm: python -m sample_factory.launcher.run --run=sf_examples.brax.experiments.brax_basic_envs --backend=slurm --slurm_workdir=./slurm_brax --experiment_suffix=slurm --slurm_gpus_per_job=1 --slurm_cpus_per_gpu=16 --slurm_sbatch_template=./sf_examples/brax/experiments/sbatch_timeout_brax.sh --pause_between=1 --slurm_print_only=False",
        "detail": "deps.sample-factory.sf_examples.brax.experiments.brax_basic_envs",
        "documentation": {}
    },
    {
        "label": "cli",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.brax.experiments.brax_basic_envs",
        "description": "deps.sample-factory.sf_examples.brax.experiments.brax_basic_envs",
        "peekOfCode": "cli = \"python -m sf_examples.brax.train_brax --actor_worker_gpus 0 --wandb_project=sample_factory --with_wandb=True\"\n_experiments = [Experiment(vstr, cli, _params.generate_params())]\nRUN_DESCRIPTION = RunDescription(vstr, experiments=_experiments)\n# Run locally: python -m sample_factory.launcher.run --run=sf_examples.brax.experiments.brax_basic_envs --backend=processes --max_parallel=1 --experiments_per_gpu=1 --num_gpus=1\n# Run on Slurm: python -m sample_factory.launcher.run --run=sf_examples.brax.experiments.brax_basic_envs --backend=slurm --slurm_workdir=./slurm_brax --experiment_suffix=slurm --slurm_gpus_per_job=1 --slurm_cpus_per_gpu=16 --slurm_sbatch_template=./sf_examples/brax/experiments/sbatch_timeout_brax.sh --pause_between=1 --slurm_print_only=False",
        "detail": "deps.sample-factory.sf_examples.brax.experiments.brax_basic_envs",
        "documentation": {}
    },
    {
        "label": "_experiments",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.brax.experiments.brax_basic_envs",
        "description": "deps.sample-factory.sf_examples.brax.experiments.brax_basic_envs",
        "peekOfCode": "_experiments = [Experiment(vstr, cli, _params.generate_params())]\nRUN_DESCRIPTION = RunDescription(vstr, experiments=_experiments)\n# Run locally: python -m sample_factory.launcher.run --run=sf_examples.brax.experiments.brax_basic_envs --backend=processes --max_parallel=1 --experiments_per_gpu=1 --num_gpus=1\n# Run on Slurm: python -m sample_factory.launcher.run --run=sf_examples.brax.experiments.brax_basic_envs --backend=slurm --slurm_workdir=./slurm_brax --experiment_suffix=slurm --slurm_gpus_per_job=1 --slurm_cpus_per_gpu=16 --slurm_sbatch_template=./sf_examples/brax/experiments/sbatch_timeout_brax.sh --pause_between=1 --slurm_print_only=False",
        "detail": "deps.sample-factory.sf_examples.brax.experiments.brax_basic_envs",
        "documentation": {}
    },
    {
        "label": "RUN_DESCRIPTION",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.brax.experiments.brax_basic_envs",
        "description": "deps.sample-factory.sf_examples.brax.experiments.brax_basic_envs",
        "peekOfCode": "RUN_DESCRIPTION = RunDescription(vstr, experiments=_experiments)\n# Run locally: python -m sample_factory.launcher.run --run=sf_examples.brax.experiments.brax_basic_envs --backend=processes --max_parallel=1 --experiments_per_gpu=1 --num_gpus=1\n# Run on Slurm: python -m sample_factory.launcher.run --run=sf_examples.brax.experiments.brax_basic_envs --backend=slurm --slurm_workdir=./slurm_brax --experiment_suffix=slurm --slurm_gpus_per_job=1 --slurm_cpus_per_gpu=16 --slurm_sbatch_template=./sf_examples/brax/experiments/sbatch_timeout_brax.sh --pause_between=1 --slurm_print_only=False",
        "detail": "deps.sample-factory.sf_examples.brax.experiments.brax_basic_envs",
        "documentation": {}
    },
    {
        "label": "BraxRenderer",
        "kind": 6,
        "importPath": "deps.sample-factory.sf_examples.brax.brax_render",
        "description": "deps.sample-factory.sf_examples.brax.brax_render",
        "peekOfCode": "class BraxRenderer:\n    def __init__(self, env, render_mode: str, brax_video_res_px: int = 200):\n        self.env = env\n        self.screen = None\n        self.render_mode = render_mode\n        self.instances, self.extra_info, self.scene = None, None, None\n        self.ssaa = 2  # supersampling factor\n        self.width = self.height = brax_video_res_px  # anything higher is super slow because CPU renderer :|\n    # noinspection PyProtectedMember\n    def render(self):",
        "detail": "deps.sample-factory.sf_examples.brax.brax_render",
        "documentation": {}
    },
    {
        "label": "quat_mul",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.brax.brax_render",
        "description": "deps.sample-factory.sf_examples.brax.brax_render",
        "peekOfCode": "def quat_mul(u, v):\n    \"\"\"Multiplies two quaternions.\n    Args:\n      u: (4,) quaternion (w,x,y,z)\n      v: (4,) quaternion (w,x,y,z)\n    Returns:\n      A quaternion u * v.\n    \"\"\"\n    return np.array(\n        [",
        "detail": "deps.sample-factory.sf_examples.brax.brax_render",
        "documentation": {}
    },
    {
        "label": "create_scene",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.brax.brax_render",
        "description": "deps.sample-factory.sf_examples.brax.brax_render",
        "peekOfCode": "def create_scene(qp, sys):\n    if (len(qp.pos.shape), len(qp.rot.shape)) != (2, 2):\n        raise RuntimeError(\"unexpected shape in qp\")\n    scene, instances, extra_info = _scene(sys)\n    return instances, scene, extra_info\ndef create_camera(height, width, qp, ssaa, sys, target):\n    eye, up = _eye(sys, qp), _up(sys)\n    hfov = 58.0\n    vfov = hfov * height / width\n    camera = Camera(",
        "detail": "deps.sample-factory.sf_examples.brax.brax_render",
        "documentation": {}
    },
    {
        "label": "create_camera",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.brax.brax_render",
        "description": "deps.sample-factory.sf_examples.brax.brax_render",
        "peekOfCode": "def create_camera(height, width, qp, ssaa, sys, target):\n    eye, up = _eye(sys, qp), _up(sys)\n    hfov = 58.0\n    vfov = hfov * height / width\n    camera = Camera(\n        viewWidth=width * ssaa, viewHeight=height * ssaa, position=eye, target=target, up=up, hfov=hfov, vfov=vfov\n    )\n    return camera\ndef create_light(target):\n    direction = [0.57735, -0.57735, 0.57735]",
        "detail": "deps.sample-factory.sf_examples.brax.brax_render",
        "documentation": {}
    },
    {
        "label": "create_light",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.brax.brax_render",
        "description": "deps.sample-factory.sf_examples.brax.brax_render",
        "peekOfCode": "def create_light(target):\n    direction = [0.57735, -0.57735, 0.57735]\n    light = Light(direction=direction, ambient=0.8, diffuse=0.8, specular=0.6, shadowmap_center=target)\n    return light\nclass BraxRenderer:\n    def __init__(self, env, render_mode: str, brax_video_res_px: int = 200):\n        self.env = env\n        self.screen = None\n        self.render_mode = render_mode\n        self.instances, self.extra_info, self.scene = None, None, None",
        "detail": "deps.sample-factory.sf_examples.brax.brax_render",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.brax.enjoy_brax",
        "description": "deps.sample-factory.sf_examples.brax.enjoy_brax",
        "peekOfCode": "def main():\n    \"\"\"Script entry point.\"\"\"\n    register_brax_custom_components(evaluation=True)\n    cfg = parse_brax_cfg(evaluation=True)\n    status = enjoy(cfg)\n    return status\nif __name__ == \"__main__\":\n    sys.exit(main())",
        "detail": "deps.sample-factory.sf_examples.brax.enjoy_brax",
        "documentation": {}
    },
    {
        "label": "BraxEnv",
        "kind": 6,
        "importPath": "deps.sample-factory.sf_examples.brax.train_brax",
        "description": "deps.sample-factory.sf_examples.brax.train_brax",
        "peekOfCode": "class BraxEnv(gym.Env):\n    # noinspection PyProtectedMember\n    def __init__(\n        self,\n        brax_env,\n        num_actors,\n        render_mode: Optional[str],\n        render_res: int,\n        clamp_actions: bool,\n        clamp_rew_obs: bool,",
        "detail": "deps.sample-factory.sf_examples.brax.train_brax",
        "documentation": {}
    },
    {
        "label": "jax_to_torch",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.brax.train_brax",
        "description": "deps.sample-factory.sf_examples.brax.train_brax",
        "peekOfCode": "def jax_to_torch(tensor):\n    # noinspection PyProtectedMember\n    from jax._src.dlpack import to_dlpack\n    tensor = to_dlpack(tensor)\n    tensor = tpack.from_dlpack(tensor)\n    return tensor\ndef torch_to_jax(tensor):\n    # noinspection PyProtectedMember\n    from jax._src.dlpack import from_dlpack\n    tensor = tpack.to_dlpack(tensor)",
        "detail": "deps.sample-factory.sf_examples.brax.train_brax",
        "documentation": {}
    },
    {
        "label": "torch_to_jax",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.brax.train_brax",
        "description": "deps.sample-factory.sf_examples.brax.train_brax",
        "peekOfCode": "def torch_to_jax(tensor):\n    # noinspection PyProtectedMember\n    from jax._src.dlpack import from_dlpack\n    tensor = tpack.to_dlpack(tensor)\n    tensor = from_dlpack(tensor)\n    return tensor\nclass BraxEnv(gym.Env):\n    # noinspection PyProtectedMember\n    def __init__(\n        self,",
        "detail": "deps.sample-factory.sf_examples.brax.train_brax",
        "documentation": {}
    },
    {
        "label": "make_brax_env",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.brax.train_brax",
        "description": "deps.sample-factory.sf_examples.brax.train_brax",
        "peekOfCode": "def make_brax_env(full_env_name: str, cfg: Config, _env_config=None, render_mode: Optional[str] = None) -> Env:\n    assert (\n        full_env_name in env_configs.keys()\n    ), f\"Env {full_env_name} is not supported. Supported envs: {list(env_configs.keys())}\"\n    # use batch size 2 instead of 1 so we don't have to deal with vector-nonvector env issues\n    batch_size = 64 if BRAX_EVALUATION else cfg.env_agents\n    from brax import envs\n    gym_env = envs.create_gym_env(env_name=full_env_name, batch_size=batch_size, seed=0, backend=\"gpu\")\n    env = BraxEnv(gym_env, batch_size, render_mode, cfg.brax_render_res, cfg.clamp_actions, cfg.clamp_rew_obs)\n    return env",
        "detail": "deps.sample-factory.sf_examples.brax.train_brax",
        "documentation": {}
    },
    {
        "label": "add_extra_params_func",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.brax.train_brax",
        "description": "deps.sample-factory.sf_examples.brax.train_brax",
        "peekOfCode": "def add_extra_params_func(parser) -> None:\n    \"\"\"\n    Specify any additional command line arguments for this family of custom environments.\n    \"\"\"\n    p = parser\n    p.add_argument(\n        \"--env_agents\",\n        default=2048,\n        type=int,\n        help=\"Num. agents in a vectorized env\",",
        "detail": "deps.sample-factory.sf_examples.brax.train_brax",
        "documentation": {}
    },
    {
        "label": "override_default_params_func",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.brax.train_brax",
        "description": "deps.sample-factory.sf_examples.brax.train_brax",
        "peekOfCode": "def override_default_params_func(env, parser):\n    \"\"\"Most of these parameters are the same as IsaacGymEnvs default config files.\"\"\"\n    parser.set_defaults(\n        # we're using a single very vectorized env, no need to parallelize it further\n        batched_sampling=True,\n        num_workers=1,\n        num_envs_per_worker=1,\n        worker_num_splits=1,\n        actor_worker_gpus=[0],  # obviously need a GPU\n        train_for_env_steps=100000000,",
        "detail": "deps.sample-factory.sf_examples.brax.train_brax",
        "documentation": {}
    },
    {
        "label": "register_brax_custom_components",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.brax.train_brax",
        "description": "deps.sample-factory.sf_examples.brax.train_brax",
        "peekOfCode": "def register_brax_custom_components(evaluation: bool = False) -> None:\n    global BRAX_EVALUATION\n    BRAX_EVALUATION = evaluation\n    for env_name in env_configs:\n        register_env(env_name, make_brax_env)\ndef parse_brax_cfg(evaluation=False):\n    parser, partial_cfg = parse_sf_args(evaluation=evaluation)\n    add_extra_params_func(parser)\n    override_default_params_func(partial_cfg.env, parser)\n    final_cfg = parse_full_cfg(parser)",
        "detail": "deps.sample-factory.sf_examples.brax.train_brax",
        "documentation": {}
    },
    {
        "label": "parse_brax_cfg",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.brax.train_brax",
        "description": "deps.sample-factory.sf_examples.brax.train_brax",
        "peekOfCode": "def parse_brax_cfg(evaluation=False):\n    parser, partial_cfg = parse_sf_args(evaluation=evaluation)\n    add_extra_params_func(parser)\n    override_default_params_func(partial_cfg.env, parser)\n    final_cfg = parse_full_cfg(parser)\n    return final_cfg\ndef main():\n    \"\"\"Script entry point.\"\"\"\n    register_brax_custom_components()\n    cfg = parse_brax_cfg()",
        "detail": "deps.sample-factory.sf_examples.brax.train_brax",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.brax.train_brax",
        "description": "deps.sample-factory.sf_examples.brax.train_brax",
        "peekOfCode": "def main():\n    \"\"\"Script entry point.\"\"\"\n    register_brax_custom_components()\n    cfg = parse_brax_cfg()\n    status = run_rl(cfg)\n    return status\nif __name__ == \"__main__\":\n    sys.exit(main())",
        "detail": "deps.sample-factory.sf_examples.brax.train_brax",
        "documentation": {}
    },
    {
        "label": "BRAX_EVALUATION",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.brax.train_brax",
        "description": "deps.sample-factory.sf_examples.brax.train_brax",
        "peekOfCode": "BRAX_EVALUATION = False\ntorch.ones(1, device=\"cuda\")  # init torch cuda before jax\ndef jax_to_torch(tensor):\n    # noinspection PyProtectedMember\n    from jax._src.dlpack import to_dlpack\n    tensor = to_dlpack(tensor)\n    tensor = tpack.from_dlpack(tensor)\n    return tensor\ndef torch_to_jax(tensor):\n    # noinspection PyProtectedMember",
        "detail": "deps.sample-factory.sf_examples.brax.train_brax",
        "documentation": {}
    },
    {
        "label": "env_configs",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.brax.train_brax",
        "description": "deps.sample-factory.sf_examples.brax.train_brax",
        "peekOfCode": "env_configs = dict(\n    ant=dict(\n        encoder_mlp_layers=[256, 128, 64],\n        save_every_sec=15,\n    ),\n    humanoid=dict(\n        encoder_mlp_layers=[512, 256, 128],\n    ),\n    halfcheetah=dict(\n        encoder_mlp_layers=[256, 128, 64],",
        "detail": "deps.sample-factory.sf_examples.brax.train_brax",
        "documentation": {}
    },
    {
        "label": "_params",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.dmlab.experiments.dmlab30",
        "description": "deps.sample-factory.sf_examples.dmlab.experiments.dmlab30",
        "peekOfCode": "_params = ParamGrid([(\"seed\", [1111])])\nvstr = \"dmlab30\"\ncli = (\n    \"python -m sf_examples.dmlab.train_dmlab \"\n    \"--env=dmlab_30 \"\n    \"--train_for_seconds=3600000 \"\n    \"--algo=APPO \"\n    \"--gamma=0.99 \"\n    \"--use_rnn=True \"\n    \"--num_workers=60 \"",
        "detail": "deps.sample-factory.sf_examples.dmlab.experiments.dmlab30",
        "documentation": {}
    },
    {
        "label": "vstr",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.dmlab.experiments.dmlab30",
        "description": "deps.sample-factory.sf_examples.dmlab.experiments.dmlab30",
        "peekOfCode": "vstr = \"dmlab30\"\ncli = (\n    \"python -m sf_examples.dmlab.train_dmlab \"\n    \"--env=dmlab_30 \"\n    \"--train_for_seconds=3600000 \"\n    \"--algo=APPO \"\n    \"--gamma=0.99 \"\n    \"--use_rnn=True \"\n    \"--num_workers=60 \"\n    \"--num_envs_per_worker=12 \"",
        "detail": "deps.sample-factory.sf_examples.dmlab.experiments.dmlab30",
        "documentation": {}
    },
    {
        "label": "cli",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.dmlab.experiments.dmlab30",
        "description": "deps.sample-factory.sf_examples.dmlab.experiments.dmlab30",
        "peekOfCode": "cli = (\n    \"python -m sf_examples.dmlab.train_dmlab \"\n    \"--env=dmlab_30 \"\n    \"--train_for_seconds=3600000 \"\n    \"--algo=APPO \"\n    \"--gamma=0.99 \"\n    \"--use_rnn=True \"\n    \"--num_workers=60 \"\n    \"--num_envs_per_worker=12 \"\n    \"--num_epochs=1 \"",
        "detail": "deps.sample-factory.sf_examples.dmlab.experiments.dmlab30",
        "documentation": {}
    },
    {
        "label": "_experiments",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.dmlab.experiments.dmlab30",
        "description": "deps.sample-factory.sf_examples.dmlab.experiments.dmlab30",
        "peekOfCode": "_experiments = [\n    Experiment(\"dm30\", cli, _params.generate_params(False)),\n]\nRUN_DESCRIPTION = RunDescription(f\"{vstr}\", experiments=_experiments)\n# Run locally: python -m sample_factory.launcher.run --backend=processes --max_parallel=1 --experiments_per_gpu=1 --num_gpus=1 --run=sf_examples.dmlab.experiments.dmlab30\n# Run on Slurm: python -m sample_factory.launcher.run --backend=slurm --slurm_workdir=./slurm_isaacgym --experiment_suffix=slurm --slurm_gpus_per_job=1 --slurm_cpus_per_gpu=16 --slurm_sbatch_template=./sample_factory/launcher/slurm/sbatch_timeout.sh --pause_between=1 --slurm_print_only=False --run=sf_examples.dmlab.experiments.dmlab30",
        "detail": "deps.sample-factory.sf_examples.dmlab.experiments.dmlab30",
        "documentation": {}
    },
    {
        "label": "RUN_DESCRIPTION",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.dmlab.experiments.dmlab30",
        "description": "deps.sample-factory.sf_examples.dmlab.experiments.dmlab30",
        "peekOfCode": "RUN_DESCRIPTION = RunDescription(f\"{vstr}\", experiments=_experiments)\n# Run locally: python -m sample_factory.launcher.run --backend=processes --max_parallel=1 --experiments_per_gpu=1 --num_gpus=1 --run=sf_examples.dmlab.experiments.dmlab30\n# Run on Slurm: python -m sample_factory.launcher.run --backend=slurm --slurm_workdir=./slurm_isaacgym --experiment_suffix=slurm --slurm_gpus_per_job=1 --slurm_cpus_per_gpu=16 --slurm_sbatch_template=./sample_factory/launcher/slurm/sbatch_timeout.sh --pause_between=1 --slurm_print_only=False --run=sf_examples.dmlab.experiments.dmlab30",
        "detail": "deps.sample-factory.sf_examples.dmlab.experiments.dmlab30",
        "documentation": {}
    },
    {
        "label": "DmlabRewardShapingWrapper",
        "kind": 6,
        "importPath": "deps.sample-factory.sf_examples.dmlab.wrappers.reward_shaping",
        "description": "deps.sample-factory.sf_examples.dmlab.wrappers.reward_shaping",
        "peekOfCode": "class DmlabRewardShapingWrapper(gym.Wrapper):\n    def __init__(self, env):\n        super().__init__(env)\n        self.raw_episode_return = self.episode_length = 0\n    def reset(self, **kwargs):\n        obs, info = self.env.reset(**kwargs)\n        self.raw_episode_return = self.episode_length = 0\n        return obs, info\n    def step(self, action):\n        obs, rew, terminated, truncated, info = self.env.step(action)",
        "detail": "deps.sample-factory.sf_examples.dmlab.wrappers.reward_shaping",
        "documentation": {}
    },
    {
        "label": "RAW_SCORE_SUMMARY_KEY_SUFFIX",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.dmlab.wrappers.reward_shaping",
        "description": "deps.sample-factory.sf_examples.dmlab.wrappers.reward_shaping",
        "peekOfCode": "RAW_SCORE_SUMMARY_KEY_SUFFIX = \"dmlab_raw_score\"\nclass DmlabRewardShapingWrapper(gym.Wrapper):\n    def __init__(self, env):\n        super().__init__(env)\n        self.raw_episode_return = self.episode_length = 0\n    def reset(self, **kwargs):\n        obs, info = self.env.reset(**kwargs)\n        self.raw_episode_return = self.episode_length = 0\n        return obs, info\n    def step(self, action):",
        "detail": "deps.sample-factory.sf_examples.dmlab.wrappers.reward_shaping",
        "documentation": {}
    },
    {
        "label": "dmlab30_num_envs",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.dmlab.dmlab30",
        "description": "deps.sample-factory.sf_examples.dmlab.dmlab30",
        "peekOfCode": "def dmlab30_num_envs():\n    num_envs = len(tuple(LEVEL_MAPPING.keys()))\n    return num_envs\ndef dmlab30_level_name_to_level(level_name):\n    return f\"contributed/dmlab30/{level_name}\"",
        "detail": "deps.sample-factory.sf_examples.dmlab.dmlab30",
        "documentation": {}
    },
    {
        "label": "dmlab30_level_name_to_level",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.dmlab.dmlab30",
        "description": "deps.sample-factory.sf_examples.dmlab.dmlab30",
        "peekOfCode": "def dmlab30_level_name_to_level(level_name):\n    return f\"contributed/dmlab30/{level_name}\"",
        "detail": "deps.sample-factory.sf_examples.dmlab.dmlab30",
        "documentation": {}
    },
    {
        "label": "DMLAB_INSTRUCTIONS",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.dmlab.dmlab30",
        "description": "deps.sample-factory.sf_examples.dmlab.dmlab30",
        "peekOfCode": "DMLAB_INSTRUCTIONS = \"INSTR\"\nDMLAB_VOCABULARY_SIZE = 1000\nDMLAB_MAX_INSTRUCTION_LEN = 16\nLEVEL_MAPPING = collections.OrderedDict(\n    [\n        (\"rooms_collect_good_objects_train\", \"rooms_collect_good_objects_test\"),\n        (\"rooms_exploit_deferred_effects_train\", \"rooms_exploit_deferred_effects_test\"),\n        (\"rooms_select_nonmatching_object\", \"rooms_select_nonmatching_object\"),\n        (\"rooms_watermaze\", \"rooms_watermaze\"),\n        (\"rooms_keys_doors_puzzle\", \"rooms_keys_doors_puzzle\"),",
        "detail": "deps.sample-factory.sf_examples.dmlab.dmlab30",
        "documentation": {}
    },
    {
        "label": "DMLAB_VOCABULARY_SIZE",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.dmlab.dmlab30",
        "description": "deps.sample-factory.sf_examples.dmlab.dmlab30",
        "peekOfCode": "DMLAB_VOCABULARY_SIZE = 1000\nDMLAB_MAX_INSTRUCTION_LEN = 16\nLEVEL_MAPPING = collections.OrderedDict(\n    [\n        (\"rooms_collect_good_objects_train\", \"rooms_collect_good_objects_test\"),\n        (\"rooms_exploit_deferred_effects_train\", \"rooms_exploit_deferred_effects_test\"),\n        (\"rooms_select_nonmatching_object\", \"rooms_select_nonmatching_object\"),\n        (\"rooms_watermaze\", \"rooms_watermaze\"),\n        (\"rooms_keys_doors_puzzle\", \"rooms_keys_doors_puzzle\"),\n        (\"language_select_described_object\", \"language_select_described_object\"),",
        "detail": "deps.sample-factory.sf_examples.dmlab.dmlab30",
        "documentation": {}
    },
    {
        "label": "DMLAB_MAX_INSTRUCTION_LEN",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.dmlab.dmlab30",
        "description": "deps.sample-factory.sf_examples.dmlab.dmlab30",
        "peekOfCode": "DMLAB_MAX_INSTRUCTION_LEN = 16\nLEVEL_MAPPING = collections.OrderedDict(\n    [\n        (\"rooms_collect_good_objects_train\", \"rooms_collect_good_objects_test\"),\n        (\"rooms_exploit_deferred_effects_train\", \"rooms_exploit_deferred_effects_test\"),\n        (\"rooms_select_nonmatching_object\", \"rooms_select_nonmatching_object\"),\n        (\"rooms_watermaze\", \"rooms_watermaze\"),\n        (\"rooms_keys_doors_puzzle\", \"rooms_keys_doors_puzzle\"),\n        (\"language_select_described_object\", \"language_select_described_object\"),\n        (\"language_select_located_object\", \"language_select_located_object\"),",
        "detail": "deps.sample-factory.sf_examples.dmlab.dmlab30",
        "documentation": {}
    },
    {
        "label": "LEVEL_MAPPING",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.dmlab.dmlab30",
        "description": "deps.sample-factory.sf_examples.dmlab.dmlab30",
        "peekOfCode": "LEVEL_MAPPING = collections.OrderedDict(\n    [\n        (\"rooms_collect_good_objects_train\", \"rooms_collect_good_objects_test\"),\n        (\"rooms_exploit_deferred_effects_train\", \"rooms_exploit_deferred_effects_test\"),\n        (\"rooms_select_nonmatching_object\", \"rooms_select_nonmatching_object\"),\n        (\"rooms_watermaze\", \"rooms_watermaze\"),\n        (\"rooms_keys_doors_puzzle\", \"rooms_keys_doors_puzzle\"),\n        (\"language_select_described_object\", \"language_select_described_object\"),\n        (\"language_select_located_object\", \"language_select_located_object\"),\n        (\"language_execute_random_task\", \"language_execute_random_task\"),",
        "detail": "deps.sample-factory.sf_examples.dmlab.dmlab30",
        "documentation": {}
    },
    {
        "label": "DMLAB30_LEVELS",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.dmlab.dmlab30",
        "description": "deps.sample-factory.sf_examples.dmlab.dmlab30",
        "peekOfCode": "DMLAB30_LEVELS = tuple(LEVEL_MAPPING.keys())\nHUMAN_SCORES = {\n    \"rooms_collect_good_objects_test\": 10,\n    \"rooms_exploit_deferred_effects_test\": 85.65,\n    \"rooms_select_nonmatching_object\": 65.9,\n    \"rooms_watermaze\": 54,\n    \"rooms_keys_doors_puzzle\": 53.8,\n    \"language_select_described_object\": 389.5,\n    \"language_select_located_object\": 280.7,\n    \"language_execute_random_task\": 254.05,",
        "detail": "deps.sample-factory.sf_examples.dmlab.dmlab30",
        "documentation": {}
    },
    {
        "label": "HUMAN_SCORES",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.dmlab.dmlab30",
        "description": "deps.sample-factory.sf_examples.dmlab.dmlab30",
        "peekOfCode": "HUMAN_SCORES = {\n    \"rooms_collect_good_objects_test\": 10,\n    \"rooms_exploit_deferred_effects_test\": 85.65,\n    \"rooms_select_nonmatching_object\": 65.9,\n    \"rooms_watermaze\": 54,\n    \"rooms_keys_doors_puzzle\": 53.8,\n    \"language_select_described_object\": 389.5,\n    \"language_select_located_object\": 280.7,\n    \"language_execute_random_task\": 254.05,\n    \"language_answer_quantitative_question\": 184.5,",
        "detail": "deps.sample-factory.sf_examples.dmlab.dmlab30",
        "documentation": {}
    },
    {
        "label": "RANDOM_SCORES",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.dmlab.dmlab30",
        "description": "deps.sample-factory.sf_examples.dmlab.dmlab30",
        "peekOfCode": "RANDOM_SCORES = {\n    \"rooms_collect_good_objects_test\": 0.073,\n    \"rooms_exploit_deferred_effects_test\": 8.501,\n    \"rooms_select_nonmatching_object\": 0.312,\n    \"rooms_watermaze\": 4.065,\n    \"rooms_keys_doors_puzzle\": 4.135,\n    \"language_select_described_object\": -0.07,\n    \"language_select_located_object\": 1.929,\n    \"language_execute_random_task\": -5.913,\n    \"language_answer_quantitative_question\": -0.33,",
        "detail": "deps.sample-factory.sf_examples.dmlab.dmlab30",
        "documentation": {}
    },
    {
        "label": "RANDOM_POLICY_EPISODE_LEN",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.dmlab.dmlab30",
        "description": "deps.sample-factory.sf_examples.dmlab.dmlab30",
        "peekOfCode": "RANDOM_POLICY_EPISODE_LEN = {\n    \"rooms_collect_good_objects_train\": 3600,\n    \"rooms_exploit_deferred_effects_train\": 3600,\n    \"rooms_select_nonmatching_object\": 720,\n    \"rooms_watermaze\": 7200,\n    \"rooms_keys_doors_puzzle\": 3468,\n    \"language_select_described_object\": 3600,\n    \"language_select_located_object\": 7200,\n    \"language_execute_random_task\": 7200,\n    \"language_answer_quantitative_question\": 3600,",
        "detail": "deps.sample-factory.sf_examples.dmlab.dmlab30",
        "documentation": {}
    },
    {
        "label": "DMLAB30_APPROX_NUM_EPISODES_PER_BILLION_FRAMES",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.dmlab.dmlab30",
        "description": "deps.sample-factory.sf_examples.dmlab.dmlab30",
        "peekOfCode": "DMLAB30_APPROX_NUM_EPISODES_PER_BILLION_FRAMES = {\n    \"rooms_keys_doors_puzzle\": 11200,\n    \"lasertag_one_opponent_small\": 2400,\n    \"lasertag_three_opponents_small\": 2400,\n    \"lasertag_one_opponent_large\": 2400,\n    \"lasertag_three_opponents_large\": 2400,\n    \"skymaze_irreversible_path_hard\": 11200,\n    \"skymaze_irreversible_path_varied\": 13500,\n    \"explore_object_locations_small\": 6200,\n    \"explore_object_locations_large\": 4700,",
        "detail": "deps.sample-factory.sf_examples.dmlab.dmlab30",
        "documentation": {}
    },
    {
        "label": "DMLAB30_LEVELS_THAT_USE_LEVEL_CACHE",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.dmlab.dmlab30",
        "description": "deps.sample-factory.sf_examples.dmlab.dmlab30",
        "peekOfCode": "DMLAB30_LEVELS_THAT_USE_LEVEL_CACHE = tuple(DMLAB30_APPROX_NUM_EPISODES_PER_BILLION_FRAMES.keys())\ndef dmlab30_num_envs():\n    num_envs = len(tuple(LEVEL_MAPPING.keys()))\n    return num_envs\ndef dmlab30_level_name_to_level(level_name):\n    return f\"contributed/dmlab30/{level_name}\"",
        "detail": "deps.sample-factory.sf_examples.dmlab.dmlab30",
        "documentation": {}
    },
    {
        "label": "DmLabSpec",
        "kind": 6,
        "importPath": "deps.sample-factory.sf_examples.dmlab.dmlab_env",
        "description": "deps.sample-factory.sf_examples.dmlab.dmlab_env",
        "peekOfCode": "class DmLabSpec:\n    def __init__(self, name, level, extra_cfg=None):\n        self.name = name\n        self.level = level\n        self.extra_cfg = {} if extra_cfg is None else extra_cfg\nDMLAB_ENVS = [\n    DmLabSpec(\"dmlab_benchmark\", \"contributed/dmlab30/rooms_collect_good_objects_train\"),\n    # train a single agent for all 30 DMLab tasks\n    DmLabSpec(\"dmlab_30\", [dmlab30_level_name_to_level(lvl) for lvl in DMLAB30_LEVELS]),\n    DmLabSpec(\"dmlab_level_cache\", [dmlab30_level_name_to_level(lvl) for lvl in DMLAB30_LEVELS_THAT_USE_LEVEL_CACHE]),",
        "detail": "deps.sample-factory.sf_examples.dmlab.dmlab_env",
        "documentation": {}
    },
    {
        "label": "get_dataset_path",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.dmlab.dmlab_env",
        "description": "deps.sample-factory.sf_examples.dmlab.dmlab_env",
        "peekOfCode": "def get_dataset_path(cfg):\n    cfg_dataset_path = os.path.expanduser(cfg.dmlab30_dataset)\n    return cfg_dataset_path\nclass DmLabSpec:\n    def __init__(self, name, level, extra_cfg=None):\n        self.name = name\n        self.level = level\n        self.extra_cfg = {} if extra_cfg is None else extra_cfg\nDMLAB_ENVS = [\n    DmLabSpec(\"dmlab_benchmark\", \"contributed/dmlab30/rooms_collect_good_objects_train\"),",
        "detail": "deps.sample-factory.sf_examples.dmlab.dmlab_env",
        "documentation": {}
    },
    {
        "label": "dmlab_env_by_name",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.dmlab.dmlab_env",
        "description": "deps.sample-factory.sf_examples.dmlab.dmlab_env",
        "peekOfCode": "def dmlab_env_by_name(name):\n    for spec in DMLAB_ENVS:\n        if spec.name == name:\n            return spec\n    # not a known \"named\" environment with a predefined spec\n    log.warning(\"Level %s not found. Interpreting the level name as an unmodified DMLab-30 env name!\", name)\n    level = name.split(\"dmlab_\")[1]\n    spec = DmLabSpec(name, level)\n    return spec\ndef get_task_id(env_config, spec, cfg):",
        "detail": "deps.sample-factory.sf_examples.dmlab.dmlab_env",
        "documentation": {}
    },
    {
        "label": "get_task_id",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.dmlab.dmlab_env",
        "description": "deps.sample-factory.sf_examples.dmlab.dmlab_env",
        "peekOfCode": "def get_task_id(env_config, spec, cfg):\n    if env_config is None:\n        return 0\n    elif isinstance(spec.level, str):\n        return 0\n    elif isinstance(spec.level, (list, tuple)):\n        num_envs = len(spec.level)\n        if cfg.dmlab_one_task_per_worker:\n            return env_config[\"worker_index\"] % num_envs\n        else:",
        "detail": "deps.sample-factory.sf_examples.dmlab.dmlab_env",
        "documentation": {}
    },
    {
        "label": "task_id_to_level",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.dmlab.dmlab_env",
        "description": "deps.sample-factory.sf_examples.dmlab.dmlab_env",
        "peekOfCode": "def task_id_to_level(task_id, spec):\n    if isinstance(spec.level, str):\n        return spec.level\n    elif isinstance(spec.level, (list, tuple)):\n        levels = spec.level\n        level = levels[task_id]\n        return level\n    else:\n        raise Exception(\"spec level is either string or a list/tuple\")\ndef list_all_levels_for_experiment(env_name):",
        "detail": "deps.sample-factory.sf_examples.dmlab.dmlab_env",
        "documentation": {}
    },
    {
        "label": "list_all_levels_for_experiment",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.dmlab.dmlab_env",
        "description": "deps.sample-factory.sf_examples.dmlab.dmlab_env",
        "peekOfCode": "def list_all_levels_for_experiment(env_name):\n    spec = dmlab_env_by_name(env_name)\n    if isinstance(spec.level, str):\n        return [spec.level]\n    elif isinstance(spec.level, (list, tuple)):\n        levels = spec.level\n        return levels\n    else:\n        raise Exception(\"spec level is either string or a list/tuple\")\ndef make_dmlab_env_impl(",
        "detail": "deps.sample-factory.sf_examples.dmlab.dmlab_env",
        "documentation": {}
    },
    {
        "label": "make_dmlab_env_impl",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.dmlab.dmlab_env",
        "description": "deps.sample-factory.sf_examples.dmlab.dmlab_env",
        "peekOfCode": "def make_dmlab_env_impl(\n    spec,\n    cfg,\n    env_config,\n    render_mode: Optional[str] = None,\n    dmlab_level_caches_per_policy: Dict[PolicyID, DmlabLevelCache] = None,\n    **_kwargs,\n):\n    skip_frames = cfg.env_frameskip\n    gpu_idx = 0",
        "detail": "deps.sample-factory.sf_examples.dmlab.dmlab_env",
        "documentation": {}
    },
    {
        "label": "make_dmlab_env",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.dmlab.dmlab_env",
        "description": "deps.sample-factory.sf_examples.dmlab.dmlab_env",
        "peekOfCode": "def make_dmlab_env(\n    env_name,\n    cfg,\n    env_config,\n    render_mode: Optional[str] = None,\n    dmlab_level_caches_per_policy: Optional[DmlabLevelCaches] = None,\n):\n    spec = dmlab_env_by_name(env_name)\n    return make_dmlab_env_impl(spec, cfg, env_config, render_mode, dmlab_level_caches_per_policy)\n@static_vars(new_level_returns=dict(), env_spec=None)",
        "detail": "deps.sample-factory.sf_examples.dmlab.dmlab_env",
        "documentation": {}
    },
    {
        "label": "dmlab_extra_episodic_stats_processing",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.dmlab.dmlab_env",
        "description": "deps.sample-factory.sf_examples.dmlab.dmlab_env",
        "peekOfCode": "def dmlab_extra_episodic_stats_processing(runner: Runner, msg: Dict, policy_id: PolicyID) -> None:\n    episode_stats = msg[EPISODIC].get(\"episode_extra_stats\", {})\n    for stat_key, stat_value in episode_stats.items():\n        if RAW_SCORE_SUMMARY_KEY_SUFFIX in stat_key:\n            new_level_returns = dmlab_extra_episodic_stats_processing.new_level_returns\n            if policy_id not in new_level_returns:\n                new_level_returns[policy_id] = dict()\n            if dmlab_extra_episodic_stats_processing.env_spec is None:\n                dmlab_extra_episodic_stats_processing.env_spec = dmlab_env_by_name(runner.cfg.env)\n            task_id = int(stat_key.split(\"_\")[1])  # this is a bit hacky but should do the job",
        "detail": "deps.sample-factory.sf_examples.dmlab.dmlab_env",
        "documentation": {}
    },
    {
        "label": "dmlab_extra_summaries",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.dmlab.dmlab_env",
        "description": "deps.sample-factory.sf_examples.dmlab.dmlab_env",
        "peekOfCode": "def dmlab_extra_summaries(runner: Runner, policy_id: PolicyID, env_steps: int, summary_writer: SummaryWriter) -> None:\n    \"\"\"\n    We precisely follow IMPALA repo (scalable_agent) here for the reward calculation.\n    The procedure is:\n    1. Calculate mean raw episode score for the last few episodes for each level\n    2. Calculate human-normalized score using this mean value\n    3. Calculate capped score\n    The key point is that human-normalization and capping is done AFTER mean, which can lead to slighly higher capped\n    scores for levels that exceed the human baseline.\n    Another important point: we write the avg score summary only when we have at least one episode result for every",
        "detail": "deps.sample-factory.sf_examples.dmlab.dmlab_env",
        "documentation": {}
    },
    {
        "label": "DMLAB_ENVS",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.dmlab.dmlab_env",
        "description": "deps.sample-factory.sf_examples.dmlab.dmlab_env",
        "peekOfCode": "DMLAB_ENVS = [\n    DmLabSpec(\"dmlab_benchmark\", \"contributed/dmlab30/rooms_collect_good_objects_train\"),\n    # train a single agent for all 30 DMLab tasks\n    DmLabSpec(\"dmlab_30\", [dmlab30_level_name_to_level(lvl) for lvl in DMLAB30_LEVELS]),\n    DmLabSpec(\"dmlab_level_cache\", [dmlab30_level_name_to_level(lvl) for lvl in DMLAB30_LEVELS_THAT_USE_LEVEL_CACHE]),\n    # this is very hard to work with as a benchmark, because FPS fluctuates a lot due to slow resets.\n    # also depends a lot on whether levels are in level cache or not\n    DmLabSpec(\"dmlab_benchmark_slow_reset\", \"contributed/dmlab30/rooms_keys_doors_puzzle\"),\n    DmLabSpec(\"dmlab_sparse\", \"contributed/dmlab30/explore_goal_locations_large\"),\n    DmLabSpec(",
        "detail": "deps.sample-factory.sf_examples.dmlab.dmlab_env",
        "documentation": {}
    },
    {
        "label": "DmlabGymEnv",
        "kind": 6,
        "importPath": "deps.sample-factory.sf_examples.dmlab.dmlab_gym",
        "description": "deps.sample-factory.sf_examples.dmlab.dmlab_gym",
        "peekOfCode": "class DmlabGymEnv(gym.Env):\n    def __init__(\n        self,\n        task_id,\n        level,\n        action_repeat,\n        res_w,\n        res_h,\n        benchmark_mode,\n        renderer,",
        "detail": "deps.sample-factory.sf_examples.dmlab.dmlab_gym",
        "documentation": {}
    },
    {
        "label": "dmlab_level_to_level_name",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.dmlab.dmlab_gym",
        "description": "deps.sample-factory.sf_examples.dmlab.dmlab_gym",
        "peekOfCode": "def dmlab_level_to_level_name(level):\n    level_name = level.split(\"/\")[-1]\n    return level_name\nclass DmlabGymEnv(gym.Env):\n    def __init__(\n        self,\n        task_id,\n        level,\n        action_repeat,\n        res_w,",
        "detail": "deps.sample-factory.sf_examples.dmlab.dmlab_gym",
        "documentation": {}
    },
    {
        "label": "ACTION_SET",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.dmlab.dmlab_gym",
        "description": "deps.sample-factory.sf_examples.dmlab.dmlab_gym",
        "peekOfCode": "ACTION_SET = (\n    (0, 0, 0, 1, 0, 0, 0),  # Forward\n    (0, 0, 0, -1, 0, 0, 0),  # Backward\n    (0, 0, -1, 0, 0, 0, 0),  # Strafe Left\n    (0, 0, 1, 0, 0, 0, 0),  # Strafe Right\n    (-20, 0, 0, 0, 0, 0, 0),  # Look Left\n    (20, 0, 0, 0, 0, 0, 0),  # Look Right\n    (-20, 0, 0, 1, 0, 0, 0),  # Look Left + Forward\n    (20, 0, 0, 1, 0, 0, 0),  # Look Right + Forward\n    (0, 0, 0, 0, 1, 0, 0),  # Fire.",
        "detail": "deps.sample-factory.sf_examples.dmlab.dmlab_gym",
        "documentation": {}
    },
    {
        "label": "EXTENDED_ACTION_SET",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.dmlab.dmlab_gym",
        "description": "deps.sample-factory.sf_examples.dmlab.dmlab_gym",
        "peekOfCode": "EXTENDED_ACTION_SET = (\n    (0, 0, 0, 1, 0, 0, 0),  # Forward\n    (0, 0, 0, -1, 0, 0, 0),  # Backward\n    (0, 0, -1, 0, 0, 0, 0),  # Strafe Left\n    (0, 0, 1, 0, 0, 0, 0),  # Strafe Right\n    (-10, 0, 0, 0, 0, 0, 0),  # Small Look Left\n    (10, 0, 0, 0, 0, 0, 0),  # Small Look Right\n    (-60, 0, 0, 0, 0, 0, 0),  # Large Look Left\n    (60, 0, 0, 0, 0, 0, 0),  # Large Look Right\n    (0, 10, 0, 0, 0, 0, 0),  # Look Down",
        "detail": "deps.sample-factory.sf_examples.dmlab.dmlab_gym",
        "documentation": {}
    },
    {
        "label": "DmlabLevelCache",
        "kind": 6,
        "importPath": "deps.sample-factory.sf_examples.dmlab.dmlab_level_cache",
        "description": "deps.sample-factory.sf_examples.dmlab.dmlab_level_cache",
        "peekOfCode": "class DmlabLevelCache:\n    \"\"\"\n    This is a global DMLab level cache designed to be shared across multiple worker processes.\n    Here's how it works:\n    1) We pre-generate a number of maps for environments that require level generation by either running the\n    experiment without caching, or by using a specifically designed script. The generated levels are\n    stored in the cache directory, and the correspondence from seed to the level is stored in separate *.dm_lvl_seeds\n    files, e.g. a list of seeds present in the cache for each of the environments\n    2) When we start a new experiment, we read all the available *.dm_lvl_seeds files in the cache dir. As long as\n    we have available pre-generated levels we will only use seeds that correspond to these levels to avoid costly",
        "detail": "deps.sample-factory.sf_examples.dmlab.dmlab_level_cache",
        "documentation": {}
    },
    {
        "label": "filename_to_level",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.dmlab.dmlab_level_cache",
        "description": "deps.sample-factory.sf_examples.dmlab.dmlab_level_cache",
        "peekOfCode": "def filename_to_level(filename):\n    level = filename.split(\".\")[0]\n    level = level[1:]  # remove leading underscore\n    return level\ndef level_to_filename(level):\n    # add leading underscore so these folders appear at the top of cache dir (to simplify debugging)\n    filename = f\"_{level}.{LEVEL_SEEDS_FILE_EXT}\"\n    return filename\ndef read_seeds_file(filename, has_keys):\n    seeds = []",
        "detail": "deps.sample-factory.sf_examples.dmlab.dmlab_level_cache",
        "documentation": {}
    },
    {
        "label": "level_to_filename",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.dmlab.dmlab_level_cache",
        "description": "deps.sample-factory.sf_examples.dmlab.dmlab_level_cache",
        "peekOfCode": "def level_to_filename(level):\n    # add leading underscore so these folders appear at the top of cache dir (to simplify debugging)\n    filename = f\"_{level}.{LEVEL_SEEDS_FILE_EXT}\"\n    return filename\ndef read_seeds_file(filename, has_keys):\n    seeds = []\n    with open(filename, \"r\") as seed_file:\n        lines = seed_file.readlines()\n        for line in lines:\n            try:",
        "detail": "deps.sample-factory.sf_examples.dmlab.dmlab_level_cache",
        "documentation": {}
    },
    {
        "label": "read_seeds_file",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.dmlab.dmlab_level_cache",
        "description": "deps.sample-factory.sf_examples.dmlab.dmlab_level_cache",
        "peekOfCode": "def read_seeds_file(filename, has_keys):\n    seeds = []\n    with open(filename, \"r\") as seed_file:\n        lines = seed_file.readlines()\n        for line in lines:\n            try:\n                if has_keys:\n                    seed, cache_key = line.split(\" \")\n                else:\n                    seed = line",
        "detail": "deps.sample-factory.sf_examples.dmlab.dmlab_level_cache",
        "documentation": {}
    },
    {
        "label": "make_dmlab_caches",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.dmlab.dmlab_level_cache",
        "description": "deps.sample-factory.sf_examples.dmlab.dmlab_level_cache",
        "peekOfCode": "def make_dmlab_caches(\n    experiment_dir,\n    all_levels_for_experiment,\n    num_policies,\n    level_cache_dir,\n    mp_ctx: BaseContext,\n) -> DmlabLevelCaches:\n    caches = dict()\n    for policy_id in range(num_policies):\n        log.info(\"Initializing level cache for policy %d...\", policy_id)",
        "detail": "deps.sample-factory.sf_examples.dmlab.dmlab_level_cache",
        "documentation": {}
    },
    {
        "label": "LEVEL_SEEDS_FILE_EXT",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.dmlab.dmlab_level_cache",
        "description": "deps.sample-factory.sf_examples.dmlab.dmlab_level_cache",
        "peekOfCode": "LEVEL_SEEDS_FILE_EXT = \"dm_lvl_seeds\"\n# we normally don't need more than 30 tasks (for DMLab-30), or 57 tasks for Atari\nMAX_NUM_TASKS = 64\ndef filename_to_level(filename):\n    level = filename.split(\".\")[0]\n    level = level[1:]  # remove leading underscore\n    return level\ndef level_to_filename(level):\n    # add leading underscore so these folders appear at the top of cache dir (to simplify debugging)\n    filename = f\"_{level}.{LEVEL_SEEDS_FILE_EXT}\"",
        "detail": "deps.sample-factory.sf_examples.dmlab.dmlab_level_cache",
        "documentation": {}
    },
    {
        "label": "MAX_NUM_TASKS",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.dmlab.dmlab_level_cache",
        "description": "deps.sample-factory.sf_examples.dmlab.dmlab_level_cache",
        "peekOfCode": "MAX_NUM_TASKS = 64\ndef filename_to_level(filename):\n    level = filename.split(\".\")[0]\n    level = level[1:]  # remove leading underscore\n    return level\ndef level_to_filename(level):\n    # add leading underscore so these folders appear at the top of cache dir (to simplify debugging)\n    filename = f\"_{level}.{LEVEL_SEEDS_FILE_EXT}\"\n    return filename\ndef read_seeds_file(filename, has_keys):",
        "detail": "deps.sample-factory.sf_examples.dmlab.dmlab_level_cache",
        "documentation": {}
    },
    {
        "label": "DmlabLevelCaches",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.dmlab.dmlab_level_cache",
        "description": "deps.sample-factory.sf_examples.dmlab.dmlab_level_cache",
        "peekOfCode": "DmlabLevelCaches = Dict[PolicyID, DmlabLevelCache]\ndef make_dmlab_caches(\n    experiment_dir,\n    all_levels_for_experiment,\n    num_policies,\n    level_cache_dir,\n    mp_ctx: BaseContext,\n) -> DmlabLevelCaches:\n    caches = dict()\n    for policy_id in range(num_policies):",
        "detail": "deps.sample-factory.sf_examples.dmlab.dmlab_level_cache",
        "documentation": {}
    },
    {
        "label": "DmlabEncoder",
        "kind": 6,
        "importPath": "deps.sample-factory.sf_examples.dmlab.dmlab_model",
        "description": "deps.sample-factory.sf_examples.dmlab.dmlab_model",
        "peekOfCode": "class DmlabEncoder(Encoder):\n    def __init__(self, cfg: Config, obs_space: ObsSpace):\n        super().__init__(cfg)\n        self.basic_encoder = make_img_encoder(cfg, obs_space[\"obs\"])\n        self.encoder_out_size = self.basic_encoder.get_out_size()\n        # same as IMPALA paper\n        self.embedding_size = 20\n        self.instructions_lstm_units = 64\n        self.instructions_lstm_layers = 1\n        padding_idx = 0",
        "detail": "deps.sample-factory.sf_examples.dmlab.dmlab_model",
        "documentation": {}
    },
    {
        "label": "make_dmlab_encoder",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.dmlab.dmlab_model",
        "description": "deps.sample-factory.sf_examples.dmlab.dmlab_model",
        "peekOfCode": "def make_dmlab_encoder(cfg: Config, obs_space: ObsSpace) -> Encoder:\n    return DmlabEncoder(cfg, obs_space)",
        "detail": "deps.sample-factory.sf_examples.dmlab.dmlab_model",
        "documentation": {}
    },
    {
        "label": "dmlab_override_defaults",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.dmlab.dmlab_params",
        "description": "deps.sample-factory.sf_examples.dmlab.dmlab_params",
        "peekOfCode": "def dmlab_override_defaults(parser: argparse.ArgumentParser) -> None:\n    parser.set_defaults(\n        encoder_conv_architecture=\"convnet_impala\",\n        obs_subtract_mean=0.0,\n        obs_scale=255.0,\n        env_frameskip=4,\n        nonlinearity=\"relu\",\n        rollout=32,\n        recurrence=32,\n        rnn_type=\"lstm\",",
        "detail": "deps.sample-factory.sf_examples.dmlab.dmlab_params",
        "documentation": {}
    },
    {
        "label": "add_dmlab_env_args",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.dmlab.dmlab_params",
        "description": "deps.sample-factory.sf_examples.dmlab.dmlab_params",
        "peekOfCode": "def add_dmlab_env_args(parser: argparse.ArgumentParser) -> None:\n    p = parser\n    p.add_argument(\"--res_w\", default=96, type=int, help=\"Game frame width after resize\")\n    p.add_argument(\"--res_h\", default=72, type=int, help=\"Game frame height after resize\")\n    p.add_argument(\n        \"--dmlab_throughput_benchmark\",\n        default=False,\n        type=str2bool,\n        help=\"Execute random policy for performance measurements\",\n    )",
        "detail": "deps.sample-factory.sf_examples.dmlab.dmlab_params",
        "documentation": {}
    },
    {
        "label": "dmlab_available",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.dmlab.dmlab_utils",
        "description": "deps.sample-factory.sf_examples.dmlab.dmlab_utils",
        "peekOfCode": "def dmlab_available():\n    return is_module_available(\"deepmind_lab\")\ndef string_to_hash_bucket(s, vocabulary_size):\n    return (int(hashlib.md5(s.encode(\"utf-8\")).hexdigest(), 16) % (vocabulary_size - 1)) + 1",
        "detail": "deps.sample-factory.sf_examples.dmlab.dmlab_utils",
        "documentation": {}
    },
    {
        "label": "string_to_hash_bucket",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.dmlab.dmlab_utils",
        "description": "deps.sample-factory.sf_examples.dmlab.dmlab_utils",
        "peekOfCode": "def string_to_hash_bucket(s, vocabulary_size):\n    return (int(hashlib.md5(s.encode(\"utf-8\")).hexdigest(), 16) % (vocabulary_size - 1)) + 1",
        "detail": "deps.sample-factory.sf_examples.dmlab.dmlab_utils",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.dmlab.enjoy_dmlab",
        "description": "deps.sample-factory.sf_examples.dmlab.enjoy_dmlab",
        "peekOfCode": "def main():\n    \"\"\"Script entry point.\"\"\"\n    register_dmlab_components()\n    cfg = parse_dmlab_args(evaluation=True)\n    status = enjoy(cfg)\n    return status\nif __name__ == \"__main__\":\n    sys.exit(main())",
        "detail": "deps.sample-factory.sf_examples.dmlab.enjoy_dmlab",
        "documentation": {}
    },
    {
        "label": "DmlabEnvWithCache",
        "kind": 6,
        "importPath": "deps.sample-factory.sf_examples.dmlab.train_dmlab",
        "description": "deps.sample-factory.sf_examples.dmlab.train_dmlab",
        "peekOfCode": "class DmlabEnvWithCache:\n    def __init__(self, level_caches: Optional[DmlabLevelCaches] = None):\n        self.caches = level_caches\n    def make_env(self, env_name, cfg, env_config, render_mode) -> Env:\n        return make_dmlab_env(env_name, cfg, env_config, render_mode, self.caches)\ndef register_dmlab_envs(level_caches: Optional[DmlabLevelCaches] = None):\n    env_factory = DmlabEnvWithCache(level_caches)\n    for env in DMLAB_ENVS:\n        register_env(env.name, env_factory.make_env)\ndef register_dmlab_components(level_caches: Optional[DmlabLevelCaches] = None):",
        "detail": "deps.sample-factory.sf_examples.dmlab.train_dmlab",
        "documentation": {}
    },
    {
        "label": "DmlabExtraSummariesObserver",
        "kind": 6,
        "importPath": "deps.sample-factory.sf_examples.dmlab.train_dmlab",
        "description": "deps.sample-factory.sf_examples.dmlab.train_dmlab",
        "peekOfCode": "class DmlabExtraSummariesObserver(AlgoObserver):\n    def extra_summaries(self, runner: Runner, policy_id: PolicyID, writer: SummaryWriter, env_steps: int) -> None:\n        dmlab_extra_summaries(runner, policy_id, env_steps, writer)\ndef register_msg_handlers(cfg: Config, runner: Runner):\n    if cfg.env == \"dmlab_30\":\n        # extra functions to calculate human-normalized score etc.\n        runner.register_episodic_stats_handler(dmlab_extra_episodic_stats_processing)\n        runner.register_observer(DmlabExtraSummariesObserver())\ndef initialize_level_cache(cfg: Config, mp_ctx: BaseContext) -> Optional[DmlabLevelCaches]:\n    if not cfg.dmlab_use_level_cache:",
        "detail": "deps.sample-factory.sf_examples.dmlab.train_dmlab",
        "documentation": {}
    },
    {
        "label": "register_dmlab_envs",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.dmlab.train_dmlab",
        "description": "deps.sample-factory.sf_examples.dmlab.train_dmlab",
        "peekOfCode": "def register_dmlab_envs(level_caches: Optional[DmlabLevelCaches] = None):\n    env_factory = DmlabEnvWithCache(level_caches)\n    for env in DMLAB_ENVS:\n        register_env(env.name, env_factory.make_env)\ndef register_dmlab_components(level_caches: Optional[DmlabLevelCaches] = None):\n    register_dmlab_envs(level_caches)\n    global_model_factory().register_encoder_factory(make_dmlab_encoder)\nclass DmlabExtraSummariesObserver(AlgoObserver):\n    def extra_summaries(self, runner: Runner, policy_id: PolicyID, writer: SummaryWriter, env_steps: int) -> None:\n        dmlab_extra_summaries(runner, policy_id, env_steps, writer)",
        "detail": "deps.sample-factory.sf_examples.dmlab.train_dmlab",
        "documentation": {}
    },
    {
        "label": "register_dmlab_components",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.dmlab.train_dmlab",
        "description": "deps.sample-factory.sf_examples.dmlab.train_dmlab",
        "peekOfCode": "def register_dmlab_components(level_caches: Optional[DmlabLevelCaches] = None):\n    register_dmlab_envs(level_caches)\n    global_model_factory().register_encoder_factory(make_dmlab_encoder)\nclass DmlabExtraSummariesObserver(AlgoObserver):\n    def extra_summaries(self, runner: Runner, policy_id: PolicyID, writer: SummaryWriter, env_steps: int) -> None:\n        dmlab_extra_summaries(runner, policy_id, env_steps, writer)\ndef register_msg_handlers(cfg: Config, runner: Runner):\n    if cfg.env == \"dmlab_30\":\n        # extra functions to calculate human-normalized score etc.\n        runner.register_episodic_stats_handler(dmlab_extra_episodic_stats_processing)",
        "detail": "deps.sample-factory.sf_examples.dmlab.train_dmlab",
        "documentation": {}
    },
    {
        "label": "register_msg_handlers",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.dmlab.train_dmlab",
        "description": "deps.sample-factory.sf_examples.dmlab.train_dmlab",
        "peekOfCode": "def register_msg_handlers(cfg: Config, runner: Runner):\n    if cfg.env == \"dmlab_30\":\n        # extra functions to calculate human-normalized score etc.\n        runner.register_episodic_stats_handler(dmlab_extra_episodic_stats_processing)\n        runner.register_observer(DmlabExtraSummariesObserver())\ndef initialize_level_cache(cfg: Config, mp_ctx: BaseContext) -> Optional[DmlabLevelCaches]:\n    if not cfg.dmlab_use_level_cache:\n        return None\n    env_name = cfg.env\n    num_policies = cfg.num_policies if hasattr(cfg, \"num_policies\") else 1",
        "detail": "deps.sample-factory.sf_examples.dmlab.train_dmlab",
        "documentation": {}
    },
    {
        "label": "initialize_level_cache",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.dmlab.train_dmlab",
        "description": "deps.sample-factory.sf_examples.dmlab.train_dmlab",
        "peekOfCode": "def initialize_level_cache(cfg: Config, mp_ctx: BaseContext) -> Optional[DmlabLevelCaches]:\n    if not cfg.dmlab_use_level_cache:\n        return None\n    env_name = cfg.env\n    num_policies = cfg.num_policies if hasattr(cfg, \"num_policies\") else 1\n    all_levels = list_all_levels_for_experiment(env_name)\n    level_cache_dir = cfg.dmlab_level_cache_path\n    caches = make_dmlab_caches(experiment_dir(cfg), all_levels, num_policies, level_cache_dir, mp_ctx)\n    return caches\ndef parse_dmlab_args(argv=None, evaluation=False):",
        "detail": "deps.sample-factory.sf_examples.dmlab.train_dmlab",
        "documentation": {}
    },
    {
        "label": "parse_dmlab_args",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.dmlab.train_dmlab",
        "description": "deps.sample-factory.sf_examples.dmlab.train_dmlab",
        "peekOfCode": "def parse_dmlab_args(argv=None, evaluation=False):\n    parser, cfg = parse_sf_args(argv, evaluation=evaluation)\n    add_dmlab_env_args(parser)\n    dmlab_override_defaults(parser)\n    cfg = parse_full_cfg(parser, argv)\n    return cfg\ndef main():\n    \"\"\"Script entry point.\"\"\"\n    cfg = parse_dmlab_args()\n    # explicitly create the runner instead of simply calling run_rl()",
        "detail": "deps.sample-factory.sf_examples.dmlab.train_dmlab",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.dmlab.train_dmlab",
        "description": "deps.sample-factory.sf_examples.dmlab.train_dmlab",
        "peekOfCode": "def main():\n    \"\"\"Script entry point.\"\"\"\n    cfg = parse_dmlab_args()\n    # explicitly create the runner instead of simply calling run_rl()\n    # this allows us to register additional message handlers\n    cfg, runner = make_runner(cfg)\n    register_msg_handlers(cfg, runner)\n    level_caches = initialize_level_cache(cfg, get_mp_ctx(cfg.serial_mode))\n    register_dmlab_components(level_caches)\n    status = runner.init()",
        "detail": "deps.sample-factory.sf_examples.dmlab.train_dmlab",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.envpool.atari.enjoy_envpool_atari",
        "description": "deps.sample-factory.sf_examples.envpool.atari.enjoy_envpool_atari",
        "peekOfCode": "def main():\n    \"\"\"Script entry point.\"\"\"\n    register_atari_components()\n    cfg = parse_atari_args(evaluation=True)\n    status = enjoy(cfg)\n    return status\nif __name__ == \"__main__\":\n    sys.exit(main())",
        "detail": "deps.sample-factory.sf_examples.envpool.atari.enjoy_envpool_atari",
        "documentation": {}
    },
    {
        "label": "atari_override_defaults",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.envpool.atari.envpool_atari_params",
        "description": "deps.sample-factory.sf_examples.envpool.atari.envpool_atari_params",
        "peekOfCode": "def atari_override_defaults(_env, parser):\n    \"\"\"RL params specific to Atari envs.\"\"\"\n    parser.set_defaults(\n        # let's set this to True by default so it's consistent with how we report results for other envs\n        # (i.e. VizDoom or DMLab). When running evaluations for reports or to compare with other frameworks we can\n        # set this to false in command line\n        summaries_use_frameskip=True,\n        use_record_episode_statistics=True,\n        encoder_conv_architecture=\"convnet_atari\",\n        obs_scale=255.0,",
        "detail": "deps.sample-factory.sf_examples.envpool.atari.envpool_atari_params",
        "documentation": {}
    },
    {
        "label": "add_atari_env_args",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.envpool.atari.envpool_atari_params",
        "description": "deps.sample-factory.sf_examples.envpool.atari.envpool_atari_params",
        "peekOfCode": "def add_atari_env_args(_env, p: argparse.ArgumentParser, evaluation=False):\n    if evaluation:\n        # apparently env.render(mode=\"human\") is not supported anymore and we need to specify the render mode in\n        # the env ctor\n        p.add_argument(\"--render_mode\", default=\"human\", type=str, help=\"\")\n    p.add_argument(\n        \"--env_agents\",\n        default=2,\n        type=int,\n        help=\"Num agents in each envpool (if used)\",",
        "detail": "deps.sample-factory.sf_examples.envpool.atari.envpool_atari_params",
        "documentation": {}
    },
    {
        "label": "atari_env_by_name",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.envpool.atari.envpool_atari_utils",
        "description": "deps.sample-factory.sf_examples.envpool.atari.envpool_atari_utils",
        "peekOfCode": "def atari_env_by_name(name):\n    for cfg in ENVPOOL_ATARI_ENVS:\n        if cfg.name == name:\n            return cfg\n    raise Exception(\"Unknown Atari env\")\ndef make_atari_env(env_name, cfg, env_config, render_mode: Optional[str] = None):\n    if cfg.num_envs_per_worker > 1:\n        log.warning(\n            \"When using envpool, set num_envs_per_worker=1 and use --env_agents={desired number of envs}. \"\n            f\"Setting --num_envs_per_worker={cfg.num_envs_per_worker} will create multiple envpools per worker process \"",
        "detail": "deps.sample-factory.sf_examples.envpool.atari.envpool_atari_utils",
        "documentation": {}
    },
    {
        "label": "make_atari_env",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.envpool.atari.envpool_atari_utils",
        "description": "deps.sample-factory.sf_examples.envpool.atari.envpool_atari_utils",
        "peekOfCode": "def make_atari_env(env_name, cfg, env_config, render_mode: Optional[str] = None):\n    if cfg.num_envs_per_worker > 1:\n        log.warning(\n            \"When using envpool, set num_envs_per_worker=1 and use --env_agents={desired number of envs}. \"\n            f\"Setting --num_envs_per_worker={cfg.num_envs_per_worker} will create multiple envpools per worker process \"\n            f\"which is not the desirable behavior in most configurations.\"\n        )\n    atari_spec = atari_env_by_name(env_name)\n    env_kwargs = dict()\n    if atari_spec.default_timeout is not None:",
        "detail": "deps.sample-factory.sf_examples.envpool.atari.envpool_atari_utils",
        "documentation": {}
    },
    {
        "label": "ENVPOOL_ATARI_ENVS",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.envpool.atari.envpool_atari_utils",
        "description": "deps.sample-factory.sf_examples.envpool.atari.envpool_atari_utils",
        "peekOfCode": "ENVPOOL_ATARI_ENVS = [\n    AtariSpec(\n        spec.name,\n        spec.env_id.replace(\"NoFrameskip-v4\", \"-v5\"),\n        default_timeout=spec.default_timeout,\n    )\n    for spec in ATARI_ENVS\n]\ndef atari_env_by_name(name):\n    for cfg in ENVPOOL_ATARI_ENVS:",
        "detail": "deps.sample-factory.sf_examples.envpool.atari.envpool_atari_utils",
        "documentation": {}
    },
    {
        "label": "register_atari_envs",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.envpool.atari.train_envpool_atari",
        "description": "deps.sample-factory.sf_examples.envpool.atari.train_envpool_atari",
        "peekOfCode": "def register_atari_envs():\n    for env in ENVPOOL_ATARI_ENVS:\n        register_env(env.name, make_atari_env)\ndef register_atari_components():\n    register_atari_envs()\ndef parse_atari_args(argv=None, evaluation=False):\n    parser, partial_cfg = parse_sf_args(argv=argv, evaluation=evaluation)\n    add_atari_env_args(partial_cfg.env, parser, evaluation=evaluation)\n    atari_override_defaults(partial_cfg.env, parser)\n    final_cfg = parse_full_cfg(parser, argv)",
        "detail": "deps.sample-factory.sf_examples.envpool.atari.train_envpool_atari",
        "documentation": {}
    },
    {
        "label": "register_atari_components",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.envpool.atari.train_envpool_atari",
        "description": "deps.sample-factory.sf_examples.envpool.atari.train_envpool_atari",
        "peekOfCode": "def register_atari_components():\n    register_atari_envs()\ndef parse_atari_args(argv=None, evaluation=False):\n    parser, partial_cfg = parse_sf_args(argv=argv, evaluation=evaluation)\n    add_atari_env_args(partial_cfg.env, parser, evaluation=evaluation)\n    atari_override_defaults(partial_cfg.env, parser)\n    final_cfg = parse_full_cfg(parser, argv)\n    return final_cfg\ndef main():\n    \"\"\"Script entry point.\"\"\"",
        "detail": "deps.sample-factory.sf_examples.envpool.atari.train_envpool_atari",
        "documentation": {}
    },
    {
        "label": "parse_atari_args",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.envpool.atari.train_envpool_atari",
        "description": "deps.sample-factory.sf_examples.envpool.atari.train_envpool_atari",
        "peekOfCode": "def parse_atari_args(argv=None, evaluation=False):\n    parser, partial_cfg = parse_sf_args(argv=argv, evaluation=evaluation)\n    add_atari_env_args(partial_cfg.env, parser, evaluation=evaluation)\n    atari_override_defaults(partial_cfg.env, parser)\n    final_cfg = parse_full_cfg(parser, argv)\n    return final_cfg\ndef main():\n    \"\"\"Script entry point.\"\"\"\n    register_atari_components()\n    cfg = parse_atari_args()",
        "detail": "deps.sample-factory.sf_examples.envpool.atari.train_envpool_atari",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.envpool.atari.train_envpool_atari",
        "description": "deps.sample-factory.sf_examples.envpool.atari.train_envpool_atari",
        "peekOfCode": "def main():\n    \"\"\"Script entry point.\"\"\"\n    register_atari_components()\n    cfg = parse_atari_args()\n    status = run_rl(cfg)\n    return status\nif __name__ == \"__main__\":\n    sys.exit(main())",
        "detail": "deps.sample-factory.sf_examples.envpool.atari.train_envpool_atari",
        "documentation": {}
    },
    {
        "label": "_params",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.envpool.mujoco.experiments.mujoco_envpool",
        "description": "deps.sample-factory.sf_examples.envpool.mujoco.experiments.mujoco_envpool",
        "peekOfCode": "_params = ParamGrid(\n    [\n        (\"seed\", [00, 11, 22]),\n        (\n            \"env\",\n            [\n                \"mujoco_ant\",\n                \"mujoco_halfcheetah\",\n                \"mujoco_hopper\",\n                \"mujoco_humanoid\",",
        "detail": "deps.sample-factory.sf_examples.envpool.mujoco.experiments.mujoco_envpool",
        "documentation": {}
    },
    {
        "label": "vstr",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.envpool.mujoco.experiments.mujoco_envpool",
        "description": "deps.sample-factory.sf_examples.envpool.mujoco.experiments.mujoco_envpool",
        "peekOfCode": "vstr = f\"mujoco_envpool_v{ALGO_VERSION}\"\ncli = (\n    f\"python -m sf_examples.envpool.mujoco.train_envpool_mujoco \"\n    f\"--train_for_env_steps=100000000 --with_wandb=True --wandb_tags {vstr} --wandb_group=sf2_{vstr}\"\n)\n_experiments = [Experiment(f\"{vstr}\", cli, _params.generate_params(False))]\nRUN_DESCRIPTION = RunDescription(f\"{vstr}\", experiments=_experiments)\n# Run locally: python -m sample_factory.launcher.run --run=sf_examples.envpool.mujoco.experiments.mujoco_envpool --backend=processes --max_parallel=2 --experiments_per_gpu=2 --num_gpus=1\n# Run on Slurm: python -m sample_factory.launcher.run --run=sf_examples.envpool.mujoco.experiments.mujoco_envpool --backend=slurm --slurm_workdir=./slurm_envpool --experiment_suffix=slurm --slurm_gpus_per_job=1 --slurm_cpus_per_gpu=16 --slurm_sbatch_template=./sample_factory/launcher/slurm/sbatch_timeout.sh --pause_between=1 --slurm_print_only=False",
        "detail": "deps.sample-factory.sf_examples.envpool.mujoco.experiments.mujoco_envpool",
        "documentation": {}
    },
    {
        "label": "cli",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.envpool.mujoco.experiments.mujoco_envpool",
        "description": "deps.sample-factory.sf_examples.envpool.mujoco.experiments.mujoco_envpool",
        "peekOfCode": "cli = (\n    f\"python -m sf_examples.envpool.mujoco.train_envpool_mujoco \"\n    f\"--train_for_env_steps=100000000 --with_wandb=True --wandb_tags {vstr} --wandb_group=sf2_{vstr}\"\n)\n_experiments = [Experiment(f\"{vstr}\", cli, _params.generate_params(False))]\nRUN_DESCRIPTION = RunDescription(f\"{vstr}\", experiments=_experiments)\n# Run locally: python -m sample_factory.launcher.run --run=sf_examples.envpool.mujoco.experiments.mujoco_envpool --backend=processes --max_parallel=2 --experiments_per_gpu=2 --num_gpus=1\n# Run on Slurm: python -m sample_factory.launcher.run --run=sf_examples.envpool.mujoco.experiments.mujoco_envpool --backend=slurm --slurm_workdir=./slurm_envpool --experiment_suffix=slurm --slurm_gpus_per_job=1 --slurm_cpus_per_gpu=16 --slurm_sbatch_template=./sample_factory/launcher/slurm/sbatch_timeout.sh --pause_between=1 --slurm_print_only=False",
        "detail": "deps.sample-factory.sf_examples.envpool.mujoco.experiments.mujoco_envpool",
        "documentation": {}
    },
    {
        "label": "_experiments",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.envpool.mujoco.experiments.mujoco_envpool",
        "description": "deps.sample-factory.sf_examples.envpool.mujoco.experiments.mujoco_envpool",
        "peekOfCode": "_experiments = [Experiment(f\"{vstr}\", cli, _params.generate_params(False))]\nRUN_DESCRIPTION = RunDescription(f\"{vstr}\", experiments=_experiments)\n# Run locally: python -m sample_factory.launcher.run --run=sf_examples.envpool.mujoco.experiments.mujoco_envpool --backend=processes --max_parallel=2 --experiments_per_gpu=2 --num_gpus=1\n# Run on Slurm: python -m sample_factory.launcher.run --run=sf_examples.envpool.mujoco.experiments.mujoco_envpool --backend=slurm --slurm_workdir=./slurm_envpool --experiment_suffix=slurm --slurm_gpus_per_job=1 --slurm_cpus_per_gpu=16 --slurm_sbatch_template=./sample_factory/launcher/slurm/sbatch_timeout.sh --pause_between=1 --slurm_print_only=False",
        "detail": "deps.sample-factory.sf_examples.envpool.mujoco.experiments.mujoco_envpool",
        "documentation": {}
    },
    {
        "label": "RUN_DESCRIPTION",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.envpool.mujoco.experiments.mujoco_envpool",
        "description": "deps.sample-factory.sf_examples.envpool.mujoco.experiments.mujoco_envpool",
        "peekOfCode": "RUN_DESCRIPTION = RunDescription(f\"{vstr}\", experiments=_experiments)\n# Run locally: python -m sample_factory.launcher.run --run=sf_examples.envpool.mujoco.experiments.mujoco_envpool --backend=processes --max_parallel=2 --experiments_per_gpu=2 --num_gpus=1\n# Run on Slurm: python -m sample_factory.launcher.run --run=sf_examples.envpool.mujoco.experiments.mujoco_envpool --backend=slurm --slurm_workdir=./slurm_envpool --experiment_suffix=slurm --slurm_gpus_per_job=1 --slurm_cpus_per_gpu=16 --slurm_sbatch_template=./sample_factory/launcher/slurm/sbatch_timeout.sh --pause_between=1 --slurm_print_only=False",
        "detail": "deps.sample-factory.sf_examples.envpool.mujoco.experiments.mujoco_envpool",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.envpool.mujoco.enjoy_envpool_mujoco",
        "description": "deps.sample-factory.sf_examples.envpool.mujoco.enjoy_envpool_mujoco",
        "peekOfCode": "def main():\n    register_mujoco_components()\n    cfg = parse_mujoco_cfg(evaluation=True)\n    status = enjoy(cfg)\n    return status\nif __name__ == \"__main__\":\n    sys.exit(main())",
        "detail": "deps.sample-factory.sf_examples.envpool.mujoco.enjoy_envpool_mujoco",
        "documentation": {}
    },
    {
        "label": "mujoco_envpool_override_defaults",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.envpool.mujoco.envpool_mujoco_params",
        "description": "deps.sample-factory.sf_examples.envpool.mujoco.envpool_mujoco_params",
        "peekOfCode": "def mujoco_envpool_override_defaults(env: str, parser: argparse.ArgumentParser) -> None:\n    # High-throughput parameters optimized for wall-time performance (e.g. getting the highest reward in 10 minutes).\n    # See sf_examples/mujoco/mujoco_params.py for more standard parameters similar to SB3/CleanRL that are known\n    # to provide good sample efficiency\n    parser.set_defaults(\n        batched_sampling=True,\n        num_workers=1,  # envpool takes care of parallelization, so use only 1 worker?\n        num_envs_per_worker=1,  # two envs per worker for double-buffered sampling, one for single-buffered\n        worker_num_splits=1,  # change to 2 to enable double-buffered sampling\n        train_for_env_steps=10000000,",
        "detail": "deps.sample-factory.sf_examples.envpool.mujoco.envpool_mujoco_params",
        "documentation": {}
    },
    {
        "label": "add_mujoco_envpool_env_args",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.envpool.mujoco.envpool_mujoco_params",
        "description": "deps.sample-factory.sf_examples.envpool.mujoco.envpool_mujoco_params",
        "peekOfCode": "def add_mujoco_envpool_env_args(env, parser, evaluation: bool = False) -> None:\n    # in case we need to add more args in the future\n    parser.add_argument(\n        \"--env_agents\",\n        default=1 if evaluation else 64,\n        type=int,\n        help=\"Num agents in each envpool (if used)\",\n    )\n    add_envpool_common_args(env, parser)",
        "detail": "deps.sample-factory.sf_examples.envpool.mujoco.envpool_mujoco_params",
        "documentation": {}
    },
    {
        "label": "env_configs",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.envpool.mujoco.envpool_mujoco_params",
        "description": "deps.sample-factory.sf_examples.envpool.mujoco.envpool_mujoco_params",
        "peekOfCode": "env_configs = dict(\n    mujoco_ant=dict(\n        encoder_mlp_layers=[128, 64, 32],\n        nonlinearity=\"elu\",\n        learning_rate=3e-4,\n        rollout=64,\n        num_epochs=4,\n        num_batches_per_epoch=2,\n    ),\n    mujoco_halfcheetah=dict(",
        "detail": "deps.sample-factory.sf_examples.envpool.mujoco.envpool_mujoco_params",
        "documentation": {}
    },
    {
        "label": "mujoco_env_by_name",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.envpool.mujoco.envpool_mujoco_utils",
        "description": "deps.sample-factory.sf_examples.envpool.mujoco.envpool_mujoco_utils",
        "peekOfCode": "def mujoco_env_by_name(name):\n    for cfg in MUJOCO_ENVS:\n        if cfg.name == name:\n            return cfg\n    raise Exception(\"Unknown Mujoco env\")\ndef make_mujoco_env(env_name, cfg, env_config, render_mode: Optional[str] = None, **kwargs):\n    assert cfg.batched_sampling, \"batched sampling must be used when using envpool\"\n    # assert cfg.num_envs_per_worker == 1, \"when using envpool, set num_envs_per_worker=1 and use --env_agents=\"\n    mujoco_spec = mujoco_env_by_name(env_name)\n    env_kwargs = dict()",
        "detail": "deps.sample-factory.sf_examples.envpool.mujoco.envpool_mujoco_utils",
        "documentation": {}
    },
    {
        "label": "make_mujoco_env",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.envpool.mujoco.envpool_mujoco_utils",
        "description": "deps.sample-factory.sf_examples.envpool.mujoco.envpool_mujoco_utils",
        "peekOfCode": "def make_mujoco_env(env_name, cfg, env_config, render_mode: Optional[str] = None, **kwargs):\n    assert cfg.batched_sampling, \"batched sampling must be used when using envpool\"\n    # assert cfg.num_envs_per_worker == 1, \"when using envpool, set num_envs_per_worker=1 and use --env_agents=\"\n    mujoco_spec = mujoco_env_by_name(env_name)\n    env_kwargs = dict()\n    if env_config is not None:\n        env_kwargs[\"seed\"] = env_config.env_id\n    log.debug(\n        f\"Envpool uses {cfg.envpool_num_threads} threads and thread affinity offset {cfg.envpool_thread_affinity_offset}\"\n    )",
        "detail": "deps.sample-factory.sf_examples.envpool.mujoco.envpool_mujoco_utils",
        "documentation": {}
    },
    {
        "label": "register_mujoco_components",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.envpool.mujoco.train_envpool_mujoco",
        "description": "deps.sample-factory.sf_examples.envpool.mujoco.train_envpool_mujoco",
        "peekOfCode": "def register_mujoco_components():\n    for env in MUJOCO_ENVS:\n        register_env(env.name, make_mujoco_env)\ndef parse_mujoco_cfg(argv=None, evaluation: bool = False) -> Config:\n    parser, partial_cfg = parse_sf_args(argv=argv, evaluation=evaluation)\n    add_mujoco_envpool_env_args(partial_cfg.env, parser, evaluation)\n    mujoco_envpool_override_defaults(partial_cfg.env, parser)\n    final_cfg = parse_full_cfg(parser, argv)\n    return final_cfg\ndef main():",
        "detail": "deps.sample-factory.sf_examples.envpool.mujoco.train_envpool_mujoco",
        "documentation": {}
    },
    {
        "label": "parse_mujoco_cfg",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.envpool.mujoco.train_envpool_mujoco",
        "description": "deps.sample-factory.sf_examples.envpool.mujoco.train_envpool_mujoco",
        "peekOfCode": "def parse_mujoco_cfg(argv=None, evaluation: bool = False) -> Config:\n    parser, partial_cfg = parse_sf_args(argv=argv, evaluation=evaluation)\n    add_mujoco_envpool_env_args(partial_cfg.env, parser, evaluation)\n    mujoco_envpool_override_defaults(partial_cfg.env, parser)\n    final_cfg = parse_full_cfg(parser, argv)\n    return final_cfg\ndef main():\n    register_mujoco_components()\n    cfg = parse_mujoco_cfg()\n    status = run_rl(cfg)",
        "detail": "deps.sample-factory.sf_examples.envpool.mujoco.train_envpool_mujoco",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.envpool.mujoco.train_envpool_mujoco",
        "description": "deps.sample-factory.sf_examples.envpool.mujoco.train_envpool_mujoco",
        "peekOfCode": "def main():\n    register_mujoco_components()\n    cfg = parse_mujoco_cfg()\n    status = run_rl(cfg)\n    return status\nif __name__ == \"__main__\":\n    sys.exit(main())",
        "detail": "deps.sample-factory.sf_examples.envpool.mujoco.train_envpool_mujoco",
        "documentation": {}
    },
    {
        "label": "envpool_available",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.envpool.envpool_utils",
        "description": "deps.sample-factory.sf_examples.envpool.envpool_utils",
        "peekOfCode": "def envpool_available():\n    return is_module_available(\"envpool\")\ndef add_envpool_common_args(env, parser) -> None:\n    parser.add_argument(\n        \"--envpool_num_threads\",\n        default=multiprocessing.cpu_count(),\n        type=int,\n        help=\"Num threads to use for envpool, defaults to the number of logical CPUs\",\n    )\n    parser.add_argument(",
        "detail": "deps.sample-factory.sf_examples.envpool.envpool_utils",
        "documentation": {}
    },
    {
        "label": "add_envpool_common_args",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.envpool.envpool_utils",
        "description": "deps.sample-factory.sf_examples.envpool.envpool_utils",
        "peekOfCode": "def add_envpool_common_args(env, parser) -> None:\n    parser.add_argument(\n        \"--envpool_num_threads\",\n        default=multiprocessing.cpu_count(),\n        type=int,\n        help=\"Num threads to use for envpool, defaults to the number of logical CPUs\",\n    )\n    parser.add_argument(\n        \"--envpool_thread_affinity_offset\",\n        default=-1,",
        "detail": "deps.sample-factory.sf_examples.envpool.envpool_utils",
        "documentation": {}
    },
    {
        "label": "EnvPoolResetFixWrapper",
        "kind": 6,
        "importPath": "deps.sample-factory.sf_examples.envpool.envpool_wrappers",
        "description": "deps.sample-factory.sf_examples.envpool.envpool_wrappers",
        "peekOfCode": "class EnvPoolResetFixWrapper(gym.Wrapper):\n    def __init__(self, env):\n        super().__init__(env)\n    def step(self, actions):\n        obs, reward, terminated, truncated, info = self.env.step(actions)\n        needs_reset = np.nonzero(terminated | truncated)[0]\n        obs[needs_reset], _ = self.env.reset(needs_reset)\n        return obs, reward, terminated, truncated, info\n    def reset(self, **kwargs):\n        kwargs.pop(\"seed\", None)  # envpool does not support the seed in reset, even with the updated API",
        "detail": "deps.sample-factory.sf_examples.envpool.envpool_wrappers",
        "documentation": {}
    },
    {
        "label": "BatchedRecordEpisodeStatistics",
        "kind": 6,
        "importPath": "deps.sample-factory.sf_examples.envpool.envpool_wrappers",
        "description": "deps.sample-factory.sf_examples.envpool.envpool_wrappers",
        "peekOfCode": "class BatchedRecordEpisodeStatistics(gym.Wrapper):\n    def __init__(self, env, num_envs, deque_size=100):\n        super().__init__(env)\n        self.num_envs = getattr(env, \"num_envs\", num_envs)\n        self.episode_returns = None\n        self.episode_lengths = None\n    def reset(self, **kwargs):\n        observations, infos = self.env.reset(**kwargs)\n        self.episode_returns = np.zeros(self.num_envs, dtype=np.float32)\n        self.episode_lengths = np.zeros(self.num_envs, dtype=np.int32)",
        "detail": "deps.sample-factory.sf_examples.envpool.envpool_wrappers",
        "documentation": {}
    },
    {
        "label": "has_image_observations",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.envpool.envpool_wrappers",
        "description": "deps.sample-factory.sf_examples.envpool.envpool_wrappers",
        "peekOfCode": "def has_image_observations(observation_space):\n    \"\"\"It's a heuristic.\"\"\"\n    return len(observation_space.shape) >= 2\nclass EnvPoolResetFixWrapper(gym.Wrapper):\n    def __init__(self, env):\n        super().__init__(env)\n    def step(self, actions):\n        obs, reward, terminated, truncated, info = self.env.step(actions)\n        needs_reset = np.nonzero(terminated | truncated)[0]\n        obs[needs_reset], _ = self.env.reset(needs_reset)",
        "detail": "deps.sample-factory.sf_examples.envpool.envpool_wrappers",
        "documentation": {}
    },
    {
        "label": "DoneStepType",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.envpool.envpool_wrappers",
        "description": "deps.sample-factory.sf_examples.envpool.envpool_wrappers",
        "peekOfCode": "DoneStepType = Tuple[\n    Union[ObsType, np.ndarray],\n    Union[float, np.ndarray],\n    Union[bool, np.ndarray],\n    Union[dict, list],\n]\nTerminatedTruncatedStepType = Tuple[\n    Union[ObsType, np.ndarray],\n    Union[float, np.ndarray],\n    Union[bool, np.ndarray],",
        "detail": "deps.sample-factory.sf_examples.envpool.envpool_wrappers",
        "documentation": {}
    },
    {
        "label": "TerminatedTruncatedStepType",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.envpool.envpool_wrappers",
        "description": "deps.sample-factory.sf_examples.envpool.envpool_wrappers",
        "peekOfCode": "TerminatedTruncatedStepType = Tuple[\n    Union[ObsType, np.ndarray],\n    Union[float, np.ndarray],\n    Union[bool, np.ndarray],\n    Union[bool, np.ndarray],\n    Union[dict, list],\n]\ndef has_image_observations(observation_space):\n    \"\"\"It's a heuristic.\"\"\"\n    return len(observation_space.shape) >= 2",
        "detail": "deps.sample-factory.sf_examples.envpool.envpool_wrappers",
        "documentation": {}
    },
    {
        "label": "_params",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.isaacgym_examples.experiments.isaacgym_allegrohand",
        "description": "deps.sample-factory.sf_examples.isaacgym_examples.experiments.isaacgym_allegrohand",
        "peekOfCode": "_params = ParamGrid(\n    [\n        (\"seed\", [1111, 2222, 3333, 4444]),\n        (\"serial_mode\", [True]),\n        (\"async_rl\", [False]),\n        (\"normalize_returns\", [True, False]),\n    ]\n)\nvstr = f\"{vstr}_norm_returns\"\nahand_cli = (",
        "detail": "deps.sample-factory.sf_examples.isaacgym_examples.experiments.isaacgym_allegrohand",
        "documentation": {}
    },
    {
        "label": "vstr",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.isaacgym_examples.experiments.isaacgym_allegrohand",
        "description": "deps.sample-factory.sf_examples.isaacgym_examples.experiments.isaacgym_allegrohand",
        "peekOfCode": "vstr = f\"{vstr}_norm_returns\"\nahand_cli = (\n    f\" --env=AllegroHand --train_for_env_steps=150000000 \"\n    f\"--with_wandb=True --wandb_group=isaacgym_allegrohand_sf2_{vstr} --wandb_tags allegrohand {vstr}\"\n)\ncli = base_cli + ahand_cli\n_experiments = [\n    Experiment(f\"allegrohand_{vstr}\", cli, _params.generate_params(False)),\n]\nRUN_DESCRIPTION = RunDescription(f\"allegrohand_{vstr}\", experiments=_experiments)",
        "detail": "deps.sample-factory.sf_examples.isaacgym_examples.experiments.isaacgym_allegrohand",
        "documentation": {}
    },
    {
        "label": "ahand_cli",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.isaacgym_examples.experiments.isaacgym_allegrohand",
        "description": "deps.sample-factory.sf_examples.isaacgym_examples.experiments.isaacgym_allegrohand",
        "peekOfCode": "ahand_cli = (\n    f\" --env=AllegroHand --train_for_env_steps=150000000 \"\n    f\"--with_wandb=True --wandb_group=isaacgym_allegrohand_sf2_{vstr} --wandb_tags allegrohand {vstr}\"\n)\ncli = base_cli + ahand_cli\n_experiments = [\n    Experiment(f\"allegrohand_{vstr}\", cli, _params.generate_params(False)),\n]\nRUN_DESCRIPTION = RunDescription(f\"allegrohand_{vstr}\", experiments=_experiments)\n# Run locally: python -m sample_factory.launcher.run --run=sf_examples.isaacgym_examples.experiments.isaacgym_allegrohand --backend=processes --max_parallel=1 --experiments_per_gpu=1 --num_gpus=1",
        "detail": "deps.sample-factory.sf_examples.isaacgym_examples.experiments.isaacgym_allegrohand",
        "documentation": {}
    },
    {
        "label": "cli",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.isaacgym_examples.experiments.isaacgym_allegrohand",
        "description": "deps.sample-factory.sf_examples.isaacgym_examples.experiments.isaacgym_allegrohand",
        "peekOfCode": "cli = base_cli + ahand_cli\n_experiments = [\n    Experiment(f\"allegrohand_{vstr}\", cli, _params.generate_params(False)),\n]\nRUN_DESCRIPTION = RunDescription(f\"allegrohand_{vstr}\", experiments=_experiments)\n# Run locally: python -m sample_factory.launcher.run --run=sf_examples.isaacgym_examples.experiments.isaacgym_allegrohand --backend=processes --max_parallel=1 --experiments_per_gpu=1 --num_gpus=1\n# Run on Slurm: python -m sample_factory.launcher.run --run=sf_examples.isaacgym_examples.experiments.isaacgym_allegrohand --backend=slurm --slurm_workdir=./slurm_isaacgym --experiment_suffix=slurm --slurm_gpus_per_job=1 --slurm_cpus_per_gpu=16 --slurm_sbatch_template=./sample_factory/launcher/slurm/sbatch_timeout.sh --pause_between=1 --slurm_print_only=False",
        "detail": "deps.sample-factory.sf_examples.isaacgym_examples.experiments.isaacgym_allegrohand",
        "documentation": {}
    },
    {
        "label": "_experiments",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.isaacgym_examples.experiments.isaacgym_allegrohand",
        "description": "deps.sample-factory.sf_examples.isaacgym_examples.experiments.isaacgym_allegrohand",
        "peekOfCode": "_experiments = [\n    Experiment(f\"allegrohand_{vstr}\", cli, _params.generate_params(False)),\n]\nRUN_DESCRIPTION = RunDescription(f\"allegrohand_{vstr}\", experiments=_experiments)\n# Run locally: python -m sample_factory.launcher.run --run=sf_examples.isaacgym_examples.experiments.isaacgym_allegrohand --backend=processes --max_parallel=1 --experiments_per_gpu=1 --num_gpus=1\n# Run on Slurm: python -m sample_factory.launcher.run --run=sf_examples.isaacgym_examples.experiments.isaacgym_allegrohand --backend=slurm --slurm_workdir=./slurm_isaacgym --experiment_suffix=slurm --slurm_gpus_per_job=1 --slurm_cpus_per_gpu=16 --slurm_sbatch_template=./sample_factory/launcher/slurm/sbatch_timeout.sh --pause_between=1 --slurm_print_only=False",
        "detail": "deps.sample-factory.sf_examples.isaacgym_examples.experiments.isaacgym_allegrohand",
        "documentation": {}
    },
    {
        "label": "RUN_DESCRIPTION",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.isaacgym_examples.experiments.isaacgym_allegrohand",
        "description": "deps.sample-factory.sf_examples.isaacgym_examples.experiments.isaacgym_allegrohand",
        "peekOfCode": "RUN_DESCRIPTION = RunDescription(f\"allegrohand_{vstr}\", experiments=_experiments)\n# Run locally: python -m sample_factory.launcher.run --run=sf_examples.isaacgym_examples.experiments.isaacgym_allegrohand --backend=processes --max_parallel=1 --experiments_per_gpu=1 --num_gpus=1\n# Run on Slurm: python -m sample_factory.launcher.run --run=sf_examples.isaacgym_examples.experiments.isaacgym_allegrohand --backend=slurm --slurm_workdir=./slurm_isaacgym --experiment_suffix=slurm --slurm_gpus_per_job=1 --slurm_cpus_per_gpu=16 --slurm_sbatch_template=./sample_factory/launcher/slurm/sbatch_timeout.sh --pause_between=1 --slurm_print_only=False",
        "detail": "deps.sample-factory.sf_examples.isaacgym_examples.experiments.isaacgym_allegrohand",
        "documentation": {}
    },
    {
        "label": "_params",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.isaacgym_examples.experiments.isaacgym_ant",
        "description": "deps.sample-factory.sf_examples.isaacgym_examples.experiments.isaacgym_ant",
        "peekOfCode": "_params = ParamGrid(\n    [\n        (\"seed\", [1111, 2222, 3333, 4444, 5555, 6666, 7777, 8888]),\n        ((\"serial_mode\", \"async_rl\"), ([True, False], [False, True])),\n        (\"value_bootstrap\", [True, False]),\n        # ((\"use_rnn\", \"recurrence\"), ([False, 1], [True, 16])),\n    ]\n)\nvstr = f\"{vstr}_vb\"\nant_cli = f\" --env=Ant --train_for_env_steps=100000000 --with_wandb=True --wandb_tags ant {vstr}\"",
        "detail": "deps.sample-factory.sf_examples.isaacgym_examples.experiments.isaacgym_ant",
        "documentation": {}
    },
    {
        "label": "vstr",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.isaacgym_examples.experiments.isaacgym_ant",
        "description": "deps.sample-factory.sf_examples.isaacgym_examples.experiments.isaacgym_ant",
        "peekOfCode": "vstr = f\"{vstr}_vb\"\nant_cli = f\" --env=Ant --train_for_env_steps=100000000 --with_wandb=True --wandb_tags ant {vstr}\"\ncli = base_cli + ant_cli\n_experiments = [\n    Experiment(f\"ant_{vstr}\", cli + f\" --wandb_group=isaacgym_ant_sf2_{vstr}\", _params.generate_params(False)),\n]\nRUN_DESCRIPTION = RunDescription(f\"ant_{vstr}\", experiments=_experiments)\n# Run locally: python -m sample_factory.launcher.run --run=sf_examples.isaacgym_examples.experiments.isaacgym_ant --backend=processes --max_parallel=2 --experiments_per_gpu=2 --num_gpus=1\n# Run on Slurm: python -m sample_factory.launcher.run --run=sf_examples.isaacgym_examples.experiments.isaacgym_ant --backend=slurm --slurm_workdir=./slurm_isaacgym --experiment_suffix=slurm --slurm_gpus_per_job=1 --slurm_cpus_per_gpu=16 --slurm_sbatch_template=./sample_factory/launcher/slurm/sbatch_timeout.sh --pause_between=1 --slurm_print_only=False",
        "detail": "deps.sample-factory.sf_examples.isaacgym_examples.experiments.isaacgym_ant",
        "documentation": {}
    },
    {
        "label": "ant_cli",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.isaacgym_examples.experiments.isaacgym_ant",
        "description": "deps.sample-factory.sf_examples.isaacgym_examples.experiments.isaacgym_ant",
        "peekOfCode": "ant_cli = f\" --env=Ant --train_for_env_steps=100000000 --with_wandb=True --wandb_tags ant {vstr}\"\ncli = base_cli + ant_cli\n_experiments = [\n    Experiment(f\"ant_{vstr}\", cli + f\" --wandb_group=isaacgym_ant_sf2_{vstr}\", _params.generate_params(False)),\n]\nRUN_DESCRIPTION = RunDescription(f\"ant_{vstr}\", experiments=_experiments)\n# Run locally: python -m sample_factory.launcher.run --run=sf_examples.isaacgym_examples.experiments.isaacgym_ant --backend=processes --max_parallel=2 --experiments_per_gpu=2 --num_gpus=1\n# Run on Slurm: python -m sample_factory.launcher.run --run=sf_examples.isaacgym_examples.experiments.isaacgym_ant --backend=slurm --slurm_workdir=./slurm_isaacgym --experiment_suffix=slurm --slurm_gpus_per_job=1 --slurm_cpus_per_gpu=16 --slurm_sbatch_template=./sample_factory/launcher/slurm/sbatch_timeout.sh --pause_between=1 --slurm_print_only=False",
        "detail": "deps.sample-factory.sf_examples.isaacgym_examples.experiments.isaacgym_ant",
        "documentation": {}
    },
    {
        "label": "cli",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.isaacgym_examples.experiments.isaacgym_ant",
        "description": "deps.sample-factory.sf_examples.isaacgym_examples.experiments.isaacgym_ant",
        "peekOfCode": "cli = base_cli + ant_cli\n_experiments = [\n    Experiment(f\"ant_{vstr}\", cli + f\" --wandb_group=isaacgym_ant_sf2_{vstr}\", _params.generate_params(False)),\n]\nRUN_DESCRIPTION = RunDescription(f\"ant_{vstr}\", experiments=_experiments)\n# Run locally: python -m sample_factory.launcher.run --run=sf_examples.isaacgym_examples.experiments.isaacgym_ant --backend=processes --max_parallel=2 --experiments_per_gpu=2 --num_gpus=1\n# Run on Slurm: python -m sample_factory.launcher.run --run=sf_examples.isaacgym_examples.experiments.isaacgym_ant --backend=slurm --slurm_workdir=./slurm_isaacgym --experiment_suffix=slurm --slurm_gpus_per_job=1 --slurm_cpus_per_gpu=16 --slurm_sbatch_template=./sample_factory/launcher/slurm/sbatch_timeout.sh --pause_between=1 --slurm_print_only=False",
        "detail": "deps.sample-factory.sf_examples.isaacgym_examples.experiments.isaacgym_ant",
        "documentation": {}
    },
    {
        "label": "_experiments",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.isaacgym_examples.experiments.isaacgym_ant",
        "description": "deps.sample-factory.sf_examples.isaacgym_examples.experiments.isaacgym_ant",
        "peekOfCode": "_experiments = [\n    Experiment(f\"ant_{vstr}\", cli + f\" --wandb_group=isaacgym_ant_sf2_{vstr}\", _params.generate_params(False)),\n]\nRUN_DESCRIPTION = RunDescription(f\"ant_{vstr}\", experiments=_experiments)\n# Run locally: python -m sample_factory.launcher.run --run=sf_examples.isaacgym_examples.experiments.isaacgym_ant --backend=processes --max_parallel=2 --experiments_per_gpu=2 --num_gpus=1\n# Run on Slurm: python -m sample_factory.launcher.run --run=sf_examples.isaacgym_examples.experiments.isaacgym_ant --backend=slurm --slurm_workdir=./slurm_isaacgym --experiment_suffix=slurm --slurm_gpus_per_job=1 --slurm_cpus_per_gpu=16 --slurm_sbatch_template=./sample_factory/launcher/slurm/sbatch_timeout.sh --pause_between=1 --slurm_print_only=False",
        "detail": "deps.sample-factory.sf_examples.isaacgym_examples.experiments.isaacgym_ant",
        "documentation": {}
    },
    {
        "label": "RUN_DESCRIPTION",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.isaacgym_examples.experiments.isaacgym_ant",
        "description": "deps.sample-factory.sf_examples.isaacgym_examples.experiments.isaacgym_ant",
        "peekOfCode": "RUN_DESCRIPTION = RunDescription(f\"ant_{vstr}\", experiments=_experiments)\n# Run locally: python -m sample_factory.launcher.run --run=sf_examples.isaacgym_examples.experiments.isaacgym_ant --backend=processes --max_parallel=2 --experiments_per_gpu=2 --num_gpus=1\n# Run on Slurm: python -m sample_factory.launcher.run --run=sf_examples.isaacgym_examples.experiments.isaacgym_ant --backend=slurm --slurm_workdir=./slurm_isaacgym --experiment_suffix=slurm --slurm_gpus_per_job=1 --slurm_cpus_per_gpu=16 --slurm_sbatch_template=./sample_factory/launcher/slurm/sbatch_timeout.sh --pause_between=1 --slurm_print_only=False",
        "detail": "deps.sample-factory.sf_examples.isaacgym_examples.experiments.isaacgym_ant",
        "documentation": {}
    },
    {
        "label": "_params",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.isaacgym_examples.experiments.isaacgym_basic_envs",
        "description": "deps.sample-factory.sf_examples.isaacgym_examples.experiments.isaacgym_basic_envs",
        "peekOfCode": "_params = ParamGrid(\n    [\n        (\"seed\", seeds(3)),\n        (\"env\", [\"Ant\", \"Humanoid\"]),\n        # should be 16 recurrence for Ant and 32 for Humanoid\n        # ((\"use_rnn\", \"recurrence\"), ([False, 1], [True, 16])),  # train recurrent and non-recurrent models\n    ]\n)\nvstr = f\"{vstr}_basic_ige\"\ncli = base_cli + f\" --train_for_env_steps=100000000 --with_wandb=True --wandb_tags {vstr} --wandb_group=sf2_{vstr}\"",
        "detail": "deps.sample-factory.sf_examples.isaacgym_examples.experiments.isaacgym_basic_envs",
        "documentation": {}
    },
    {
        "label": "vstr",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.isaacgym_examples.experiments.isaacgym_basic_envs",
        "description": "deps.sample-factory.sf_examples.isaacgym_examples.experiments.isaacgym_basic_envs",
        "peekOfCode": "vstr = f\"{vstr}_basic_ige\"\ncli = base_cli + f\" --train_for_env_steps=100000000 --with_wandb=True --wandb_tags {vstr} --wandb_group=sf2_{vstr}\"\n_experiments = [Experiment(f\"{vstr}\", cli, _params.generate_params(False))]\nRUN_DESCRIPTION = RunDescription(f\"{vstr}\", experiments=_experiments)\n# Run locally: python -m sample_factory.launcher.run --run=sf_examples.isaacgym_examples.experiments.isaacgym_basic_envs --backend=processes --max_parallel=2 --experiments_per_gpu=2 --num_gpus=1\n# Run on Slurm: python -m sample_factory.launcher.run --run=sf_examples.isaacgym_examples.experiments.isaacgym_basic_envs --backend=slurm --slurm_workdir=./slurm_isaacgym --experiment_suffix=slurm --slurm_gpus_per_job=1 --slurm_cpus_per_gpu=16 --slurm_sbatch_template=./sample_factory/launcher/slurm/sbatch_timeout.sh --pause_between=1 --slurm_print_only=False",
        "detail": "deps.sample-factory.sf_examples.isaacgym_examples.experiments.isaacgym_basic_envs",
        "documentation": {}
    },
    {
        "label": "cli",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.isaacgym_examples.experiments.isaacgym_basic_envs",
        "description": "deps.sample-factory.sf_examples.isaacgym_examples.experiments.isaacgym_basic_envs",
        "peekOfCode": "cli = base_cli + f\" --train_for_env_steps=100000000 --with_wandb=True --wandb_tags {vstr} --wandb_group=sf2_{vstr}\"\n_experiments = [Experiment(f\"{vstr}\", cli, _params.generate_params(False))]\nRUN_DESCRIPTION = RunDescription(f\"{vstr}\", experiments=_experiments)\n# Run locally: python -m sample_factory.launcher.run --run=sf_examples.isaacgym_examples.experiments.isaacgym_basic_envs --backend=processes --max_parallel=2 --experiments_per_gpu=2 --num_gpus=1\n# Run on Slurm: python -m sample_factory.launcher.run --run=sf_examples.isaacgym_examples.experiments.isaacgym_basic_envs --backend=slurm --slurm_workdir=./slurm_isaacgym --experiment_suffix=slurm --slurm_gpus_per_job=1 --slurm_cpus_per_gpu=16 --slurm_sbatch_template=./sample_factory/launcher/slurm/sbatch_timeout.sh --pause_between=1 --slurm_print_only=False",
        "detail": "deps.sample-factory.sf_examples.isaacgym_examples.experiments.isaacgym_basic_envs",
        "documentation": {}
    },
    {
        "label": "_experiments",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.isaacgym_examples.experiments.isaacgym_basic_envs",
        "description": "deps.sample-factory.sf_examples.isaacgym_examples.experiments.isaacgym_basic_envs",
        "peekOfCode": "_experiments = [Experiment(f\"{vstr}\", cli, _params.generate_params(False))]\nRUN_DESCRIPTION = RunDescription(f\"{vstr}\", experiments=_experiments)\n# Run locally: python -m sample_factory.launcher.run --run=sf_examples.isaacgym_examples.experiments.isaacgym_basic_envs --backend=processes --max_parallel=2 --experiments_per_gpu=2 --num_gpus=1\n# Run on Slurm: python -m sample_factory.launcher.run --run=sf_examples.isaacgym_examples.experiments.isaacgym_basic_envs --backend=slurm --slurm_workdir=./slurm_isaacgym --experiment_suffix=slurm --slurm_gpus_per_job=1 --slurm_cpus_per_gpu=16 --slurm_sbatch_template=./sample_factory/launcher/slurm/sbatch_timeout.sh --pause_between=1 --slurm_print_only=False",
        "detail": "deps.sample-factory.sf_examples.isaacgym_examples.experiments.isaacgym_basic_envs",
        "documentation": {}
    },
    {
        "label": "RUN_DESCRIPTION",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.isaacgym_examples.experiments.isaacgym_basic_envs",
        "description": "deps.sample-factory.sf_examples.isaacgym_examples.experiments.isaacgym_basic_envs",
        "peekOfCode": "RUN_DESCRIPTION = RunDescription(f\"{vstr}\", experiments=_experiments)\n# Run locally: python -m sample_factory.launcher.run --run=sf_examples.isaacgym_examples.experiments.isaacgym_basic_envs --backend=processes --max_parallel=2 --experiments_per_gpu=2 --num_gpus=1\n# Run on Slurm: python -m sample_factory.launcher.run --run=sf_examples.isaacgym_examples.experiments.isaacgym_basic_envs --backend=slurm --slurm_workdir=./slurm_isaacgym --experiment_suffix=slurm --slurm_gpus_per_job=1 --slurm_cpus_per_gpu=16 --slurm_sbatch_template=./sample_factory/launcher/slurm/sbatch_timeout.sh --pause_between=1 --slurm_print_only=False",
        "detail": "deps.sample-factory.sf_examples.isaacgym_examples.experiments.isaacgym_basic_envs",
        "documentation": {}
    },
    {
        "label": "_params",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.isaacgym_examples.experiments.isaacgym_humanoid",
        "description": "deps.sample-factory.sf_examples.isaacgym_examples.experiments.isaacgym_humanoid",
        "peekOfCode": "_params = ParamGrid(\n    [\n        (\"seed\", [1111, 2222, 3333, 4444, 5555]),\n        ((\"serial_mode\", \"async_rl\"), ([True, False], [False, True])),\n        # (\"value_bootstrap\", [True, False]),\n        ((\"use_rnn\", \"recurrence\"), ([False, 1], [True, 32])),\n    ]\n)\nvstr = f\"humanoid_{vstr}\"\nhumanoid_cli = f\" --env=Humanoid --train_for_env_steps=100000000 --with_wandb=True --wandb_tags humanoid {vstr}\"",
        "detail": "deps.sample-factory.sf_examples.isaacgym_examples.experiments.isaacgym_humanoid",
        "documentation": {}
    },
    {
        "label": "vstr",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.isaacgym_examples.experiments.isaacgym_humanoid",
        "description": "deps.sample-factory.sf_examples.isaacgym_examples.experiments.isaacgym_humanoid",
        "peekOfCode": "vstr = f\"humanoid_{vstr}\"\nhumanoid_cli = f\" --env=Humanoid --train_for_env_steps=100000000 --with_wandb=True --wandb_tags humanoid {vstr}\"\ncli = base_cli + humanoid_cli\n_experiments = [\n    Experiment(vstr, cli + f\" --wandb_group=isaacgym_humanoid_sf2_{vstr}\", _params.generate_params(False)),\n]\nRUN_DESCRIPTION = RunDescription(vstr, experiments=_experiments)\n# Run locally: python -m sample_factory.launcher.run --run=sf_examples.isaacgym_examples.experiments.isaacgym_humanoid --backend=processes --max_parallel=2 --experiments_per_gpu=2 --num_gpus=1\n# Run on Slurm: python -m sample_factory.launcher.run --run=sf_examples.isaacgym_examples.experiments.isaacgym_humanoid --backend=slurm --slurm_workdir=./slurm_isaacgym --experiment_suffix=slurm --slurm_gpus_per_job=1 --slurm_cpus_per_gpu=16 --slurm_sbatch_template=./sample_factory/launcher/slurm/sbatch_timeout.sh --pause_between=1 --slurm_print_only=False",
        "detail": "deps.sample-factory.sf_examples.isaacgym_examples.experiments.isaacgym_humanoid",
        "documentation": {}
    },
    {
        "label": "humanoid_cli",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.isaacgym_examples.experiments.isaacgym_humanoid",
        "description": "deps.sample-factory.sf_examples.isaacgym_examples.experiments.isaacgym_humanoid",
        "peekOfCode": "humanoid_cli = f\" --env=Humanoid --train_for_env_steps=100000000 --with_wandb=True --wandb_tags humanoid {vstr}\"\ncli = base_cli + humanoid_cli\n_experiments = [\n    Experiment(vstr, cli + f\" --wandb_group=isaacgym_humanoid_sf2_{vstr}\", _params.generate_params(False)),\n]\nRUN_DESCRIPTION = RunDescription(vstr, experiments=_experiments)\n# Run locally: python -m sample_factory.launcher.run --run=sf_examples.isaacgym_examples.experiments.isaacgym_humanoid --backend=processes --max_parallel=2 --experiments_per_gpu=2 --num_gpus=1\n# Run on Slurm: python -m sample_factory.launcher.run --run=sf_examples.isaacgym_examples.experiments.isaacgym_humanoid --backend=slurm --slurm_workdir=./slurm_isaacgym --experiment_suffix=slurm --slurm_gpus_per_job=1 --slurm_cpus_per_gpu=16 --slurm_sbatch_template=./sample_factory/launcher/slurm/sbatch_timeout.sh --pause_between=1 --slurm_print_only=False",
        "detail": "deps.sample-factory.sf_examples.isaacgym_examples.experiments.isaacgym_humanoid",
        "documentation": {}
    },
    {
        "label": "cli",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.isaacgym_examples.experiments.isaacgym_humanoid",
        "description": "deps.sample-factory.sf_examples.isaacgym_examples.experiments.isaacgym_humanoid",
        "peekOfCode": "cli = base_cli + humanoid_cli\n_experiments = [\n    Experiment(vstr, cli + f\" --wandb_group=isaacgym_humanoid_sf2_{vstr}\", _params.generate_params(False)),\n]\nRUN_DESCRIPTION = RunDescription(vstr, experiments=_experiments)\n# Run locally: python -m sample_factory.launcher.run --run=sf_examples.isaacgym_examples.experiments.isaacgym_humanoid --backend=processes --max_parallel=2 --experiments_per_gpu=2 --num_gpus=1\n# Run on Slurm: python -m sample_factory.launcher.run --run=sf_examples.isaacgym_examples.experiments.isaacgym_humanoid --backend=slurm --slurm_workdir=./slurm_isaacgym --experiment_suffix=slurm --slurm_gpus_per_job=1 --slurm_cpus_per_gpu=16 --slurm_sbatch_template=./sample_factory/launcher/slurm/sbatch_timeout.sh --pause_between=1 --slurm_print_only=False",
        "detail": "deps.sample-factory.sf_examples.isaacgym_examples.experiments.isaacgym_humanoid",
        "documentation": {}
    },
    {
        "label": "_experiments",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.isaacgym_examples.experiments.isaacgym_humanoid",
        "description": "deps.sample-factory.sf_examples.isaacgym_examples.experiments.isaacgym_humanoid",
        "peekOfCode": "_experiments = [\n    Experiment(vstr, cli + f\" --wandb_group=isaacgym_humanoid_sf2_{vstr}\", _params.generate_params(False)),\n]\nRUN_DESCRIPTION = RunDescription(vstr, experiments=_experiments)\n# Run locally: python -m sample_factory.launcher.run --run=sf_examples.isaacgym_examples.experiments.isaacgym_humanoid --backend=processes --max_parallel=2 --experiments_per_gpu=2 --num_gpus=1\n# Run on Slurm: python -m sample_factory.launcher.run --run=sf_examples.isaacgym_examples.experiments.isaacgym_humanoid --backend=slurm --slurm_workdir=./slurm_isaacgym --experiment_suffix=slurm --slurm_gpus_per_job=1 --slurm_cpus_per_gpu=16 --slurm_sbatch_template=./sample_factory/launcher/slurm/sbatch_timeout.sh --pause_between=1 --slurm_print_only=False",
        "detail": "deps.sample-factory.sf_examples.isaacgym_examples.experiments.isaacgym_humanoid",
        "documentation": {}
    },
    {
        "label": "RUN_DESCRIPTION",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.isaacgym_examples.experiments.isaacgym_humanoid",
        "description": "deps.sample-factory.sf_examples.isaacgym_examples.experiments.isaacgym_humanoid",
        "peekOfCode": "RUN_DESCRIPTION = RunDescription(vstr, experiments=_experiments)\n# Run locally: python -m sample_factory.launcher.run --run=sf_examples.isaacgym_examples.experiments.isaacgym_humanoid --backend=processes --max_parallel=2 --experiments_per_gpu=2 --num_gpus=1\n# Run on Slurm: python -m sample_factory.launcher.run --run=sf_examples.isaacgym_examples.experiments.isaacgym_humanoid --backend=slurm --slurm_workdir=./slurm_isaacgym --experiment_suffix=slurm --slurm_gpus_per_job=1 --slurm_cpus_per_gpu=16 --slurm_sbatch_template=./sample_factory/launcher/slurm/sbatch_timeout.sh --pause_between=1 --slurm_print_only=False",
        "detail": "deps.sample-factory.sf_examples.isaacgym_examples.experiments.isaacgym_humanoid",
        "documentation": {}
    },
    {
        "label": "version",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.isaacgym_examples.experiments.isaacgym_runs",
        "description": "deps.sample-factory.sf_examples.isaacgym_examples.experiments.isaacgym_runs",
        "peekOfCode": "version = ALGO_VERSION\nvstr = f\"v{version:03d}\"\n# wandb_project = 'rlgpu-2022'\nwandb_project = \"sample_factory\"\nbase_cli = (\n    f\"python -m sf_examples.isaacgym_examples.train_isaacgym \"\n    f\"--actor_worker_gpus 0 \"\n    f\"--wandb_project={wandb_project}\"\n)",
        "detail": "deps.sample-factory.sf_examples.isaacgym_examples.experiments.isaacgym_runs",
        "documentation": {}
    },
    {
        "label": "vstr",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.isaacgym_examples.experiments.isaacgym_runs",
        "description": "deps.sample-factory.sf_examples.isaacgym_examples.experiments.isaacgym_runs",
        "peekOfCode": "vstr = f\"v{version:03d}\"\n# wandb_project = 'rlgpu-2022'\nwandb_project = \"sample_factory\"\nbase_cli = (\n    f\"python -m sf_examples.isaacgym_examples.train_isaacgym \"\n    f\"--actor_worker_gpus 0 \"\n    f\"--wandb_project={wandb_project}\"\n)",
        "detail": "deps.sample-factory.sf_examples.isaacgym_examples.experiments.isaacgym_runs",
        "documentation": {}
    },
    {
        "label": "wandb_project",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.isaacgym_examples.experiments.isaacgym_runs",
        "description": "deps.sample-factory.sf_examples.isaacgym_examples.experiments.isaacgym_runs",
        "peekOfCode": "wandb_project = \"sample_factory\"\nbase_cli = (\n    f\"python -m sf_examples.isaacgym_examples.train_isaacgym \"\n    f\"--actor_worker_gpus 0 \"\n    f\"--wandb_project={wandb_project}\"\n)",
        "detail": "deps.sample-factory.sf_examples.isaacgym_examples.experiments.isaacgym_runs",
        "documentation": {}
    },
    {
        "label": "base_cli",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.isaacgym_examples.experiments.isaacgym_runs",
        "description": "deps.sample-factory.sf_examples.isaacgym_examples.experiments.isaacgym_runs",
        "peekOfCode": "base_cli = (\n    f\"python -m sf_examples.isaacgym_examples.train_isaacgym \"\n    f\"--actor_worker_gpus 0 \"\n    f\"--wandb_project={wandb_project}\"\n)",
        "detail": "deps.sample-factory.sf_examples.isaacgym_examples.experiments.isaacgym_runs",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.isaacgym_examples.enjoy_isaacgym",
        "description": "deps.sample-factory.sf_examples.isaacgym_examples.enjoy_isaacgym",
        "peekOfCode": "def main():\n    \"\"\"Script entry point.\"\"\"\n    register_isaacgym_custom_components()\n    cfg = parse_isaacgym_cfg(evaluation=True)\n    status = enjoy(cfg)\n    return status\nif __name__ == \"__main__\":\n    sys.exit(main())",
        "detail": "deps.sample-factory.sf_examples.isaacgym_examples.enjoy_isaacgym",
        "documentation": {}
    },
    {
        "label": "IsaacGymVecEnv",
        "kind": 6,
        "importPath": "deps.sample-factory.sf_examples.isaacgym_examples.train_isaacgym",
        "description": "deps.sample-factory.sf_examples.isaacgym_examples.train_isaacgym",
        "peekOfCode": "class IsaacGymVecEnv(gym.Env):\n    def __init__(self, isaacgym_env, obs_key):\n        self.env = isaacgym_env\n        # what about vectorized multi-agent envs? should we take num_agents into account also?\n        self.num_agents = self.env.num_envs\n        self.action_space = convert_space(self.env.action_space)\n        # isaacgym_examples environments actually return dicts\n        if obs_key == \"obs\":\n            self.observation_space = gym.spaces.Dict(dict(obs=convert_space(self.env.observation_space)))\n            self._proc_obs_func = lambda obs_dict: obs_dict",
        "detail": "deps.sample-factory.sf_examples.isaacgym_examples.train_isaacgym",
        "documentation": {}
    },
    {
        "label": "make_isaacgym_env",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.isaacgym_examples.train_isaacgym",
        "description": "deps.sample-factory.sf_examples.isaacgym_examples.train_isaacgym",
        "peekOfCode": "def make_isaacgym_env(full_env_name: str, cfg: Config, _env_config=None, render_mode: Optional[str] = None) -> Env:\n    task_name = full_env_name\n    overrides = ige_task_cfg_overrides(task_name, cfg)\n    import isaacgymenvs\n    from hydra import compose, initialize\n    # this will register resolvers for the hydra config\n    # noinspection PyUnresolvedReferences\n    from isaacgymenvs import train\n    module_dir = isaacgymenvs.__path__[0]\n    cfg_dir = join(module_dir, \"cfg\")",
        "detail": "deps.sample-factory.sf_examples.isaacgym_examples.train_isaacgym",
        "documentation": {}
    },
    {
        "label": "add_extra_params_func",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.isaacgym_examples.train_isaacgym",
        "description": "deps.sample-factory.sf_examples.isaacgym_examples.train_isaacgym",
        "peekOfCode": "def add_extra_params_func(parser):\n    \"\"\"\n    Specify any additional command line arguments for this family of custom environments.\n    \"\"\"\n    p = parser\n    p.add_argument(\n        \"--env_agents\",\n        default=-1,\n        type=int,\n        help=\"Num agents in each env (default: -1, means use default value from isaacgymenvs env yaml config file)\",",
        "detail": "deps.sample-factory.sf_examples.isaacgym_examples.train_isaacgym",
        "documentation": {}
    },
    {
        "label": "override_default_params_func",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.isaacgym_examples.train_isaacgym",
        "description": "deps.sample-factory.sf_examples.isaacgym_examples.train_isaacgym",
        "peekOfCode": "def override_default_params_func(env, parser):\n    \"\"\"Most of these parameters are taken from IsaacGymEnvs default config files.\"\"\"\n    parser.set_defaults(\n        # we're using a single very vectorized env, no need to parallelize it further\n        batched_sampling=True,\n        num_workers=1,\n        num_envs_per_worker=1,\n        worker_num_splits=1,\n        actor_worker_gpus=[0],  # obviously need a GPU\n        train_for_env_steps=10000000,",
        "detail": "deps.sample-factory.sf_examples.isaacgym_examples.train_isaacgym",
        "documentation": {}
    },
    {
        "label": "ige_task_cfg_overrides",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.isaacgym_examples.train_isaacgym",
        "description": "deps.sample-factory.sf_examples.isaacgym_examples.train_isaacgym",
        "peekOfCode": "def ige_task_cfg_overrides(task_name: str, cfg: Config) -> List[str]:\n    \"\"\"\n    Ideally we would directly override these in CLI in Hydra config, but this would require integrating\n    Hydra config into Sample Factory, which would require anyone who uses Sample Factory to use Hydra as well.\n    We might want to do this in the future, but for now this should be sufficient.\n    \"\"\"\n    overrides = [f\"task={task_name}\"]\n    if cfg.env_agents > 0:\n        overrides.append(f\"num_envs={cfg.env_agents}\")\n    if cfg.subtask is not None:",
        "detail": "deps.sample-factory.sf_examples.isaacgym_examples.train_isaacgym",
        "documentation": {}
    },
    {
        "label": "register_isaacgym_custom_components",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.isaacgym_examples.train_isaacgym",
        "description": "deps.sample-factory.sf_examples.isaacgym_examples.train_isaacgym",
        "peekOfCode": "def register_isaacgym_custom_components():\n    for env_name in env_configs:\n        register_env(env_name, make_isaacgym_env)\ndef parse_isaacgym_cfg(evaluation=False):\n    parser, partial_cfg = parse_sf_args(evaluation=evaluation)\n    add_extra_params_func(parser)\n    override_default_params_func(partial_cfg.env, parser)\n    final_cfg = parse_full_cfg(parser)\n    return final_cfg\ndef main():",
        "detail": "deps.sample-factory.sf_examples.isaacgym_examples.train_isaacgym",
        "documentation": {}
    },
    {
        "label": "parse_isaacgym_cfg",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.isaacgym_examples.train_isaacgym",
        "description": "deps.sample-factory.sf_examples.isaacgym_examples.train_isaacgym",
        "peekOfCode": "def parse_isaacgym_cfg(evaluation=False):\n    parser, partial_cfg = parse_sf_args(evaluation=evaluation)\n    add_extra_params_func(parser)\n    override_default_params_func(partial_cfg.env, parser)\n    final_cfg = parse_full_cfg(parser)\n    return final_cfg\ndef main():\n    \"\"\"Script entry point.\"\"\"\n    register_isaacgym_custom_components()\n    cfg = parse_isaacgym_cfg()",
        "detail": "deps.sample-factory.sf_examples.isaacgym_examples.train_isaacgym",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.isaacgym_examples.train_isaacgym",
        "description": "deps.sample-factory.sf_examples.isaacgym_examples.train_isaacgym",
        "peekOfCode": "def main():\n    \"\"\"Script entry point.\"\"\"\n    register_isaacgym_custom_components()\n    cfg = parse_isaacgym_cfg()\n    status = run_rl(cfg)\n    return status\nif __name__ == \"__main__\":\n    sys.exit(main())",
        "detail": "deps.sample-factory.sf_examples.isaacgym_examples.train_isaacgym",
        "documentation": {}
    },
    {
        "label": "env_configs",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.isaacgym_examples.train_isaacgym",
        "description": "deps.sample-factory.sf_examples.isaacgym_examples.train_isaacgym",
        "peekOfCode": "env_configs = dict(\n    Ant=dict(\n        encoder_mlp_layers=[256, 128, 64],\n        experiment_summaries_interval=3,  # experiments are short so we should save summaries often\n        save_every_sec=15,\n        # trains better without normalized returns, but we keep the default value for consistency\n        # normalize_returns=False,\n    ),\n    Anymal=dict(\n        train_for_env_steps=1310000000,",
        "detail": "deps.sample-factory.sf_examples.isaacgym_examples.train_isaacgym",
        "documentation": {}
    },
    {
        "label": "env_configs[\"AllegroKukaTwoArmsLSTM\"]",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.isaacgym_examples.train_isaacgym",
        "description": "deps.sample-factory.sf_examples.isaacgym_examples.train_isaacgym",
        "peekOfCode": "env_configs[\"AllegroKukaTwoArmsLSTM\"] = env_configs[\"AllegroKukaLSTM\"]\ndef ige_task_cfg_overrides(task_name: str, cfg: Config) -> List[str]:\n    \"\"\"\n    Ideally we would directly override these in CLI in Hydra config, but this would require integrating\n    Hydra config into Sample Factory, which would require anyone who uses Sample Factory to use Hydra as well.\n    We might want to do this in the future, but for now this should be sufficient.\n    \"\"\"\n    overrides = [f\"task={task_name}\"]\n    if cfg.env_agents > 0:\n        overrides.append(f\"num_envs={cfg.env_agents}\")",
        "detail": "deps.sample-factory.sf_examples.isaacgym_examples.train_isaacgym",
        "documentation": {}
    },
    {
        "label": "_params",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.mujoco.experiments.mujoco_all_envs",
        "description": "deps.sample-factory.sf_examples.mujoco.experiments.mujoco_all_envs",
        "peekOfCode": "_params = ParamGrid(\n    [\n        (\"seed\", [0, 1111, 2222, 3333, 4444, 5555, 6666, 7777, 8888, 9999]),\n        (\n            \"env\",\n            [\n                \"mujoco_ant\",\n                \"mujoco_halfcheetah\",\n                \"mujoco_hopper\",\n                \"mujoco_humanoid\",",
        "detail": "deps.sample-factory.sf_examples.mujoco.experiments.mujoco_all_envs",
        "documentation": {}
    },
    {
        "label": "_experiments",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.mujoco.experiments.mujoco_all_envs",
        "description": "deps.sample-factory.sf_examples.mujoco.experiments.mujoco_all_envs",
        "peekOfCode": "_experiments = [\n    Experiment(\n        \"mujoco_all_envs\",\n        \"python -m sf_examples.mujoco.train_mujoco --algo=APPO --with_wandb=True --wandb_tags mujoco\",\n        _params.generate_params(randomize=False),\n    ),\n]\nRUN_DESCRIPTION = RunDescription(\"mujoco_all_envs\", experiments=_experiments)\n# python -m sample_factory.launcher.run --run=sf_examples.mujoco.experiments.mujoco_all_envs --backend=processes --max_parallel=4  --pause_between=1 --experiments_per_gpu=4 --num_gpus=1",
        "detail": "deps.sample-factory.sf_examples.mujoco.experiments.mujoco_all_envs",
        "documentation": {}
    },
    {
        "label": "RUN_DESCRIPTION",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.mujoco.experiments.mujoco_all_envs",
        "description": "deps.sample-factory.sf_examples.mujoco.experiments.mujoco_all_envs",
        "peekOfCode": "RUN_DESCRIPTION = RunDescription(\"mujoco_all_envs\", experiments=_experiments)\n# python -m sample_factory.launcher.run --run=sf_examples.mujoco.experiments.mujoco_all_envs --backend=processes --max_parallel=4  --pause_between=1 --experiments_per_gpu=4 --num_gpus=1",
        "detail": "deps.sample-factory.sf_examples.mujoco.experiments.mujoco_all_envs",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.mujoco.enjoy_mujoco",
        "description": "deps.sample-factory.sf_examples.mujoco.enjoy_mujoco",
        "peekOfCode": "def main():\n    \"\"\"Script entry point.\"\"\"\n    register_mujoco_components()\n    cfg = parse_mujoco_cfg(evaluation=True)\n    status = enjoy(cfg)\n    return status\nif __name__ == \"__main__\":\n    sys.exit(main())",
        "detail": "deps.sample-factory.sf_examples.mujoco.enjoy_mujoco",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.mujoco.fast_eval_mujoco",
        "description": "deps.sample-factory.sf_examples.mujoco.fast_eval_mujoco",
        "peekOfCode": "def main():\n    \"\"\"Script entry point.\"\"\"\n    register_mujoco_components()\n    parser, cfg = parse_sf_args(evaluation=True)\n    add_mujoco_env_args(cfg.env, parser)\n    mujoco_override_defaults(cfg.env, parser)\n    # important, instead of `load_from_checkpoint` as in enjoy we want\n    # to override it here to be able to use argv arguments\n    checkpoint_override_defaults(cfg, parser)\n    cfg = parse_full_cfg(parser)",
        "detail": "deps.sample-factory.sf_examples.mujoco.fast_eval_mujoco",
        "documentation": {}
    },
    {
        "label": "mujoco_override_defaults",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.mujoco.mujoco_params",
        "description": "deps.sample-factory.sf_examples.mujoco.mujoco_params",
        "peekOfCode": "def mujoco_override_defaults(env, parser):\n    parser.set_defaults(\n        batched_sampling=False,\n        num_workers=8,\n        num_envs_per_worker=8,\n        worker_num_splits=2,\n        train_for_env_steps=10000000,\n        encoder_mlp_layers=[64, 64],\n        env_frameskip=1,\n        nonlinearity=\"tanh\",",
        "detail": "deps.sample-factory.sf_examples.mujoco.mujoco_params",
        "documentation": {}
    },
    {
        "label": "add_mujoco_env_args",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.mujoco.mujoco_params",
        "description": "deps.sample-factory.sf_examples.mujoco.mujoco_params",
        "peekOfCode": "def add_mujoco_env_args(env, parser):\n    # in case we need to add more args in the future\n    pass",
        "detail": "deps.sample-factory.sf_examples.mujoco.mujoco_params",
        "documentation": {}
    },
    {
        "label": "MujocoSpec",
        "kind": 6,
        "importPath": "deps.sample-factory.sf_examples.mujoco.mujoco_utils",
        "description": "deps.sample-factory.sf_examples.mujoco.mujoco_utils",
        "peekOfCode": "class MujocoSpec:\n    def __init__(self, name, env_id):\n        self.name = name\n        self.env_id = env_id\nMUJOCO_ENVS = [\n    MujocoSpec(\"mujoco_hopper\", \"Hopper-v4\"),\n    MujocoSpec(\"mujoco_halfcheetah\", \"HalfCheetah-v4\"),\n    MujocoSpec(\"mujoco_humanoid\", \"Humanoid-v4\"),\n    MujocoSpec(\"mujoco_ant\", \"Ant-v4\"),\n    MujocoSpec(\"mujoco_standup\", \"HumanoidStandup-v4\"),",
        "detail": "deps.sample-factory.sf_examples.mujoco.mujoco_utils",
        "documentation": {}
    },
    {
        "label": "mujoco_available",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.mujoco.mujoco_utils",
        "description": "deps.sample-factory.sf_examples.mujoco.mujoco_utils",
        "peekOfCode": "def mujoco_available():\n    return is_module_available(\"mujoco\")\nclass MujocoSpec:\n    def __init__(self, name, env_id):\n        self.name = name\n        self.env_id = env_id\nMUJOCO_ENVS = [\n    MujocoSpec(\"mujoco_hopper\", \"Hopper-v4\"),\n    MujocoSpec(\"mujoco_halfcheetah\", \"HalfCheetah-v4\"),\n    MujocoSpec(\"mujoco_humanoid\", \"Humanoid-v4\"),",
        "detail": "deps.sample-factory.sf_examples.mujoco.mujoco_utils",
        "documentation": {}
    },
    {
        "label": "mujoco_env_by_name",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.mujoco.mujoco_utils",
        "description": "deps.sample-factory.sf_examples.mujoco.mujoco_utils",
        "peekOfCode": "def mujoco_env_by_name(name):\n    for cfg in MUJOCO_ENVS:\n        if cfg.name == name:\n            return cfg\n    raise Exception(\"Unknown Mujoco env\")\ndef make_mujoco_env(env_name, _cfg, _env_config, render_mode: Optional[str] = None, **kwargs):\n    mujoco_spec = mujoco_env_by_name(env_name)\n    env = gym.make(mujoco_spec.env_id, render_mode=render_mode)\n    return env",
        "detail": "deps.sample-factory.sf_examples.mujoco.mujoco_utils",
        "documentation": {}
    },
    {
        "label": "make_mujoco_env",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.mujoco.mujoco_utils",
        "description": "deps.sample-factory.sf_examples.mujoco.mujoco_utils",
        "peekOfCode": "def make_mujoco_env(env_name, _cfg, _env_config, render_mode: Optional[str] = None, **kwargs):\n    mujoco_spec = mujoco_env_by_name(env_name)\n    env = gym.make(mujoco_spec.env_id, render_mode=render_mode)\n    return env",
        "detail": "deps.sample-factory.sf_examples.mujoco.mujoco_utils",
        "documentation": {}
    },
    {
        "label": "MUJOCO_ENVS",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.mujoco.mujoco_utils",
        "description": "deps.sample-factory.sf_examples.mujoco.mujoco_utils",
        "peekOfCode": "MUJOCO_ENVS = [\n    MujocoSpec(\"mujoco_hopper\", \"Hopper-v4\"),\n    MujocoSpec(\"mujoco_halfcheetah\", \"HalfCheetah-v4\"),\n    MujocoSpec(\"mujoco_humanoid\", \"Humanoid-v4\"),\n    MujocoSpec(\"mujoco_ant\", \"Ant-v4\"),\n    MujocoSpec(\"mujoco_standup\", \"HumanoidStandup-v4\"),\n    MujocoSpec(\"mujoco_doublependulum\", \"InvertedDoublePendulum-v4\"),\n    MujocoSpec(\"mujoco_pendulum\", \"InvertedPendulum-v4\"),\n    MujocoSpec(\"mujoco_reacher\", \"Reacher-v4\"),\n    MujocoSpec(\"mujoco_walker\", \"Walker2d-v4\"),",
        "detail": "deps.sample-factory.sf_examples.mujoco.mujoco_utils",
        "documentation": {}
    },
    {
        "label": "register_mujoco_components",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.mujoco.train_mujoco",
        "description": "deps.sample-factory.sf_examples.mujoco.train_mujoco",
        "peekOfCode": "def register_mujoco_components():\n    for env in MUJOCO_ENVS:\n        register_env(env.name, make_mujoco_env)\ndef parse_mujoco_cfg(argv=None, evaluation=False):\n    parser, partial_cfg = parse_sf_args(argv=argv, evaluation=evaluation)\n    add_mujoco_env_args(partial_cfg.env, parser)\n    mujoco_override_defaults(partial_cfg.env, parser)\n    final_cfg = parse_full_cfg(parser, argv)\n    return final_cfg\ndef main():  # pragma: no cover",
        "detail": "deps.sample-factory.sf_examples.mujoco.train_mujoco",
        "documentation": {}
    },
    {
        "label": "parse_mujoco_cfg",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.mujoco.train_mujoco",
        "description": "deps.sample-factory.sf_examples.mujoco.train_mujoco",
        "peekOfCode": "def parse_mujoco_cfg(argv=None, evaluation=False):\n    parser, partial_cfg = parse_sf_args(argv=argv, evaluation=evaluation)\n    add_mujoco_env_args(partial_cfg.env, parser)\n    mujoco_override_defaults(partial_cfg.env, parser)\n    final_cfg = parse_full_cfg(parser, argv)\n    return final_cfg\ndef main():  # pragma: no cover\n    \"\"\"Script entry point.\"\"\"\n    register_mujoco_components()\n    cfg = parse_mujoco_cfg()",
        "detail": "deps.sample-factory.sf_examples.mujoco.train_mujoco",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.mujoco.train_mujoco",
        "description": "deps.sample-factory.sf_examples.mujoco.train_mujoco",
        "peekOfCode": "def main():  # pragma: no cover\n    \"\"\"Script entry point.\"\"\"\n    register_mujoco_components()\n    cfg = parse_mujoco_cfg()\n    status = run_rl(cfg)\n    return status\nif __name__ == \"__main__\":  # pragma: no cover\n    sys.exit(main())",
        "detail": "deps.sample-factory.sf_examples.mujoco.train_mujoco",
        "documentation": {}
    },
    {
        "label": "MessageEncoder",
        "kind": 6,
        "importPath": "deps.sample-factory.sf_examples.nethack.models.chaotic_dwarf",
        "description": "deps.sample-factory.sf_examples.nethack.models.chaotic_dwarf",
        "peekOfCode": "class MessageEncoder(nn.Module):\n    def __init__(self):\n        super(MessageEncoder, self).__init__()\n        self.hidden_dim = 128\n        self.msg_fwd = nn.Sequential(\n            nn.Linear(nethack.MESSAGE_SHAPE[0], 128),\n            nn.ELU(inplace=True),\n            nn.Linear(128, self.hidden_dim),\n            nn.ELU(inplace=True),\n        )",
        "detail": "deps.sample-factory.sf_examples.nethack.models.chaotic_dwarf",
        "documentation": {}
    },
    {
        "label": "BLStatsEncoder",
        "kind": 6,
        "importPath": "deps.sample-factory.sf_examples.nethack.models.chaotic_dwarf",
        "description": "deps.sample-factory.sf_examples.nethack.models.chaotic_dwarf",
        "peekOfCode": "class BLStatsEncoder(nn.Module):\n    def __init__(self):\n        super(BLStatsEncoder, self).__init__()\n        self.hidden_dim = 128 + nethack.BLSTATS_SHAPE[0]\n        self.blstats_fwd = nn.Sequential(\n            nn.Linear(nethack.BLSTATS_SHAPE[0], 128),\n            nn.ELU(inplace=True),\n            nn.Linear(128, 128),\n            nn.ELU(inplace=True),\n        )",
        "detail": "deps.sample-factory.sf_examples.nethack.models.chaotic_dwarf",
        "documentation": {}
    },
    {
        "label": "TopLineEncoder",
        "kind": 6,
        "importPath": "deps.sample-factory.sf_examples.nethack.models.chaotic_dwarf",
        "description": "deps.sample-factory.sf_examples.nethack.models.chaotic_dwarf",
        "peekOfCode": "class TopLineEncoder(nn.Module):\n    def __init__(self):\n        super(TopLineEncoder, self).__init__()\n        self.hidden_dim = 128\n        self.i_dim = nethack.NLE_TERM_CO * 256\n        self.msg_fwd = nn.Sequential(\n            nn.Linear(self.i_dim, 128),\n            nn.ELU(inplace=True),\n            nn.Linear(128, self.hidden_dim),\n            nn.ELU(inplace=True),",
        "detail": "deps.sample-factory.sf_examples.nethack.models.chaotic_dwarf",
        "documentation": {}
    },
    {
        "label": "BottomLinesEncoder",
        "kind": 6,
        "importPath": "deps.sample-factory.sf_examples.nethack.models.chaotic_dwarf",
        "description": "deps.sample-factory.sf_examples.nethack.models.chaotic_dwarf",
        "peekOfCode": "class BottomLinesEncoder(nn.Module):\n    def __init__(self):\n        super(BottomLinesEncoder, self).__init__()\n        self.conv_layers = []\n        w = nethack.NLE_TERM_CO * 2\n        for in_ch, out_ch, filter, stride in [[2, 32, 8, 4], [32, 64, 4, 1]]:\n            self.conv_layers.append(nn.Conv1d(in_ch, out_ch, filter, stride=stride))\n            self.conv_layers.append(nn.ELU(inplace=True))\n            w = conv_outdim(w, filter, padding=0, stride=stride)\n        self.conv_net = nn.Sequential(*self.conv_layers)",
        "detail": "deps.sample-factory.sf_examples.nethack.models.chaotic_dwarf",
        "documentation": {}
    },
    {
        "label": "InverseModel",
        "kind": 6,
        "importPath": "deps.sample-factory.sf_examples.nethack.models.chaotic_dwarf",
        "description": "deps.sample-factory.sf_examples.nethack.models.chaotic_dwarf",
        "peekOfCode": "class InverseModel(nn.Module):\n    def __init__(self, h_dim, action_space):\n        super(InverseModel, self).__init__()\n        self.h_dim = h_dim * 2\n        self.action_space = action_space\n        self.fwd_model = nn.Sequential(\n            nn.Linear(self.h_dim, 128),\n            nn.ELU(inplace=True),\n            nn.Linear(128, 128),\n            nn.ELU(inplace=True),",
        "detail": "deps.sample-factory.sf_examples.nethack.models.chaotic_dwarf",
        "documentation": {}
    },
    {
        "label": "ScreenEncoder",
        "kind": 6,
        "importPath": "deps.sample-factory.sf_examples.nethack.models.chaotic_dwarf",
        "description": "deps.sample-factory.sf_examples.nethack.models.chaotic_dwarf",
        "peekOfCode": "class ScreenEncoder(nn.Module):\n    def __init__(self, screen_shape):\n        super(ScreenEncoder, self).__init__()\n        conv_layers = []\n        self.h, self.w = screen_shape\n        self.hidden_dim = 512\n        self.conv_filters = [\n            [3, 32, 8, 6, 1],\n            [32, 64, 4, 2, 1],\n            [64, 128, 3, 2, 1],",
        "detail": "deps.sample-factory.sf_examples.nethack.models.chaotic_dwarf",
        "documentation": {}
    },
    {
        "label": "ChaoticDwarvenGPT5",
        "kind": 6,
        "importPath": "deps.sample-factory.sf_examples.nethack.models.chaotic_dwarf",
        "description": "deps.sample-factory.sf_examples.nethack.models.chaotic_dwarf",
        "peekOfCode": "class ChaoticDwarvenGPT5(Encoder):\n    def __init__(self, cfg: Config, obs_space: ObsSpace):\n        super().__init__(cfg)\n        self.obs_keys = list(sorted(obs_space.keys()))  # always the same order\n        self.encoders = nn.ModuleDict()\n        self.use_tty_only = cfg.use_tty_only\n        self.use_prev_action = cfg.use_prev_action\n        # screen encoder (TODO: could also use only tty_chars)\n        pixel_size = cfg.pixel_size\n        if cfg.crop_dim == 0:",
        "detail": "deps.sample-factory.sf_examples.nethack.models.chaotic_dwarf",
        "documentation": {}
    },
    {
        "label": "conv_outdim",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.nethack.models.chaotic_dwarf",
        "description": "deps.sample-factory.sf_examples.nethack.models.chaotic_dwarf",
        "peekOfCode": "def conv_outdim(i_dim, k, padding=0, stride=1, dilation=1):\n    \"\"\"Return the dimension after applying a convolution along one axis\"\"\"\n    return int(1 + (i_dim + 2 * padding - dilation * (k - 1) - 1) / stride)\nclass InverseModel(nn.Module):\n    def __init__(self, h_dim, action_space):\n        super(InverseModel, self).__init__()\n        self.h_dim = h_dim * 2\n        self.action_space = action_space\n        self.fwd_model = nn.Sequential(\n            nn.Linear(self.h_dim, 128),",
        "detail": "deps.sample-factory.sf_examples.nethack.models.chaotic_dwarf",
        "documentation": {}
    },
    {
        "label": "CMakeExtension",
        "kind": 6,
        "importPath": "deps.sample-factory.sf_examples.nethack.nethack_render_utils.setup",
        "description": "deps.sample-factory.sf_examples.nethack.nethack_render_utils.setup",
        "peekOfCode": "class CMakeExtension(Extension):\n    def __init__(self, name, sourcedir=\"\"):\n        Extension.__init__(self, name, sources=[])\n        self.sourcedir = os.path.abspath(sourcedir)\nclass CMakeBuild(build_ext):\n    def build_extension(self, ext):\n        extdir = os.path.abspath(os.path.dirname(self.get_ext_fullpath(ext.name)))\n        # required for auto-detection & inclusion of auxiliary \"native\" libs\n        if not extdir.endswith(os.path.sep):\n            extdir += os.path.sep",
        "detail": "deps.sample-factory.sf_examples.nethack.nethack_render_utils.setup",
        "documentation": {}
    },
    {
        "label": "CMakeBuild",
        "kind": 6,
        "importPath": "deps.sample-factory.sf_examples.nethack.nethack_render_utils.setup",
        "description": "deps.sample-factory.sf_examples.nethack.nethack_render_utils.setup",
        "peekOfCode": "class CMakeBuild(build_ext):\n    def build_extension(self, ext):\n        extdir = os.path.abspath(os.path.dirname(self.get_ext_fullpath(ext.name)))\n        # required for auto-detection & inclusion of auxiliary \"native\" libs\n        if not extdir.endswith(os.path.sep):\n            extdir += os.path.sep\n        debug = int(os.environ.get(\"DEBUG\", 0)) if self.debug is None else self.debug\n        cfg = \"Debug\" if debug else \"Release\"\n        # CMake lets you override the generator - we need to check this.\n        # Can be set with Conda-Build, for example.",
        "detail": "deps.sample-factory.sf_examples.nethack.nethack_render_utils.setup",
        "documentation": {}
    },
    {
        "label": "PLAT_TO_CMAKE",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.nethack.nethack_render_utils.setup",
        "description": "deps.sample-factory.sf_examples.nethack.nethack_render_utils.setup",
        "peekOfCode": "PLAT_TO_CMAKE = {\n    \"win32\": \"Win32\",\n    \"win-amd64\": \"x64\",\n    \"win-arm32\": \"ARM\",\n    \"win-arm64\": \"ARM64\",\n}\n# A CMakeExtension needs a sourcedir instead of a file list.\n# The name must be the _single_ output extension from the CMake build.\n# If you need multiple extensions, see scikit-build.\nclass CMakeExtension(Extension):",
        "detail": "deps.sample-factory.sf_examples.nethack.nethack_render_utils.setup",
        "documentation": {}
    },
    {
        "label": "create_env",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.nethack.nethack_render_utils.test",
        "description": "deps.sample-factory.sf_examples.nethack.nethack_render_utils.test",
        "peekOfCode": "def create_env():\n    return wrappers.RenderCharImagesWithNumpyWrapper(gym.make(\"NetHackChallenge-v0\"), blstats_cursor=False)\ndef load_obs():\n    e = create_env()\n    e.reset()\n    e.step(0)\n    obs = e.step(1)[0]\n    obs = e.step(5)[0]\n    images = e.char_array.copy()\n    return (",
        "detail": "deps.sample-factory.sf_examples.nethack.nethack_render_utils.test",
        "documentation": {}
    },
    {
        "label": "load_obs",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.nethack.nethack_render_utils.test",
        "description": "deps.sample-factory.sf_examples.nethack.nethack_render_utils.test",
        "peekOfCode": "def load_obs():\n    e = create_env()\n    e.reset()\n    e.step(0)\n    obs = e.step(1)[0]\n    obs = e.step(5)[0]\n    images = e.char_array.copy()\n    return (\n        obs[\"tty_chars\"].copy(),\n        obs[\"tty_colors\"].copy(),",
        "detail": "deps.sample-factory.sf_examples.nethack.nethack_render_utils.test",
        "documentation": {}
    },
    {
        "label": "test_main",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.nethack.nethack_render_utils.test",
        "description": "deps.sample-factory.sf_examples.nethack.nethack_render_utils.test",
        "peekOfCode": "def test_main():\n    assert m.__version__ == \"0.0.1\"\n    assert m.add(1, 2) == 3\n    assert m.subtract(1, 2) == -1\nnp.set_printoptions(threshold=sys.maxsize)\ndef test(_):\n    obs = [np.ascontiguousarray(x) for x in load_obs()]\n    chars, colors, cursor, images, screen_image = obs\n    out = np.zeros_like(screen_image, order=\"C\")\n    out = np.zeros((3, 72, 72), order=\"C\", dtype=np.uint8)",
        "detail": "deps.sample-factory.sf_examples.nethack.nethack_render_utils.test",
        "documentation": {}
    },
    {
        "label": "test",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.nethack.nethack_render_utils.test",
        "description": "deps.sample-factory.sf_examples.nethack.nethack_render_utils.test",
        "peekOfCode": "def test(_):\n    obs = [np.ascontiguousarray(x) for x in load_obs()]\n    chars, colors, cursor, images, screen_image = obs\n    out = np.zeros_like(screen_image, order=\"C\")\n    out = np.zeros((3, 72, 72), order=\"C\", dtype=np.uint8)\n    m.render_crop(chars, colors, cursor, images, out, screen_image)\n    if not np.all(out == screen_image):\n        scr_im = im.fromarray(np.transpose(screen_image, (1, 2, 0)))\n        out_im = im.fromarray(np.transpose(out, (1, 2, 0)))\n        # saving the final output",
        "detail": "deps.sample-factory.sf_examples.nethack.nethack_render_utils.test",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.nethack.scripts.sample_env",
        "description": "deps.sample-factory.sf_examples.nethack.scripts.sample_env",
        "peekOfCode": "def main():\n    register_nethack_components()\n    cfg = parse_nethack_args(evaluation=True)\n    render_mode = \"human\"\n    if cfg.save_video:\n        render_mode = \"rgb_array\"\n    elif cfg.no_render:\n        render_mode = None\n    env = create_env(cfg.env, cfg=cfg, render_mode=render_mode)\n    env.seed(0)",
        "detail": "deps.sample-factory.sf_examples.nethack.scripts.sample_env",
        "documentation": {}
    },
    {
        "label": "BlstatsInfoWrapper",
        "kind": 6,
        "importPath": "deps.sample-factory.sf_examples.nethack.utils.wrappers.blstats_info",
        "description": "deps.sample-factory.sf_examples.nethack.utils.wrappers.blstats_info",
        "peekOfCode": "class BlstatsInfoWrapper(gym.Wrapper):\n    def step(self, action):\n        # because we will see done=True at the first timestep of the new episode\n        # to properly calculate blstats at the end of the episode we need to keep the last_observation around\n        last_observation = tuple(a.copy() for a in self.env.unwrapped.last_observation)\n        obs, reward, done, info = self.env.step(action)\n        if done:\n            info[\"episode_extra_stats\"] = self.add_more_stats(info, last_observation)\n        return obs, reward, done, info\n    def add_more_stats(self, info, last_observation):",
        "detail": "deps.sample-factory.sf_examples.nethack.utils.wrappers.blstats_info",
        "documentation": {}
    },
    {
        "label": "BLStats",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.nethack.utils.wrappers.blstats_info",
        "description": "deps.sample-factory.sf_examples.nethack.utils.wrappers.blstats_info",
        "peekOfCode": "BLStats = namedtuple(\n    \"BLStats\",\n    \"x y strength_percentage strength dexterity constitution intelligence wisdom charisma score hitpoints max_hitpoints depth gold energy max_energy armor_class monster_level experience_level experience_points time hunger_state carrying_capacity dungeon_number level_number prop_mask align_bits\",\n)\nclass BlstatsInfoWrapper(gym.Wrapper):\n    def step(self, action):\n        # because we will see done=True at the first timestep of the new episode\n        # to properly calculate blstats at the end of the episode we need to keep the last_observation around\n        last_observation = tuple(a.copy() for a in self.env.unwrapped.last_observation)\n        obs, reward, done, info = self.env.step(action)",
        "detail": "deps.sample-factory.sf_examples.nethack.utils.wrappers.blstats_info",
        "documentation": {}
    },
    {
        "label": "PrevActionsWrapper",
        "kind": 6,
        "importPath": "deps.sample-factory.sf_examples.nethack.utils.wrappers.prev_actions",
        "description": "deps.sample-factory.sf_examples.nethack.utils.wrappers.prev_actions",
        "peekOfCode": "class PrevActionsWrapper(gym.Wrapper):\n    def __init__(self, env):\n        super().__init__(env)\n        self.prev_action = 0\n        obs_spaces = {\"prev_actions\": self.env.action_space}\n        obs_spaces.update([(k, self.env.observation_space[k]) for k in self.env.observation_space])\n        self.observation_space = gym.spaces.Dict(obs_spaces)\n    def reset(self, **kwargs):\n        self.prev_action = 0\n        obs = self.env.reset(**kwargs)",
        "detail": "deps.sample-factory.sf_examples.nethack.utils.wrappers.prev_actions",
        "documentation": {}
    },
    {
        "label": "RenderCharImagesWithNumpyWrapper",
        "kind": 6,
        "importPath": "deps.sample-factory.sf_examples.nethack.utils.wrappers.screen_image",
        "description": "deps.sample-factory.sf_examples.nethack.utils.wrappers.screen_image",
        "peekOfCode": "class RenderCharImagesWithNumpyWrapper(gym.Wrapper):\n    \"\"\"\n    Render characters as images, using PIL to render characters like we humans see on screen\n    but then some caching and numpy stuff to speed up things.\n    To speed things up, crop image around the player.\n    \"\"\"\n    def __init__(\n        self,\n        env,\n        font_size=9,",
        "detail": "deps.sample-factory.sf_examples.nethack.utils.wrappers.screen_image",
        "documentation": {}
    },
    {
        "label": "RenderCharImagesWithNumpyWrapperV2",
        "kind": 6,
        "importPath": "deps.sample-factory.sf_examples.nethack.utils.wrappers.screen_image",
        "description": "deps.sample-factory.sf_examples.nethack.utils.wrappers.screen_image",
        "peekOfCode": "class RenderCharImagesWithNumpyWrapperV2(gym.Wrapper):\n    \"\"\"\n    Same as V1, but simpler and faster.\n    \"\"\"\n    def __init__(\n        self,\n        env,\n        font_size=9,\n        crop_size=12,\n        rescale_font_size=(6, 6),",
        "detail": "deps.sample-factory.sf_examples.nethack.utils.wrappers.screen_image",
        "documentation": {}
    },
    {
        "label": "SMALL_FONT_PATH",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.nethack.utils.wrappers.screen_image",
        "description": "deps.sample-factory.sf_examples.nethack.utils.wrappers.screen_image",
        "peekOfCode": "SMALL_FONT_PATH = os.path.abspath(\"sf_examples/nethack/nethack_render_utils/Hack-Regular.ttf\")\n# Mapping of 0-15 colors used.\n# Taken from bottom image here. It seems about right\n# https://i.stack.imgur.com/UQVe5.png\nCOLORS = [\n    \"#000000\",\n    \"#800000\",\n    \"#008000\",\n    \"#808000\",\n    \"#000080\",",
        "detail": "deps.sample-factory.sf_examples.nethack.utils.wrappers.screen_image",
        "documentation": {}
    },
    {
        "label": "COLORS",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.nethack.utils.wrappers.screen_image",
        "description": "deps.sample-factory.sf_examples.nethack.utils.wrappers.screen_image",
        "peekOfCode": "COLORS = [\n    \"#000000\",\n    \"#800000\",\n    \"#008000\",\n    \"#808000\",\n    \"#000080\",\n    \"#800080\",\n    \"#008080\",\n    \"#808080\",  # - flipped these ones around\n    \"#C0C0C0\",  # | the gray-out dull stuff",
        "detail": "deps.sample-factory.sf_examples.nethack.utils.wrappers.screen_image",
        "documentation": {}
    },
    {
        "label": "SeedActionSpaceWrapper",
        "kind": 6,
        "importPath": "deps.sample-factory.sf_examples.nethack.utils.wrappers.seed_action_space",
        "description": "deps.sample-factory.sf_examples.nethack.utils.wrappers.seed_action_space",
        "peekOfCode": "class SeedActionSpaceWrapper(gym.Wrapper):\n    \"\"\"\n    To have reproducible decorrelate experience we need to seed action space\n    \"\"\"\n    def reset(self, *, seed: int | None = None, options: dict[str, Any] | None = None):\n        obs, info = self.env.reset(seed=seed, options=options)\n        self.action_space.seed(seed=seed)\n        return obs, info",
        "detail": "deps.sample-factory.sf_examples.nethack.utils.wrappers.seed_action_space",
        "documentation": {}
    },
    {
        "label": "TaskRewardsInfoWrapper",
        "kind": 6,
        "importPath": "deps.sample-factory.sf_examples.nethack.utils.wrappers.task_rewards",
        "description": "deps.sample-factory.sf_examples.nethack.utils.wrappers.task_rewards",
        "peekOfCode": "class TaskRewardsInfoWrapper(gym.Wrapper):\n    def __init__(self, env: gym.Env):\n        super().__init__(env)\n        self.tasks = [\n            EatingScore(),\n            GoldScore(),\n            ScoutScore(),\n            SokobanfillpitScore(),\n            # SokobansolvedlevelsScore(), # TODO: it could have bugs, for now turn off\n            StaircasePetScore(),",
        "detail": "deps.sample-factory.sf_examples.nethack.utils.wrappers.task_rewards",
        "documentation": {}
    },
    {
        "label": "Score",
        "kind": 6,
        "importPath": "deps.sample-factory.sf_examples.nethack.utils.task_rewards",
        "description": "deps.sample-factory.sf_examples.nethack.utils.task_rewards",
        "peekOfCode": "class Score:\n    def __init__(self):\n        self.score = 0\n        # convert name to snake_case\n        # https://stackoverflow.com/questions/1175208/elegant-python-function-to-convert-camelcase-to-snake-case\n        self.name = re.sub(\"(?!^)([A-Z]+)\", r\"_\\1\", self.__class__.__name__).lower()\n    def reset_score(self):\n        self.score = 0\nclass GoldScore(Score):\n    def reward(self, env, last_observation, observation, end_status):",
        "detail": "deps.sample-factory.sf_examples.nethack.utils.task_rewards",
        "documentation": {}
    },
    {
        "label": "GoldScore",
        "kind": 6,
        "importPath": "deps.sample-factory.sf_examples.nethack.utils.task_rewards",
        "description": "deps.sample-factory.sf_examples.nethack.utils.task_rewards",
        "peekOfCode": "class GoldScore(Score):\n    def reward(self, env, last_observation, observation, end_status):\n        old_blstats = last_observation[env._blstats_index]\n        blstats = observation[env._blstats_index]\n        old_gold = old_blstats[nethack.NLE_BL_GOLD]\n        gold = blstats[nethack.NLE_BL_GOLD]\n        reward = np.abs(gold - old_gold)\n        self.score += reward\n        return reward\nclass EatingScore(Score):",
        "detail": "deps.sample-factory.sf_examples.nethack.utils.task_rewards",
        "documentation": {}
    },
    {
        "label": "EatingScore",
        "kind": 6,
        "importPath": "deps.sample-factory.sf_examples.nethack.utils.task_rewards",
        "description": "deps.sample-factory.sf_examples.nethack.utils.task_rewards",
        "peekOfCode": "class EatingScore(Score):\n    def reward(self, env, last_observation, observation, end_status):\n        old_internal = last_observation[env._internal_index]\n        internal = observation[env._internal_index]\n        reward = max(0, internal[7] - old_internal[7])\n        self.score += reward\n        return reward\nclass ScoutScore(Score):\n    def __init__(self):\n        super().__init__()",
        "detail": "deps.sample-factory.sf_examples.nethack.utils.task_rewards",
        "documentation": {}
    },
    {
        "label": "ScoutScore",
        "kind": 6,
        "importPath": "deps.sample-factory.sf_examples.nethack.utils.task_rewards",
        "description": "deps.sample-factory.sf_examples.nethack.utils.task_rewards",
        "peekOfCode": "class ScoutScore(Score):\n    def __init__(self):\n        super().__init__()\n        self.dungeon_explored = {}\n    def reward(self, env, last_observation, observation, end_status):\n        glyphs = observation[env._glyph_index]\n        blstats = observation[env._blstats_index]\n        dungeon_num = blstats[nethack.NLE_BL_DNUM]\n        dungeon_level = blstats[nethack.NLE_BL_DLEVEL]\n        key = (dungeon_num, dungeon_level)",
        "detail": "deps.sample-factory.sf_examples.nethack.utils.task_rewards",
        "documentation": {}
    },
    {
        "label": "StaircaseScore",
        "kind": 6,
        "importPath": "deps.sample-factory.sf_examples.nethack.utils.task_rewards",
        "description": "deps.sample-factory.sf_examples.nethack.utils.task_rewards",
        "peekOfCode": "class StaircaseScore(Score):\n    \"\"\"\n    This task requires the agent to get on top of a staircase down (>).\n    The reward function is :math:`I`, where :math:`I` is 1 if the\n    task is successful, and 0 otherwise.\n    \"\"\"\n    def reward(self, env, last_observation, observation, end_status):\n        internal = observation[env._internal_index]\n        stairs_down = internal[4]\n        reward = 1 if stairs_down else 0",
        "detail": "deps.sample-factory.sf_examples.nethack.utils.task_rewards",
        "documentation": {}
    },
    {
        "label": "StaircasePetScore",
        "kind": 6,
        "importPath": "deps.sample-factory.sf_examples.nethack.utils.task_rewards",
        "description": "deps.sample-factory.sf_examples.nethack.utils.task_rewards",
        "peekOfCode": "class StaircasePetScore(Score):\n    \"\"\"\n    This task requires the agent to get on top of a staircase down (>), while\n    having their pet next to it. See `NetHackStaircase` for the reward function.\n    \"\"\"\n    def reward(self, env, last_observation, observation, end_status):\n        internal = observation[env._internal_index]\n        stairs_down = internal[4]\n        reward = 0\n        if stairs_down:",
        "detail": "deps.sample-factory.sf_examples.nethack.utils.task_rewards",
        "documentation": {}
    },
    {
        "label": "SokobanfillpitScore",
        "kind": 6,
        "importPath": "deps.sample-factory.sf_examples.nethack.utils.task_rewards",
        "description": "deps.sample-factory.sf_examples.nethack.utils.task_rewards",
        "peekOfCode": "class SokobanfillpitScore(Score):\n    \"\"\"\n    This task requires the agent to put the boulders inside wholes for sokoban.\n    We count each successful boulder moved into a whole as a total reward.\n    \"\"\"\n    def reward(self, env, last_observation, observation, end_status):\n        # the score counts how many pits we fill\n        char_array = [chr(i) for i in observation[env._message_index]]\n        message = \"\".join(char_array)\n        if message.startswith(\"The boulder fills a pit.\") or message.startswith(",
        "detail": "deps.sample-factory.sf_examples.nethack.utils.task_rewards",
        "documentation": {}
    },
    {
        "label": "SokobansolvedlevelsScore",
        "kind": 6,
        "importPath": "deps.sample-factory.sf_examples.nethack.utils.task_rewards",
        "description": "deps.sample-factory.sf_examples.nethack.utils.task_rewards",
        "peekOfCode": "class SokobansolvedlevelsScore(Score):\n    def __init__(self):\n        super().__init__()\n        self.sokoban_levels = {}\n    def reward(self, env, last_observation, observation, end_status):\n        glyphs = observation[env._glyph_index]\n        blstats = observation[env._blstats_index]\n        dungeon_num = blstats[nethack.NLE_BL_DNUM]\n        dungeon_level = blstats[nethack.NLE_BL_DLEVEL]\n        # when we know that this is sokoban",
        "detail": "deps.sample-factory.sf_examples.nethack.utils.task_rewards",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.nethack.enjoy_nethack",
        "description": "deps.sample-factory.sf_examples.nethack.enjoy_nethack",
        "peekOfCode": "def main():  # pragma: no cover\n    \"\"\"Script entry point.\"\"\"\n    register_nethack_components()\n    parser, cfg = parse_sf_args(evaluation=True)\n    add_extra_params_nethack_env(parser)\n    add_extra_params_model(parser)\n    add_extra_params_general(parser)\n    nethack_override_defaults(cfg.env, parser)\n    cfg = parse_full_cfg(parser)\n    status = enjoy(cfg)",
        "detail": "deps.sample-factory.sf_examples.nethack.enjoy_nethack",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.nethack.fast_eval_nethack",
        "description": "deps.sample-factory.sf_examples.nethack.fast_eval_nethack",
        "peekOfCode": "def main():  # pragma: no cover\n    \"\"\"Script entry point.\"\"\"\n    register_nethack_components()\n    parser, cfg = parse_sf_args(evaluation=True)\n    add_extra_params_nethack_env(parser)\n    add_extra_params_model(parser)\n    add_extra_params_general(parser)\n    nethack_override_defaults(cfg.env, parser)\n    # important, instead of `load_from_checkpoint` as in enjoy we want\n    # to override it here to be able to use argv arguments",
        "detail": "deps.sample-factory.sf_examples.nethack.fast_eval_nethack",
        "documentation": {}
    },
    {
        "label": "nethack_env_by_name",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.nethack.nethack_env",
        "description": "deps.sample-factory.sf_examples.nethack.nethack_env",
        "peekOfCode": "def nethack_env_by_name(name):\n    if name in NETHACK_ENVS.keys():\n        return NETHACK_ENVS[name]\n    else:\n        raise Exception(\"Unknown NetHack env\")\ndef make_nethack_env(env_name, cfg, env_config, render_mode: Optional[str] = None):\n    assert render_mode in (None, \"human\", \"full\", \"ansi\", \"string\", \"rgb_array\")\n    env_class = nethack_env_by_name(env_name)\n    observation_keys = (\n        \"message\",",
        "detail": "deps.sample-factory.sf_examples.nethack.nethack_env",
        "documentation": {}
    },
    {
        "label": "make_nethack_env",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.nethack.nethack_env",
        "description": "deps.sample-factory.sf_examples.nethack.nethack_env",
        "peekOfCode": "def make_nethack_env(env_name, cfg, env_config, render_mode: Optional[str] = None):\n    assert render_mode in (None, \"human\", \"full\", \"ansi\", \"string\", \"rgb_array\")\n    env_class = nethack_env_by_name(env_name)\n    observation_keys = (\n        \"message\",\n        \"blstats\",\n        \"tty_chars\",\n        \"tty_colors\",\n        \"tty_cursor\",\n        # ALSO AVAILABLE (OFF for speed)",
        "detail": "deps.sample-factory.sf_examples.nethack.nethack_env",
        "documentation": {}
    },
    {
        "label": "NETHACK_ENVS",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.nethack.nethack_env",
        "description": "deps.sample-factory.sf_examples.nethack.nethack_env",
        "peekOfCode": "NETHACK_ENVS = dict(\n    nethack_staircase=NetHackStaircase,\n    nethack_score=NetHackScore,\n    nethack_pet=NetHackStaircasePet,\n    nethack_oracle=NetHackOracle,\n    nethack_gold=NetHackGold,\n    nethack_eat=NetHackEat,\n    nethack_scout=NetHackScout,\n    nethack_challenge=NetHackChallenge,\n)",
        "detail": "deps.sample-factory.sf_examples.nethack.nethack_env",
        "documentation": {}
    },
    {
        "label": "add_extra_params_nethack_env",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.nethack.nethack_params",
        "description": "deps.sample-factory.sf_examples.nethack.nethack_params",
        "peekOfCode": "def add_extra_params_nethack_env(parser):\n    \"\"\"\n    Specify any additional command line arguments for NetHack environments.\n    \"\"\"\n    p = parser\n    p.add_argument(\n        \"--character\", type=str, default=\"mon-hum-neu-mal\", help=\"name of character. Defaults to 'mon-hum-neu-mal'.\"\n    )\n    p.add_argument(\n        \"--max_episode_steps\",",
        "detail": "deps.sample-factory.sf_examples.nethack.nethack_params",
        "documentation": {}
    },
    {
        "label": "add_extra_params_model",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.nethack.nethack_params",
        "description": "deps.sample-factory.sf_examples.nethack.nethack_params",
        "peekOfCode": "def add_extra_params_model(parser):\n    \"\"\"\n    Specify any additional command line arguments for NetHack models.\n    \"\"\"\n    p = parser\n    p.add_argument(\n        \"--use_prev_action\",\n        type=str2bool,\n        default=True,\n        help=\"If True, the model will use previous action. Defaults to `True`\",",
        "detail": "deps.sample-factory.sf_examples.nethack.nethack_params",
        "documentation": {}
    },
    {
        "label": "add_extra_params_general",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.nethack.nethack_params",
        "description": "deps.sample-factory.sf_examples.nethack.nethack_params",
        "peekOfCode": "def add_extra_params_general(parser):\n    \"\"\"\n    Specify any additional command line arguments for NetHack.\n    \"\"\"\n    p = parser\n    p.add_argument(\n        \"--model\", type=str, default=\"ChaoticDwarvenGPT5\", help=\"Name of the model. Defaults to `ChaoticDwarvenGPT5`.\"\n    )\n    p.add_argument(\n        \"--add_stats_to_info\",",
        "detail": "deps.sample-factory.sf_examples.nethack.nethack_params",
        "documentation": {}
    },
    {
        "label": "nethack_override_defaults",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.nethack.nethack_params",
        "description": "deps.sample-factory.sf_examples.nethack.nethack_params",
        "peekOfCode": "def nethack_override_defaults(_env, parser):\n    \"\"\"RL params specific to NetHack envs.\"\"\"\n    # set hyperparameter values to the same as in d&d\n    parser.set_defaults(\n        use_record_episode_statistics=False,\n        gamma=0.999,\n        num_workers=12,\n        num_envs_per_worker=2,\n        worker_num_splits=2,\n        train_for_env_steps=2_000_000_000,",
        "detail": "deps.sample-factory.sf_examples.nethack.nethack_params",
        "documentation": {}
    },
    {
        "label": "register_nethack_envs",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.nethack.train_nethack",
        "description": "deps.sample-factory.sf_examples.nethack.train_nethack",
        "peekOfCode": "def register_nethack_envs():\n    for env_name in NETHACK_ENVS.keys():\n        register_env(env_name, make_nethack_env)\ndef make_nethack_encoder(cfg: Config, obs_space: ObsSpace) -> Encoder:\n    \"\"\"Factory function as required by the API.\"\"\"\n    try:\n        model_cls = MODELS_LOOKUP[cfg.model]\n    except KeyError:\n        raise NotImplementedError(\"model=%s\" % cfg.model) from None\n    return model_cls(cfg, obs_space)",
        "detail": "deps.sample-factory.sf_examples.nethack.train_nethack",
        "documentation": {}
    },
    {
        "label": "make_nethack_encoder",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.nethack.train_nethack",
        "description": "deps.sample-factory.sf_examples.nethack.train_nethack",
        "peekOfCode": "def make_nethack_encoder(cfg: Config, obs_space: ObsSpace) -> Encoder:\n    \"\"\"Factory function as required by the API.\"\"\"\n    try:\n        model_cls = MODELS_LOOKUP[cfg.model]\n    except KeyError:\n        raise NotImplementedError(\"model=%s\" % cfg.model) from None\n    return model_cls(cfg, obs_space)\ndef register_nethack_components():\n    register_nethack_envs()\n    global_model_factory().register_encoder_factory(make_nethack_encoder)",
        "detail": "deps.sample-factory.sf_examples.nethack.train_nethack",
        "documentation": {}
    },
    {
        "label": "register_nethack_components",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.nethack.train_nethack",
        "description": "deps.sample-factory.sf_examples.nethack.train_nethack",
        "peekOfCode": "def register_nethack_components():\n    register_nethack_envs()\n    global_model_factory().register_encoder_factory(make_nethack_encoder)\ndef parse_nethack_args(argv=None, evaluation=False):\n    parser, partial_cfg = parse_sf_args(argv=argv, evaluation=evaluation)\n    add_extra_params_nethack_env(parser)\n    add_extra_params_model(parser)\n    add_extra_params_general(parser)\n    nethack_override_defaults(partial_cfg.env, parser)\n    final_cfg = parse_full_cfg(parser, argv)",
        "detail": "deps.sample-factory.sf_examples.nethack.train_nethack",
        "documentation": {}
    },
    {
        "label": "parse_nethack_args",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.nethack.train_nethack",
        "description": "deps.sample-factory.sf_examples.nethack.train_nethack",
        "peekOfCode": "def parse_nethack_args(argv=None, evaluation=False):\n    parser, partial_cfg = parse_sf_args(argv=argv, evaluation=evaluation)\n    add_extra_params_nethack_env(parser)\n    add_extra_params_model(parser)\n    add_extra_params_general(parser)\n    nethack_override_defaults(partial_cfg.env, parser)\n    final_cfg = parse_full_cfg(parser, argv)\n    return final_cfg\ndef main():  # pragma: no cover\n    \"\"\"Script entry point.\"\"\"",
        "detail": "deps.sample-factory.sf_examples.nethack.train_nethack",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.nethack.train_nethack",
        "description": "deps.sample-factory.sf_examples.nethack.train_nethack",
        "peekOfCode": "def main():  # pragma: no cover\n    \"\"\"Script entry point.\"\"\"\n    register_nethack_components()\n    cfg = parse_nethack_args()\n    status = run_rl(cfg)\n    return status\nif __name__ == \"__main__\":  # pragma: no cover\n    sys.exit(main())",
        "detail": "deps.sample-factory.sf_examples.nethack.train_nethack",
        "documentation": {}
    },
    {
        "label": "generate_trajectories",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.sampler.use_simplified_sampling_api",
        "description": "deps.sample-factory.sf_examples.sampler.use_simplified_sampling_api",
        "peekOfCode": "def generate_trajectories(cfg: Config, env_info: EnvInfo, sample_env_steps: int = 1_000_000) -> StatusCode:\n    sampler = SyncSamplingAPI(cfg, env_info)\n    sampler.start()\n    print_interval_sec = 1.0\n    fps_stats = deque([(time.time(), 0)], maxlen=10)\n    sampled = 0\n    last_print = time.time()\n    while sampled < sample_env_steps:\n        try:\n            trajectory = sampler.get_trajectories_sync()",
        "detail": "deps.sample-factory.sf_examples.sampler.use_simplified_sampling_api",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.sampler.use_simplified_sampling_api",
        "description": "deps.sample-factory.sf_examples.sampler.use_simplified_sampling_api",
        "peekOfCode": "def main() -> StatusCode:\n    register_atari_components()\n    cfg = parse_atari_args()\n    env_info = obtain_env_info_in_a_separate_process(cfg)\n    return generate_trajectories(cfg, env_info)\nif __name__ == \"__main__\":\n    sys.exit(main())",
        "detail": "deps.sample-factory.sf_examples.sampler.use_simplified_sampling_api",
        "documentation": {}
    },
    {
        "label": "VizdoomEnvMultiplayer",
        "kind": 6,
        "importPath": "deps.sample-factory.sf_examples.vizdoom.doom.multiplayer.doom_multiagent",
        "description": "deps.sample-factory.sf_examples.vizdoom.doom.multiplayer.doom_multiagent",
        "peekOfCode": "class VizdoomEnvMultiplayer(VizdoomEnv):\n    def __init__(\n        self,\n        action_space,\n        config_file,\n        player_id,\n        num_agents,\n        max_num_players,\n        num_bots,\n        skip_frames,",
        "detail": "deps.sample-factory.sf_examples.vizdoom.doom.multiplayer.doom_multiagent",
        "documentation": {}
    },
    {
        "label": "find_available_port",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.vizdoom.doom.multiplayer.doom_multiagent",
        "description": "deps.sample-factory.sf_examples.vizdoom.doom.multiplayer.doom_multiagent",
        "peekOfCode": "def find_available_port(start_port, increment=1000):\n    port = start_port\n    while port < 65535 and not is_udp_port_available(port):\n        port += increment\n    log.debug(\"Port %r is available\", port)\n    return port\nclass VizdoomEnvMultiplayer(VizdoomEnv):\n    def __init__(\n        self,\n        action_space,",
        "detail": "deps.sample-factory.sf_examples.vizdoom.doom.multiplayer.doom_multiagent",
        "documentation": {}
    },
    {
        "label": "DEFAULT_UDP_PORT",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.vizdoom.doom.multiplayer.doom_multiagent",
        "description": "deps.sample-factory.sf_examples.vizdoom.doom.multiplayer.doom_multiagent",
        "peekOfCode": "DEFAULT_UDP_PORT = int(os.environ.get(\"DOOM_DEFAULT_UDP_PORT\", 40300))\n# log.info('Default UDP port is %r', DEFAULT_UDP_PORT)\n# This try except block is to increase the env timeout connection flag in travis\ntry:\n    vizdoom_env_timeout = int(os.environ[\"TRAVIS_VIZDOOM_ENV_TIMEOUT\"])\nexcept KeyError:\n    vizdoom_env_timeout = 4\ndef find_available_port(start_port, increment=1000):\n    port = start_port\n    while port < 65535 and not is_udp_port_available(port):",
        "detail": "deps.sample-factory.sf_examples.vizdoom.doom.multiplayer.doom_multiagent",
        "documentation": {}
    },
    {
        "label": "TaskType",
        "kind": 6,
        "importPath": "deps.sample-factory.sf_examples.vizdoom.doom.multiplayer.doom_multiagent_wrapper",
        "description": "deps.sample-factory.sf_examples.vizdoom.doom.multiplayer.doom_multiagent_wrapper",
        "peekOfCode": "class TaskType(Enum):\n    INIT, TERMINATE, RESET, STEP, STEP_UPDATE, INFO, SET_ATTR = range(7)\ndef init_multiplayer_env(make_env_func, player_id, env_config, init_info=None):\n    env = make_env_func(player_id=player_id)\n    if env_config is not None and \"worker_index\" in env_config:\n        env.unwrapped.worker_index = env_config.worker_index\n    if env_config is not None and \"vector_index\" in env_config:\n        env.unwrapped.vector_index = env_config.vector_index\n    if init_info is None:\n        port_to_use = udp_port_num(env_config)",
        "detail": "deps.sample-factory.sf_examples.vizdoom.doom.multiplayer.doom_multiagent_wrapper",
        "documentation": {}
    },
    {
        "label": "MultiAgentEnvWorker",
        "kind": 6,
        "importPath": "deps.sample-factory.sf_examples.vizdoom.doom.multiplayer.doom_multiagent_wrapper",
        "description": "deps.sample-factory.sf_examples.vizdoom.doom.multiplayer.doom_multiagent_wrapper",
        "peekOfCode": "class MultiAgentEnvWorker:\n    def __init__(self, player_id, make_env_func, env_config, use_multiprocessing=False, reset_on_init=True):\n        self.player_id = player_id\n        self.make_env_func = make_env_func\n        self.env_config = env_config\n        self.reset_on_init = reset_on_init\n        if use_multiprocessing:\n            self.process = Process(target=self.start, daemon=False)\n            self.task_queue, self.result_queue = faster_fifo.Queue(), faster_fifo.Queue()\n        else:",
        "detail": "deps.sample-factory.sf_examples.vizdoom.doom.multiplayer.doom_multiagent_wrapper",
        "documentation": {}
    },
    {
        "label": "MultiAgentEnv",
        "kind": 6,
        "importPath": "deps.sample-factory.sf_examples.vizdoom.doom.multiplayer.doom_multiagent_wrapper",
        "description": "deps.sample-factory.sf_examples.vizdoom.doom.multiplayer.doom_multiagent_wrapper",
        "peekOfCode": "class MultiAgentEnv(gym.Env, RewardShapingInterface):\n    def __init__(self, num_agents, make_env_func, env_config, skip_frames, render_mode):\n        gym.Env.__init__(self)\n        RewardShapingInterface.__init__(self)\n        self.num_agents = num_agents\n        log.debug(\"Multi agent env, num agents: %d\", self.num_agents)\n        self.skip_frames = skip_frames  # number of frames to skip (1 = no skip)\n        env = make_env_func(player_id=-1)  # temporary env just to query observation_space and stuff\n        self.action_space = env.action_space\n        self.observation_space = env.observation_space",
        "detail": "deps.sample-factory.sf_examples.vizdoom.doom.multiplayer.doom_multiagent_wrapper",
        "documentation": {}
    },
    {
        "label": "retry_doom",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.vizdoom.doom.multiplayer.doom_multiagent_wrapper",
        "description": "deps.sample-factory.sf_examples.vizdoom.doom.multiplayer.doom_multiagent_wrapper",
        "peekOfCode": "def retry_doom(exception_class=Exception, num_attempts=3, sleep_time=1, should_reset=False):\n    def decorator(func):\n        @wraps(func)\n        def wrapper(*args, **kwargs):\n            for i in range(num_attempts):\n                try:\n                    return func(*args, **kwargs)\n                except exception_class as e:\n                    # This accesses the self instance variable\n                    multiagent_wrapper_obj = args[0]",
        "detail": "deps.sample-factory.sf_examples.vizdoom.doom.multiplayer.doom_multiagent_wrapper",
        "documentation": {}
    },
    {
        "label": "safe_get",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.vizdoom.doom.multiplayer.doom_multiagent_wrapper",
        "description": "deps.sample-factory.sf_examples.vizdoom.doom.multiplayer.doom_multiagent_wrapper",
        "peekOfCode": "def safe_get(q, timeout=1e6, msg=\"Queue timeout\"):\n    \"\"\"Using queue.get() with timeout is necessary, otherwise KeyboardInterrupt is not handled.\"\"\"\n    while True:\n        try:\n            return q.get(timeout=timeout)\n        except Empty:\n            log.warning(msg)\ndef udp_port_num(env_config):\n    if env_config is None:\n        return DEFAULT_UDP_PORT",
        "detail": "deps.sample-factory.sf_examples.vizdoom.doom.multiplayer.doom_multiagent_wrapper",
        "documentation": {}
    },
    {
        "label": "udp_port_num",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.vizdoom.doom.multiplayer.doom_multiagent_wrapper",
        "description": "deps.sample-factory.sf_examples.vizdoom.doom.multiplayer.doom_multiagent_wrapper",
        "peekOfCode": "def udp_port_num(env_config):\n    if env_config is None:\n        return DEFAULT_UDP_PORT\n    port_to_use = DEFAULT_UDP_PORT + 100 * env_config.worker_index + env_config.vector_index\n    return port_to_use\nclass TaskType(Enum):\n    INIT, TERMINATE, RESET, STEP, STEP_UPDATE, INFO, SET_ATTR = range(7)\ndef init_multiplayer_env(make_env_func, player_id, env_config, init_info=None):\n    env = make_env_func(player_id=player_id)\n    if env_config is not None and \"worker_index\" in env_config:",
        "detail": "deps.sample-factory.sf_examples.vizdoom.doom.multiplayer.doom_multiagent_wrapper",
        "documentation": {}
    },
    {
        "label": "init_multiplayer_env",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.vizdoom.doom.multiplayer.doom_multiagent_wrapper",
        "description": "deps.sample-factory.sf_examples.vizdoom.doom.multiplayer.doom_multiagent_wrapper",
        "peekOfCode": "def init_multiplayer_env(make_env_func, player_id, env_config, init_info=None):\n    env = make_env_func(player_id=player_id)\n    if env_config is not None and \"worker_index\" in env_config:\n        env.unwrapped.worker_index = env_config.worker_index\n    if env_config is not None and \"vector_index\" in env_config:\n        env.unwrapped.vector_index = env_config.vector_index\n    if init_info is None:\n        port_to_use = udp_port_num(env_config)\n        port = find_available_port(port_to_use, increment=1000)\n        log.debug(\"Using port %d\", port)",
        "detail": "deps.sample-factory.sf_examples.vizdoom.doom.multiplayer.doom_multiagent_wrapper",
        "documentation": {}
    },
    {
        "label": "bot_param",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.vizdoom.doom.scripts.generate_bots",
        "description": "deps.sample-factory.sf_examples.vizdoom.doom.scripts.generate_bots",
        "peekOfCode": "def bot_param(difficulty):\n    if difficulty >= 100:\n        return 100\n    param = int(np.random.normal(difficulty, 10))\n    param = min(param, 100)\n    param = max(param, 1)\n    return param\ndef fmt_bot(difficulty, idx):\n    weaponpref = list(range(9))\n    np.random.shuffle(weaponpref)",
        "detail": "deps.sample-factory.sf_examples.vizdoom.doom.scripts.generate_bots",
        "documentation": {}
    },
    {
        "label": "fmt_bot",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.vizdoom.doom.scripts.generate_bots",
        "description": "deps.sample-factory.sf_examples.vizdoom.doom.scripts.generate_bots",
        "peekOfCode": "def fmt_bot(difficulty, idx):\n    weaponpref = list(range(9))\n    np.random.shuffle(weaponpref)\n    # weaponpref_str = \"\".join([str(w) for w in weaponpref])  # currently not used\n    bot_str = (\n        \"{ \\n\"\n        f\"    name BOT_{difficulty}_{idx} \\n\"\n        f\"    aiming {bot_param(difficulty)} \\n\"\n        f\"    perfection {bot_param(difficulty)} \\n\"\n        f\"    reaction {bot_param(difficulty)} \\n\"",
        "detail": "deps.sample-factory.sf_examples.vizdoom.doom.scripts.generate_bots",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.vizdoom.doom.scripts.generate_bots",
        "description": "deps.sample-factory.sf_examples.vizdoom.doom.scripts.generate_bots",
        "peekOfCode": "def main():\n    levels = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100]\n    for level in levels:\n        for idx in range(10):\n            bot_cfg_string = fmt_bot(level, idx)\n            print(bot_cfg_string)\nif __name__ == \"__main__\":\n    main()",
        "detail": "deps.sample-factory.sf_examples.vizdoom.doom.scripts.generate_bots",
        "documentation": {}
    },
    {
        "label": "DoomGatheringRewardShaping",
        "kind": 6,
        "importPath": "deps.sample-factory.sf_examples.vizdoom.doom.wrappers.scenario_wrappers.gathering_reward_shaping",
        "description": "deps.sample-factory.sf_examples.vizdoom.doom.wrappers.scenario_wrappers.gathering_reward_shaping",
        "peekOfCode": "class DoomGatheringRewardShaping(gym.Wrapper):\n    \"\"\"Reward shaping specific for gathering scenarios.\"\"\"\n    def __init__(self, env):\n        super().__init__(env)\n        self._prev_health = None\n        self.orig_env_reward = 0.0\n    def _reward_shaping(self, info, done):\n        if info is None or done:\n            return 0.0\n        curr_health = info.get(\"HEALTH\", 0.0)",
        "detail": "deps.sample-factory.sf_examples.vizdoom.doom.wrappers.scenario_wrappers.gathering_reward_shaping",
        "documentation": {}
    },
    {
        "label": "DoomAdditionalInput",
        "kind": 6,
        "importPath": "deps.sample-factory.sf_examples.vizdoom.doom.wrappers.additional_input",
        "description": "deps.sample-factory.sf_examples.vizdoom.doom.wrappers.additional_input",
        "peekOfCode": "class DoomAdditionalInput(gym.Wrapper):\n    \"\"\"Add game variables to the observation space + reward shaping.\"\"\"\n    def __init__(self, env):\n        super().__init__(env)\n        current_obs_space = self.observation_space\n        self.num_weapons = NUM_WEAPONS\n        weapons_low = [0.0] * self.num_weapons\n        ammo_low = [0.0] * self.num_weapons\n        low = [0.0, 0.0, -1.0, -1.0, -50.0, 0.0, 0.0] + weapons_low + ammo_low\n        weapons_high = [5.0] * self.num_weapons  # can have multiple weapons in the same slot?",
        "detail": "deps.sample-factory.sf_examples.vizdoom.doom.wrappers.additional_input",
        "documentation": {}
    },
    {
        "label": "BotDifficultyWrapper",
        "kind": 6,
        "importPath": "deps.sample-factory.sf_examples.vizdoom.doom.wrappers.bot_difficulty",
        "description": "deps.sample-factory.sf_examples.vizdoom.doom.wrappers.bot_difficulty",
        "peekOfCode": "class BotDifficultyWrapper(gym.Wrapper):\n    \"\"\"Adjust bot difficulty according to agent's final position in the match.\"\"\"\n    def __init__(self, env, initial_difficulty=None):\n        super().__init__(env)\n        self._min_difficulty = 0\n        self._max_difficulty = 150\n        self._difficulty_step = 10\n        self._curr_difficulty = 20 if initial_difficulty is None else initial_difficulty\n        self._difficulty_std = 10\n        log.info(\"Starting with bot difficulty %d\", self._curr_difficulty)",
        "detail": "deps.sample-factory.sf_examples.vizdoom.doom.wrappers.bot_difficulty",
        "documentation": {}
    },
    {
        "label": "ExplorationWrapper",
        "kind": 6,
        "importPath": "deps.sample-factory.sf_examples.vizdoom.doom.wrappers.exploration",
        "description": "deps.sample-factory.sf_examples.vizdoom.doom.wrappers.exploration",
        "peekOfCode": "class ExplorationWrapper(gym.Wrapper):\n    def __init__(self, env):\n        super().__init__(env)\n        self.landmarks = deque([], maxlen=200)\n        self.landmark_threshold = 75.0\n    def _calc_intrinsic_reward(self, info):\n        pos = info.get(\"pos\", None)\n        if pos is None:\n            return 0.0\n        x, y, angle = pos[\"agent_x\"], pos[\"agent_y\"], pos[\"agent_a\"]",
        "detail": "deps.sample-factory.sf_examples.vizdoom.doom.wrappers.exploration",
        "documentation": {}
    },
    {
        "label": "MultiplayerStatsWrapper",
        "kind": 6,
        "importPath": "deps.sample-factory.sf_examples.vizdoom.doom.wrappers.multiplayer_stats",
        "description": "deps.sample-factory.sf_examples.vizdoom.doom.wrappers.multiplayer_stats",
        "peekOfCode": "class MultiplayerStatsWrapper(gym.Wrapper):\n    \"\"\"Add to info things like place in the match, gap to leader, kill-death ratio etc.\"\"\"\n    def __init__(self, env):\n        super().__init__(env)\n        self.timestep = 0\n        self.prev_extra_info = dict()\n    def _parse_info(self, info, done):\n        if (self.timestep % 20 == 0 or done) and \"FRAGCOUNT\" in info:\n            # no need to update these stats every frame\n            kdr = info.get(\"FRAGCOUNT\", 0.0) / (info.get(\"DEATHCOUNT\", 0.0) + 1)",
        "detail": "deps.sample-factory.sf_examples.vizdoom.doom.wrappers.multiplayer_stats",
        "documentation": {}
    },
    {
        "label": "SetResolutionWrapper",
        "kind": 6,
        "importPath": "deps.sample-factory.sf_examples.vizdoom.doom.wrappers.observation_space",
        "description": "deps.sample-factory.sf_examples.vizdoom.doom.wrappers.observation_space",
        "peekOfCode": "class SetResolutionWrapper(gym.Wrapper):\n    \"\"\"Doom wrapper to change screen resolution.\"\"\"\n    def __init__(self, env, target_resolution):\n        super(SetResolutionWrapper, self).__init__(env)\n        if target_resolution not in resolutions:\n            raise gym.error.Error(\n                'Error - The specified resolution \"{}\" is not supported by Vizdoom.'.format(target_resolution),\n            )\n        orig_obs_space = self.observation_space\n        parts = target_resolution.lower().split(\"x\")",
        "detail": "deps.sample-factory.sf_examples.vizdoom.doom.wrappers.observation_space",
        "documentation": {}
    },
    {
        "label": "resolutions",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.vizdoom.doom.wrappers.observation_space",
        "description": "deps.sample-factory.sf_examples.vizdoom.doom.wrappers.observation_space",
        "peekOfCode": "resolutions = [\n    \"160x120\",\n    \"200x125\",\n    \"200x150\",\n    \"256x144\",\n    \"256x160\",\n    \"256x192\",\n    \"320x180\",\n    \"320x200\",\n    \"320x240\",",
        "detail": "deps.sample-factory.sf_examples.vizdoom.doom.wrappers.observation_space",
        "documentation": {}
    },
    {
        "label": "DoomRewardShapingWrapper",
        "kind": 6,
        "importPath": "deps.sample-factory.sf_examples.vizdoom.doom.wrappers.reward_shaping",
        "description": "deps.sample-factory.sf_examples.vizdoom.doom.wrappers.reward_shaping",
        "peekOfCode": "class DoomRewardShapingWrapper(gym.Wrapper, RewardShapingInterface):\n    \"\"\"Convert game info variables into scalar reward using a reward shaping scheme.\"\"\"\n    def __init__(self, env, reward_shaping_scheme=None, true_objective_func=None):\n        gym.Wrapper.__init__(self, env)\n        RewardShapingInterface.__init__(self)\n        self.reward_shaping_scheme = reward_shaping_scheme\n        self.true_objective_func: Callable = true_objective_func\n        # without this we reward using BFG and shotguns too much\n        self.reward_delta_limits = dict(DAMAGECOUNT=200, HITCOUNT=5)\n        self.prev_vars = dict()",
        "detail": "deps.sample-factory.sf_examples.vizdoom.doom.wrappers.reward_shaping",
        "documentation": {}
    },
    {
        "label": "true_objective_winning_the_game",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.vizdoom.doom.wrappers.reward_shaping",
        "description": "deps.sample-factory.sf_examples.vizdoom.doom.wrappers.reward_shaping",
        "peekOfCode": "def true_objective_winning_the_game(info):\n    if info[\"LEADER_GAP\"] == 0:\n        # tied with the leader for the win, we don't reward for ties, only for the win\n        return 0.0\n    elif info[\"FINAL_PLACE\"] > 1:\n        # lost the match (don't care about the place, losing is losing)\n        return 0.0\n    else:\n        # won the match!\n        assert info[\"FINAL_PLACE\"] == 1",
        "detail": "deps.sample-factory.sf_examples.vizdoom.doom.wrappers.reward_shaping",
        "documentation": {}
    },
    {
        "label": "true_objective_frags",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.vizdoom.doom.wrappers.reward_shaping",
        "description": "deps.sample-factory.sf_examples.vizdoom.doom.wrappers.reward_shaping",
        "peekOfCode": "def true_objective_frags(info):\n    return info[\"FRAGCOUNT\"]\nclass DoomRewardShapingWrapper(gym.Wrapper, RewardShapingInterface):\n    \"\"\"Convert game info variables into scalar reward using a reward shaping scheme.\"\"\"\n    def __init__(self, env, reward_shaping_scheme=None, true_objective_func=None):\n        gym.Wrapper.__init__(self, env)\n        RewardShapingInterface.__init__(self)\n        self.reward_shaping_scheme = reward_shaping_scheme\n        self.true_objective_func: Callable = true_objective_func\n        # without this we reward using BFG and shotguns too much",
        "detail": "deps.sample-factory.sf_examples.vizdoom.doom.wrappers.reward_shaping",
        "documentation": {}
    },
    {
        "label": "NUM_WEAPONS",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.vizdoom.doom.wrappers.reward_shaping",
        "description": "deps.sample-factory.sf_examples.vizdoom.doom.wrappers.reward_shaping",
        "peekOfCode": "NUM_WEAPONS = 8\n# these are somewhat arbitrary, but can be optimized via PBT\nWEAPON_PREFERENCE = {\n    2: 1,  # pistol\n    3: 5,  # shotguns\n    4: 5,  # machinegun\n    5: 5,  # rocket launcher\n    6: 10,  # plasmagun\n    7: 10,  # bfg\n}",
        "detail": "deps.sample-factory.sf_examples.vizdoom.doom.wrappers.reward_shaping",
        "documentation": {}
    },
    {
        "label": "WEAPON_PREFERENCE",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.vizdoom.doom.wrappers.reward_shaping",
        "description": "deps.sample-factory.sf_examples.vizdoom.doom.wrappers.reward_shaping",
        "peekOfCode": "WEAPON_PREFERENCE = {\n    2: 1,  # pistol\n    3: 5,  # shotguns\n    4: 5,  # machinegun\n    5: 5,  # rocket launcher\n    6: 10,  # plasmagun\n    7: 10,  # bfg\n}\nWEAPON_DELTA_REWARDS = dict()\nSELECTED_WEAPON_REWARDS = dict()",
        "detail": "deps.sample-factory.sf_examples.vizdoom.doom.wrappers.reward_shaping",
        "documentation": {}
    },
    {
        "label": "WEAPON_DELTA_REWARDS",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.vizdoom.doom.wrappers.reward_shaping",
        "description": "deps.sample-factory.sf_examples.vizdoom.doom.wrappers.reward_shaping",
        "peekOfCode": "WEAPON_DELTA_REWARDS = dict()\nSELECTED_WEAPON_REWARDS = dict()\nfor weapon in range(NUM_WEAPONS):\n    pref = WEAPON_PREFERENCE.get(weapon, 1)\n    # reward/penalty for finding/losing a weapon\n    WEAPON_DELTA_REWARDS[f\"WEAPON{weapon}\"] = (+0.02 * pref, -0.01 * pref)\n    # reward/penalty for picking up/spending weapon ammo\n    WEAPON_DELTA_REWARDS[f\"AMMO{weapon}\"] = (+0.0002 * pref, -0.0001 * pref)\n    # reward for choosing a weapon and sticking to it; really helps learning in the beginning, otherwise the agent\n    # just keeps changing weapons all the time, unable to shoot. Towards the later stages of the training agents",
        "detail": "deps.sample-factory.sf_examples.vizdoom.doom.wrappers.reward_shaping",
        "documentation": {}
    },
    {
        "label": "SELECTED_WEAPON_REWARDS",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.vizdoom.doom.wrappers.reward_shaping",
        "description": "deps.sample-factory.sf_examples.vizdoom.doom.wrappers.reward_shaping",
        "peekOfCode": "SELECTED_WEAPON_REWARDS = dict()\nfor weapon in range(NUM_WEAPONS):\n    pref = WEAPON_PREFERENCE.get(weapon, 1)\n    # reward/penalty for finding/losing a weapon\n    WEAPON_DELTA_REWARDS[f\"WEAPON{weapon}\"] = (+0.02 * pref, -0.01 * pref)\n    # reward/penalty for picking up/spending weapon ammo\n    WEAPON_DELTA_REWARDS[f\"AMMO{weapon}\"] = (+0.0002 * pref, -0.0001 * pref)\n    # reward for choosing a weapon and sticking to it; really helps learning in the beginning, otherwise the agent\n    # just keeps changing weapons all the time, unable to shoot. Towards the later stages of the training agents\n    # tend to ignore this, and change weapons at will",
        "detail": "deps.sample-factory.sf_examples.vizdoom.doom.wrappers.reward_shaping",
        "documentation": {}
    },
    {
        "label": "REWARD_SHAPING_DEATHMATCH_V0",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.vizdoom.doom.wrappers.reward_shaping",
        "description": "deps.sample-factory.sf_examples.vizdoom.doom.wrappers.reward_shaping",
        "peekOfCode": "REWARD_SHAPING_DEATHMATCH_V0 = dict(\n    delta=dict(\n        FRAGCOUNT=(+1, -1.5),  # reward per unit of positive or negative change\n        DEATHCOUNT=(-0.75, +0.75),\n        HITCOUNT=(+0.01, -0.01),\n        DAMAGECOUNT=(+0.003, -0.003),\n        HEALTH=(+0.005, -0.003),\n        ARMOR=(+0.005, -0.001),\n        **WEAPON_DELTA_REWARDS,\n    ),",
        "detail": "deps.sample-factory.sf_examples.vizdoom.doom.wrappers.reward_shaping",
        "documentation": {}
    },
    {
        "label": "REWARD_SHAPING_DEATHMATCH_V1",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.vizdoom.doom.wrappers.reward_shaping",
        "description": "deps.sample-factory.sf_examples.vizdoom.doom.wrappers.reward_shaping",
        "peekOfCode": "REWARD_SHAPING_DEATHMATCH_V1 = copy.deepcopy(REWARD_SHAPING_DEATHMATCH_V0)\nREWARD_SHAPING_DEATHMATCH_V1[\"delta\"].update(\n    dict(\n        FRAGCOUNT=(+1, -0.001),\n        DEATHCOUNT=(-1, +1),\n        HITCOUNT=(0, 0),\n        DAMAGECOUNT=(+0.01, -0.01),\n        HEALTH=(+0.01, -0.01),\n    )\n)",
        "detail": "deps.sample-factory.sf_examples.vizdoom.doom.wrappers.reward_shaping",
        "documentation": {}
    },
    {
        "label": "REWARD_SHAPING_BATTLE",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.vizdoom.doom.wrappers.reward_shaping",
        "description": "deps.sample-factory.sf_examples.vizdoom.doom.wrappers.reward_shaping",
        "peekOfCode": "REWARD_SHAPING_BATTLE = copy.deepcopy(REWARD_SHAPING_DEATHMATCH_V0)\ndef true_objective_winning_the_game(info):\n    if info[\"LEADER_GAP\"] == 0:\n        # tied with the leader for the win, we don't reward for ties, only for the win\n        return 0.0\n    elif info[\"FINAL_PLACE\"] > 1:\n        # lost the match (don't care about the place, losing is losing)\n        return 0.0\n    else:\n        # won the match!",
        "detail": "deps.sample-factory.sf_examples.vizdoom.doom.wrappers.reward_shaping",
        "documentation": {}
    },
    {
        "label": "StepHumanInput",
        "kind": 6,
        "importPath": "deps.sample-factory.sf_examples.vizdoom.doom.wrappers.step_human_input",
        "description": "deps.sample-factory.sf_examples.vizdoom.doom.wrappers.step_human_input",
        "peekOfCode": "class StepHumanInput(gym.Wrapper):\n    \"\"\"Doom wrapper that allows to play with human input.\"\"\"\n    def __init__(self, env):\n        super(StepHumanInput, self).__init__(env)\n    def reset(self, **kwargs):\n        self.unwrapped.mode = \"human\"\n        self.unwrapped._ensure_initialized()\n        return self.env.reset(**kwargs)\n    def step(self, action):\n        del action  # we actually ignore action and take input from keyboard",
        "detail": "deps.sample-factory.sf_examples.vizdoom.doom.wrappers.step_human_input",
        "documentation": {}
    },
    {
        "label": "key_to_action_basic",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.vizdoom.doom.action_space",
        "description": "deps.sample-factory.sf_examples.vizdoom.doom.action_space",
        "peekOfCode": "def key_to_action_basic(key):\n    from pynput.keyboard import Key\n    table = {Key.left: 0, Key.right: 1, Key.up: 2, Key.down: 3}\n    return table.get(key, None)\ndef doom_turn_and_attack_only():\n    \"\"\"\n    TURN_LEFT\n    TURN_RIGHT\n    ATTACK\n    \"\"\"",
        "detail": "deps.sample-factory.sf_examples.vizdoom.doom.action_space",
        "documentation": {}
    },
    {
        "label": "doom_turn_and_attack_only",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.vizdoom.doom.action_space",
        "description": "deps.sample-factory.sf_examples.vizdoom.doom.action_space",
        "peekOfCode": "def doom_turn_and_attack_only():\n    \"\"\"\n    TURN_LEFT\n    TURN_RIGHT\n    ATTACK\n    \"\"\"\n    space = gym.spaces.Tuple(\n        (\n            Discrete(3),\n            Discrete(2),",
        "detail": "deps.sample-factory.sf_examples.vizdoom.doom.action_space",
        "documentation": {}
    },
    {
        "label": "doom_action_space_basic",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.vizdoom.doom.action_space",
        "description": "deps.sample-factory.sf_examples.vizdoom.doom.action_space",
        "peekOfCode": "def doom_action_space_basic():\n    \"\"\"\n    TURN_LEFT\n    TURN_RIGHT\n    MOVE_FORWARD\n    MOVE_BACKWARD\n    \"\"\"\n    space = gym.spaces.Tuple(\n        (\n            Discrete(3),",
        "detail": "deps.sample-factory.sf_examples.vizdoom.doom.action_space",
        "documentation": {}
    },
    {
        "label": "doom_action_space_extended",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.vizdoom.doom.action_space",
        "description": "deps.sample-factory.sf_examples.vizdoom.doom.action_space",
        "peekOfCode": "def doom_action_space_extended():\n    \"\"\"\n    This function assumes the following list of available buttons:\n    TURN_LEFT\n    TURN_RIGHT\n    MOVE_FORWARD\n    MOVE_BACKWARD\n    MOVE_LEFT\n    MOVE_RIGHT\n    ATTACK",
        "detail": "deps.sample-factory.sf_examples.vizdoom.doom.action_space",
        "documentation": {}
    },
    {
        "label": "doom_action_space",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.vizdoom.doom.action_space",
        "description": "deps.sample-factory.sf_examples.vizdoom.doom.action_space",
        "peekOfCode": "def doom_action_space():\n    \"\"\"\n    Standard action space for full-featured Doom environments (e.g. deathmatch).\n    TODO: crouch?\n    TODO: strafe?\n    This should precisely correspond to the available_buttons configuration in the .cfg file.\n    This function assumes:\n        MOVE_FORWARD\n        MOVE_BACKWARD\n        MOVE_RIGHT",
        "detail": "deps.sample-factory.sf_examples.vizdoom.doom.action_space",
        "documentation": {}
    },
    {
        "label": "doom_action_space_discretized",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.vizdoom.doom.action_space",
        "description": "deps.sample-factory.sf_examples.vizdoom.doom.action_space",
        "peekOfCode": "def doom_action_space_discretized():\n    return gym.spaces.Tuple(\n        (\n            Discrete(3),  # noop, forward, backward\n            Discrete(3),  # noop, move right, move left\n            Discrete(3),  # noop, prev_weapon, next_weapon\n            Discrete(2),  # noop, attack\n            Discrete(2),  # noop, sprint\n            Discretized(11, min_action=-10.0, max_action=10.0),  # turning using discretized continuous control\n        )",
        "detail": "deps.sample-factory.sf_examples.vizdoom.doom.action_space",
        "documentation": {}
    },
    {
        "label": "doom_action_space_discretized_no_weap",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.vizdoom.doom.action_space",
        "description": "deps.sample-factory.sf_examples.vizdoom.doom.action_space",
        "peekOfCode": "def doom_action_space_discretized_no_weap():\n    return gym.spaces.Tuple(\n        (\n            Discrete(3),  # noop, forward, backward\n            Discrete(3),  # noop, move right, move left\n            Discrete(2),  # noop, attack\n            Discrete(2),  # noop, sprint\n            Discretized(11, min_action=-10.0, max_action=10.0),  # turning using discretized continuous control\n        )\n    )",
        "detail": "deps.sample-factory.sf_examples.vizdoom.doom.action_space",
        "documentation": {}
    },
    {
        "label": "doom_action_space_continuous_no_weap",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.vizdoom.doom.action_space",
        "description": "deps.sample-factory.sf_examples.vizdoom.doom.action_space",
        "peekOfCode": "def doom_action_space_continuous_no_weap():\n    return gym.spaces.Tuple(\n        (\n            Discrete(3),  # noop, forward, backward\n            Discrete(3),  # noop, move right, move left\n            Discrete(2),  # noop, attack\n            Discrete(2),  # noop, sprint\n            Box(float(-1.0), float(1.0), (1,)),\n        )\n    )",
        "detail": "deps.sample-factory.sf_examples.vizdoom.doom.action_space",
        "documentation": {}
    },
    {
        "label": "doom_action_space_discrete",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.vizdoom.doom.action_space",
        "description": "deps.sample-factory.sf_examples.vizdoom.doom.action_space",
        "peekOfCode": "def doom_action_space_discrete():\n    return gym.spaces.Tuple(\n        (\n            Discrete(3),  # noop, forward, backward\n            Discrete(3),  # noop, move right, move left\n            Discrete(3),  # noop, turn right, turn left\n            Discrete(3),  # noop, prev_weapon, next_weapon\n            Discrete(2),  # noop, attack\n            Discrete(2),  # noop, sprint\n        )",
        "detail": "deps.sample-factory.sf_examples.vizdoom.doom.action_space",
        "documentation": {}
    },
    {
        "label": "doom_action_space_discrete_no_weap",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.vizdoom.doom.action_space",
        "description": "deps.sample-factory.sf_examples.vizdoom.doom.action_space",
        "peekOfCode": "def doom_action_space_discrete_no_weap():\n    return gym.spaces.Tuple(\n        (\n            Discrete(3),  # noop, forward, backward\n            Discrete(3),  # noop, move right, move left\n            Discrete(3),  # noop, turn right, turn left\n            Discrete(2),  # noop, attack\n            Discrete(2),  # noop, sprint\n        )\n    )",
        "detail": "deps.sample-factory.sf_examples.vizdoom.doom.action_space",
        "documentation": {}
    },
    {
        "label": "doom_action_space_full_discretized",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.vizdoom.doom.action_space",
        "description": "deps.sample-factory.sf_examples.vizdoom.doom.action_space",
        "peekOfCode": "def doom_action_space_full_discretized(with_use=False):\n    \"\"\"\n    MOVE_FORWARD\n    MOVE_BACKWARD\n    MOVE_RIGHT\n    MOVE_LEFT\n    SELECT_WEAPON1\n    SELECT_WEAPON2\n    SELECT_WEAPON3\n    SELECT_WEAPON4",
        "detail": "deps.sample-factory.sf_examples.vizdoom.doom.action_space",
        "documentation": {}
    },
    {
        "label": "VizdoomEnv",
        "kind": 6,
        "importPath": "deps.sample-factory.sf_examples.vizdoom.doom.doom_gym",
        "description": "deps.sample-factory.sf_examples.vizdoom.doom.doom_gym",
        "peekOfCode": "class VizdoomEnv(gym.Env):\n    def __init__(\n        self,\n        action_space,\n        config_file,\n        coord_limits=None,\n        max_histogram_length=200,\n        show_automap=False,\n        skip_frames=1,\n        async_mode=False,",
        "detail": "deps.sample-factory.sf_examples.vizdoom.doom.doom_gym",
        "documentation": {}
    },
    {
        "label": "doom_lock_file",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.vizdoom.doom.doom_gym",
        "description": "deps.sample-factory.sf_examples.vizdoom.doom.doom_gym",
        "peekOfCode": "def doom_lock_file(max_parallel):\n    \"\"\"\n    Doom instances tend to have problems starting when a lot of them are initialized in parallel.\n    This is not a problem during normal execution once the envs are initialized.\n    The \"sweet spot\" for the number of envs that can be initialized in parallel is about 5-10.\n    Here we use file locking mechanism to ensure that only a limited amount of envs are being initialized at the same\n    time.\n    This tends to be more of a problem for multiplayer envs.\n    This also has an advantage of working across completely independent process groups, e.g. different experiments.\n    \"\"\"",
        "detail": "deps.sample-factory.sf_examples.vizdoom.doom.doom_gym",
        "documentation": {}
    },
    {
        "label": "key_to_action_default",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.vizdoom.doom.doom_gym",
        "description": "deps.sample-factory.sf_examples.vizdoom.doom.doom_gym",
        "peekOfCode": "def key_to_action_default(key):\n    \"\"\"\n    MOVE_FORWARD\n    MOVE_BACKWARD\n    MOVE_RIGHT\n    MOVE_LEFT\n    SELECT_WEAPON1\n    SELECT_WEAPON2\n    SELECT_WEAPON3\n    SELECT_WEAPON4",
        "detail": "deps.sample-factory.sf_examples.vizdoom.doom.doom_gym",
        "documentation": {}
    },
    {
        "label": "VizdoomEncoder",
        "kind": 6,
        "importPath": "deps.sample-factory.sf_examples.vizdoom.doom.doom_model",
        "description": "deps.sample-factory.sf_examples.vizdoom.doom.doom_model",
        "peekOfCode": "class VizdoomEncoder(Encoder):\n    def __init__(self, cfg: Config, obs_space: ObsSpace):\n        super().__init__(cfg)\n        # reuse the default image encoder\n        self.basic_encoder = make_img_encoder(cfg, obs_space[\"obs\"])\n        self.encoder_out_size = self.basic_encoder.get_out_size()\n        self.measurements_head = None\n        if \"measurements\" in list(obs_space.keys()):\n            self.measurements_head = nn.Sequential(\n                nn.Linear(obs_space[\"measurements\"].shape[0], 128),",
        "detail": "deps.sample-factory.sf_examples.vizdoom.doom.doom_model",
        "documentation": {}
    },
    {
        "label": "make_vizdoom_encoder",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.vizdoom.doom.doom_model",
        "description": "deps.sample-factory.sf_examples.vizdoom.doom.doom_model",
        "peekOfCode": "def make_vizdoom_encoder(cfg: Config, obs_space: ObsSpace) -> Encoder:\n    \"\"\"Factory function as required by the API.\"\"\"\n    return VizdoomEncoder(cfg, obs_space)",
        "detail": "deps.sample-factory.sf_examples.vizdoom.doom.doom_model",
        "documentation": {}
    },
    {
        "label": "add_doom_env_args",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.vizdoom.doom.doom_params",
        "description": "deps.sample-factory.sf_examples.vizdoom.doom.doom_params",
        "peekOfCode": "def add_doom_env_args(parser):\n    p = parser\n    p.add_argument(\n        \"--num_agents\",\n        default=-1,\n        type=int,\n        help=\"Allows to set number of agents less than number of players, to allow humans to join the match. Default value (-1) means default number defined by the environment\",\n    )\n    p.add_argument(\"--num_humans\", default=0, type=int, help=\"Meatbags want to play?\")\n    p.add_argument(",
        "detail": "deps.sample-factory.sf_examples.vizdoom.doom.doom_params",
        "documentation": {}
    },
    {
        "label": "add_doom_env_eval_args",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.vizdoom.doom.doom_params",
        "description": "deps.sample-factory.sf_examples.vizdoom.doom.doom_params",
        "peekOfCode": "def add_doom_env_eval_args(parser):\n    \"\"\"Arguments used only during evaluation.\"\"\"\n    parser.add_argument(\n        \"--record_to\",\n        # default=join(os.getcwd(), \"..\", \"recs\"),\n        default=None,\n        type=str,\n        help=\"Record episodes to this folder. This records a demo that can be replayed at full resolution. Currently, this does not work for bot environments so it is recommended to use --save_video to record episodes at lower resolution instead for such environments\",\n    )\ndef doom_override_defaults(parser):",
        "detail": "deps.sample-factory.sf_examples.vizdoom.doom.doom_params",
        "documentation": {}
    },
    {
        "label": "doom_override_defaults",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.vizdoom.doom.doom_params",
        "description": "deps.sample-factory.sf_examples.vizdoom.doom.doom_params",
        "peekOfCode": "def doom_override_defaults(parser):\n    \"\"\"RL params specific to Doom envs.\"\"\"\n    parser.set_defaults(\n        ppo_clip_value=0.2,  # value used in all experiments in the paper\n        obs_subtract_mean=0.0,\n        obs_scale=255.0,\n        exploration_loss=\"symmetric_kl\",\n        exploration_loss_coeff=0.001,\n        normalize_returns=True,\n        normalize_input=True,",
        "detail": "deps.sample-factory.sf_examples.vizdoom.doom.doom_params",
        "documentation": {}
    },
    {
        "label": "default_doom_cfg",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.vizdoom.doom.doom_params",
        "description": "deps.sample-factory.sf_examples.vizdoom.doom.doom_params",
        "peekOfCode": "def default_doom_cfg(algo=\"APPO\", env=\"env\", experiment=\"test\"):\n    \"\"\"Useful in tests.\"\"\"\n    argv = [f\"--algo={algo}\", f\"--env={env}\", f\"--experiment={experiment}\"]\n    parser, args = parse_sf_args(argv)\n    add_doom_env_args(parser)\n    doom_override_defaults(parser)\n    args = parse_full_cfg(parser, argv)\n    return args",
        "detail": "deps.sample-factory.sf_examples.vizdoom.doom.doom_params",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.vizdoom.doom.doom_play_demo",
        "description": "deps.sample-factory.sf_examples.vizdoom.doom.doom_play_demo",
        "peekOfCode": "def main():\n    parser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter)\n    parser.add_argument(\"--env\", type=str, default=None, required=True)\n    parser.add_argument(\"--demo_path\", type=str, default=None, required=True)\n    args = parser.parse_args()\n    spec = doom_env_by_name(args.env)\n    cfg = default_cfg(env=args.env)\n    if spec.num_agents <= 1:\n        env = make_doom_env(args.env, cfg=cfg, env_config=None, render_mode=\"rgb_array\", custom_resolution=\"1280x720\")\n    else:",
        "detail": "deps.sample-factory.sf_examples.vizdoom.doom.doom_play_demo",
        "documentation": {}
    },
    {
        "label": "concat_grid",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.vizdoom.doom.doom_render",
        "description": "deps.sample-factory.sf_examples.vizdoom.doom.doom_render",
        "peekOfCode": "def concat_grid(obs, render_mode):\n    obs = [cvt_doom_obs(o, render_mode) for o in obs]\n    max_horizontal = 3\n    horizontal = min(max_horizontal, len(obs))\n    while len(obs) % horizontal != 0:\n        obs.append(np.zeros_like(obs[0]))  # pad with black images until right size\n    vertical = max(1, len(obs) // horizontal)\n    assert vertical * horizontal == len(obs)\n    obs_concat_h = []\n    for i in range(vertical):",
        "detail": "deps.sample-factory.sf_examples.vizdoom.doom.doom_render",
        "documentation": {}
    },
    {
        "label": "cvt_doom_obs",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.vizdoom.doom.doom_render",
        "description": "deps.sample-factory.sf_examples.vizdoom.doom.doom_render",
        "peekOfCode": "def cvt_doom_obs(obs, render_mode):\n    if obs.shape[0] <= 4:\n        # channels first\n        obs = np.transpose(obs, (1, 2, 0))\n    if render_mode == \"human\":\n        w, h = 1200, 675\n        obs = cv2.cvtColor(obs, cv2.COLOR_RGB2BGR)\n        obs = cv2.resize(obs, (w, h))\n    return obs",
        "detail": "deps.sample-factory.sf_examples.vizdoom.doom.doom_render",
        "documentation": {}
    },
    {
        "label": "DoomSpec",
        "kind": 6,
        "importPath": "deps.sample-factory.sf_examples.vizdoom.doom.doom_utils",
        "description": "deps.sample-factory.sf_examples.vizdoom.doom.doom_utils",
        "peekOfCode": "class DoomSpec:\n    def __init__(\n        self,\n        name,\n        env_spec_file,\n        action_space,\n        reward_scaling=1.0,\n        default_timeout=-1,\n        num_agents=1,\n        num_bots=0,",
        "detail": "deps.sample-factory.sf_examples.vizdoom.doom.doom_utils",
        "documentation": {}
    },
    {
        "label": "doom_env_by_name",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.vizdoom.doom.doom_utils",
        "description": "deps.sample-factory.sf_examples.vizdoom.doom.doom_utils",
        "peekOfCode": "def doom_env_by_name(name):\n    for cfg in DOOM_ENVS:\n        if cfg.name == name:\n            return cfg\n    raise RuntimeError(\"Unknown Doom env\")\n# noinspection PyUnusedLocal\ndef make_doom_env_impl(\n    doom_spec,\n    cfg=None,\n    env_config=None,",
        "detail": "deps.sample-factory.sf_examples.vizdoom.doom.doom_utils",
        "documentation": {}
    },
    {
        "label": "make_doom_env_impl",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.vizdoom.doom.doom_utils",
        "description": "deps.sample-factory.sf_examples.vizdoom.doom.doom_utils",
        "peekOfCode": "def make_doom_env_impl(\n    doom_spec,\n    cfg=None,\n    env_config=None,\n    skip_frames=None,\n    episode_horizon=None,\n    player_id=None,\n    num_agents=None,\n    max_num_players=None,\n    num_bots=0,  # for multi-agent",
        "detail": "deps.sample-factory.sf_examples.vizdoom.doom.doom_utils",
        "documentation": {}
    },
    {
        "label": "make_doom_multiplayer_env",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.vizdoom.doom.doom_utils",
        "description": "deps.sample-factory.sf_examples.vizdoom.doom.doom_utils",
        "peekOfCode": "def make_doom_multiplayer_env(doom_spec, cfg=None, env_config=None, render_mode: Optional[str] = None, **kwargs):\n    skip_frames = cfg.env_frameskip\n    if cfg.num_bots < 0:\n        num_bots = doom_spec.num_bots\n    else:\n        num_bots = cfg.num_bots\n    num_agents = doom_spec.num_agents if cfg.num_agents <= 0 else cfg.num_agents\n    max_num_players = num_agents + cfg.num_humans\n    is_multiagent = num_agents > 1\n    def make_env_func(player_id):",
        "detail": "deps.sample-factory.sf_examples.vizdoom.doom.doom_utils",
        "documentation": {}
    },
    {
        "label": "make_doom_env",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.vizdoom.doom.doom_utils",
        "description": "deps.sample-factory.sf_examples.vizdoom.doom.doom_utils",
        "peekOfCode": "def make_doom_env(env_name, cfg, env_config, render_mode: Optional[str] = None, **kwargs):\n    spec = doom_env_by_name(env_name)\n    return make_doom_env_from_spec(spec, env_name, cfg, env_config, render_mode, **kwargs)\ndef make_doom_env_from_spec(spec, _env_name, cfg, env_config, render_mode: Optional[str] = None, **kwargs):\n    \"\"\"\n    Makes a Doom environment from a DoomSpec instance.\n    _env_name is unused but we keep it, so functools.partial(make_doom_env_from_spec, env_spec) can registered\n    in Sample Factory (first argument in make_env_func is expected to be the env_name).\n    \"\"\"\n    if \"record_to\" in cfg and cfg.record_to:",
        "detail": "deps.sample-factory.sf_examples.vizdoom.doom.doom_utils",
        "documentation": {}
    },
    {
        "label": "make_doom_env_from_spec",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.vizdoom.doom.doom_utils",
        "description": "deps.sample-factory.sf_examples.vizdoom.doom.doom_utils",
        "peekOfCode": "def make_doom_env_from_spec(spec, _env_name, cfg, env_config, render_mode: Optional[str] = None, **kwargs):\n    \"\"\"\n    Makes a Doom environment from a DoomSpec instance.\n    _env_name is unused but we keep it, so functools.partial(make_doom_env_from_spec, env_spec) can registered\n    in Sample Factory (first argument in make_env_func is expected to be the env_name).\n    \"\"\"\n    if \"record_to\" in cfg and cfg.record_to:\n        tstamp = datetime.datetime.now().strftime(\"%Y_%m_%d__%H_%M_%S\")\n        cfg.record_to = join(cfg.record_to, f\"{cfg.experiment}\", tstamp)\n        if not os.path.isdir(cfg.record_to):",
        "detail": "deps.sample-factory.sf_examples.vizdoom.doom.doom_utils",
        "documentation": {}
    },
    {
        "label": "ADDITIONAL_INPUT",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.vizdoom.doom.doom_utils",
        "description": "deps.sample-factory.sf_examples.vizdoom.doom.doom_utils",
        "peekOfCode": "ADDITIONAL_INPUT = (DoomAdditionalInput, {})  # health, ammo, etc. as input vector\nBATTLE_REWARD_SHAPING = (\n    DoomRewardShapingWrapper,\n    dict(reward_shaping_scheme=REWARD_SHAPING_BATTLE, true_objective_func=None),\n)  # \"true\" reward None means just the env reward (monster kills)\nBOTS_REWARD_SHAPING = (\n    DoomRewardShapingWrapper,\n    dict(reward_shaping_scheme=REWARD_SHAPING_DEATHMATCH_V0, true_objective_func=true_objective_frags),\n)\nDEATHMATCH_REWARD_SHAPING = (",
        "detail": "deps.sample-factory.sf_examples.vizdoom.doom.doom_utils",
        "documentation": {}
    },
    {
        "label": "BATTLE_REWARD_SHAPING",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.vizdoom.doom.doom_utils",
        "description": "deps.sample-factory.sf_examples.vizdoom.doom.doom_utils",
        "peekOfCode": "BATTLE_REWARD_SHAPING = (\n    DoomRewardShapingWrapper,\n    dict(reward_shaping_scheme=REWARD_SHAPING_BATTLE, true_objective_func=None),\n)  # \"true\" reward None means just the env reward (monster kills)\nBOTS_REWARD_SHAPING = (\n    DoomRewardShapingWrapper,\n    dict(reward_shaping_scheme=REWARD_SHAPING_DEATHMATCH_V0, true_objective_func=true_objective_frags),\n)\nDEATHMATCH_REWARD_SHAPING = (\n    DoomRewardShapingWrapper,",
        "detail": "deps.sample-factory.sf_examples.vizdoom.doom.doom_utils",
        "documentation": {}
    },
    {
        "label": "BOTS_REWARD_SHAPING",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.vizdoom.doom.doom_utils",
        "description": "deps.sample-factory.sf_examples.vizdoom.doom.doom_utils",
        "peekOfCode": "BOTS_REWARD_SHAPING = (\n    DoomRewardShapingWrapper,\n    dict(reward_shaping_scheme=REWARD_SHAPING_DEATHMATCH_V0, true_objective_func=true_objective_frags),\n)\nDEATHMATCH_REWARD_SHAPING = (\n    DoomRewardShapingWrapper,\n    dict(reward_shaping_scheme=REWARD_SHAPING_DEATHMATCH_V1, true_objective_func=true_objective_winning_the_game),\n)\nDOOM_ENVS = [\n    DoomSpec(",
        "detail": "deps.sample-factory.sf_examples.vizdoom.doom.doom_utils",
        "documentation": {}
    },
    {
        "label": "DEATHMATCH_REWARD_SHAPING",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.vizdoom.doom.doom_utils",
        "description": "deps.sample-factory.sf_examples.vizdoom.doom.doom_utils",
        "peekOfCode": "DEATHMATCH_REWARD_SHAPING = (\n    DoomRewardShapingWrapper,\n    dict(reward_shaping_scheme=REWARD_SHAPING_DEATHMATCH_V1, true_objective_func=true_objective_winning_the_game),\n)\nDOOM_ENVS = [\n    DoomSpec(\n        \"doom_basic\",\n        \"basic.cfg\",\n        Discrete(1 + 3),  # idle, left, right, attack\n        reward_scaling=0.01,",
        "detail": "deps.sample-factory.sf_examples.vizdoom.doom.doom_utils",
        "documentation": {}
    },
    {
        "label": "DOOM_ENVS",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.vizdoom.doom.doom_utils",
        "description": "deps.sample-factory.sf_examples.vizdoom.doom.doom_utils",
        "peekOfCode": "DOOM_ENVS = [\n    DoomSpec(\n        \"doom_basic\",\n        \"basic.cfg\",\n        Discrete(1 + 3),  # idle, left, right, attack\n        reward_scaling=0.01,\n        default_timeout=300,\n    ),\n    DoomSpec(\n        \"doom_two_colors_easy\",",
        "detail": "deps.sample-factory.sf_examples.vizdoom.doom.doom_utils",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.vizdoom.doom.play_doom",
        "description": "deps.sample-factory.sf_examples.vizdoom.doom.play_doom",
        "peekOfCode": "def main():\n    env_name = \"doom_duel_bots\"\n    cfg = parse_vizdoom_cfg(argv=[\"--algo=APPO\", f\"--env={env_name}\", \"--experiment=play_doom\"])\n    env = make_doom_env_impl(doom_env_by_name(env_name), cfg=cfg, custom_resolution=\"1280x720\")\n    # cfg.num_agents = 1\n    # cfg.num_bots = 7\n    # # cfg.num_humans = 1\n    # env = make_doom_multiplayer_env(doom_env_by_name(env_name), cfg=cfg, custom_resolution='1280x720')\n    return VizdoomEnv.play_human_mode(env, skip_frames=2, num_actions=15)\nif __name__ == \"__main__\":",
        "detail": "deps.sample-factory.sf_examples.vizdoom.doom.play_doom",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.vizdoom.doom.sample_env",
        "description": "deps.sample-factory.sf_examples.vizdoom.doom.sample_env",
        "peekOfCode": "def main():\n    env_name = \"doom_battle\"\n    env = create_env(env_name, cfg=default_cfg(env=env_name))\n    env.reset()\n    done = False\n    while not done:\n        env.render()\n        obs, rew, terminated, truncated, info = env.step(env.action_space.sample())\n        done = make_dones(terminated, truncated)\n    log.info(\"Done!\")",
        "detail": "deps.sample-factory.sf_examples.vizdoom.doom.sample_env",
        "documentation": {}
    },
    {
        "label": "_params",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.vizdoom.experiments.doom_basic",
        "description": "deps.sample-factory.sf_examples.vizdoom.experiments.doom_basic",
        "peekOfCode": "_params = ParamGrid(\n    [\n        (\"seed\", seeds(4)),\n    ]\n)\n_experiment = Experiment(\n    \"doom_basic\",\n    \"python -m sf_examples.vizdoom.train_vizdoom --env=doom_basic --train_for_env_steps=2000000 --algo=APPO --env_frameskip=4 --use_rnn=True --wide_aspect_ratio=False --num_workers=20 --num_envs_per_worker=16 --decorrelate_envs_on_one_worker=False\",\n    _params.generate_params(randomize=False),\n)",
        "detail": "deps.sample-factory.sf_examples.vizdoom.experiments.doom_basic",
        "documentation": {}
    },
    {
        "label": "_experiment",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.vizdoom.experiments.doom_basic",
        "description": "deps.sample-factory.sf_examples.vizdoom.experiments.doom_basic",
        "peekOfCode": "_experiment = Experiment(\n    \"doom_basic\",\n    \"python -m sf_examples.vizdoom.train_vizdoom --env=doom_basic --train_for_env_steps=2000000 --algo=APPO --env_frameskip=4 --use_rnn=True --wide_aspect_ratio=False --num_workers=20 --num_envs_per_worker=16 --decorrelate_envs_on_one_worker=False\",\n    _params.generate_params(randomize=False),\n)\nRUN_DESCRIPTION = RunDescription(\"doom_basic\", experiments=[_experiment])\n# To run:\n# python -m sample_factory.launcher.run --run=sf_examples.vizdoom.experiments.doom_basic --backend=processes --num_gpus=1 --max_parallel=2  --pause_between=0 --experiments_per_gpu=2",
        "detail": "deps.sample-factory.sf_examples.vizdoom.experiments.doom_basic",
        "documentation": {}
    },
    {
        "label": "RUN_DESCRIPTION",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.vizdoom.experiments.doom_basic",
        "description": "deps.sample-factory.sf_examples.vizdoom.experiments.doom_basic",
        "peekOfCode": "RUN_DESCRIPTION = RunDescription(\"doom_basic\", experiments=[_experiment])\n# To run:\n# python -m sample_factory.launcher.run --run=sf_examples.vizdoom.experiments.doom_basic --backend=processes --num_gpus=1 --max_parallel=2  --pause_between=0 --experiments_per_gpu=2",
        "detail": "deps.sample-factory.sf_examples.vizdoom.experiments.doom_basic",
        "documentation": {}
    },
    {
        "label": "_params",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.vizdoom.experiments.doom_battle_battle2_appo",
        "description": "deps.sample-factory.sf_examples.vizdoom.experiments.doom_battle_battle2_appo",
        "peekOfCode": "_params = ParamGrid(\n    [\n        (\"env\", [\"doom_battle\", \"doom_battle2\"]),\n        (\"seed\", seeds(4)),\n    ]\n)\n_experiments = [\n    Experiment(\n        \"battle_fs4\",\n        \"python -m sf_examples.vizdoom.train_vizdoom --train_for_env_steps=4000000000 --algo=APPO --env_frameskip=4 --use_rnn=True --num_workers=16 --num_envs_per_worker=20 --num_policies=1 --batch_size=2048 --wide_aspect_ratio=False --max_grad_norm=0.0\",",
        "detail": "deps.sample-factory.sf_examples.vizdoom.experiments.doom_battle_battle2_appo",
        "documentation": {}
    },
    {
        "label": "_experiments",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.vizdoom.experiments.doom_battle_battle2_appo",
        "description": "deps.sample-factory.sf_examples.vizdoom.experiments.doom_battle_battle2_appo",
        "peekOfCode": "_experiments = [\n    Experiment(\n        \"battle_fs4\",\n        \"python -m sf_examples.vizdoom.train_vizdoom --train_for_env_steps=4000000000 --algo=APPO --env_frameskip=4 --use_rnn=True --num_workers=16 --num_envs_per_worker=20 --num_policies=1 --batch_size=2048 --wide_aspect_ratio=False --max_grad_norm=0.0\",\n        _params.generate_params(randomize=False),\n    ),\n]\nRUN_DESCRIPTION = RunDescription(\"doom_battle_battle2_appo_v1.121.2\", experiments=_experiments)",
        "detail": "deps.sample-factory.sf_examples.vizdoom.experiments.doom_battle_battle2_appo",
        "documentation": {}
    },
    {
        "label": "RUN_DESCRIPTION",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.vizdoom.experiments.doom_battle_battle2_appo",
        "description": "deps.sample-factory.sf_examples.vizdoom.experiments.doom_battle_battle2_appo",
        "peekOfCode": "RUN_DESCRIPTION = RunDescription(\"doom_battle_battle2_appo_v1.121.2\", experiments=_experiments)",
        "detail": "deps.sample-factory.sf_examples.vizdoom.experiments.doom_battle_battle2_appo",
        "documentation": {}
    },
    {
        "label": "_params",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.vizdoom.experiments.doom_battle_d4_appo_pbt",
        "description": "deps.sample-factory.sf_examples.vizdoom.experiments.doom_battle_d4_appo_pbt",
        "peekOfCode": "_params = ParamGrid(\n    [\n        (\"num_epochs\", [1]),\n    ]\n)\n_experiments = [\n    Experiment(\n        \"battle_d4_fs4_pbt\",\n        \"python -m sf_examples.vizdoom.train_vizdoom --env=doom_battle_d4 --train_for_env_steps=50000000000 --algo=APPO --env_frameskip=4 --use_rnn=True --reward_scale=0.5 --num_workers=24 --num_envs_per_worker=30 --num_policies=4 --macro_batch=2048 --batch_size=2048 --wide_aspect_ratio=False --pbt_period_env_steps=5000000\",\n        _params.generate_params(randomize=False),",
        "detail": "deps.sample-factory.sf_examples.vizdoom.experiments.doom_battle_d4_appo_pbt",
        "documentation": {}
    },
    {
        "label": "_experiments",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.vizdoom.experiments.doom_battle_d4_appo_pbt",
        "description": "deps.sample-factory.sf_examples.vizdoom.experiments.doom_battle_d4_appo_pbt",
        "peekOfCode": "_experiments = [\n    Experiment(\n        \"battle_d4_fs4_pbt\",\n        \"python -m sf_examples.vizdoom.train_vizdoom --env=doom_battle_d4 --train_for_env_steps=50000000000 --algo=APPO --env_frameskip=4 --use_rnn=True --reward_scale=0.5 --num_workers=24 --num_envs_per_worker=30 --num_policies=4 --macro_batch=2048 --batch_size=2048 --wide_aspect_ratio=False --pbt_period_env_steps=5000000\",\n        _params.generate_params(randomize=False),\n    ),\n]\nRUN_DESCRIPTION = RunDescription(\n    \"doom_battle_d4_appo_v64_fs4_pbt\", experiments=_experiments, use_gpus=2, experiments_per_gpu=-1, max_parallel=1\n)",
        "detail": "deps.sample-factory.sf_examples.vizdoom.experiments.doom_battle_d4_appo_pbt",
        "documentation": {}
    },
    {
        "label": "RUN_DESCRIPTION",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.vizdoom.experiments.doom_battle_d4_appo_pbt",
        "description": "deps.sample-factory.sf_examples.vizdoom.experiments.doom_battle_d4_appo_pbt",
        "peekOfCode": "RUN_DESCRIPTION = RunDescription(\n    \"doom_battle_d4_appo_v64_fs4_pbt\", experiments=_experiments, use_gpus=2, experiments_per_gpu=-1, max_parallel=1\n)",
        "detail": "deps.sample-factory.sf_examples.vizdoom.experiments.doom_battle_d4_appo_pbt",
        "documentation": {}
    },
    {
        "label": "_params",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.vizdoom.experiments.doom_bots_sweep",
        "description": "deps.sample-factory.sf_examples.vizdoom.experiments.doom_bots_sweep",
        "peekOfCode": "_params = ParamGrid(\n    [\n        (\"seed\", [42]),\n    ]\n)\n_experiments = [\n    Experiment(\n        \"bots_128_fs2_wide\",\n        \"python -m sf_examples.vizdoom.train_vizdoom --env=doom_dwango5_bots_experimental --train_for_seconds=3600000 --algo=APPO --use_rnn=True --gamma=0.995 --env_frameskip=2 --reward_scale=0.5 --num_workers=18 --num_envs_per_worker=20 --num_policies=1 --macro_batch=2048 --batch_size=2048 --res_w=128 --res_h=72 --wide_aspect_ratio=True\",\n        _params.generate_params(randomize=False),",
        "detail": "deps.sample-factory.sf_examples.vizdoom.experiments.doom_bots_sweep",
        "documentation": {}
    },
    {
        "label": "_experiments",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.vizdoom.experiments.doom_bots_sweep",
        "description": "deps.sample-factory.sf_examples.vizdoom.experiments.doom_bots_sweep",
        "peekOfCode": "_experiments = [\n    Experiment(\n        \"bots_128_fs2_wide\",\n        \"python -m sf_examples.vizdoom.train_vizdoom --env=doom_dwango5_bots_experimental --train_for_seconds=3600000 --algo=APPO --use_rnn=True --gamma=0.995 --env_frameskip=2 --reward_scale=0.5 --num_workers=18 --num_envs_per_worker=20 --num_policies=1 --macro_batch=2048 --batch_size=2048 --res_w=128 --res_h=72 --wide_aspect_ratio=True\",\n        _params.generate_params(randomize=False),\n        dict(DOOM_DEFAULT_UDP_PORT=35300),\n    ),\n    Experiment(\n        \"bots_128_fs2_narrow\",\n        \"python -m sf_examples.vizdoom.train_vizdoom --env=doom_dwango5_bots_experimental --train_for_seconds=3600000 --algo=APPO --use_rnn=True --gamma=0.995 --env_frameskip=2 --reward_scale=0.5 --num_workers=18 --num_envs_per_worker=20 --num_policies=1 --macro_batch=2048 --batch_size=2048 --res_w=128 --res_h=72 --wide_aspect_ratio=False\",",
        "detail": "deps.sample-factory.sf_examples.vizdoom.experiments.doom_bots_sweep",
        "documentation": {}
    },
    {
        "label": "RUN_DESCRIPTION",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.vizdoom.experiments.doom_bots_sweep",
        "description": "deps.sample-factory.sf_examples.vizdoom.experiments.doom_bots_sweep",
        "peekOfCode": "RUN_DESCRIPTION = RunDescription(\n    \"doom_bots_sweep\",\n    experiments=_experiments,\n)",
        "detail": "deps.sample-factory.sf_examples.vizdoom.experiments.doom_bots_sweep",
        "documentation": {}
    },
    {
        "label": "_params",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.vizdoom.experiments.doom_defend_center",
        "description": "deps.sample-factory.sf_examples.vizdoom.experiments.doom_defend_center",
        "peekOfCode": "_params = ParamGrid(\n    [\n        (\"seed\", [1111, 2222, 3333]),\n        (\"env\", [\"doom_defend_the_center_flat_actions\"]),\n        (\"num_envs_per_worker\", [16]),\n    ]\n)\n_experiments = [\n    Experiment(\n        \"basic_envs_fs4\",",
        "detail": "deps.sample-factory.sf_examples.vizdoom.experiments.doom_defend_center",
        "documentation": {}
    },
    {
        "label": "_experiments",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.vizdoom.experiments.doom_defend_center",
        "description": "deps.sample-factory.sf_examples.vizdoom.experiments.doom_defend_center",
        "peekOfCode": "_experiments = [\n    Experiment(\n        \"basic_envs_fs4\",\n        \"python -m sf_examples.vizdoom.train_vizdoom --train_for_env_steps=100000000 --algo=APPO --env_frameskip=4 --use_rnn=True --rnn_type=lstm --num_workers=72 --num_policies=1 --batch_size=2048 --wide_aspect_ratio=False --policy_workers_per_policy=3 --experiment_summaries_interval=5 --ppo_clip_value=10.0 --nonlinearity=relu\",\n        _params.generate_params(randomize=False),\n    ),\n]\nRUN_DESCRIPTION = RunDescription(\"paper_doom_wall_time_v97_fs4\", experiments=_experiments)",
        "detail": "deps.sample-factory.sf_examples.vizdoom.experiments.doom_defend_center",
        "documentation": {}
    },
    {
        "label": "RUN_DESCRIPTION",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.vizdoom.experiments.doom_defend_center",
        "description": "deps.sample-factory.sf_examples.vizdoom.experiments.doom_defend_center",
        "peekOfCode": "RUN_DESCRIPTION = RunDescription(\"paper_doom_wall_time_v97_fs4\", experiments=_experiments)",
        "detail": "deps.sample-factory.sf_examples.vizdoom.experiments.doom_defend_center",
        "documentation": {}
    },
    {
        "label": "_experiment",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.vizdoom.experiments.doom_freedm",
        "description": "deps.sample-factory.sf_examples.vizdoom.experiments.doom_freedm",
        "peekOfCode": "_experiment = Experiment(\n    \"bots_freedm_fs2\",\n    \"python -m sf_examples.vizdoom.train_vizdoom --env=doom_freedm --train_for_seconds=360000 --algo=APPO --gamma=0.995 --env_frameskip=2 --use_rnn=True --reward_scale=0.5 --num_workers=20 --num_envs_per_worker=4 --num_policies=1 --macro_batch=2048 --batch_size=2048 --benchmark=False --start_bot_difficulty=150\",\n)\nRUN_DESCRIPTION = RunDescription(\n    \"doom_freedm_fs2\",\n    experiments=[_experiment],\n)",
        "detail": "deps.sample-factory.sf_examples.vizdoom.experiments.doom_freedm",
        "documentation": {}
    },
    {
        "label": "RUN_DESCRIPTION",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.vizdoom.experiments.doom_freedm",
        "description": "deps.sample-factory.sf_examples.vizdoom.experiments.doom_freedm",
        "peekOfCode": "RUN_DESCRIPTION = RunDescription(\n    \"doom_freedm_fs2\",\n    experiments=[_experiment],\n)",
        "detail": "deps.sample-factory.sf_examples.vizdoom.experiments.doom_freedm",
        "documentation": {}
    },
    {
        "label": "_params",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.vizdoom.experiments.doom_health_gathering",
        "description": "deps.sample-factory.sf_examples.vizdoom.experiments.doom_health_gathering",
        "peekOfCode": "_params = ParamGrid(\n    [\n        (\"seed\", [1111, 2222, 3333, 4444, 5555]),\n        (\"env\", [\"doom_health_gathering_supreme\"]),\n    ]\n)\n_experiments = [\n    Experiment(\n        \"health_0_255\",\n        \"python -m sf_examples.vizdoom.train_vizdoom --train_for_env_steps=40000000 --algo=APPO --env_frameskip=4 --use_rnn=True --num_workers=20 --num_envs_per_worker=12 --num_policies=1 --batch_size=2048 --wide_aspect_ratio=False\",",
        "detail": "deps.sample-factory.sf_examples.vizdoom.experiments.doom_health_gathering",
        "documentation": {}
    },
    {
        "label": "_experiments",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.vizdoom.experiments.doom_health_gathering",
        "description": "deps.sample-factory.sf_examples.vizdoom.experiments.doom_health_gathering",
        "peekOfCode": "_experiments = [\n    Experiment(\n        \"health_0_255\",\n        \"python -m sf_examples.vizdoom.train_vizdoom --train_for_env_steps=40000000 --algo=APPO --env_frameskip=4 --use_rnn=True --num_workers=20 --num_envs_per_worker=12 --num_policies=1 --batch_size=2048 --wide_aspect_ratio=False\",\n        _params.generate_params(randomize=False),\n    ),\n    Experiment(\n        \"health_128_128\",\n        \"python -m sf_examples.vizdoom.train_vizdoom --train_for_env_steps=40000000 --algo=APPO --env_frameskip=4 --use_rnn=True --num_workers=20 --num_envs_per_worker=12 --num_policies=1 --batch_size=2048 --wide_aspect_ratio=False --obs_subtract_mean=128.0 --obs_scale=128.0\",\n        _params.generate_params(randomize=False),",
        "detail": "deps.sample-factory.sf_examples.vizdoom.experiments.doom_health_gathering",
        "documentation": {}
    },
    {
        "label": "RUN_DESCRIPTION",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.vizdoom.experiments.doom_health_gathering",
        "description": "deps.sample-factory.sf_examples.vizdoom.experiments.doom_health_gathering",
        "peekOfCode": "RUN_DESCRIPTION = RunDescription(\"doom_health_gathering_v97_fs4\", experiments=_experiments)",
        "detail": "deps.sample-factory.sf_examples.vizdoom.experiments.doom_health_gathering",
        "documentation": {}
    },
    {
        "label": "_params",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.vizdoom.experiments.paper_doom_all_basic_envs",
        "description": "deps.sample-factory.sf_examples.vizdoom.experiments.paper_doom_all_basic_envs",
        "peekOfCode": "_params = ParamGrid(\n    [\n        (\"seed\", [0, 1111, 2222, 3333, 4444, 5555, 6666, 7777, 8888, 9999]),\n        (\n            \"env\",\n            [\n                \"doom_my_way_home\",\n                \"doom_deadly_corridor\",\n                \"doom_defend_the_center\",\n                \"doom_defend_the_line\",",
        "detail": "deps.sample-factory.sf_examples.vizdoom.experiments.paper_doom_all_basic_envs",
        "documentation": {}
    },
    {
        "label": "_experiments",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.vizdoom.experiments.paper_doom_all_basic_envs",
        "description": "deps.sample-factory.sf_examples.vizdoom.experiments.paper_doom_all_basic_envs",
        "peekOfCode": "_experiments = [\n    Experiment(\n        \"basic_envs_fs4\",\n        \"python -m sf_examples.vizdoom.train_vizdoom --train_for_env_steps=500000000 --algo=APPO --env_frameskip=4 --use_rnn=True --num_workers=36 --num_envs_per_worker=8 --num_policies=1 --batch_size=2048 --wide_aspect_ratio=False\",\n        _params.generate_params(randomize=False),\n    ),\n]\nRUN_DESCRIPTION = RunDescription(\"paper_doom_basic_envs\", experiments=_experiments)",
        "detail": "deps.sample-factory.sf_examples.vizdoom.experiments.paper_doom_all_basic_envs",
        "documentation": {}
    },
    {
        "label": "RUN_DESCRIPTION",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.vizdoom.experiments.paper_doom_all_basic_envs",
        "description": "deps.sample-factory.sf_examples.vizdoom.experiments.paper_doom_all_basic_envs",
        "peekOfCode": "RUN_DESCRIPTION = RunDescription(\"paper_doom_basic_envs\", experiments=_experiments)",
        "detail": "deps.sample-factory.sf_examples.vizdoom.experiments.paper_doom_all_basic_envs",
        "documentation": {}
    },
    {
        "label": "_params",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.vizdoom.experiments.paper_doom_battle2_appo",
        "description": "deps.sample-factory.sf_examples.vizdoom.experiments.paper_doom_battle2_appo",
        "peekOfCode": "_params = ParamGrid(\n    [\n        (\"seed\", [1111, 2222, 3333]),\n    ]\n)\n_experiments = [\n    Experiment(\n        \"battle2_fs4\",\n        \"python -m sf_examples.vizdoom.train_vizdoom --env=doom_battle2 --train_for_env_steps=3000000000 --algo=APPO --env_frameskip=4 --use_rnn=True --reward_scale=0.5 --num_workers=20 --num_envs_per_worker=20 --num_policies=1 --batch_size=2048 --wide_aspect_ratio=False\",\n        _params.generate_params(randomize=False),",
        "detail": "deps.sample-factory.sf_examples.vizdoom.experiments.paper_doom_battle2_appo",
        "documentation": {}
    },
    {
        "label": "_experiments",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.vizdoom.experiments.paper_doom_battle2_appo",
        "description": "deps.sample-factory.sf_examples.vizdoom.experiments.paper_doom_battle2_appo",
        "peekOfCode": "_experiments = [\n    Experiment(\n        \"battle2_fs4\",\n        \"python -m sf_examples.vizdoom.train_vizdoom --env=doom_battle2 --train_for_env_steps=3000000000 --algo=APPO --env_frameskip=4 --use_rnn=True --reward_scale=0.5 --num_workers=20 --num_envs_per_worker=20 --num_policies=1 --batch_size=2048 --wide_aspect_ratio=False\",\n        _params.generate_params(randomize=False),\n    ),\n]\nRUN_DESCRIPTION = RunDescription(\"doom_battle2_appo_v1.119.0_fs4\", experiments=_experiments)",
        "detail": "deps.sample-factory.sf_examples.vizdoom.experiments.paper_doom_battle2_appo",
        "documentation": {}
    },
    {
        "label": "RUN_DESCRIPTION",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.vizdoom.experiments.paper_doom_battle2_appo",
        "description": "deps.sample-factory.sf_examples.vizdoom.experiments.paper_doom_battle2_appo",
        "peekOfCode": "RUN_DESCRIPTION = RunDescription(\"doom_battle2_appo_v1.119.0_fs4\", experiments=_experiments)",
        "detail": "deps.sample-factory.sf_examples.vizdoom.experiments.paper_doom_battle2_appo",
        "documentation": {}
    },
    {
        "label": "_params",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.vizdoom.experiments.paper_doom_battle2_appo_pbt",
        "description": "deps.sample-factory.sf_examples.vizdoom.experiments.paper_doom_battle2_appo_pbt",
        "peekOfCode": "_params = ParamGrid([])\n_experiments = [\n    Experiment(\n        \"battle2_fs4\",\n        \"python -m sf_examples.vizdoom.train_vizdoom --env=doom_battle2 --train_for_env_steps=3000000000 --algo=APPO --env_frameskip=4 --use_rnn=True --macro_batch=2048 --batch_size=2048 --wide_aspect_ratio=False --num_workers=72 --num_envs_per_worker=30 --num_policies=8 --with_pbt=True\",\n        _params.generate_params(randomize=False),\n    ),\n]\nRUN_DESCRIPTION = RunDescription(\"paper_doom_battle2_appo_pbt_v65_fs4\", experiments=_experiments)",
        "detail": "deps.sample-factory.sf_examples.vizdoom.experiments.paper_doom_battle2_appo_pbt",
        "documentation": {}
    },
    {
        "label": "_experiments",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.vizdoom.experiments.paper_doom_battle2_appo_pbt",
        "description": "deps.sample-factory.sf_examples.vizdoom.experiments.paper_doom_battle2_appo_pbt",
        "peekOfCode": "_experiments = [\n    Experiment(\n        \"battle2_fs4\",\n        \"python -m sf_examples.vizdoom.train_vizdoom --env=doom_battle2 --train_for_env_steps=3000000000 --algo=APPO --env_frameskip=4 --use_rnn=True --macro_batch=2048 --batch_size=2048 --wide_aspect_ratio=False --num_workers=72 --num_envs_per_worker=30 --num_policies=8 --with_pbt=True\",\n        _params.generate_params(randomize=False),\n    ),\n]\nRUN_DESCRIPTION = RunDescription(\"paper_doom_battle2_appo_pbt_v65_fs4\", experiments=_experiments)",
        "detail": "deps.sample-factory.sf_examples.vizdoom.experiments.paper_doom_battle2_appo_pbt",
        "documentation": {}
    },
    {
        "label": "RUN_DESCRIPTION",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.vizdoom.experiments.paper_doom_battle2_appo_pbt",
        "description": "deps.sample-factory.sf_examples.vizdoom.experiments.paper_doom_battle2_appo_pbt",
        "peekOfCode": "RUN_DESCRIPTION = RunDescription(\"paper_doom_battle2_appo_pbt_v65_fs4\", experiments=_experiments)",
        "detail": "deps.sample-factory.sf_examples.vizdoom.experiments.paper_doom_battle2_appo_pbt",
        "documentation": {}
    },
    {
        "label": "_params",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.vizdoom.experiments.paper_doom_battle_appo",
        "description": "deps.sample-factory.sf_examples.vizdoom.experiments.paper_doom_battle_appo",
        "peekOfCode": "_params = ParamGrid(\n    [\n        (\"seed\", [1111, 2222, 3333, 4444]),\n    ]\n)\n_experiments = [\n    Experiment(\n        \"battle_fs4\",\n        \"python -m sf_examples.vizdoom.train_vizdoom --env=doom_battle --train_for_env_steps=4000000000 --algo=APPO --env_frameskip=4 --use_rnn=True --num_workers=72 --num_envs_per_worker=8 --num_policies=1 --batch_size=2048 --wide_aspect_ratio=False --max_grad_norm=0.0\",\n        _params.generate_params(randomize=False),",
        "detail": "deps.sample-factory.sf_examples.vizdoom.experiments.paper_doom_battle_appo",
        "documentation": {}
    },
    {
        "label": "_experiments",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.vizdoom.experiments.paper_doom_battle_appo",
        "description": "deps.sample-factory.sf_examples.vizdoom.experiments.paper_doom_battle_appo",
        "peekOfCode": "_experiments = [\n    Experiment(\n        \"battle_fs4\",\n        \"python -m sf_examples.vizdoom.train_vizdoom --env=doom_battle --train_for_env_steps=4000000000 --algo=APPO --env_frameskip=4 --use_rnn=True --num_workers=72 --num_envs_per_worker=8 --num_policies=1 --batch_size=2048 --wide_aspect_ratio=False --max_grad_norm=0.0\",\n        _params.generate_params(randomize=False),\n    ),\n]\nRUN_DESCRIPTION = RunDescription(\"paper_doom_battle_appo_v108_fs4\", experiments=_experiments)",
        "detail": "deps.sample-factory.sf_examples.vizdoom.experiments.paper_doom_battle_appo",
        "documentation": {}
    },
    {
        "label": "RUN_DESCRIPTION",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.vizdoom.experiments.paper_doom_battle_appo",
        "description": "deps.sample-factory.sf_examples.vizdoom.experiments.paper_doom_battle_appo",
        "peekOfCode": "RUN_DESCRIPTION = RunDescription(\"paper_doom_battle_appo_v108_fs4\", experiments=_experiments)",
        "detail": "deps.sample-factory.sf_examples.vizdoom.experiments.paper_doom_battle_appo",
        "documentation": {}
    },
    {
        "label": "_params",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.vizdoom.experiments.paper_doom_battle_appo_pbt",
        "description": "deps.sample-factory.sf_examples.vizdoom.experiments.paper_doom_battle_appo_pbt",
        "peekOfCode": "_params = ParamGrid([])\n_experiments = [\n    Experiment(\n        \"battle_fs4\",\n        \"python -m sf_examples.vizdoom.train_vizdoom --env=doom_battle --train_for_env_steps=4000000000 --algo=APPO --env_frameskip=4 --use_rnn=True --batch_size=2048 --wide_aspect_ratio=False --num_workers=72 --num_envs_per_worker=32 --num_policies=8 --with_pbt=True\",\n        _params.generate_params(randomize=False),\n    ),\n]\nRUN_DESCRIPTION = RunDescription(\"paper_doom_battle_appo_pbt_v98_fs4\", experiments=_experiments)",
        "detail": "deps.sample-factory.sf_examples.vizdoom.experiments.paper_doom_battle_appo_pbt",
        "documentation": {}
    },
    {
        "label": "_experiments",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.vizdoom.experiments.paper_doom_battle_appo_pbt",
        "description": "deps.sample-factory.sf_examples.vizdoom.experiments.paper_doom_battle_appo_pbt",
        "peekOfCode": "_experiments = [\n    Experiment(\n        \"battle_fs4\",\n        \"python -m sf_examples.vizdoom.train_vizdoom --env=doom_battle --train_for_env_steps=4000000000 --algo=APPO --env_frameskip=4 --use_rnn=True --batch_size=2048 --wide_aspect_ratio=False --num_workers=72 --num_envs_per_worker=32 --num_policies=8 --with_pbt=True\",\n        _params.generate_params(randomize=False),\n    ),\n]\nRUN_DESCRIPTION = RunDescription(\"paper_doom_battle_appo_pbt_v98_fs4\", experiments=_experiments)",
        "detail": "deps.sample-factory.sf_examples.vizdoom.experiments.paper_doom_battle_appo_pbt",
        "documentation": {}
    },
    {
        "label": "RUN_DESCRIPTION",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.vizdoom.experiments.paper_doom_battle_appo_pbt",
        "description": "deps.sample-factory.sf_examples.vizdoom.experiments.paper_doom_battle_appo_pbt",
        "peekOfCode": "RUN_DESCRIPTION = RunDescription(\"paper_doom_battle_appo_pbt_v98_fs4\", experiments=_experiments)",
        "detail": "deps.sample-factory.sf_examples.vizdoom.experiments.paper_doom_battle_appo_pbt",
        "documentation": {}
    },
    {
        "label": "_params",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.vizdoom.experiments.paper_doom_bots_pbt",
        "description": "deps.sample-factory.sf_examples.vizdoom.experiments.paper_doom_bots_pbt",
        "peekOfCode": "_params = ParamGrid(\n    [\n        (\"seed\", [42]),\n    ]\n)\n_experiments = [\n    Experiment(\n        \"bots_128_fs2_narrow\",\n        \"python -m sf_examples.vizdoom.train_vizdoom --env=doom_deathmatch_bots --train_for_seconds=3600000 --algo=APPO --use_rnn=True --gamma=0.995 --env_frameskip=2 --num_workers=80 --num_envs_per_worker=24 --num_policies=8 --batch_size=2048 --res_w=128 --res_h=72 --wide_aspect_ratio=False --with_pbt=True --pbt_period_env_steps=5000000\",\n        _params.generate_params(randomize=False),",
        "detail": "deps.sample-factory.sf_examples.vizdoom.experiments.paper_doom_bots_pbt",
        "documentation": {}
    },
    {
        "label": "_experiments",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.vizdoom.experiments.paper_doom_bots_pbt",
        "description": "deps.sample-factory.sf_examples.vizdoom.experiments.paper_doom_bots_pbt",
        "peekOfCode": "_experiments = [\n    Experiment(\n        \"bots_128_fs2_narrow\",\n        \"python -m sf_examples.vizdoom.train_vizdoom --env=doom_deathmatch_bots --train_for_seconds=3600000 --algo=APPO --use_rnn=True --gamma=0.995 --env_frameskip=2 --num_workers=80 --num_envs_per_worker=24 --num_policies=8 --batch_size=2048 --res_w=128 --res_h=72 --wide_aspect_ratio=False --with_pbt=True --pbt_period_env_steps=5000000\",\n        _params.generate_params(randomize=False),\n        dict(DOOM_DEFAULT_UDP_PORT=35300),\n    ),\n]\nRUN_DESCRIPTION = RunDescription(\"doom_bots_v100_pbt\", experiments=_experiments)",
        "detail": "deps.sample-factory.sf_examples.vizdoom.experiments.paper_doom_bots_pbt",
        "documentation": {}
    },
    {
        "label": "RUN_DESCRIPTION",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.vizdoom.experiments.paper_doom_bots_pbt",
        "description": "deps.sample-factory.sf_examples.vizdoom.experiments.paper_doom_bots_pbt",
        "peekOfCode": "RUN_DESCRIPTION = RunDescription(\"doom_bots_v100_pbt\", experiments=_experiments)",
        "detail": "deps.sample-factory.sf_examples.vizdoom.experiments.paper_doom_bots_pbt",
        "documentation": {}
    },
    {
        "label": "_experiment",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.vizdoom.experiments.paper_doom_duel_bots_pbt",
        "description": "deps.sample-factory.sf_examples.vizdoom.experiments.paper_doom_duel_bots_pbt",
        "peekOfCode": "_experiment = Experiment(\n    \"bots_ssl2_fs2\",\n    \"python -m sf_examples.vizdoom.train_vizdoom --env=doom_duel_bots --train_for_seconds=360000 --algo=APPO --gamma=0.995 --env_frameskip=2 --use_rnn=True --reward_scale=0.5 --num_workers=72 --num_envs_per_worker=32 --num_policies=8 --batch_size=2048 --benchmark=False --res_w=128 --res_h=72 --wide_aspect_ratio=False --pbt_replace_reward_gap=0.2 --pbt_replace_reward_gap_absolute=3.0 --pbt_period_env_steps=5000000 --save_milestones_sec=1800 --with_pbt=True\",\n)\nRUN_DESCRIPTION = RunDescription(\"paper_doom_duel_bots_fs2\", experiments=[_experiment])",
        "detail": "deps.sample-factory.sf_examples.vizdoom.experiments.paper_doom_duel_bots_pbt",
        "documentation": {}
    },
    {
        "label": "RUN_DESCRIPTION",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.vizdoom.experiments.paper_doom_duel_bots_pbt",
        "description": "deps.sample-factory.sf_examples.vizdoom.experiments.paper_doom_duel_bots_pbt",
        "peekOfCode": "RUN_DESCRIPTION = RunDescription(\"paper_doom_duel_bots_fs2\", experiments=[_experiment])",
        "detail": "deps.sample-factory.sf_examples.vizdoom.experiments.paper_doom_duel_bots_pbt",
        "documentation": {}
    },
    {
        "label": "_experiment",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.vizdoom.experiments.paper_doom_duel_pbt",
        "description": "deps.sample-factory.sf_examples.vizdoom.experiments.paper_doom_duel_pbt",
        "peekOfCode": "_experiment = Experiment(\n    \"bots_ssl2_fs2\",\n    \"python -m sf_examples.vizdoom.train_vizdoom --env=doom_duel --train_for_seconds=360000 --algo=APPO --gamma=0.995 --env_frameskip=2 --use_rnn=True --reward_scale=0.5 --num_workers=72 --num_envs_per_worker=16 --num_policies=8 --batch_size=2048 --res_w=128 --res_h=72 --wide_aspect_ratio=False --benchmark=False --pbt_replace_reward_gap=0.5 --pbt_replace_reward_gap_absolute=0.35 --pbt_period_env_steps=5000000 --with_pbt=True --pbt_start_mutation=100000000\",\n)\nRUN_DESCRIPTION = RunDescription(\"paper_doom_duel_fs2\", experiments=[_experiment])",
        "detail": "deps.sample-factory.sf_examples.vizdoom.experiments.paper_doom_duel_pbt",
        "documentation": {}
    },
    {
        "label": "RUN_DESCRIPTION",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.vizdoom.experiments.paper_doom_duel_pbt",
        "description": "deps.sample-factory.sf_examples.vizdoom.experiments.paper_doom_duel_pbt",
        "peekOfCode": "RUN_DESCRIPTION = RunDescription(\"paper_doom_duel_fs2\", experiments=[_experiment])",
        "detail": "deps.sample-factory.sf_examples.vizdoom.experiments.paper_doom_duel_pbt",
        "documentation": {}
    },
    {
        "label": "_params",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.vizdoom.experiments.paper_doom_wall_time",
        "description": "deps.sample-factory.sf_examples.vizdoom.experiments.paper_doom_wall_time",
        "peekOfCode": "_params = ParamGrid(\n    [\n        (\"seed\", [1111, 2222, 3333]),\n        (\"env\", [\"doom_defend_the_center_flat_actions\", \"doom_my_way_home_flat_actions\"]),\n        (\"num_envs_per_worker\", [16]),\n    ]\n)\n_experiments = [\n    Experiment(\n        \"basic_envs_fs4\",",
        "detail": "deps.sample-factory.sf_examples.vizdoom.experiments.paper_doom_wall_time",
        "documentation": {}
    },
    {
        "label": "_experiments",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.vizdoom.experiments.paper_doom_wall_time",
        "description": "deps.sample-factory.sf_examples.vizdoom.experiments.paper_doom_wall_time",
        "peekOfCode": "_experiments = [\n    Experiment(\n        \"basic_envs_fs4\",\n        \"python -m sf_examples.vizdoom.train_vizdoom --train_for_env_steps=100000000 --algo=APPO --env_frameskip=4 --use_rnn=True --rnn_type=lstm --num_workers=72 --num_policies=1 --batch_size=2048 --wide_aspect_ratio=False --policy_workers_per_policy=3 --experiment_summaries_interval=5 --ppo_clip_value=10.0 --nonlinearity=relu\",\n        _params.generate_params(randomize=False),\n    ),\n]\nRUN_DESCRIPTION = RunDescription(\"paper_doom_wall_time_v97_fs4\", experiments=_experiments)",
        "detail": "deps.sample-factory.sf_examples.vizdoom.experiments.paper_doom_wall_time",
        "documentation": {}
    },
    {
        "label": "RUN_DESCRIPTION",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.vizdoom.experiments.paper_doom_wall_time",
        "description": "deps.sample-factory.sf_examples.vizdoom.experiments.paper_doom_wall_time",
        "peekOfCode": "RUN_DESCRIPTION = RunDescription(\"paper_doom_wall_time_v97_fs4\", experiments=_experiments)",
        "detail": "deps.sample-factory.sf_examples.vizdoom.experiments.paper_doom_wall_time",
        "documentation": {}
    },
    {
        "label": "_params",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.vizdoom.experiments.sf2_doom_battle_envs",
        "description": "deps.sample-factory.sf_examples.vizdoom.experiments.sf2_doom_battle_envs",
        "peekOfCode": "_params = ParamGrid(\n    [\n        (\"env\", [\"doom_battle\", \"doom_battle2\"]),\n        (\"seed\", seeds(4)),\n    ]\n)\n_experiments = [\n    Experiment(\n        \"sf2_doom_battle_envs\",\n        \"python -m sf_examples.vizdoom.train_vizdoom --train_for_env_steps=4000000000 --algo=APPO --env_frameskip=4 --use_rnn=True --num_workers=16 --num_envs_per_worker=20 --num_policies=1 --batch_size=2048 --wide_aspect_ratio=False --max_grad_norm=0.0 --normalize_input=True\",",
        "detail": "deps.sample-factory.sf_examples.vizdoom.experiments.sf2_doom_battle_envs",
        "documentation": {}
    },
    {
        "label": "_experiments",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.vizdoom.experiments.sf2_doom_battle_envs",
        "description": "deps.sample-factory.sf_examples.vizdoom.experiments.sf2_doom_battle_envs",
        "peekOfCode": "_experiments = [\n    Experiment(\n        \"sf2_doom_battle_envs\",\n        \"python -m sf_examples.vizdoom.train_vizdoom --train_for_env_steps=4000000000 --algo=APPO --env_frameskip=4 --use_rnn=True --num_workers=16 --num_envs_per_worker=20 --num_policies=1 --batch_size=2048 --wide_aspect_ratio=False --max_grad_norm=0.0 --normalize_input=True\",\n        _params.generate_params(randomize=False),\n    ),\n]\nRUN_DESCRIPTION = RunDescription(\"sf2_doom_battle_envs\", experiments=_experiments)",
        "detail": "deps.sample-factory.sf_examples.vizdoom.experiments.sf2_doom_battle_envs",
        "documentation": {}
    },
    {
        "label": "RUN_DESCRIPTION",
        "kind": 5,
        "importPath": "deps.sample-factory.sf_examples.vizdoom.experiments.sf2_doom_battle_envs",
        "description": "deps.sample-factory.sf_examples.vizdoom.experiments.sf2_doom_battle_envs",
        "peekOfCode": "RUN_DESCRIPTION = RunDescription(\"sf2_doom_battle_envs\", experiments=_experiments)",
        "detail": "deps.sample-factory.sf_examples.vizdoom.experiments.sf2_doom_battle_envs",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.vizdoom.enjoy_custom_vizdoom_env",
        "description": "deps.sample-factory.sf_examples.vizdoom.enjoy_custom_vizdoom_env",
        "peekOfCode": "def main():\n    \"\"\"Script entry point.\"\"\"\n    register_vizdoom_components()\n    parser, cfg = parse_sf_args(evaluation=True)\n    add_doom_env_args(parser)\n    add_doom_env_eval_args(parser)\n    doom_override_defaults(parser)\n    add_custom_args(parser)\n    cfg = parse_full_cfg(parser)\n    register_custom_doom_env(custom_timeout=cfg.my_custom_doom_arg)",
        "detail": "deps.sample-factory.sf_examples.vizdoom.enjoy_custom_vizdoom_env",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.vizdoom.enjoy_vizdoom",
        "description": "deps.sample-factory.sf_examples.vizdoom.enjoy_vizdoom",
        "peekOfCode": "def main():\n    \"\"\"Script entry point.\"\"\"\n    register_vizdoom_components()\n    parser, cfg = parse_sf_args(evaluation=True)\n    # parameters specific to Doom envs\n    add_doom_env_args(parser)\n    add_doom_env_eval_args(parser)\n    # override Doom default values for algo parameters\n    doom_override_defaults(parser)\n    # second parsing pass yields the final configuration",
        "detail": "deps.sample-factory.sf_examples.vizdoom.enjoy_vizdoom",
        "documentation": {}
    },
    {
        "label": "add_custom_args",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.vizdoom.train_custom_vizdoom_env",
        "description": "deps.sample-factory.sf_examples.vizdoom.train_custom_vizdoom_env",
        "peekOfCode": "def add_custom_args(parser: argparse.ArgumentParser) -> None:\n    parser.add_argument(\"--my_custom_doom_arg\", type=int, default=300, help=\"Any custom arguments users might define\")\ndef register_custom_doom_env(custom_timeout):\n    # absolute path needs to be specified, otherwise Doom will look in the SampleFactory scenarios folder\n    scenario_absolute_path = join(os.path.dirname(__file__), \"custom_env\", \"custom_doom_env.cfg\")\n    spec = DoomSpec(\n        \"doom_my_custom_env\",\n        scenario_absolute_path,  # use your custom cfg here\n        doom_action_space_extended(),\n        reward_scaling=0.01,",
        "detail": "deps.sample-factory.sf_examples.vizdoom.train_custom_vizdoom_env",
        "documentation": {}
    },
    {
        "label": "register_custom_doom_env",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.vizdoom.train_custom_vizdoom_env",
        "description": "deps.sample-factory.sf_examples.vizdoom.train_custom_vizdoom_env",
        "peekOfCode": "def register_custom_doom_env(custom_timeout):\n    # absolute path needs to be specified, otherwise Doom will look in the SampleFactory scenarios folder\n    scenario_absolute_path = join(os.path.dirname(__file__), \"custom_env\", \"custom_doom_env.cfg\")\n    spec = DoomSpec(\n        \"doom_my_custom_env\",\n        scenario_absolute_path,  # use your custom cfg here\n        doom_action_space_extended(),\n        reward_scaling=0.01,\n        default_timeout=custom_timeout,\n    )",
        "detail": "deps.sample-factory.sf_examples.vizdoom.train_custom_vizdoom_env",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.vizdoom.train_custom_vizdoom_env",
        "description": "deps.sample-factory.sf_examples.vizdoom.train_custom_vizdoom_env",
        "peekOfCode": "def main():\n    \"\"\"Script entry point.\"\"\"\n    register_vizdoom_components()\n    parser, cfg = parse_sf_args()\n    add_doom_env_args(parser)\n    doom_override_defaults(parser)\n    add_custom_args(parser)\n    # second parsing pass yields the final configuration\n    cfg = parse_full_cfg(parser)\n    register_custom_doom_env(custom_timeout=cfg.my_custom_doom_arg)",
        "detail": "deps.sample-factory.sf_examples.vizdoom.train_custom_vizdoom_env",
        "documentation": {}
    },
    {
        "label": "register_vizdoom_envs",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.vizdoom.train_vizdoom",
        "description": "deps.sample-factory.sf_examples.vizdoom.train_vizdoom",
        "peekOfCode": "def register_vizdoom_envs():\n    for env_spec in DOOM_ENVS:\n        make_env_func = functools.partial(make_doom_env_from_spec, env_spec)\n        register_env(env_spec.name, make_env_func)\ndef register_vizdoom_models():\n    global_model_factory().register_encoder_factory(make_vizdoom_encoder)\ndef register_vizdoom_components():\n    register_vizdoom_envs()\n    register_vizdoom_models()\ndef parse_vizdoom_cfg(argv=None, evaluation=False):",
        "detail": "deps.sample-factory.sf_examples.vizdoom.train_vizdoom",
        "documentation": {}
    },
    {
        "label": "register_vizdoom_models",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.vizdoom.train_vizdoom",
        "description": "deps.sample-factory.sf_examples.vizdoom.train_vizdoom",
        "peekOfCode": "def register_vizdoom_models():\n    global_model_factory().register_encoder_factory(make_vizdoom_encoder)\ndef register_vizdoom_components():\n    register_vizdoom_envs()\n    register_vizdoom_models()\ndef parse_vizdoom_cfg(argv=None, evaluation=False):\n    parser, _ = parse_sf_args(argv=argv, evaluation=evaluation)\n    # parameters specific to Doom envs\n    add_doom_env_args(parser)\n    # override Doom default values for algo parameters",
        "detail": "deps.sample-factory.sf_examples.vizdoom.train_vizdoom",
        "documentation": {}
    },
    {
        "label": "register_vizdoom_components",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.vizdoom.train_vizdoom",
        "description": "deps.sample-factory.sf_examples.vizdoom.train_vizdoom",
        "peekOfCode": "def register_vizdoom_components():\n    register_vizdoom_envs()\n    register_vizdoom_models()\ndef parse_vizdoom_cfg(argv=None, evaluation=False):\n    parser, _ = parse_sf_args(argv=argv, evaluation=evaluation)\n    # parameters specific to Doom envs\n    add_doom_env_args(parser)\n    # override Doom default values for algo parameters\n    doom_override_defaults(parser)\n    # second parsing pass yields the final configuration",
        "detail": "deps.sample-factory.sf_examples.vizdoom.train_vizdoom",
        "documentation": {}
    },
    {
        "label": "parse_vizdoom_cfg",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.vizdoom.train_vizdoom",
        "description": "deps.sample-factory.sf_examples.vizdoom.train_vizdoom",
        "peekOfCode": "def parse_vizdoom_cfg(argv=None, evaluation=False):\n    parser, _ = parse_sf_args(argv=argv, evaluation=evaluation)\n    # parameters specific to Doom envs\n    add_doom_env_args(parser)\n    # override Doom default values for algo parameters\n    doom_override_defaults(parser)\n    # second parsing pass yields the final configuration\n    final_cfg = parse_full_cfg(parser, argv)\n    return final_cfg\ndef main():  # pragma: no cover",
        "detail": "deps.sample-factory.sf_examples.vizdoom.train_vizdoom",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.vizdoom.train_vizdoom",
        "description": "deps.sample-factory.sf_examples.vizdoom.train_vizdoom",
        "peekOfCode": "def main():  # pragma: no cover\n    \"\"\"Script entry point.\"\"\"\n    register_vizdoom_components()\n    cfg = parse_vizdoom_cfg()\n    status = run_rl(cfg)\n    return status\nif __name__ == \"__main__\":  # pragma: no cover\n    sys.exit(main())",
        "detail": "deps.sample-factory.sf_examples.vizdoom.train_vizdoom",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.enjoy_custom_env_custom_model",
        "description": "deps.sample-factory.sf_examples.enjoy_custom_env_custom_model",
        "peekOfCode": "def main():\n    \"\"\"Script entry point.\"\"\"\n    register_custom_components()\n    cfg = parse_custom_args(evaluation=True)\n    status = enjoy(cfg)\n    return status\nif __name__ == \"__main__\":\n    sys.exit(main())",
        "detail": "deps.sample-factory.sf_examples.enjoy_custom_env_custom_model",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.enjoy_custom_multi_env",
        "description": "deps.sample-factory.sf_examples.enjoy_custom_multi_env",
        "peekOfCode": "def main():\n    \"\"\"Script entry point.\"\"\"\n    register_custom_components()\n    cfg = parse_custom_args(evaluation=True)\n    status = enjoy(cfg)\n    return status\nif __name__ == \"__main__\":\n    sys.exit(main())",
        "detail": "deps.sample-factory.sf_examples.enjoy_custom_multi_env",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.enjoy_gym_env",
        "description": "deps.sample-factory.sf_examples.enjoy_gym_env",
        "peekOfCode": "def main():  # pragma: no cover\n    \"\"\"Script entry point.\"\"\"\n    register_custom_components()\n    cfg = parse_custom_args(evaluation=True)\n    status = enjoy(cfg)\n    return status\nif __name__ == \"__main__\":  # pragma: no cover\n    sys.exit(main())",
        "detail": "deps.sample-factory.sf_examples.enjoy_gym_env",
        "documentation": {}
    },
    {
        "label": "CustomEnv",
        "kind": 6,
        "importPath": "deps.sample-factory.sf_examples.train_custom_env_custom_model",
        "description": "deps.sample-factory.sf_examples.train_custom_env_custom_model",
        "peekOfCode": "class CustomEnv(gym.Env, TrainingInfoInterface, RewardShapingInterface):\n    def __init__(self, full_env_name, cfg, render_mode: Optional[str] = None):\n        TrainingInfoInterface.__init__(self)\n        self.name = full_env_name  # optional\n        self.cfg = cfg\n        self.curr_episode_steps = 0\n        self.res = 10  # 10x10 images\n        self.channels = 1  # it's easier when the channel dimension is present, even if it's 1\n        self.observation_space = gym.spaces.Box(0, 1, (self.channels, self.res, self.res))\n        self.action_space = gym.spaces.Discrete(self.cfg.custom_env_num_actions)",
        "detail": "deps.sample-factory.sf_examples.train_custom_env_custom_model",
        "documentation": {}
    },
    {
        "label": "CustomEncoder",
        "kind": 6,
        "importPath": "deps.sample-factory.sf_examples.train_custom_env_custom_model",
        "description": "deps.sample-factory.sf_examples.train_custom_env_custom_model",
        "peekOfCode": "class CustomEncoder(Encoder):\n    \"\"\"Just an example of how to use a custom model component.\"\"\"\n    def __init__(self, cfg, obs_space):\n        super().__init__(cfg)\n        obs_shape = obs_space[\"obs\"].shape\n        conv_layers = [\n            nn.Conv2d(1, 8, 3, stride=2),\n            nonlinearity(cfg),\n            nn.Conv2d(8, 16, 2, stride=1),\n            nonlinearity(cfg),",
        "detail": "deps.sample-factory.sf_examples.train_custom_env_custom_model",
        "documentation": {}
    },
    {
        "label": "make_custom_env_func",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.train_custom_env_custom_model",
        "description": "deps.sample-factory.sf_examples.train_custom_env_custom_model",
        "peekOfCode": "def make_custom_env_func(full_env_name, cfg=None, _env_config=None, render_mode: Optional[str] = None):\n    return CustomEnv(full_env_name, cfg, render_mode=render_mode)\ndef add_extra_params(parser):\n    \"\"\"\n    Specify any additional command line arguments for this family of custom environments.\n    \"\"\"\n    p = parser\n    p.add_argument(\"--custom_env_num_actions\", default=10, type=int, help=\"Number of actions in my custom env\")\n    p.add_argument(\"--custom_env_episode_len\", default=1000, type=int, help=\"Number of steps in the episode\")\ndef override_default_params(parser):",
        "detail": "deps.sample-factory.sf_examples.train_custom_env_custom_model",
        "documentation": {}
    },
    {
        "label": "add_extra_params",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.train_custom_env_custom_model",
        "description": "deps.sample-factory.sf_examples.train_custom_env_custom_model",
        "peekOfCode": "def add_extra_params(parser):\n    \"\"\"\n    Specify any additional command line arguments for this family of custom environments.\n    \"\"\"\n    p = parser\n    p.add_argument(\"--custom_env_num_actions\", default=10, type=int, help=\"Number of actions in my custom env\")\n    p.add_argument(\"--custom_env_episode_len\", default=1000, type=int, help=\"Number of steps in the episode\")\ndef override_default_params(parser):\n    \"\"\"\n    Override default argument values for this family of environments.",
        "detail": "deps.sample-factory.sf_examples.train_custom_env_custom_model",
        "documentation": {}
    },
    {
        "label": "override_default_params",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.train_custom_env_custom_model",
        "description": "deps.sample-factory.sf_examples.train_custom_env_custom_model",
        "peekOfCode": "def override_default_params(parser):\n    \"\"\"\n    Override default argument values for this family of environments.\n    All experiments for environments from my_custom_env_ family will have these parameters unless\n    different values are passed from command line.\n    \"\"\"\n    parser.set_defaults(\n        rnn_size=128,\n    )\nclass CustomEncoder(Encoder):",
        "detail": "deps.sample-factory.sf_examples.train_custom_env_custom_model",
        "documentation": {}
    },
    {
        "label": "make_custom_encoder",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.train_custom_env_custom_model",
        "description": "deps.sample-factory.sf_examples.train_custom_env_custom_model",
        "peekOfCode": "def make_custom_encoder(cfg: Config, obs_space: ObsSpace) -> Encoder:\n    \"\"\"Factory function as required by the API.\"\"\"\n    return CustomEncoder(cfg, obs_space)\ndef register_custom_components():\n    register_env(\"my_custom_env_v1\", make_custom_env_func)\n    global_model_factory().register_encoder_factory(make_custom_encoder)\ndef parse_custom_args(argv=None, evaluation=False):\n    parser, cfg = parse_sf_args(argv, evaluation=evaluation)\n    add_extra_params(parser)\n    override_default_params(parser)",
        "detail": "deps.sample-factory.sf_examples.train_custom_env_custom_model",
        "documentation": {}
    },
    {
        "label": "register_custom_components",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.train_custom_env_custom_model",
        "description": "deps.sample-factory.sf_examples.train_custom_env_custom_model",
        "peekOfCode": "def register_custom_components():\n    register_env(\"my_custom_env_v1\", make_custom_env_func)\n    global_model_factory().register_encoder_factory(make_custom_encoder)\ndef parse_custom_args(argv=None, evaluation=False):\n    parser, cfg = parse_sf_args(argv, evaluation=evaluation)\n    add_extra_params(parser)\n    override_default_params(parser)\n    # second parsing pass yields the final configuration\n    cfg = parse_full_cfg(parser, argv)\n    return cfg",
        "detail": "deps.sample-factory.sf_examples.train_custom_env_custom_model",
        "documentation": {}
    },
    {
        "label": "parse_custom_args",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.train_custom_env_custom_model",
        "description": "deps.sample-factory.sf_examples.train_custom_env_custom_model",
        "peekOfCode": "def parse_custom_args(argv=None, evaluation=False):\n    parser, cfg = parse_sf_args(argv, evaluation=evaluation)\n    add_extra_params(parser)\n    override_default_params(parser)\n    # second parsing pass yields the final configuration\n    cfg = parse_full_cfg(parser, argv)\n    return cfg\ndef main():\n    \"\"\"Script entry point.\"\"\"\n    register_custom_components()",
        "detail": "deps.sample-factory.sf_examples.train_custom_env_custom_model",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.train_custom_env_custom_model",
        "description": "deps.sample-factory.sf_examples.train_custom_env_custom_model",
        "peekOfCode": "def main():\n    \"\"\"Script entry point.\"\"\"\n    register_custom_components()\n    cfg = parse_custom_args()\n    status = run_rl(cfg)\n    return status\nif __name__ == \"__main__\":\n    sys.exit(main())",
        "detail": "deps.sample-factory.sf_examples.train_custom_env_custom_model",
        "documentation": {}
    },
    {
        "label": "CustomMultiEnv",
        "kind": 6,
        "importPath": "deps.sample-factory.sf_examples.train_custom_multi_env",
        "description": "deps.sample-factory.sf_examples.train_custom_multi_env",
        "peekOfCode": "class CustomMultiEnv(gym.Env, TrainingInfoInterface, RewardShapingInterface):\n    \"\"\"\n    Implements a simple 2-agent game. Observation space is irrelevant. Optimal strategy is for both agents\n    to choose the same action (both 0 or 1).\n    \"\"\"\n    def __init__(self, full_env_name, cfg, render_mode: Optional[str] = None):\n        TrainingInfoInterface.__init__(self)\n        self.name = full_env_name  # optional\n        self.cfg = cfg\n        self.curr_episode_steps = 0",
        "detail": "deps.sample-factory.sf_examples.train_custom_multi_env",
        "documentation": {}
    },
    {
        "label": "make_custom_multi_env_func",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.train_custom_multi_env",
        "description": "deps.sample-factory.sf_examples.train_custom_multi_env",
        "peekOfCode": "def make_custom_multi_env_func(full_env_name, cfg=None, _env_config=None, render_mode: Optional[str] = None):\n    return CustomMultiEnv(full_env_name, cfg, render_mode=render_mode)\ndef add_extra_params_func(parser):\n    \"\"\"\n    Specify any additional command line arguments for this family of custom environments.\n    \"\"\"\n    p = parser\n    p.add_argument(\"--custom_env_episode_len\", default=10, type=int, help=\"Number of steps in the episode\")\ndef register_custom_components():\n    register_env(\"my_custom_multi_env_v1\", make_custom_multi_env_func)",
        "detail": "deps.sample-factory.sf_examples.train_custom_multi_env",
        "documentation": {}
    },
    {
        "label": "add_extra_params_func",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.train_custom_multi_env",
        "description": "deps.sample-factory.sf_examples.train_custom_multi_env",
        "peekOfCode": "def add_extra_params_func(parser):\n    \"\"\"\n    Specify any additional command line arguments for this family of custom environments.\n    \"\"\"\n    p = parser\n    p.add_argument(\"--custom_env_episode_len\", default=10, type=int, help=\"Number of steps in the episode\")\ndef register_custom_components():\n    register_env(\"my_custom_multi_env_v1\", make_custom_multi_env_func)\n    global_model_factory().register_encoder_factory(make_custom_encoder)\ndef parse_custom_args(argv=None, evaluation=False):",
        "detail": "deps.sample-factory.sf_examples.train_custom_multi_env",
        "documentation": {}
    },
    {
        "label": "register_custom_components",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.train_custom_multi_env",
        "description": "deps.sample-factory.sf_examples.train_custom_multi_env",
        "peekOfCode": "def register_custom_components():\n    register_env(\"my_custom_multi_env_v1\", make_custom_multi_env_func)\n    global_model_factory().register_encoder_factory(make_custom_encoder)\ndef parse_custom_args(argv=None, evaluation=False):\n    parser, cfg = parse_sf_args(argv=argv, evaluation=evaluation)\n    add_extra_params_func(parser)\n    override_default_params(parser)\n    # second parsing pass yields the final configuration\n    cfg = parse_full_cfg(parser, argv)\n    return cfg",
        "detail": "deps.sample-factory.sf_examples.train_custom_multi_env",
        "documentation": {}
    },
    {
        "label": "parse_custom_args",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.train_custom_multi_env",
        "description": "deps.sample-factory.sf_examples.train_custom_multi_env",
        "peekOfCode": "def parse_custom_args(argv=None, evaluation=False):\n    parser, cfg = parse_sf_args(argv=argv, evaluation=evaluation)\n    add_extra_params_func(parser)\n    override_default_params(parser)\n    # second parsing pass yields the final configuration\n    cfg = parse_full_cfg(parser, argv)\n    return cfg\ndef main():\n    \"\"\"Script entry point.\"\"\"\n    register_custom_components()",
        "detail": "deps.sample-factory.sf_examples.train_custom_multi_env",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.train_custom_multi_env",
        "description": "deps.sample-factory.sf_examples.train_custom_multi_env",
        "peekOfCode": "def main():\n    \"\"\"Script entry point.\"\"\"\n    register_custom_components()\n    cfg = parse_custom_args()\n    status = run_rl(cfg)\n    return status\nif __name__ == \"__main__\":\n    sys.exit(main())",
        "detail": "deps.sample-factory.sf_examples.train_custom_multi_env",
        "documentation": {}
    },
    {
        "label": "make_gym_env_func",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.train_gym_env",
        "description": "deps.sample-factory.sf_examples.train_gym_env",
        "peekOfCode": "def make_gym_env_func(full_env_name, cfg=None, env_config=None, render_mode: Optional[str] = None):\n    return gym.make(full_env_name, render_mode=render_mode)\ndef register_custom_components():\n    register_env(\"CartPole-v1\", make_gym_env_func)\ndef parse_custom_args(argv=None, evaluation=False):\n    parser, cfg = parse_sf_args(argv=argv, evaluation=evaluation)\n    cfg = parse_full_cfg(parser, argv)\n    return cfg\ndef main():\n    \"\"\"Script entry point.\"\"\"",
        "detail": "deps.sample-factory.sf_examples.train_gym_env",
        "documentation": {}
    },
    {
        "label": "register_custom_components",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.train_gym_env",
        "description": "deps.sample-factory.sf_examples.train_gym_env",
        "peekOfCode": "def register_custom_components():\n    register_env(\"CartPole-v1\", make_gym_env_func)\ndef parse_custom_args(argv=None, evaluation=False):\n    parser, cfg = parse_sf_args(argv=argv, evaluation=evaluation)\n    cfg = parse_full_cfg(parser, argv)\n    return cfg\ndef main():\n    \"\"\"Script entry point.\"\"\"\n    register_custom_components()\n    cfg = parse_custom_args()",
        "detail": "deps.sample-factory.sf_examples.train_gym_env",
        "documentation": {}
    },
    {
        "label": "parse_custom_args",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.train_gym_env",
        "description": "deps.sample-factory.sf_examples.train_gym_env",
        "peekOfCode": "def parse_custom_args(argv=None, evaluation=False):\n    parser, cfg = parse_sf_args(argv=argv, evaluation=evaluation)\n    cfg = parse_full_cfg(parser, argv)\n    return cfg\ndef main():\n    \"\"\"Script entry point.\"\"\"\n    register_custom_components()\n    cfg = parse_custom_args()\n    status = run_rl(cfg)\n    return status",
        "detail": "deps.sample-factory.sf_examples.train_gym_env",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "deps.sample-factory.sf_examples.train_gym_env",
        "description": "deps.sample-factory.sf_examples.train_gym_env",
        "peekOfCode": "def main():\n    \"\"\"Script entry point.\"\"\"\n    register_custom_components()\n    cfg = parse_custom_args()\n    status = run_rl(cfg)\n    return status\nif __name__ == \"__main__\":\n    sys.exit(main())",
        "detail": "deps.sample-factory.sf_examples.train_gym_env",
        "documentation": {}
    },
    {
        "label": "TestActionDistributions",
        "kind": 6,
        "importPath": "deps.sample-factory.tests.algo.test_action_distributions",
        "description": "deps.sample-factory.tests.algo.test_action_distributions",
        "peekOfCode": "class TestActionDistributions:\n    @pytest.mark.parametrize(\"gym_space\", [gym.spaces.Discrete(3)])\n    @pytest.mark.parametrize(\"batch_size\", [128])\n    def test_simple_distribution(self, gym_space, batch_size):\n        simple_action_space = gym_space\n        simple_num_logits = calc_num_action_parameters(simple_action_space)\n        assert simple_num_logits == simple_action_space.n\n        simple_logits = torch.rand(batch_size, simple_num_logits)\n        simple_action_distribution = get_action_distribution(simple_action_space, simple_logits)\n        simple_actions = simple_action_distribution.sample()",
        "detail": "deps.sample-factory.tests.algo.test_action_distributions",
        "documentation": {}
    },
    {
        "label": "test_tuple_action_distribution",
        "kind": 2,
        "importPath": "deps.sample-factory.tests.algo.test_action_distributions",
        "description": "deps.sample-factory.tests.algo.test_action_distributions",
        "peekOfCode": "def test_tuple_action_distribution(spaces, sizes):\n    # I like to use prime numbers for tests as it can flag problems hidden by automatic broadcasting etc\n    BATCH_SIZE = 31\n    assert len(spaces) > 0\n    assert len(spaces) == len(sizes)\n    num_actions = 0\n    num_logits = 0\n    _action_spaces = []\n    for space, size in zip(spaces, sizes):\n        if space is gym.spaces.Discrete:",
        "detail": "deps.sample-factory.tests.algo.test_action_distributions",
        "documentation": {}
    },
    {
        "label": "TestValidMasks",
        "kind": 6,
        "importPath": "deps.sample-factory.tests.algo.test_learner",
        "description": "deps.sample-factory.tests.algo.test_learner",
        "peekOfCode": "class TestValidMasks:\n    @pytest.fixture(scope=\"class\", autouse=True)\n    def register_mujoco_fixture(self):\n        register_mujoco_components()\n    @pytest.mark.parametrize(\"use_rnn\", [False, True])\n    def test_losses_match(self, use_rnn: bool):\n        cfg = parse_mujoco_cfg(argv=[\"--env=mujoco_humanoid\", \"--experiment=test_learner\"])\n        # this matches what we used when data was collected\n        cfg.num_workers = 2\n        cfg.rollout = 8",
        "detail": "deps.sample-factory.tests.algo.test_learner",
        "documentation": {}
    },
    {
        "label": "TestModel",
        "kind": 6,
        "importPath": "deps.sample-factory.tests.algo.test_model",
        "description": "deps.sample-factory.tests.algo.test_model",
        "peekOfCode": "class TestModel:\n    @pytest.fixture(scope=\"class\", autouse=True)\n    def register_atari_fixture(self):\n        from sf_examples.atari.train_atari import register_atari_components\n        register_atari_components()\n    @staticmethod\n    def forward_pass(device_type):\n        env_name = \"atari_breakout\"\n        cfg = default_cfg(algo=\"APPO\", env=env_name)\n        cfg.actor_critic_share_weights = True",
        "detail": "deps.sample-factory.tests.algo.test_model",
        "documentation": {}
    },
    {
        "label": "TestModelBuilder",
        "kind": 6,
        "importPath": "deps.sample-factory.tests.algo.test_model_builder",
        "description": "deps.sample-factory.tests.algo.test_model_builder",
        "peekOfCode": "class TestModelBuilder:\n    @pytest.mark.parametrize(\n        \"obs_space\",\n        [\n            Dict(\n                {\n                    \"obs_1d\": Box(-1, 1, shape=(21,)),\n                }\n            ),\n            Dict(",
        "detail": "deps.sample-factory.tests.algo.test_model_builder",
        "documentation": {}
    },
    {
        "label": "TestPBT",
        "kind": 6,
        "importPath": "deps.sample-factory.tests.algo.test_pbt",
        "description": "deps.sample-factory.tests.algo.test_pbt",
        "peekOfCode": "class TestPBT:\n    def test_example_pbt(self):\n        cfg, eval_cfg = default_multi_cfg()\n        cfg.async_rl = True\n        cfg.serial_mode = False\n        cfg.train_for_env_steps = 80000\n        cfg.num_workers = 8\n        cfg.batch_size = 512\n        cfg.custom_env_num_actions = eval_cfg.custom_env_num_actions = 100\n        cfg.num_policies = 3",
        "detail": "deps.sample-factory.tests.algo.test_pbt",
        "documentation": {}
    },
    {
        "label": "TestRMS",
        "kind": 6,
        "importPath": "deps.sample-factory.tests.algo.test_rms",
        "description": "deps.sample-factory.tests.algo.test_rms",
        "peekOfCode": "class TestRMS:\n    @pytest.mark.parametrize(\"batch_size\", [2, 100])\n    @pytest.mark.parametrize(\"shape\", [(1,), (3, 7)])\n    @pytest.mark.parametrize(\"norm_only\", [False, True])\n    def test_rms_sanity(\n        self,\n        batch_size: int,\n        shape: Tuple,\n        norm_only: bool,\n        data: Optional[Tensor] = None,",
        "detail": "deps.sample-factory.tests.algo.test_rms",
        "documentation": {}
    },
    {
        "label": "TestPackedSequences",
        "kind": 6,
        "importPath": "deps.sample-factory.tests.algo.test_rnn",
        "description": "deps.sample-factory.tests.algo.test_rnn",
        "peekOfCode": "class TestPackedSequences:\n    @staticmethod\n    def check_packed_version_matching_loopy_version(T, N, D, random_dones, norm_tolerance=4e-6):\n        rnn = nn.GRU(D, D, 1)\n        for _ in range(100):\n            if random_dones:\n                dones = torch.randint(0, 2, (N * T,))\n            else:\n                dones = torch.zeros((N * T,))\n                for i in range(1, N * T, 7):",
        "detail": "deps.sample-factory.tests.algo.test_rnn",
        "documentation": {}
    },
    {
        "label": "TestSpaces",
        "kind": 6,
        "importPath": "deps.sample-factory.tests.algo.test_spaces",
        "description": "deps.sample-factory.tests.algo.test_spaces",
        "peekOfCode": "class TestSpaces:\n    @pytest.mark.parametrize(\"n\", [11])\n    @pytest.mark.parametrize(\"min_action\", [-10.0])\n    @pytest.mark.parametrize(\"max_action\", [10.0])\n    def test_discretized(self, n, min_action, max_action):\n        space = Discretized(n, min_action, max_action)\n        random_action = space.sample()\n        assert random_action >= 0\n        assert random_action < n\n        expected_value = min_action",
        "detail": "deps.sample-factory.tests.algo.test_spaces",
        "documentation": {}
    },
    {
        "label": "TestParams",
        "kind": 6,
        "importPath": "deps.sample-factory.tests.algo.test_tensordict",
        "description": "deps.sample-factory.tests.algo.test_tensordict",
        "peekOfCode": "class TestParams:\n    # setting up tensor dict for a typical RL task\n    @pytest.mark.parametrize(\"n_agents\", [16])\n    @pytest.mark.parametrize(\"n_obs\", [5])\n    @pytest.mark.parametrize(\"rollout\", [8])\n    def test_tensordict_simple(self, n_agents, n_obs, rollout):\n        # dictionary observations\n        obs = TensorDict()\n        obs[\"pos\"] = torch.rand((n_agents, rollout, n_obs))\n        obs[\"vel\"] = torch.rand((n_agents, rollout, n_obs))",
        "detail": "deps.sample-factory.tests.algo.test_tensordict",
        "documentation": {}
    },
    {
        "label": "TestAtariEnv",
        "kind": 6,
        "importPath": "deps.sample-factory.tests.envs.atari.test_atari",
        "description": "deps.sample-factory.tests.envs.atari.test_atari",
        "peekOfCode": "class TestAtariEnv:\n    @pytest.fixture(scope=\"class\", autouse=True)\n    def register_atari_fixture(self):\n        from sf_examples.atari.train_atari import register_atari_components\n        register_atari_components()\n    # noinspection PyUnusedLocal\n    @staticmethod\n    def make_env(env_config):\n        from sf_examples.atari.atari_utils import make_atari_env\n        return make_atari_env(",
        "detail": "deps.sample-factory.tests.envs.atari.test_atari",
        "documentation": {}
    },
    {
        "label": "TestEnvpoolAtariEnv",
        "kind": 6,
        "importPath": "deps.sample-factory.tests.envs.atari.test_envpool_atari",
        "description": "deps.sample-factory.tests.envs.atari.test_envpool_atari",
        "peekOfCode": "class TestEnvpoolAtariEnv:\n    @pytest.fixture(scope=\"class\", autouse=True)\n    def register_atari_fixture(self):\n        from sf_examples.envpool.atari.train_envpool_atari import register_atari_components\n        register_atari_components()\n    @staticmethod\n    def _run_test_env(\n        env: str = \"atari_breakout\",\n        num_workers: int = 1,\n        train_steps: int = 2048,",
        "detail": "deps.sample-factory.tests.envs.atari.test_envpool_atari",
        "documentation": {}
    },
    {
        "label": "TestDmlab",
        "kind": 6,
        "importPath": "deps.sample-factory.tests.envs.dmlab.test_dmlab",
        "description": "deps.sample-factory.tests.envs.dmlab.test_dmlab",
        "peekOfCode": "class TestDmlab:\n    @staticmethod\n    def make_env(_env_config):\n        from sf_examples.dmlab.dmlab_env import make_dmlab_env\n        from sf_examples.dmlab.train_dmlab import parse_dmlab_args\n        cfg = parse_dmlab_args(argv=[\"--algo=APPO\", \"--env=dmlab_nonmatch\", \"--experiment=test_dmlab\"])\n        return make_dmlab_env(\"dmlab_nonmatch\", cfg=cfg, env_config=None)\n    @pytest.mark.skipif(not dmlab_available(), reason=\"Dmlab package not installed\")\n    def test_dmlab_performance(self):\n        from sf_examples.dmlab.train_dmlab import register_dmlab_components",
        "detail": "deps.sample-factory.tests.envs.dmlab.test_dmlab",
        "documentation": {}
    },
    {
        "label": "TestEnvpoolMujoco",
        "kind": 6,
        "importPath": "deps.sample-factory.tests.envs.mujoco.test_envpool_mujoco",
        "description": "deps.sample-factory.tests.envs.mujoco.test_envpool_mujoco",
        "peekOfCode": "class TestEnvpoolMujoco:\n    @pytest.fixture(scope=\"class\", autouse=True)\n    def register_mujoco_fixture(self):\n        from sf_examples.envpool.mujoco.train_envpool_mujoco import register_mujoco_components\n        register_mujoco_components()\n    @staticmethod\n    def _run_test_env(\n        env: str = \"mujoco_ant\",\n        num_workers: int = 8,\n        train_steps: int = 4096,",
        "detail": "deps.sample-factory.tests.envs.mujoco.test_envpool_mujoco",
        "documentation": {}
    },
    {
        "label": "TestMujoco",
        "kind": 6,
        "importPath": "deps.sample-factory.tests.envs.mujoco.test_mujoco",
        "description": "deps.sample-factory.tests.envs.mujoco.test_mujoco",
        "peekOfCode": "class TestMujoco:\n    @pytest.fixture(scope=\"class\", autouse=True)\n    def register_mujoco_fixture(self):\n        register_mujoco_components()\n    @staticmethod\n    def _run_test_env(\n        env: str = \"mujoco_ant\",\n        num_workers: int = 8,\n        train_steps: int = 128,\n        batched_sampling: bool = False,",
        "detail": "deps.sample-factory.tests.envs.mujoco.test_mujoco",
        "documentation": {}
    },
    {
        "label": "IdentityEnvMixedActions",
        "kind": 6,
        "importPath": "deps.sample-factory.tests.envs.tuple_action_envs.test_mixed_dist_env_batched",
        "description": "deps.sample-factory.tests.envs.tuple_action_envs.test_mixed_dist_env_batched",
        "peekOfCode": "class IdentityEnvMixedActions(gym.Env):\n    def __init__(self, size=4):\n        self.observation_space = gym.spaces.Box(-1, 1, shape=(size,))\n        self._observation_space = gym.spaces.Discrete(size)\n        self.action_space = gym.spaces.Tuple([gym.spaces.Discrete(size), gym.spaces.Box(-1, 1, shape=(size,))])\n        self.ep_length = 10\n        self.num_resets = -1  # Becomes 0 after __init__ exits.\n        self.eps = 0.05\n        self.current_step = 0\n        self.reset()",
        "detail": "deps.sample-factory.tests.envs.tuple_action_envs.test_mixed_dist_env_batched",
        "documentation": {}
    },
    {
        "label": "BatchedIdentityEnvMixedActions",
        "kind": 6,
        "importPath": "deps.sample-factory.tests.envs.tuple_action_envs.test_mixed_dist_env_batched",
        "description": "deps.sample-factory.tests.envs.tuple_action_envs.test_mixed_dist_env_batched",
        "peekOfCode": "class BatchedIdentityEnvMixedActions(gym.Env):\n    def __init__(self, size=4) -> None:\n        n_envs = 4\n        self.envs = [IdentityEnvMixedActions(size) for _ in range(n_envs)]\n        self.num_agents = n_envs\n        super().__init__()\n    @property\n    def observation_space(self):\n        return self.envs[0].observation_space\n    @property",
        "detail": "deps.sample-factory.tests.envs.tuple_action_envs.test_mixed_dist_env_batched",
        "documentation": {}
    },
    {
        "label": "override_defaults",
        "kind": 2,
        "importPath": "deps.sample-factory.tests.envs.tuple_action_envs.test_mixed_dist_env_batched",
        "description": "deps.sample-factory.tests.envs.tuple_action_envs.test_mixed_dist_env_batched",
        "peekOfCode": "def override_defaults(parser):\n    parser.set_defaults(\n        batched_sampling=True,\n        num_workers=1,\n        num_envs_per_worker=1,\n        worker_num_splits=1,\n        train_for_env_steps=10000,\n        env_frameskip=1,\n        nonlinearity=\"tanh\",\n        batch_size=1024,",
        "detail": "deps.sample-factory.tests.envs.tuple_action_envs.test_mixed_dist_env_batched",
        "documentation": {}
    },
    {
        "label": "make_env",
        "kind": 2,
        "importPath": "deps.sample-factory.tests.envs.tuple_action_envs.test_mixed_dist_env_batched",
        "description": "deps.sample-factory.tests.envs.tuple_action_envs.test_mixed_dist_env_batched",
        "peekOfCode": "def make_env(_env_name, _cfg, _cfg_env, render_mode: Optional[str] = None):\n    return BatchedIdentityEnvMixedActions(4)\ndef register_test_components():\n    register_env(\n        \"batched_mix_dist_env\",\n        make_env,\n    )\ndef test_batched_mixed_action_dists():\n    \"\"\"Script entry point.\"\"\"\n    register_test_components()",
        "detail": "deps.sample-factory.tests.envs.tuple_action_envs.test_mixed_dist_env_batched",
        "documentation": {}
    },
    {
        "label": "register_test_components",
        "kind": 2,
        "importPath": "deps.sample-factory.tests.envs.tuple_action_envs.test_mixed_dist_env_batched",
        "description": "deps.sample-factory.tests.envs.tuple_action_envs.test_mixed_dist_env_batched",
        "peekOfCode": "def register_test_components():\n    register_env(\n        \"batched_mix_dist_env\",\n        make_env,\n    )\ndef test_batched_mixed_action_dists():\n    \"\"\"Script entry point.\"\"\"\n    register_test_components()\n    argv = [\n        \"--algo=APPO\",",
        "detail": "deps.sample-factory.tests.envs.tuple_action_envs.test_mixed_dist_env_batched",
        "documentation": {}
    },
    {
        "label": "test_batched_mixed_action_dists",
        "kind": 2,
        "importPath": "deps.sample-factory.tests.envs.tuple_action_envs.test_mixed_dist_env_batched",
        "description": "deps.sample-factory.tests.envs.tuple_action_envs.test_mixed_dist_env_batched",
        "peekOfCode": "def test_batched_mixed_action_dists():\n    \"\"\"Script entry point.\"\"\"\n    register_test_components()\n    argv = [\n        \"--algo=APPO\",\n        \"--env=batched_mix_dist_env\",\n        \"--experiment=test_batched_mixed_action_dists\",\n        \"--device=cpu\",\n        \"--restart_behavior=overwrite\",\n    ]",
        "detail": "deps.sample-factory.tests.envs.tuple_action_envs.test_mixed_dist_env_batched",
        "documentation": {}
    },
    {
        "label": "IdentityEnvMixedActions",
        "kind": 6,
        "importPath": "deps.sample-factory.tests.envs.tuple_action_envs.test_mixed_dist_env_non_batched",
        "description": "deps.sample-factory.tests.envs.tuple_action_envs.test_mixed_dist_env_non_batched",
        "peekOfCode": "class IdentityEnvMixedActions(gym.Env):\n    def __init__(self, size=4):\n        self.observation_space = gym.spaces.Box(-1, 1, shape=(size,))\n        self._observation_space = gym.spaces.Discrete(size)\n        self.action_space = gym.spaces.Tuple([gym.spaces.Discrete(size), gym.spaces.Box(-1, 1, shape=(size,))])\n        self.ep_length = 10\n        self.num_resets = -1  # Becomes 0 after __init__ exits.\n        self.eps = 0.05\n        self.current_step = 0\n        self.reset()",
        "detail": "deps.sample-factory.tests.envs.tuple_action_envs.test_mixed_dist_env_non_batched",
        "documentation": {}
    },
    {
        "label": "mixed_actions_get_reward",
        "kind": 2,
        "importPath": "deps.sample-factory.tests.envs.tuple_action_envs.test_mixed_dist_env_non_batched",
        "description": "deps.sample-factory.tests.envs.tuple_action_envs.test_mixed_dist_env_non_batched",
        "peekOfCode": "def mixed_actions_get_reward(action: MixedActions, state, eps) -> float:\n    discrete_reward = 1.0 if np.argmax(state) == action[0] else 0.0\n    continuous_reward = 1.0 if (np.argmax(state) - eps) <= sum(action[1]) <= (np.argmax(state) + eps) else 0.0\n    return discrete_reward + continuous_reward\nclass IdentityEnvMixedActions(gym.Env):\n    def __init__(self, size=4):\n        self.observation_space = gym.spaces.Box(-1, 1, shape=(size,))\n        self._observation_space = gym.spaces.Discrete(size)\n        self.action_space = gym.spaces.Tuple([gym.spaces.Discrete(size), gym.spaces.Box(-1, 1, shape=(size,))])\n        self.ep_length = 10",
        "detail": "deps.sample-factory.tests.envs.tuple_action_envs.test_mixed_dist_env_non_batched",
        "documentation": {}
    },
    {
        "label": "override_defaults",
        "kind": 2,
        "importPath": "deps.sample-factory.tests.envs.tuple_action_envs.test_mixed_dist_env_non_batched",
        "description": "deps.sample-factory.tests.envs.tuple_action_envs.test_mixed_dist_env_non_batched",
        "peekOfCode": "def override_defaults(parser):\n    parser.set_defaults(\n        batched_sampling=False,\n        num_workers=4,\n        num_envs_per_worker=4,\n        worker_num_splits=2,\n        train_for_env_steps=10000,\n        env_frameskip=1,\n        nonlinearity=\"tanh\",\n        batch_size=1024,",
        "detail": "deps.sample-factory.tests.envs.tuple_action_envs.test_mixed_dist_env_non_batched",
        "documentation": {}
    },
    {
        "label": "make_env",
        "kind": 2,
        "importPath": "deps.sample-factory.tests.envs.tuple_action_envs.test_mixed_dist_env_non_batched",
        "description": "deps.sample-factory.tests.envs.tuple_action_envs.test_mixed_dist_env_non_batched",
        "peekOfCode": "def make_env(_env_name, _cfg, _cfg_env, render_mode: Optional[str] = None):\n    return IdentityEnvMixedActions(4)\ndef register_test_components():\n    register_env(\n        \"non_batched_mix_dist_env\",\n        make_env,\n    )\ndef test_non_batched_mixed_action_dists():\n    \"\"\"Script entry point.\"\"\"\n    register_test_components()",
        "detail": "deps.sample-factory.tests.envs.tuple_action_envs.test_mixed_dist_env_non_batched",
        "documentation": {}
    },
    {
        "label": "register_test_components",
        "kind": 2,
        "importPath": "deps.sample-factory.tests.envs.tuple_action_envs.test_mixed_dist_env_non_batched",
        "description": "deps.sample-factory.tests.envs.tuple_action_envs.test_mixed_dist_env_non_batched",
        "peekOfCode": "def register_test_components():\n    register_env(\n        \"non_batched_mix_dist_env\",\n        make_env,\n    )\ndef test_non_batched_mixed_action_dists():\n    \"\"\"Script entry point.\"\"\"\n    register_test_components()\n    argv = [\n        \"--algo=APPO\",",
        "detail": "deps.sample-factory.tests.envs.tuple_action_envs.test_mixed_dist_env_non_batched",
        "documentation": {}
    },
    {
        "label": "test_non_batched_mixed_action_dists",
        "kind": 2,
        "importPath": "deps.sample-factory.tests.envs.tuple_action_envs.test_mixed_dist_env_non_batched",
        "description": "deps.sample-factory.tests.envs.tuple_action_envs.test_mixed_dist_env_non_batched",
        "peekOfCode": "def test_non_batched_mixed_action_dists():\n    \"\"\"Script entry point.\"\"\"\n    register_test_components()\n    argv = [\n        \"--algo=APPO\",\n        \"--env=non_batched_mix_dist_env\",\n        \"--experiment=test_non_batched_mixed_action_dists\",\n        \"--device=cpu\",\n        \"--restart_behavior=overwrite\",\n    ]",
        "detail": "deps.sample-factory.tests.envs.tuple_action_envs.test_mixed_dist_env_non_batched",
        "documentation": {}
    },
    {
        "label": "MixedActions",
        "kind": 5,
        "importPath": "deps.sample-factory.tests.envs.tuple_action_envs.test_mixed_dist_env_non_batched",
        "description": "deps.sample-factory.tests.envs.tuple_action_envs.test_mixed_dist_env_non_batched",
        "peekOfCode": "MixedActions = Union[List, Tuple[int, np.ndarray]]\ndef mixed_actions_get_reward(action: MixedActions, state, eps) -> float:\n    discrete_reward = 1.0 if np.argmax(state) == action[0] else 0.0\n    continuous_reward = 1.0 if (np.argmax(state) - eps) <= sum(action[1]) <= (np.argmax(state) + eps) else 0.0\n    return discrete_reward + continuous_reward\nclass IdentityEnvMixedActions(gym.Env):\n    def __init__(self, size=4):\n        self.observation_space = gym.spaces.Box(-1, 1, shape=(size,))\n        self._observation_space = gym.spaces.Discrete(size)\n        self.action_space = gym.spaces.Tuple([gym.spaces.Discrete(size), gym.spaces.Box(-1, 1, shape=(size,))])",
        "detail": "deps.sample-factory.tests.envs.tuple_action_envs.test_mixed_dist_env_non_batched",
        "documentation": {}
    },
    {
        "label": "IdentityEnvTwoDiscreteActions",
        "kind": 6,
        "importPath": "deps.sample-factory.tests.envs.tuple_action_envs.test_two_discrete_action_dist_env_batched",
        "description": "deps.sample-factory.tests.envs.tuple_action_envs.test_two_discrete_action_dist_env_batched",
        "peekOfCode": "class IdentityEnvTwoDiscreteActions(gym.Env):\n    def __init__(self, size=4):\n        self.observation_space = gym.spaces.Box(-1, 1, shape=(size,))\n        self._observation_space = gym.spaces.Discrete(size)\n        self.action_space = gym.spaces.Tuple([gym.spaces.Discrete(size), gym.spaces.Discrete(size * 3)])\n        self.ep_length = 10\n        self.num_resets = -1  # Becomes 0 after __init__ exits.\n        self.eps = 0.05\n        self.current_step = 0\n        self.reset()",
        "detail": "deps.sample-factory.tests.envs.tuple_action_envs.test_two_discrete_action_dist_env_batched",
        "documentation": {}
    },
    {
        "label": "BatchedIdentityEnvTwoDiscreteActions",
        "kind": 6,
        "importPath": "deps.sample-factory.tests.envs.tuple_action_envs.test_two_discrete_action_dist_env_batched",
        "description": "deps.sample-factory.tests.envs.tuple_action_envs.test_two_discrete_action_dist_env_batched",
        "peekOfCode": "class BatchedIdentityEnvTwoDiscreteActions(gym.Env):\n    def __init__(self, size=4) -> None:\n        n_envs = 4\n        self.envs = [IdentityEnvTwoDiscreteActions(size) for _ in range(n_envs)]\n        self.num_agents = n_envs\n        super().__init__()\n    @property\n    def observation_space(self):\n        return self.envs[0].observation_space\n    @property",
        "detail": "deps.sample-factory.tests.envs.tuple_action_envs.test_two_discrete_action_dist_env_batched",
        "documentation": {}
    },
    {
        "label": "override_defaults",
        "kind": 2,
        "importPath": "deps.sample-factory.tests.envs.tuple_action_envs.test_two_discrete_action_dist_env_batched",
        "description": "deps.sample-factory.tests.envs.tuple_action_envs.test_two_discrete_action_dist_env_batched",
        "peekOfCode": "def override_defaults(parser):\n    parser.set_defaults(\n        batched_sampling=True,\n        num_workers=1,\n        num_envs_per_worker=1,\n        worker_num_splits=1,\n        train_for_env_steps=10000,\n        nonlinearity=\"tanh\",\n        batch_size=1024,\n        decorrelate_envs_on_one_worker=False,",
        "detail": "deps.sample-factory.tests.envs.tuple_action_envs.test_two_discrete_action_dist_env_batched",
        "documentation": {}
    },
    {
        "label": "make_env",
        "kind": 2,
        "importPath": "deps.sample-factory.tests.envs.tuple_action_envs.test_two_discrete_action_dist_env_batched",
        "description": "deps.sample-factory.tests.envs.tuple_action_envs.test_two_discrete_action_dist_env_batched",
        "peekOfCode": "def make_env(_env_name, _cfg, _cfg_env, render_mode: Optional[str] = None):\n    return BatchedIdentityEnvTwoDiscreteActions(4)\ndef register_test_components():\n    register_env(\n        \"batched_two_discrete_dist_env\",\n        make_env,\n    )\ndef test_batched_two_discrete_action_dists():\n    \"\"\"Script entry point.\"\"\"\n    register_test_components()",
        "detail": "deps.sample-factory.tests.envs.tuple_action_envs.test_two_discrete_action_dist_env_batched",
        "documentation": {}
    },
    {
        "label": "register_test_components",
        "kind": 2,
        "importPath": "deps.sample-factory.tests.envs.tuple_action_envs.test_two_discrete_action_dist_env_batched",
        "description": "deps.sample-factory.tests.envs.tuple_action_envs.test_two_discrete_action_dist_env_batched",
        "peekOfCode": "def register_test_components():\n    register_env(\n        \"batched_two_discrete_dist_env\",\n        make_env,\n    )\ndef test_batched_two_discrete_action_dists():\n    \"\"\"Script entry point.\"\"\"\n    register_test_components()\n    argv = [\n        \"--algo=APPO\",",
        "detail": "deps.sample-factory.tests.envs.tuple_action_envs.test_two_discrete_action_dist_env_batched",
        "documentation": {}
    },
    {
        "label": "test_batched_two_discrete_action_dists",
        "kind": 2,
        "importPath": "deps.sample-factory.tests.envs.tuple_action_envs.test_two_discrete_action_dist_env_batched",
        "description": "deps.sample-factory.tests.envs.tuple_action_envs.test_two_discrete_action_dist_env_batched",
        "peekOfCode": "def test_batched_two_discrete_action_dists():\n    \"\"\"Script entry point.\"\"\"\n    register_test_components()\n    argv = [\n        \"--algo=APPO\",\n        \"--env=batched_two_discrete_dist_env\",\n        \"--experiment=test_batched_two_discrete_dists\",\n        \"--restart_behavior=overwrite\",\n        \"--device=cpu\",\n    ]",
        "detail": "deps.sample-factory.tests.envs.tuple_action_envs.test_two_discrete_action_dist_env_batched",
        "documentation": {}
    },
    {
        "label": "IdentityEnvTwoDiscreteActions",
        "kind": 6,
        "importPath": "deps.sample-factory.tests.envs.tuple_action_envs.test_two_discrete_action_dist_env_non_batched",
        "description": "deps.sample-factory.tests.envs.tuple_action_envs.test_two_discrete_action_dist_env_non_batched",
        "peekOfCode": "class IdentityEnvTwoDiscreteActions(gym.Env):\n    def __init__(self, size=4):\n        self.observation_space = gym.spaces.Box(-1, 1, shape=(size,))\n        self._observation_space = gym.spaces.Discrete(size)\n        self.action_space = gym.spaces.Tuple([gym.spaces.Discrete(size), gym.spaces.Discrete(size * 3)])\n        self.ep_length = 10\n        self.num_resets = -1  # Becomes 0 after __init__ exits.\n        self.eps = 0.05\n        self.current_step = 0\n        self.reset()",
        "detail": "deps.sample-factory.tests.envs.tuple_action_envs.test_two_discrete_action_dist_env_non_batched",
        "documentation": {}
    },
    {
        "label": "get_reward",
        "kind": 2,
        "importPath": "deps.sample-factory.tests.envs.tuple_action_envs.test_two_discrete_action_dist_env_non_batched",
        "description": "deps.sample-factory.tests.envs.tuple_action_envs.test_two_discrete_action_dist_env_non_batched",
        "peekOfCode": "def get_reward(action: DiscreteActions, state) -> float:\n    discrete_reward1 = 1.0 if np.argmax(state) == action[0] else 0.0\n    discrete_reward2 = 1.0 if np.argmax(state) * 3 == (len(state) - action[1] - 1) else 0.0\n    return discrete_reward1 + discrete_reward2\nclass IdentityEnvTwoDiscreteActions(gym.Env):\n    def __init__(self, size=4):\n        self.observation_space = gym.spaces.Box(-1, 1, shape=(size,))\n        self._observation_space = gym.spaces.Discrete(size)\n        self.action_space = gym.spaces.Tuple([gym.spaces.Discrete(size), gym.spaces.Discrete(size * 3)])\n        self.ep_length = 10",
        "detail": "deps.sample-factory.tests.envs.tuple_action_envs.test_two_discrete_action_dist_env_non_batched",
        "documentation": {}
    },
    {
        "label": "override_defaults",
        "kind": 2,
        "importPath": "deps.sample-factory.tests.envs.tuple_action_envs.test_two_discrete_action_dist_env_non_batched",
        "description": "deps.sample-factory.tests.envs.tuple_action_envs.test_two_discrete_action_dist_env_non_batched",
        "peekOfCode": "def override_defaults(parser):\n    parser.set_defaults(\n        batched_sampling=False,\n        num_workers=4,\n        num_envs_per_worker=4,\n        worker_num_splits=2,\n        train_for_env_steps=10000,\n        env_frameskip=1,\n        nonlinearity=\"tanh\",\n        batch_size=1024,",
        "detail": "deps.sample-factory.tests.envs.tuple_action_envs.test_two_discrete_action_dist_env_non_batched",
        "documentation": {}
    },
    {
        "label": "make_env",
        "kind": 2,
        "importPath": "deps.sample-factory.tests.envs.tuple_action_envs.test_two_discrete_action_dist_env_non_batched",
        "description": "deps.sample-factory.tests.envs.tuple_action_envs.test_two_discrete_action_dist_env_non_batched",
        "peekOfCode": "def make_env(_env_name, _cfg, _cfg_env, render_mode: Optional[str] = None):\n    return IdentityEnvTwoDiscreteActions(4)\ndef register_test_components():\n    register_env(\n        \"non_batched_two_discrete_dist_env\",\n        make_env,\n    )\ndef test_non_batched_two_discrete_action_dists():\n    \"\"\"Script entry point.\"\"\"\n    register_test_components()",
        "detail": "deps.sample-factory.tests.envs.tuple_action_envs.test_two_discrete_action_dist_env_non_batched",
        "documentation": {}
    },
    {
        "label": "register_test_components",
        "kind": 2,
        "importPath": "deps.sample-factory.tests.envs.tuple_action_envs.test_two_discrete_action_dist_env_non_batched",
        "description": "deps.sample-factory.tests.envs.tuple_action_envs.test_two_discrete_action_dist_env_non_batched",
        "peekOfCode": "def register_test_components():\n    register_env(\n        \"non_batched_two_discrete_dist_env\",\n        make_env,\n    )\ndef test_non_batched_two_discrete_action_dists():\n    \"\"\"Script entry point.\"\"\"\n    register_test_components()\n    argv = [\n        \"--algo=APPO\",",
        "detail": "deps.sample-factory.tests.envs.tuple_action_envs.test_two_discrete_action_dist_env_non_batched",
        "documentation": {}
    },
    {
        "label": "test_non_batched_two_discrete_action_dists",
        "kind": 2,
        "importPath": "deps.sample-factory.tests.envs.tuple_action_envs.test_two_discrete_action_dist_env_non_batched",
        "description": "deps.sample-factory.tests.envs.tuple_action_envs.test_two_discrete_action_dist_env_non_batched",
        "peekOfCode": "def test_non_batched_two_discrete_action_dists():\n    \"\"\"Script entry point.\"\"\"\n    register_test_components()\n    argv = [\n        \"--algo=APPO\",\n        \"--env=non_batched_two_discrete_dist_env\",\n        \"--experiment=test_non_batched_two_discrete_dists\",\n        \"--restart_behavior=overwrite\",\n        \"--device=cpu\",\n    ]",
        "detail": "deps.sample-factory.tests.envs.tuple_action_envs.test_two_discrete_action_dist_env_non_batched",
        "documentation": {}
    },
    {
        "label": "DiscreteActions",
        "kind": 5,
        "importPath": "deps.sample-factory.tests.envs.tuple_action_envs.test_two_discrete_action_dist_env_non_batched",
        "description": "deps.sample-factory.tests.envs.tuple_action_envs.test_two_discrete_action_dist_env_non_batched",
        "peekOfCode": "DiscreteActions = Union[List[int], Tuple[int, ...], np.ndarray]\ndef get_reward(action: DiscreteActions, state) -> float:\n    discrete_reward1 = 1.0 if np.argmax(state) == action[0] else 0.0\n    discrete_reward2 = 1.0 if np.argmax(state) * 3 == (len(state) - action[1] - 1) else 0.0\n    return discrete_reward1 + discrete_reward2\nclass IdentityEnvTwoDiscreteActions(gym.Env):\n    def __init__(self, size=4):\n        self.observation_space = gym.spaces.Box(-1, 1, shape=(size,))\n        self._observation_space = gym.spaces.Discrete(size)\n        self.action_space = gym.spaces.Tuple([gym.spaces.Discrete(size), gym.spaces.Discrete(size * 3)])",
        "detail": "deps.sample-factory.tests.envs.tuple_action_envs.test_two_discrete_action_dist_env_non_batched",
        "documentation": {}
    },
    {
        "label": "TestDoom",
        "kind": 6,
        "importPath": "deps.sample-factory.tests.envs.vizdoom.test_vizdoom_basic",
        "description": "deps.sample-factory.tests.envs.vizdoom.test_vizdoom_basic",
        "peekOfCode": "class TestDoom:\n    @pytest.fixture(scope=\"class\", autouse=True)\n    def register_doom_fixture(self):\n        from sf_examples.vizdoom.train_vizdoom import register_vizdoom_components\n        register_vizdoom_components()\n        yield  # this is where the actual test happens\n        reset_global_context()\n    # noinspection PyUnusedLocal\n    @staticmethod\n    def make_env_singleplayer(env_config, **kwargs):",
        "detail": "deps.sample-factory.tests.envs.vizdoom.test_vizdoom_basic",
        "documentation": {}
    },
    {
        "label": "TestDoom",
        "kind": 6,
        "importPath": "deps.sample-factory.tests.envs.vizdoom.test_vizdoom_multiplayer",
        "description": "deps.sample-factory.tests.envs.vizdoom.test_vizdoom_multiplayer",
        "peekOfCode": "class TestDoom:\n    @pytest.fixture(scope=\"class\", autouse=True)\n    def register_doom_fixture(self):\n        from sf_examples.vizdoom.train_vizdoom import register_vizdoom_components\n        register_vizdoom_components()\n        yield\n        reset_global_context()\n    @staticmethod\n    def make_standard_dm(env_config, render_mode):\n        from sf_examples.vizdoom.doom.doom_params import default_doom_cfg",
        "detail": "deps.sample-factory.tests.envs.vizdoom.test_vizdoom_multiplayer",
        "documentation": {}
    },
    {
        "label": "eval_env_performance",
        "kind": 2,
        "importPath": "deps.sample-factory.tests.envs.utils",
        "description": "deps.sample-factory.tests.envs.utils",
        "peekOfCode": "def eval_env_performance(make_env, env_type, verbose=False, eval_frames=10_000):\n    t = Timing()\n    with t.timeit(\"init\"):\n        env = make_env(AttrDict({\"worker_index\": 0, \"vector_index\": 0}))\n        total_num_frames, frames = eval_frames, 0\n    with t.timeit(\"first_reset\"):\n        env.reset()\n    t.reset = t.step = 1e-9\n    num_resets = 0\n    with t.timeit(\"experience\"):",
        "detail": "deps.sample-factory.tests.envs.utils",
        "documentation": {}
    },
    {
        "label": "TestExample",
        "kind": 6,
        "importPath": "deps.sample-factory.tests.examples.test_example",
        "description": "deps.sample-factory.tests.examples.test_example",
        "peekOfCode": "class TestExample:\n    @pytest.mark.parametrize(\"num_actions\", [1, 10])\n    @pytest.mark.parametrize(\"batched_sampling\", [False, True])\n    def test_sanity_1(self, num_actions: int, batched_sampling: bool):\n        \"\"\"\n        Run the test env in various configurations just to make sure nothing crashes or throws exceptions.\n        \"\"\"\n        cfg, eval_cfg = default_test_cfg()\n        cfg.custom_env_num_actions = eval_cfg.custom_env_num_actions = num_actions\n        cfg.num_workers = 1",
        "detail": "deps.sample-factory.tests.examples.test_example",
        "documentation": {}
    },
    {
        "label": "default_test_cfg",
        "kind": 2,
        "importPath": "deps.sample-factory.tests.examples.test_example",
        "description": "deps.sample-factory.tests.examples.test_example",
        "peekOfCode": "def default_test_cfg(\n    env_name: str = \"my_custom_env_v1\", parse_args_func: Callable = parse_custom_args\n) -> Tuple[Config, Config]:\n    argv = [\"--algo=APPO\", f\"--env={env_name}\", \"--experiment=test_example\"]\n    cfg = parse_args_func(argv=argv)\n    cfg.num_workers = 8\n    cfg.num_envs_per_worker = 2\n    cfg.train_for_env_steps = 128\n    cfg.batch_size = 64\n    cfg.batched_sampling = False",
        "detail": "deps.sample-factory.tests.examples.test_example",
        "documentation": {}
    },
    {
        "label": "run_test_env",
        "kind": 2,
        "importPath": "deps.sample-factory.tests.examples.test_example",
        "description": "deps.sample-factory.tests.examples.test_example",
        "peekOfCode": "def run_test_env(\n    cfg: Config,\n    eval_cfg: Config,\n    expected_reward_at_least: float = -EPS,\n    expected_reward_at_most: float = 100,\n    check_envs: bool = False,\n    register_custom_components_func: Callable = register_custom_components,\n    env_name: str = \"my_custom_env_v1\",\n):\n    log.debug(f\"Testing with parameters {locals()}...\")",
        "detail": "deps.sample-factory.tests.examples.test_example",
        "documentation": {}
    },
    {
        "label": "TestExampleMulti",
        "kind": 6,
        "importPath": "deps.sample-factory.tests.examples.test_example_multi",
        "description": "deps.sample-factory.tests.examples.test_example_multi",
        "peekOfCode": "class TestExampleMulti:\n    @pytest.mark.parametrize(\"async_rl\", [False, True])\n    @pytest.mark.parametrize(\"train_steps\", [1024])\n    @pytest.mark.parametrize(\"batched_sampling\", [False, True])\n    def test_sanity(self, async_rl: bool, train_steps: int, batched_sampling: bool):\n        cfg, eval_cfg = default_multi_cfg()\n        cfg.async_rl = async_rl\n        cfg.train_for_env_steps = train_steps\n        cfg.num_workers = 2\n        cfg.batch_size = 256",
        "detail": "deps.sample-factory.tests.examples.test_example_multi",
        "documentation": {}
    },
    {
        "label": "default_multi_cfg",
        "kind": 2,
        "importPath": "deps.sample-factory.tests.examples.test_example_multi",
        "description": "deps.sample-factory.tests.examples.test_example_multi",
        "peekOfCode": "def default_multi_cfg(\n    env_name: str = \"my_custom_multi_env_v1\", parse_args_func: Callable = parse_custom_args\n) -> Tuple[Config, Config]:\n    cfg, eval_cfg = default_test_cfg(env_name, parse_args_func)\n    cfg.num_policies = 2\n    return cfg, eval_cfg\ndef run_test_env_multi(cfg: Config, eval_cfg: Config, **kwargs):\n    return run_test_env(\n        cfg,\n        eval_cfg,",
        "detail": "deps.sample-factory.tests.examples.test_example_multi",
        "documentation": {}
    },
    {
        "label": "run_test_env_multi",
        "kind": 2,
        "importPath": "deps.sample-factory.tests.examples.test_example_multi",
        "description": "deps.sample-factory.tests.examples.test_example_multi",
        "peekOfCode": "def run_test_env_multi(cfg: Config, eval_cfg: Config, **kwargs):\n    return run_test_env(\n        cfg,\n        eval_cfg,\n        register_custom_components_func=register_custom_components,\n        env_name=\"my_custom_multi_env_v1\",\n        **kwargs,\n    )\nclass TestExampleMulti:\n    @pytest.mark.parametrize(\"async_rl\", [False, True])",
        "detail": "deps.sample-factory.tests.examples.test_example_multi",
        "documentation": {}
    },
    {
        "label": "TestSampler",
        "kind": 6,
        "importPath": "deps.sample-factory.tests.examples.test_example_sampler",
        "description": "deps.sample-factory.tests.examples.test_example_sampler",
        "peekOfCode": "class TestSampler:\n    @pytest.mark.skipif(not mujoco_available(), reason=\"mujoco not installed\")\n    @pytest.mark.parametrize(\"batched_sampling\", [False, True])\n    def test_sampler(self, batched_sampling: bool):\n        # test on Mujoco because why not\n        register_mujoco_components()\n        cfg = parse_mujoco_cfg(\n            argv=[\"--env=mujoco_halfcheetah\", \"--decorrelate_envs_on_one_worker=False\", \"--device=cpu\"]\n        )\n        cfg.batched_sampling = batched_sampling",
        "detail": "deps.sample-factory.tests.examples.test_example_sampler",
        "documentation": {}
    },
    {
        "label": "TestParams",
        "kind": 6,
        "importPath": "deps.sample-factory.tests.test_launcher",
        "description": "deps.sample-factory.tests.test_launcher",
        "peekOfCode": "class TestParams:\n    def test_param_list(self):\n        params = [\n            {\"p1\": 1, \"p2\": \"a\"},\n            {\"p2\": \"b\", \"p4\": \"test\"},\n        ]\n        param_list = ParamList(params)\n        param_combinations = list(param_list.generate_params(randomize=False))\n        for i, combination in enumerate(params):\n            assert combination == param_combinations[i]",
        "detail": "deps.sample-factory.tests.test_launcher",
        "documentation": {}
    },
    {
        "label": "TestLauncher",
        "kind": 6,
        "importPath": "deps.sample-factory.tests.test_launcher",
        "description": "deps.sample-factory.tests.test_launcher",
        "peekOfCode": "class TestLauncher:\n    def test_experiment(self):\n        params = ParamGrid([(\"p1\", [3.14, 2.71]), (\"p2\", [\"a\", \"b\", \"c\"])])\n        cmd = \"python super_rl.py\"\n        ex = Experiment(\"test\", cmd, params.generate_params(randomize=False))\n        cmds = ex.generate_experiments(\"train_dir\", customize_experiment_name=True, param_prefix=\"--\")\n        for index, value in enumerate(cmds):\n            command, name = value\n            assert command.startswith(cmd)\n            assert name.startswith(f\"0{index}_test\")",
        "detail": "deps.sample-factory.tests.test_launcher",
        "documentation": {}
    },
    {
        "label": "TestPreCheck",
        "kind": 6,
        "importPath": "deps.sample-factory.tests.test_precheck",
        "description": "deps.sample-factory.tests.test_precheck",
        "peekOfCode": "class TestPreCheck:\n    @pytest.mark.parametrize(\"test_idx\", list(range(10)))\n    def test_torch_tensor_share(self, test_idx: int):\n        ctx = mp.get_context(\"spawn\")\n        t = torch.rand((300, 200, test_idx * 10 + 1))\n        m = torch.clone(t)\n        m[0][0][0] = test_idx\n        t.share_memory_()\n        q = ctx.Queue()\n        q.put(t)",
        "detail": "deps.sample-factory.tests.test_precheck",
        "documentation": {}
    },
    {
        "label": "subp",
        "kind": 2,
        "importPath": "deps.sample-factory.tests.test_precheck",
        "description": "deps.sample-factory.tests.test_precheck",
        "peekOfCode": "def subp(q, test_idx_: int):\n    t = q.get()\n    t[0][0][0] = test_idx_\nclass TestPreCheck:\n    @pytest.mark.parametrize(\"test_idx\", list(range(10)))\n    def test_torch_tensor_share(self, test_idx: int):\n        ctx = mp.get_context(\"spawn\")\n        t = torch.rand((300, 200, test_idx * 10 + 1))\n        m = torch.clone(t)\n        m[0][0][0] = test_idx",
        "detail": "deps.sample-factory.tests.test_precheck",
        "documentation": {}
    },
    {
        "label": "TestUtils",
        "kind": 6,
        "importPath": "deps.sample-factory.tests.test_utils",
        "description": "deps.sample-factory.tests.test_utils",
        "peekOfCode": "class TestUtils:\n    def test_udp(self):\n        is_udp_port_available(50301)\n    def test_cpu_affinity(self):\n        num_workers = 44\n        cpu_count = 20\n        for i in range(num_workers):\n            cores = cores_for_worker_process(i, num_workers, cpu_count)\n            if i < 40:\n                assert cores == [i % cpu_count]",
        "detail": "deps.sample-factory.tests.test_utils",
        "documentation": {}
    },
    {
        "label": "clean_test_dir",
        "kind": 2,
        "importPath": "deps.sample-factory.tests.utils",
        "description": "deps.sample-factory.tests.utils",
        "peekOfCode": "def clean_test_dir(cfg: Config) -> str:\n    directory = experiment_dir(cfg=cfg, mkdir=False)\n    if isdir(directory):\n        # remove any previous unfinished test dirs so they don't interfere with this test\n        shutil.rmtree(directory, ignore_errors=True)\n    return directory",
        "detail": "deps.sample-factory.tests.utils",
        "documentation": {}
    },
    {
        "label": "_atari_deps",
        "kind": 5,
        "importPath": "deps.sample-factory.setup",
        "description": "deps.sample-factory.setup",
        "peekOfCode": "_atari_deps = [\"gymnasium[atari, accept-rom-license]\"]\n_mujoco_deps = [\"gymnasium[mujoco]\", \"mujoco<2.5\"]\n_nethack_deps = [\n    \"numba ~= 0.58\",\n    \"pandas ~= 2.1\",\n    \"matplotlib ~= 3.8\",\n    \"seaborn ~= 0.12\",\n    \"scipy ~= 1.11\",\n    \"shimmy\",\n    \"tqdm ~= 4.66\",",
        "detail": "deps.sample-factory.setup",
        "documentation": {}
    },
    {
        "label": "_mujoco_deps",
        "kind": 5,
        "importPath": "deps.sample-factory.setup",
        "description": "deps.sample-factory.setup",
        "peekOfCode": "_mujoco_deps = [\"gymnasium[mujoco]\", \"mujoco<2.5\"]\n_nethack_deps = [\n    \"numba ~= 0.58\",\n    \"pandas ~= 2.1\",\n    \"matplotlib ~= 3.8\",\n    \"seaborn ~= 0.12\",\n    \"scipy ~= 1.11\",\n    \"shimmy\",\n    \"tqdm ~= 4.66\",\n    \"debugpy ~= 1.6\",",
        "detail": "deps.sample-factory.setup",
        "documentation": {}
    },
    {
        "label": "_nethack_deps",
        "kind": 5,
        "importPath": "deps.sample-factory.setup",
        "description": "deps.sample-factory.setup",
        "peekOfCode": "_nethack_deps = [\n    \"numba ~= 0.58\",\n    \"pandas ~= 2.1\",\n    \"matplotlib ~= 3.8\",\n    \"seaborn ~= 0.12\",\n    \"scipy ~= 1.11\",\n    \"shimmy\",\n    \"tqdm ~= 4.66\",\n    \"debugpy ~= 1.6\",\n]",
        "detail": "deps.sample-factory.setup",
        "documentation": {}
    },
    {
        "label": "_envpool_deps",
        "kind": 5,
        "importPath": "deps.sample-factory.setup",
        "description": "deps.sample-factory.setup",
        "peekOfCode": "_envpool_deps = [\"envpool\"]\n_docs_deps = [\n    \"mkdocs-material\",\n    \"mkdocs-minify-plugin\",\n    \"mkdocs-redirects\",\n    \"mkdocs-git-revision-date-localized-plugin\",\n    \"mkdocs-git-committers-plugin-2\",\n    \"mkdocs-git-authors-plugin\",\n]\nsetup(",
        "detail": "deps.sample-factory.setup",
        "documentation": {}
    },
    {
        "label": "_docs_deps",
        "kind": 5,
        "importPath": "deps.sample-factory.setup",
        "description": "deps.sample-factory.setup",
        "peekOfCode": "_docs_deps = [\n    \"mkdocs-material\",\n    \"mkdocs-minify-plugin\",\n    \"mkdocs-redirects\",\n    \"mkdocs-git-revision-date-localized-plugin\",\n    \"mkdocs-git-committers-plugin-2\",\n    \"mkdocs-git-authors-plugin\",\n]\nsetup(\n    # Information",
        "detail": "deps.sample-factory.setup",
        "documentation": {}
    },
    {
        "label": "get_batch_job_queues",
        "kind": 2,
        "importPath": "devops.aws.cluster_info",
        "description": "devops.aws.cluster_info",
        "peekOfCode": "def get_batch_job_queues():\n    batch = boto3.client('batch')\n    response = batch.describe_job_queues()\n    return [queue['jobQueueName'] for queue in response['jobQueues']]\ndef get_batch_jobs(job_queue, max_jobs):\n    batch = boto3.client('batch')\n    ecs = boto3.client('ecs')\n    running_jobs = []\n    other_jobs = []\n    # Get running jobs",
        "detail": "devops.aws.cluster_info",
        "documentation": {}
    },
    {
        "label": "get_batch_jobs",
        "kind": 2,
        "importPath": "devops.aws.cluster_info",
        "description": "devops.aws.cluster_info",
        "peekOfCode": "def get_batch_jobs(job_queue, max_jobs):\n    batch = boto3.client('batch')\n    ecs = boto3.client('ecs')\n    running_jobs = []\n    other_jobs = []\n    # Get running jobs\n    response = batch.list_jobs(jobQueue=job_queue, jobStatus='RUNNING')\n    running_jobs.extend(response['jobSummaryList'])\n    # Get jobs in other states\n    states = ['SUBMITTED', 'PENDING', 'RUNNABLE', 'STARTING', 'SUCCEEDED', 'FAILED']",
        "detail": "devops.aws.cluster_info",
        "documentation": {}
    },
    {
        "label": "get_ecs_clusters",
        "kind": 2,
        "importPath": "devops.aws.cluster_info",
        "description": "devops.aws.cluster_info",
        "peekOfCode": "def get_ecs_clusters():\n    ecs = boto3.client('ecs')\n    response = ecs.list_clusters()\n    return response['clusterArns']\ndef get_ecs_tasks(clusters, max_tasks):\n    ecs = boto3.client('ecs')\n    task_details = []\n    for cluster in clusters:\n        response = ecs.list_tasks(cluster=cluster, maxResults=max_tasks)\n        task_arns = response['taskArns']",
        "detail": "devops.aws.cluster_info",
        "documentation": {}
    },
    {
        "label": "get_ecs_tasks",
        "kind": 2,
        "importPath": "devops.aws.cluster_info",
        "description": "devops.aws.cluster_info",
        "peekOfCode": "def get_ecs_tasks(clusters, max_tasks):\n    ecs = boto3.client('ecs')\n    task_details = []\n    for cluster in clusters:\n        response = ecs.list_tasks(cluster=cluster, maxResults=max_tasks)\n        task_arns = response['taskArns']\n        for task_arn in task_arns:\n            task_desc = ecs.describe_tasks(cluster=cluster, tasks=[task_arn])\n            task = task_desc['tasks'][0]\n            task_id = task['taskArn'].split('/')[-1]",
        "detail": "devops.aws.cluster_info",
        "documentation": {}
    },
    {
        "label": "print_row",
        "kind": 2,
        "importPath": "devops.aws.cluster_info",
        "description": "devops.aws.cluster_info",
        "peekOfCode": "def print_row(key, value, use_color):\n    if use_color:\n        print(f\"  {Fore.BLUE}{key}:{Style.RESET_ALL} {value}\")\n    else:\n        print(f\"  {key}: {value}\")\ndef print_status(jobs_by_queue, tasks, use_color):\n    for job_queue, jobs in jobs_by_queue.items():\n        if use_color:\n            print(f\"{Fore.CYAN}AWS Batch Jobs - Queue: {job_queue}{Style.RESET_ALL}\")\n        else:",
        "detail": "devops.aws.cluster_info",
        "documentation": {}
    },
    {
        "label": "print_status",
        "kind": 2,
        "importPath": "devops.aws.cluster_info",
        "description": "devops.aws.cluster_info",
        "peekOfCode": "def print_status(jobs_by_queue, tasks, use_color):\n    for job_queue, jobs in jobs_by_queue.items():\n        if use_color:\n            print(f\"{Fore.CYAN}AWS Batch Jobs - Queue: {job_queue}{Style.RESET_ALL}\")\n        else:\n            print(f\"AWS Batch Jobs - Queue: {job_queue}\")\n        for job in jobs:\n            status_color = {\n                'SUBMITTED': Fore.YELLOW,\n                'PENDING': Fore.YELLOW,",
        "detail": "devops.aws.cluster_info",
        "documentation": {}
    },
    {
        "label": "register_task_definition",
        "kind": 2,
        "importPath": "devops.aws.configure",
        "description": "devops.aws.configure",
        "peekOfCode": "def register_task_definition(args):\n    ecs = boto3.client('ecs')\n    memory = int(args.memory * 1024)\n    task_definition = {\n        \"family\": \"metta-trainer\",\n        \"containerDefinitions\": [\n            {\n                \"name\": \"metta\",\n                \"image\": \"mettaai/metta:latest\",\n                \"portMappings\": [],",
        "detail": "devops.aws.configure",
        "documentation": {}
    },
    {
        "label": "submit_batch_job",
        "kind": 2,
        "importPath": "devops.aws.launch_task",
        "description": "devops.aws.launch_task",
        "peekOfCode": "def submit_batch_job(args, task_args):\n    batch = boto3.client('batch')\n    job_name = args.experiment.replace('.', '_')\n    job_queue = \"metta-batch-jq-\" + args.instance_type.replace('.', '-')\n    job_definition = \"metta-batch-train-jd\"\n    response = batch.submit_job(\n        jobName=job_name,\n        jobQueue=job_queue,\n        jobDefinition=job_definition,\n        containerOverrides=container_config(args, task_args)",
        "detail": "devops.aws.launch_task",
        "documentation": {}
    },
    {
        "label": "container_config",
        "kind": 2,
        "importPath": "devops.aws.launch_task",
        "description": "devops.aws.launch_task",
        "peekOfCode": "def container_config(args, task_args):\n    # Get the wandb key from the .netrc file\n    netrc_info = netrc.netrc(os.path.expanduser('~/.netrc'))\n    wandb_key = netrc_info.authenticators('api.wandb.ai')[2]\n    if not wandb_key:\n        raise ValueError('WANDB_API_KEY not found in .netrc file')\n    # Get the hugging face key from the cache file\n    hugging_face_key_file = os.path.expanduser(\"~/.cache/huggingface/token\")\n    with open(hugging_face_key_file, 'r') as file:\n        hugging_face_key = file.read().strip()",
        "detail": "devops.aws.launch_task",
        "documentation": {}
    },
    {
        "label": "machine_profiles",
        "kind": 5,
        "importPath": "devops.aws.launch_task",
        "description": "devops.aws.launch_task",
        "peekOfCode": "machine_profiles = {\n    \"g5.2xlarge\": {\n        \"vcpus\": 8,\n        \"memory\": 28,\n    },\n    \"g5.4xlarge\": {\n        \"vcpus\": 16,\n        \"memory\": 60,\n    },\n    \"g5.8xlarge\": {",
        "detail": "devops.aws.launch_task",
        "documentation": {}
    },
    {
        "label": "get_job_ip",
        "kind": 2,
        "importPath": "devops.aws.task_exec",
        "description": "devops.aws.task_exec",
        "peekOfCode": "def get_job_ip(job_name):\n   batch_client = boto3.client('batch')\n   ecs_client = boto3.client('ecs')\n   ec2_client = boto3.client('ec2')\n   # Get the list of job queues\n   job_queues = batch_client.describe_job_queues()['jobQueues']\n   # Iterate over the job queues to find the job\n   for job_queue in job_queues:\n       job_queue_name = job_queue['jobQueueName']\n       # List jobs in the job queue",
        "detail": "devops.aws.task_exec",
        "documentation": {}
    },
    {
        "label": "connect_to_container",
        "kind": 2,
        "importPath": "devops.aws.task_exec",
        "description": "devops.aws.task_exec",
        "peekOfCode": "def connect_to_container(ip):\n   try:\n       # Establish SSH connection and check if it's successful\n       ssh_check_output = subprocess.check_output(f\"ssh -o StrictHostKeyChecking=no -o ConnectTimeout=10 {ip} 'echo Connected'\", shell=True).decode().strip()\n       if ssh_check_output != \"Connected\":\n           raise subprocess.CalledProcessError(1, \"SSH connection check failed\")\n       # Retrieve container ID\n       container_id_output = subprocess.check_output(f\"ssh -o StrictHostKeyChecking=no -t {ip} \\\"docker ps | grep 'mettaai/metta'\\\"\", shell=True).decode().strip()\n       if container_id_output:\n           container_id = container_id_output.split()[0]",
        "detail": "devops.aws.task_exec",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "devops.wandb.project",
        "description": "devops.wandb.project",
        "peekOfCode": "def main():\n    parser = argparse.ArgumentParser()\n    parser.add_argument('--wandb_user', required=True)\n    parser.add_argument('--wandb_project', required=True)\n    parser.add_argument('--yaml_path', required=True)\n    parser.add_argument('--load', action='store_true')\n    parser.add_argument('--save', action='store_true')\n    args = parser.parse_args()\n    api = wandb.Api()\n    run = api.runs(f\"{args.wandb_user}/{args.wandb_project}\")",
        "detail": "devops.wandb.project",
        "documentation": {}
    },
    {
        "label": "FeatureMasker",
        "kind": 6,
        "importPath": "env.wrapper.feature_masker",
        "description": "env.wrapper.feature_masker",
        "peekOfCode": "class FeatureMasker(gym.Wrapper):\n    def __init__(self, env, masked_features):\n        super().__init__(env)\n        self._masked_grid_obs = [\n            self.env.unwrapped.grid_features.index(feature)\n            for feature in masked_features.grid_obs\n        ]\n        self._grid_obs_mask = np.ones(\n            self.env.unwrapped.observation_space[\"grid_obs\"].shape,\n            dtype=np.uint8)",
        "detail": "env.wrapper.feature_masker",
        "documentation": {}
    },
    {
        "label": "Kinship",
        "kind": 6,
        "importPath": "env.wrapper.kinship",
        "description": "env.wrapper.kinship",
        "peekOfCode": "class Kinship(gym.Wrapper):\n    def __init__(self, team_size: int, team_reward: float, env: gym.Env):\n        super().__init__(env)\n        self._team_size = team_size\n        self._team_reward = team_reward\n        self._num_agents = self.env.unwrapped.player_count\n        self._num_teams = int(math.ceil(self._num_agents / self._team_size))\n        self._agent_team = np.array([\n            agent // self._team_size for agent in range(self._num_agents)])\n        self._team_to_agents = {",
        "detail": "env.wrapper.kinship",
        "documentation": {}
    },
    {
        "label": "LastActionTracker",
        "kind": 6,
        "importPath": "env.wrapper.last_action_tracker",
        "description": "env.wrapper.last_action_tracker",
        "peekOfCode": "class LastActionTracker(gym.Wrapper):\n    def __init__(self, env):\n        super(LastActionTracker, self).__init__(env)\n        self._last_actions = None\n    def reset(self, **kwargs):\n        self._last_actions = np.zeros((self.unwrapped.player_count, 2), dtype=np.int32)\n        obs, infos = self.env.reset(**kwargs)\n        return self._augment_observations(obs), infos\n    def step(self, actions):\n        obs, rewards, terms, truncs, infos = self.env.step(actions)",
        "detail": "env.wrapper.last_action_tracker",
        "documentation": {}
    },
    {
        "label": "PettingZooEnvWrapper",
        "kind": 6,
        "importPath": "env.wrapper.petting_zoo",
        "description": "env.wrapper.petting_zoo",
        "peekOfCode": "class PettingZooEnvWrapper(pettingzoo.ParallelEnv):\n    def __init__(self, gym_env: gym.Env, render_mode='rgb_array'):\n        super().__init__()\n        self._gym_env = gym_env\n        self.possible_agents = [i+1 for i in range(self.num_agents)]\n        # agents gets manipulated\n        self.agents = [i+1 for i in range(self.num_agents)]\n        self.render_mode = render_mode\n    @property\n    def num_agents(self):",
        "detail": "env.wrapper.petting_zoo",
        "documentation": {}
    },
    {
        "label": "Replay",
        "kind": 6,
        "importPath": "env.wrapper.replay",
        "description": "env.wrapper.replay",
        "peekOfCode": "class Replay():\n    def __init__(self, filename):\n        self.filename = filename\n        self.data = {\n            \"steps\": [],\n            \"global_obs\": [],\n        }\n    def record_step(self, actions, obs, rewards, infos, global_obs):\n        self.data[\"global_obs\"].append(global_obs)\n    def close(self):",
        "detail": "env.wrapper.replay",
        "documentation": {}
    },
    {
        "label": "RewardTracker",
        "kind": 6,
        "importPath": "env.wrapper.reward_tracker",
        "description": "env.wrapper.reward_tracker",
        "peekOfCode": "class RewardTracker(gym.Wrapper):\n    def __init__(self, env):\n        super(RewardTracker, self).__init__(env)\n        self._last_rewards = None\n    def reset(self, **kwargs):\n        self._last_rewards = np.zeros(self.unwrapped.player_count, dtype=np.float32)\n        obs, infos = self.env.reset(**kwargs)\n        return self._augment_observations(obs), infos\n    def step(self, actions):\n        obs, rewards, terms, truncs, infos = self.env.step(actions)",
        "detail": "env.wrapper.reward_tracker",
        "documentation": {}
    },
    {
        "label": "run_eval",
        "kind": 2,
        "importPath": "evals.evals",
        "description": "evals.evals",
        "peekOfCode": "def run_eval(sf_args, eval_config: dict):\n    argv = sf_args + EVALUATION_ARGS + [\n        f\"--{k}={v}\" for k, v in eval_config.items()\n    ]\n    return evaluate(argv)\ndef run_baseline_eval(df, sf_args, eval_config: dict, baseline: str, num_trials=5):\n    print(f\"Running baseline evaluation with config: {eval_config} and baseline: {baseline}\")\n    rewards = []\n    bl_rewards = []\n    for trial in range(num_trials):",
        "detail": "evals.evals",
        "documentation": {}
    },
    {
        "label": "run_baseline_eval",
        "kind": 2,
        "importPath": "evals.evals",
        "description": "evals.evals",
        "peekOfCode": "def run_baseline_eval(df, sf_args, eval_config: dict, baseline: str, num_trials=5):\n    print(f\"Running baseline evaluation with config: {eval_config} and baseline: {baseline}\")\n    rewards = []\n    bl_rewards = []\n    for trial in range(num_trials):\n        rewards.append(run_eval(sf_args, eval_config))\n        bl_rewards.append(run_eval(sf_args, {**eval_config, \"experiment\": baseline}))\n        t_stat, p_value = stats.ttest_rel(rewards, bl_rewards)\n        print(\n            \"Reward: {:.3f} | Baseline Reward: {:.3f} | p-value: {:.3f}\".format(",
        "detail": "evals.evals",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "evals.evals",
        "description": "evals.evals",
        "peekOfCode": "def main():\n    argp = argparse.ArgumentParser()\n    argp.add_argument(\"--num_trials\", default=5, type=int)\n    args, sf_args = argp.parse_known_args()\n    sf_args.append(f\"--train_dir={args.train_dir}\")\n    sf_args.append(f\"--experiment={args.experiment}\")\n    out_path = f\"{args.train_dir}/{args.experiment}/eval/\"\n    os.makedirs(out_path, exist_ok=True)\n    flag_combinations = list(itertools.product(*flags.values()))\n    flag_combinations = [dict(zip(flags.keys(), combination)) for combination in flag_combinations]",
        "detail": "evals.evals",
        "documentation": {}
    },
    {
        "label": "color_rewards",
        "kind": 2,
        "importPath": "evals.evals",
        "description": "evals.evals",
        "peekOfCode": "def color_rewards(row):\n    \"\"\"\n    Colors rewards based on their value and the p-value.\n    \"\"\"\n    if row['p'] < 0.05:\n        if row['reward_delta'] < 0:\n            color = 'red'\n        else:\n            color = 'green'\n        return f\"[{color}]{row['reward_delta']}[/]\"",
        "detail": "evals.evals",
        "documentation": {}
    },
    {
        "label": "print_table",
        "kind": 2,
        "importPath": "evals.evals",
        "description": "evals.evals",
        "peekOfCode": "def print_table(df, file=sys.stdout, color=True):\n    console = Console(file=file)\n    table = Table(show_header=True, header_style=\"bold magenta\")\n    for column in df.columns:\n        table.add_column(column)\n    if color:\n        df = df.copy()\n        df['reward_delta'] = df.apply(color_rewards, axis=1)\n    for i in range(len(df)):\n        table.add_row(*df.iloc[i].astype(str).tolist())",
        "detail": "evals.evals",
        "documentation": {}
    },
    {
        "label": "EVALUATION_ARGS",
        "kind": 5,
        "importPath": "evals.evals",
        "description": "evals.evals",
        "peekOfCode": "EVALUATION_ARGS = [\n    \"--no_render\",\n]\nflags = {\n    \"env_num_agents\": [2, 5, 10],\n    \"env_width\": [10, 20, 30, 40, 50],\n    \"env_height\": [10, 20, 30, 40, 50],\n    \"env_num_altars\": [0, 1, 5],\n    \"env_num_chargers\": [0, 1, 5],\n    \"env_num_generators\": [0, 5, 10, 20],",
        "detail": "evals.evals",
        "documentation": {}
    },
    {
        "label": "flags",
        "kind": 5,
        "importPath": "evals.evals",
        "description": "evals.evals",
        "peekOfCode": "flags = {\n    \"env_num_agents\": [2, 5, 10],\n    \"env_width\": [10, 20, 30, 40, 50],\n    \"env_height\": [10, 20, 30, 40, 50],\n    \"env_num_altars\": [0, 1, 5],\n    \"env_num_chargers\": [0, 1, 5],\n    \"env_num_generators\": [0, 5, 10, 20],\n}\ndef run_eval(sf_args, eval_config: dict):\n    argv = sf_args + EVALUATION_ARGS + [",
        "detail": "evals.evals",
        "documentation": {}
    },
    {
        "label": "run_sweep",
        "kind": 2,
        "importPath": "rl.carbs.carb_sweep",
        "description": "rl.carbs.carb_sweep",
        "peekOfCode": "def run_sweep(cfg: OmegaConf):\n    try:\n        print(f\"Loading previous sweep {cfg.experiment}...\")\n        artifact = wandb.use_artifact(cfg.experiment + \":latest\", type=\"sweep\")\n        sweep_id = artifact.metadata[\"sweep_id\"]\n    except CommError:\n        print(f\"No previous sweep {cfg.experiment} found, creating...\")\n        sweep_id = wandb.sweep(\n            sweep=_wandb_sweep_cfg(cfg),\n            project=cfg.wandb.project,",
        "detail": "rl.carbs.carb_sweep",
        "documentation": {}
    },
    {
        "label": "run_carb_sweep_rollout",
        "kind": 2,
        "importPath": "rl.carbs.carb_sweep",
        "description": "rl.carbs.carb_sweep",
        "peekOfCode": "def run_carb_sweep_rollout():\n    global _cfg\n    init_wandb(_cfg)\n    np.random.seed(int(time.time()))\n    torch.manual_seed(int(time.time()))\n    carbs_controller = _load_carbs_state(_cfg)\n    carbs_controller._set_seed(int(time.time()))\n    print(f\"CARBS: obs: {carbs_controller.observation_count}\")\n    orig_suggestion = carbs_controller.suggest().suggestion\n    carbs_controller.num_suggestions += 1",
        "detail": "rl.carbs.carb_sweep",
        "documentation": {}
    },
    {
        "label": "_carbs_space",
        "kind": 5,
        "importPath": "rl.carbs.carb_sweep",
        "description": "rl.carbs.carb_sweep",
        "peekOfCode": "_carbs_space = {\n    \"log\": LogSpace,\n    \"linear\": LinearSpace,\n    \"pow2\": LinearSpace,\n    \"logit\": LogitSpace,\n}\ndef _carbs_params_spaces(cfg: OmegaConf):\n    param_spaces = []\n    params = _fully_qualified_parameters(cfg.sweep.parameters)\n    for param_name, param in params.items():",
        "detail": "rl.carbs.carb_sweep",
        "documentation": {}
    },
    {
        "label": "save_checkpoint",
        "kind": 2,
        "importPath": "rl.pufferlib.checkpoint",
        "description": "rl.pufferlib.checkpoint",
        "peekOfCode": "def save_checkpoint(data):\n    config = data.config\n    path = os.path.join(config.data_dir, config.exp_id)\n    if not os.path.exists(path):\n        os.makedirs(path)\n    model_name = f'model_{data.epoch:06d}.pt'\n    model_path = os.path.join(path, model_name)\n    if os.path.exists(model_path):\n        return model_path\n    torch.save(data.uncompiled_policy, model_path)",
        "detail": "rl.pufferlib.checkpoint",
        "documentation": {}
    },
    {
        "label": "try_load_checkpoint",
        "kind": 2,
        "importPath": "rl.pufferlib.checkpoint",
        "description": "rl.pufferlib.checkpoint",
        "peekOfCode": "def try_load_checkpoint(data):\n    config = data.config\n    path = os.path.join(config.data_dir, config.exp_id)\n    if not os.path.exists(path):\n        print('No checkpoints found. Assuming new experiment')\n        return\n    trainer_path = os.path.join(path, 'trainer_state.pt')\n    resume_state = torch.load(trainer_path)\n    model_path = os.path.join(path, resume_state['model_name'])\n    data.policy.uncompiled.load_state_dict(model_path, map_location=config.device)",
        "detail": "rl.pufferlib.checkpoint",
        "documentation": {}
    },
    {
        "label": "Profile",
        "kind": 6,
        "importPath": "rl.pufferlib.clean_pufferl",
        "description": "rl.pufferlib.clean_pufferl",
        "peekOfCode": "class Profile:\n    SPS: ... = 0\n    uptime: ... = 0\n    remaining: ... = 0\n    eval_time: ... = 0\n    env_time: ... = 0\n    eval_forward_time: ... = 0\n    eval_misc_time: ... = 0\n    train_time: ... = 0\n    train_forward_time: ... = 0",
        "detail": "rl.pufferlib.clean_pufferl",
        "documentation": {}
    },
    {
        "label": "Experience",
        "kind": 6,
        "importPath": "rl.pufferlib.clean_pufferl",
        "description": "rl.pufferlib.clean_pufferl",
        "peekOfCode": "class Experience:\n    '''Flat tensor storage and array views for faster indexing'''\n    def __init__(self, batch_size, bptt_horizon, minibatch_size, obs_shape, obs_dtype, atn_shape, atn_dtype,\n                 cpu_offload=False, device='cuda', lstm=None, lstm_total_agents=0):\n        if minibatch_size is None:\n            minibatch_size = batch_size\n        obs_dtype = pufferlib.pytorch.numpy_to_torch_dtype_dict[obs_dtype]\n        atn_dtype = pufferlib.pytorch.numpy_to_torch_dtype_dict[atn_dtype]\n        pin = device == 'cuda' and cpu_offload\n        obs_device = device if not pin else 'cpu'",
        "detail": "rl.pufferlib.clean_pufferl",
        "documentation": {}
    },
    {
        "label": "Utilization",
        "kind": 6,
        "importPath": "rl.pufferlib.clean_pufferl",
        "description": "rl.pufferlib.clean_pufferl",
        "peekOfCode": "class Utilization(Thread):\n    def __init__(self, delay=1, maxlen=20):\n        super().__init__()\n        self.cpu_mem = deque(maxlen=maxlen)\n        self.cpu_util = deque(maxlen=maxlen)\n        self.gpu_util = deque(maxlen=maxlen)\n        self.gpu_mem = deque(maxlen=maxlen)\n        self.delay = delay\n        self.stopped = False\n        self.start()",
        "detail": "rl.pufferlib.clean_pufferl",
        "documentation": {}
    },
    {
        "label": "create",
        "kind": 2,
        "importPath": "rl.pufferlib.clean_pufferl",
        "description": "rl.pufferlib.clean_pufferl",
        "peekOfCode": "def create(config, vecenv, policy, optimizer=None):\n    seed_everything(config.seed, config.torch_deterministic)\n    profile = Profile()\n    losses = make_losses()\n    utilization = Utilization()\n    msg = f'Model Size: {abbreviate(count_params(policy))} parameters'\n    print_dashboard(config.env, utilization, 0, 0, profile, losses, {}, msg, clear=True)\n    vecenv.async_reset(config.seed)\n    obs_shape = vecenv.single_observation_space.shape\n    obs_dtype = vecenv.single_observation_space.dtype",
        "detail": "rl.pufferlib.clean_pufferl",
        "documentation": {}
    },
    {
        "label": "evaluate",
        "kind": 2,
        "importPath": "rl.pufferlib.clean_pufferl",
        "description": "rl.pufferlib.clean_pufferl",
        "peekOfCode": "def evaluate(data):\n    config, profile, experience = data.config, data.profile, data.experience\n    with profile.eval_misc:\n        policy = data.policy\n        infos = defaultdict(list)\n        lstm_h, lstm_c = experience.lstm_h, experience.lstm_c\n    while not experience.full:\n        with profile.env:\n            o, r, d, t, info, env_id, mask = data.vecenv.recv()\n            env_id = env_id.tolist()",
        "detail": "rl.pufferlib.clean_pufferl",
        "documentation": {}
    },
    {
        "label": "train",
        "kind": 2,
        "importPath": "rl.pufferlib.clean_pufferl",
        "description": "rl.pufferlib.clean_pufferl",
        "peekOfCode": "def train(data):\n    config, profile, experience = data.config, data.profile, data.experience\n    data.losses = make_losses()\n    losses = data.losses\n    with profile.train_misc:\n        idxs = experience.sort_training_data()\n        dones_np = experience.dones_np[idxs]\n        values_np = experience.values_np[idxs]\n        rewards_np = experience.rewards_np[idxs]\n        # TODO: bootstrap between segment bounds",
        "detail": "rl.pufferlib.clean_pufferl",
        "documentation": {}
    },
    {
        "label": "mean_and_log",
        "kind": 2,
        "importPath": "rl.pufferlib.clean_pufferl",
        "description": "rl.pufferlib.clean_pufferl",
        "peekOfCode": "def mean_and_log(data):\n    for k in list(data.stats.keys()):\n        v = data.stats[k]\n        try:\n            v = np.mean(v)\n        except:\n            del data.stats[k]\n        data.stats[k] = v\n    if data.wandb is None:\n        return",
        "detail": "rl.pufferlib.clean_pufferl",
        "documentation": {}
    },
    {
        "label": "close",
        "kind": 2,
        "importPath": "rl.pufferlib.clean_pufferl",
        "description": "rl.pufferlib.clean_pufferl",
        "peekOfCode": "def close(data):\n    data.vecenv.close()\n    data.utilization.stop()\n    config = data.config\n    if data.wandb is not None:\n        artifact_name = f\"{config.exp_id}_model\"\n        artifact = data.wandb.Artifact(artifact_name, type=\"model\")\n        model_path = save_checkpoint(data)\n        artifact.add_file(model_path)\n        data.wandb.run.log_artifact(artifact)",
        "detail": "rl.pufferlib.clean_pufferl",
        "documentation": {}
    },
    {
        "label": "make_losses",
        "kind": 2,
        "importPath": "rl.pufferlib.clean_pufferl",
        "description": "rl.pufferlib.clean_pufferl",
        "peekOfCode": "def make_losses():\n    return pufferlib.namespace(\n        policy_loss=0,\n        value_loss=0,\n        entropy=0,\n        old_approx_kl=0,\n        approx_kl=0,\n        clipfrac=0,\n        explained_variance=0,\n    )",
        "detail": "rl.pufferlib.clean_pufferl",
        "documentation": {}
    },
    {
        "label": "save_checkpoint",
        "kind": 2,
        "importPath": "rl.pufferlib.clean_pufferl",
        "description": "rl.pufferlib.clean_pufferl",
        "peekOfCode": "def save_checkpoint(data):\n    config = data.config\n    path = os.path.join(config.data_dir, config.exp_id)\n    if not os.path.exists(path):\n        os.makedirs(path)\n    model_name = f'model_{data.epoch:06d}.pt'\n    model_path = os.path.join(path, model_name)\n    if os.path.exists(model_path):\n        return model_path\n    torch.save(data.uncompiled_policy, model_path)",
        "detail": "rl.pufferlib.clean_pufferl",
        "documentation": {}
    },
    {
        "label": "try_load_checkpoint",
        "kind": 2,
        "importPath": "rl.pufferlib.clean_pufferl",
        "description": "rl.pufferlib.clean_pufferl",
        "peekOfCode": "def try_load_checkpoint(data):\n    config = data.config\n    path = os.path.join(config.data_dir, config.exp_id)\n    if not os.path.exists(path):\n        print('No checkpoints found. Assuming new experiment')\n        return\n    trainer_path = os.path.join(path, 'trainer_state.pt')\n    resume_state = torch.load(trainer_path)\n    model_path = os.path.join(path, resume_state['model_name'])\n    data.global_step = resume_state['global_step']",
        "detail": "rl.pufferlib.clean_pufferl",
        "documentation": {}
    },
    {
        "label": "count_params",
        "kind": 2,
        "importPath": "rl.pufferlib.clean_pufferl",
        "description": "rl.pufferlib.clean_pufferl",
        "peekOfCode": "def count_params(policy):\n    return sum(p.numel() for p in policy.parameters() if p.requires_grad)\ndef rollout(cfg: OmegaConf, env_creator, env_kwargs, agent_creator, agent_kwargs,\n        backend, render_mode='auto', model_path=None, device='cuda'):\n    if render_mode != 'auto':\n        env_kwargs['render_mode'] = render_mode\n    # We are just using Serial vecenv to give a consistent\n    # single-agent/multi-agent API for evaluation\n    env = pufferlib.vector.make(env_creator, env_kwargs=env_kwargs, backend=backend)\n    if model_path is None:",
        "detail": "rl.pufferlib.clean_pufferl",
        "documentation": {}
    },
    {
        "label": "rollout",
        "kind": 2,
        "importPath": "rl.pufferlib.clean_pufferl",
        "description": "rl.pufferlib.clean_pufferl",
        "peekOfCode": "def rollout(cfg: OmegaConf, env_creator, env_kwargs, agent_creator, agent_kwargs,\n        backend, render_mode='auto', model_path=None, device='cuda'):\n    if render_mode != 'auto':\n        env_kwargs['render_mode'] = render_mode\n    # We are just using Serial vecenv to give a consistent\n    # single-agent/multi-agent API for evaluation\n    env = pufferlib.vector.make(env_creator, env_kwargs=env_kwargs, backend=backend)\n    if model_path is None:\n        agent = agent_creator(env.driver_env, agent_kwargs).to(device)\n    else:",
        "detail": "rl.pufferlib.clean_pufferl",
        "documentation": {}
    },
    {
        "label": "seed_everything",
        "kind": 2,
        "importPath": "rl.pufferlib.clean_pufferl",
        "description": "rl.pufferlib.clean_pufferl",
        "peekOfCode": "def seed_everything(seed, torch_deterministic):\n    random.seed(seed)\n    np.random.seed(seed)\n    if seed is not None:\n        torch.manual_seed(seed)\n    torch.backends.cudnn.deterministic = torch_deterministic\nROUND_OPEN = rich.box.Box(\n    \"\\n\"\n    \"  \\n\"\n    \"  \\n\"",
        "detail": "rl.pufferlib.clean_pufferl",
        "documentation": {}
    },
    {
        "label": "abbreviate",
        "kind": 2,
        "importPath": "rl.pufferlib.clean_pufferl",
        "description": "rl.pufferlib.clean_pufferl",
        "peekOfCode": "def abbreviate(num):\n    if num < 1e3:\n        return f'{b2}{num:.0f}'\n    elif num < 1e6:\n        return f'{b2}{num/1e3:.1f}{c2}k'\n    elif num < 1e9:\n        return f'{b2}{num/1e6:.1f}{c2}m'\n    elif num < 1e12:\n        return f'{b2}{num/1e9:.1f}{c2}b'\n    else:",
        "detail": "rl.pufferlib.clean_pufferl",
        "documentation": {}
    },
    {
        "label": "duration",
        "kind": 2,
        "importPath": "rl.pufferlib.clean_pufferl",
        "description": "rl.pufferlib.clean_pufferl",
        "peekOfCode": "def duration(seconds):\n    seconds = int(seconds)\n    h = seconds // 3600\n    m = (seconds % 3600) // 60\n    s = seconds % 60\n    return f\"{b2}{h}{c2}h {b2}{m}{c2}m {b2}{s}{c2}s\" if h else f\"{b2}{m}{c2}m {b2}{s}{c2}s\" if m else f\"{b2}{s}{c2}s\"\ndef fmt_perf(name, time, uptime):\n    percent = 0 if uptime == 0 else int(100*time/uptime - 1e-5)\n    return f'{c1}{name}', duration(time), f'{b2}{percent:2d}%'\n# TODO: Add env name to print_dashboard",
        "detail": "rl.pufferlib.clean_pufferl",
        "documentation": {}
    },
    {
        "label": "fmt_perf",
        "kind": 2,
        "importPath": "rl.pufferlib.clean_pufferl",
        "description": "rl.pufferlib.clean_pufferl",
        "peekOfCode": "def fmt_perf(name, time, uptime):\n    percent = 0 if uptime == 0 else int(100*time/uptime - 1e-5)\n    return f'{c1}{name}', duration(time), f'{b2}{percent:2d}%'\n# TODO: Add env name to print_dashboard\ndef print_dashboard(env_name, utilization, global_step, epoch,\n        profile, losses, stats, msg, clear=False, max_stats=[0]):\n    console = Console()\n    if clear:\n        console.clear()\n    dashboard = Table(box=ROUND_OPEN, expand=True,",
        "detail": "rl.pufferlib.clean_pufferl",
        "documentation": {}
    },
    {
        "label": "print_dashboard",
        "kind": 2,
        "importPath": "rl.pufferlib.clean_pufferl",
        "description": "rl.pufferlib.clean_pufferl",
        "peekOfCode": "def print_dashboard(env_name, utilization, global_step, epoch,\n        profile, losses, stats, msg, clear=False, max_stats=[0]):\n    console = Console()\n    if clear:\n        console.clear()\n    dashboard = Table(box=ROUND_OPEN, expand=True,\n        show_header=False, border_style='bright_cyan')\n    table = Table(box=None, expand=True, show_header=False)\n    dashboard.add_row(table)\n    cpu_percent = np.mean(utilization.cpu_util)",
        "detail": "rl.pufferlib.clean_pufferl",
        "documentation": {}
    },
    {
        "label": "ROUND_OPEN",
        "kind": 5,
        "importPath": "rl.pufferlib.clean_pufferl",
        "description": "rl.pufferlib.clean_pufferl",
        "peekOfCode": "ROUND_OPEN = rich.box.Box(\n    \"\\n\"\n    \"  \\n\"\n    \"  \\n\"\n    \"  \\n\"\n    \"  \\n\"\n    \"  \\n\"\n    \"  \\n\"\n    \"\\n\"\n)",
        "detail": "rl.pufferlib.clean_pufferl",
        "documentation": {}
    },
    {
        "label": "c1",
        "kind": 5,
        "importPath": "rl.pufferlib.clean_pufferl",
        "description": "rl.pufferlib.clean_pufferl",
        "peekOfCode": "c1 = '[bright_cyan]'\nc2 = '[white]'\nc3 = '[cyan]'\nb1 = '[bright_cyan]'\nb2 = '[bright_white]'\ndef abbreviate(num):\n    if num < 1e3:\n        return f'{b2}{num:.0f}'\n    elif num < 1e6:\n        return f'{b2}{num/1e3:.1f}{c2}k'",
        "detail": "rl.pufferlib.clean_pufferl",
        "documentation": {}
    },
    {
        "label": "c2",
        "kind": 5,
        "importPath": "rl.pufferlib.clean_pufferl",
        "description": "rl.pufferlib.clean_pufferl",
        "peekOfCode": "c2 = '[white]'\nc3 = '[cyan]'\nb1 = '[bright_cyan]'\nb2 = '[bright_white]'\ndef abbreviate(num):\n    if num < 1e3:\n        return f'{b2}{num:.0f}'\n    elif num < 1e6:\n        return f'{b2}{num/1e3:.1f}{c2}k'\n    elif num < 1e9:",
        "detail": "rl.pufferlib.clean_pufferl",
        "documentation": {}
    },
    {
        "label": "c3",
        "kind": 5,
        "importPath": "rl.pufferlib.clean_pufferl",
        "description": "rl.pufferlib.clean_pufferl",
        "peekOfCode": "c3 = '[cyan]'\nb1 = '[bright_cyan]'\nb2 = '[bright_white]'\ndef abbreviate(num):\n    if num < 1e3:\n        return f'{b2}{num:.0f}'\n    elif num < 1e6:\n        return f'{b2}{num/1e3:.1f}{c2}k'\n    elif num < 1e9:\n        return f'{b2}{num/1e6:.1f}{c2}m'",
        "detail": "rl.pufferlib.clean_pufferl",
        "documentation": {}
    },
    {
        "label": "b1",
        "kind": 5,
        "importPath": "rl.pufferlib.clean_pufferl",
        "description": "rl.pufferlib.clean_pufferl",
        "peekOfCode": "b1 = '[bright_cyan]'\nb2 = '[bright_white]'\ndef abbreviate(num):\n    if num < 1e3:\n        return f'{b2}{num:.0f}'\n    elif num < 1e6:\n        return f'{b2}{num/1e3:.1f}{c2}k'\n    elif num < 1e9:\n        return f'{b2}{num/1e6:.1f}{c2}m'\n    elif num < 1e12:",
        "detail": "rl.pufferlib.clean_pufferl",
        "documentation": {}
    },
    {
        "label": "b2",
        "kind": 5,
        "importPath": "rl.pufferlib.clean_pufferl",
        "description": "rl.pufferlib.clean_pufferl",
        "peekOfCode": "b2 = '[bright_white]'\ndef abbreviate(num):\n    if num < 1e3:\n        return f'{b2}{num:.0f}'\n    elif num < 1e6:\n        return f'{b2}{num/1e3:.1f}{c2}k'\n    elif num < 1e9:\n        return f'{b2}{num/1e6:.1f}{c2}m'\n    elif num < 1e12:\n        return f'{b2}{num/1e9:.1f}{c2}b'",
        "detail": "rl.pufferlib.clean_pufferl",
        "documentation": {}
    },
    {
        "label": "abbreviate",
        "kind": 2,
        "importPath": "rl.pufferlib.dashboard",
        "description": "rl.pufferlib.dashboard",
        "peekOfCode": "def abbreviate(num):\n    if num < 1e3:\n        return f'{b2}{num:.0f}'\n    elif num < 1e6:\n        return f'{b2}{num/1e3:.1f}{c2}k'\n    elif num < 1e9:\n        return f'{b2}{num/1e6:.1f}{c2}m'\n    elif num < 1e12:\n        return f'{b2}{num/1e9:.1f}{c2}b'\n    else:",
        "detail": "rl.pufferlib.dashboard",
        "documentation": {}
    },
    {
        "label": "duration",
        "kind": 2,
        "importPath": "rl.pufferlib.dashboard",
        "description": "rl.pufferlib.dashboard",
        "peekOfCode": "def duration(seconds):\n    seconds = int(seconds)\n    h = seconds // 3600\n    m = (seconds % 3600) // 60\n    s = seconds % 60\n    return f\"{b2}{h}{c2}h {b2}{m}{c2}m {b2}{s}{c2}s\" if h else f\"{b2}{m}{c2}m {b2}{s}{c2}s\" if m else f\"{b2}{s}{c2}s\"\ndef fmt_perf(name, time, uptime):\n    percent = 0 if uptime == 0 else int(100*time/uptime - 1e-5)\n    return f'{c1}{name}', duration(time), f'{b2}{percent:2d}%'\nlast_stats = {}",
        "detail": "rl.pufferlib.dashboard",
        "documentation": {}
    },
    {
        "label": "fmt_perf",
        "kind": 2,
        "importPath": "rl.pufferlib.dashboard",
        "description": "rl.pufferlib.dashboard",
        "peekOfCode": "def fmt_perf(name, time, uptime):\n    percent = 0 if uptime == 0 else int(100*time/uptime - 1e-5)\n    return f'{c1}{name}', duration(time), f'{b2}{percent:2d}%'\nlast_stats = {}\ndef print_dashboard(config, utilization, global_step, epoch,\n        profile, losses, stats, msg, clear=False, max_stats=[0]):\n    console = Console()\n    if clear:\n        console.clear()\n    env_name = config.env",
        "detail": "rl.pufferlib.dashboard",
        "documentation": {}
    },
    {
        "label": "print_dashboard",
        "kind": 2,
        "importPath": "rl.pufferlib.dashboard",
        "description": "rl.pufferlib.dashboard",
        "peekOfCode": "def print_dashboard(config, utilization, global_step, epoch,\n        profile, losses, stats, msg, clear=False, max_stats=[0]):\n    console = Console()\n    if clear:\n        console.clear()\n    env_name = config.env\n    dashboard = Table(box=ROUND_OPEN, expand=True,\n        show_header=False, border_style='bright_cyan')\n    table = Table(box=None, expand=True, show_header=False)\n    dashboard.add_row(table)",
        "detail": "rl.pufferlib.dashboard",
        "documentation": {}
    },
    {
        "label": "ROUND_OPEN",
        "kind": 5,
        "importPath": "rl.pufferlib.dashboard",
        "description": "rl.pufferlib.dashboard",
        "peekOfCode": "ROUND_OPEN = rich.box.Box(\n    \"\\n\"\n    \"  \\n\"\n    \"  \\n\"\n    \"  \\n\"\n    \"  \\n\"\n    \"  \\n\"\n    \"  \\n\"\n    \"\\n\"\n)",
        "detail": "rl.pufferlib.dashboard",
        "documentation": {}
    },
    {
        "label": "c1",
        "kind": 5,
        "importPath": "rl.pufferlib.dashboard",
        "description": "rl.pufferlib.dashboard",
        "peekOfCode": "c1 = '[bright_cyan]'\nc2 = '[white]'\nc3 = '[cyan]'\nb1 = '[bright_cyan]'\nb2 = '[bright_white]'\ndef abbreviate(num):\n    if num < 1e3:\n        return f'{b2}{num:.0f}'\n    elif num < 1e6:\n        return f'{b2}{num/1e3:.1f}{c2}k'",
        "detail": "rl.pufferlib.dashboard",
        "documentation": {}
    },
    {
        "label": "c2",
        "kind": 5,
        "importPath": "rl.pufferlib.dashboard",
        "description": "rl.pufferlib.dashboard",
        "peekOfCode": "c2 = '[white]'\nc3 = '[cyan]'\nb1 = '[bright_cyan]'\nb2 = '[bright_white]'\ndef abbreviate(num):\n    if num < 1e3:\n        return f'{b2}{num:.0f}'\n    elif num < 1e6:\n        return f'{b2}{num/1e3:.1f}{c2}k'\n    elif num < 1e9:",
        "detail": "rl.pufferlib.dashboard",
        "documentation": {}
    },
    {
        "label": "c3",
        "kind": 5,
        "importPath": "rl.pufferlib.dashboard",
        "description": "rl.pufferlib.dashboard",
        "peekOfCode": "c3 = '[cyan]'\nb1 = '[bright_cyan]'\nb2 = '[bright_white]'\ndef abbreviate(num):\n    if num < 1e3:\n        return f'{b2}{num:.0f}'\n    elif num < 1e6:\n        return f'{b2}{num/1e3:.1f}{c2}k'\n    elif num < 1e9:\n        return f'{b2}{num/1e6:.1f}{c2}m'",
        "detail": "rl.pufferlib.dashboard",
        "documentation": {}
    },
    {
        "label": "b1",
        "kind": 5,
        "importPath": "rl.pufferlib.dashboard",
        "description": "rl.pufferlib.dashboard",
        "peekOfCode": "b1 = '[bright_cyan]'\nb2 = '[bright_white]'\ndef abbreviate(num):\n    if num < 1e3:\n        return f'{b2}{num:.0f}'\n    elif num < 1e6:\n        return f'{b2}{num/1e3:.1f}{c2}k'\n    elif num < 1e9:\n        return f'{b2}{num/1e6:.1f}{c2}m'\n    elif num < 1e12:",
        "detail": "rl.pufferlib.dashboard",
        "documentation": {}
    },
    {
        "label": "b2",
        "kind": 5,
        "importPath": "rl.pufferlib.dashboard",
        "description": "rl.pufferlib.dashboard",
        "peekOfCode": "b2 = '[bright_white]'\ndef abbreviate(num):\n    if num < 1e3:\n        return f'{b2}{num:.0f}'\n    elif num < 1e6:\n        return f'{b2}{num/1e3:.1f}{c2}k'\n    elif num < 1e9:\n        return f'{b2}{num/1e6:.1f}{c2}m'\n    elif num < 1e12:\n        return f'{b2}{num/1e9:.1f}{c2}b'",
        "detail": "rl.pufferlib.dashboard",
        "documentation": {}
    },
    {
        "label": "last_stats",
        "kind": 5,
        "importPath": "rl.pufferlib.dashboard",
        "description": "rl.pufferlib.dashboard",
        "peekOfCode": "last_stats = {}\ndef print_dashboard(config, utilization, global_step, epoch,\n        profile, losses, stats, msg, clear=False, max_stats=[0]):\n    console = Console()\n    if clear:\n        console.clear()\n    env_name = config.env\n    dashboard = Table(box=ROUND_OPEN, expand=True,\n        show_header=False, border_style='bright_cyan')\n    table = Table(box=None, expand=True, show_header=False)",
        "detail": "rl.pufferlib.dashboard",
        "documentation": {}
    },
    {
        "label": "evaluate",
        "kind": 2,
        "importPath": "rl.pufferlib.evaluate",
        "description": "rl.pufferlib.evaluate",
        "peekOfCode": "def evaluate(cfg: OmegaConf):\n    device = cfg.framework.pufferlib.device\n    vecenv = make_vecenv(cfg, num_envs=cfg.eval.num_envs)\n    num_envs = len(vecenv.envs)\n    policy = load_policy_from_uri(cfg.eval.policy_uri, cfg)\n    baselines = [load_policy_from_uri(b, cfg) for b in cfg.eval.baseline_uris]\n    policy_agent_pct = cfg.eval.policy_agents_pct\n    if len(baselines) == 0:\n        policy_agent_pct = 1.0\n    num_baselines = len(baselines)",
        "detail": "rl.pufferlib.evaluate",
        "documentation": {}
    },
    {
        "label": "Experience",
        "kind": 6,
        "importPath": "rl.pufferlib.experience",
        "description": "rl.pufferlib.experience",
        "peekOfCode": "class Experience:\n    '''Flat tensor storage and array views for faster indexing'''\n    def __init__(self, batch_size, bptt_horizon, minibatch_size, obs_shape, obs_dtype, atn_shape,\n                 cpu_offload=False, device='cuda', lstm=None, lstm_total_agents=0):\n        if minibatch_size is None:\n            minibatch_size = batch_size\n        obs_dtype = pufferlib.pytorch.numpy_to_torch_dtype_dict[obs_dtype]\n        pin = device == 'cuda' and cpu_offload\n        obs_device = device if not pin else 'cpu'\n        self.obs=torch.zeros(batch_size, *obs_shape, dtype=obs_dtype,",
        "detail": "rl.pufferlib.experience",
        "documentation": {}
    },
    {
        "label": "play",
        "kind": 2,
        "importPath": "rl.pufferlib.play",
        "description": "rl.pufferlib.play",
        "peekOfCode": "def play(cfg: OmegaConf):\n    device = cfg.framework.pufferlib.device\n    vecenv = make_vecenv(cfg, num_envs=1, render_mode=\"human\")\n    policy = load_policy_from_uri(cfg.eval.policy_uri, cfg)\n    agents_count = cfg.env.game.num_agents\n    obs, _ = vecenv.reset()\n    env = vecenv.envs[0]\n    renderer = MettaGridRaylibRenderer(env._c_env.map_width(), env._c_env.map_height(), cfg.env)\n    policy_rnn_state = None\n    total_rewards = np.zeros(vecenv.num_agents)",
        "detail": "rl.pufferlib.play",
        "documentation": {}
    },
    {
        "label": "load_policy_from_file",
        "kind": 2,
        "importPath": "rl.pufferlib.policy",
        "description": "rl.pufferlib.policy",
        "peekOfCode": "def load_policy_from_file(path: str, device: str):\n    assert path.endswith('.pt'), f\"Policy file {path} does not have a .pt extension\"\n    return torch.load(path, map_location=device, weights_only=False)\ndef load_policy_from_wandb(uri: str, cfg: OmegaConf):\n    init_wandb(cfg)\n    artifact = wandb.use_artifact(uri[len(\"wandb://\"):], type=\"model\")\n    return load_policy_from_file(artifact.file(\n        root=os.path.join(cfg.data_dir, \"artifacts\")\n    ), cfg.framework.pufferlib.device)\ndef load_policy_from_dir(path: str, device: str):",
        "detail": "rl.pufferlib.policy",
        "documentation": {}
    },
    {
        "label": "load_policy_from_wandb",
        "kind": 2,
        "importPath": "rl.pufferlib.policy",
        "description": "rl.pufferlib.policy",
        "peekOfCode": "def load_policy_from_wandb(uri: str, cfg: OmegaConf):\n    init_wandb(cfg)\n    artifact = wandb.use_artifact(uri[len(\"wandb://\"):], type=\"model\")\n    return load_policy_from_file(artifact.file(\n        root=os.path.join(cfg.data_dir, \"artifacts\")\n    ), cfg.framework.pufferlib.device)\ndef load_policy_from_dir(path: str, device: str):\n    trainer_state = torch.load(os.path.join(path, 'trainer_state.pt'))\n    model_path = os.path.join(path, trainer_state[\"model_name\"])\n    return load_policy_from_file(model_path, device)",
        "detail": "rl.pufferlib.policy",
        "documentation": {}
    },
    {
        "label": "load_policy_from_dir",
        "kind": 2,
        "importPath": "rl.pufferlib.policy",
        "description": "rl.pufferlib.policy",
        "peekOfCode": "def load_policy_from_dir(path: str, device: str):\n    trainer_state = torch.load(os.path.join(path, 'trainer_state.pt'))\n    model_path = os.path.join(path, trainer_state[\"model_name\"])\n    return load_policy_from_file(model_path, device)\ndef load_policy_from_uri(uri: str, cfg: OmegaConf):\n    if uri.startswith(\"wandb://\"):\n        return load_policy_from_wandb(uri, cfg)\n    elif uri.endswith(\".pt\"):\n        return load_policy_from_file(uri, cfg.framework.pufferlib.device)\n    else:",
        "detail": "rl.pufferlib.policy",
        "documentation": {}
    },
    {
        "label": "load_policy_from_uri",
        "kind": 2,
        "importPath": "rl.pufferlib.policy",
        "description": "rl.pufferlib.policy",
        "peekOfCode": "def load_policy_from_uri(uri: str, cfg: OmegaConf):\n    if uri.startswith(\"wandb://\"):\n        return load_policy_from_wandb(uri, cfg)\n    elif uri.endswith(\".pt\"):\n        return load_policy_from_file(uri, cfg.framework.pufferlib.device)\n    else:\n        return load_policy_from_dir(uri, cfg.framework.pufferlib.device)",
        "detail": "rl.pufferlib.policy",
        "documentation": {}
    },
    {
        "label": "Profile",
        "kind": 6,
        "importPath": "rl.pufferlib.profile",
        "description": "rl.pufferlib.profile",
        "peekOfCode": "class Profile:\n    SPS: ... = 0\n    uptime: ... = 0\n    remaining: ... = 0\n    eval_time: ... = 0\n    env_time: ... = 0\n    eval_forward_time: ... = 0\n    eval_misc_time: ... = 0\n    train_time: ... = 0\n    train_forward_time: ... = 0",
        "detail": "rl.pufferlib.profile",
        "documentation": {}
    },
    {
        "label": "Recurrent",
        "kind": 6,
        "importPath": "rl.pufferlib.puffer_agent_wrapper",
        "description": "rl.pufferlib.puffer_agent_wrapper",
        "peekOfCode": "class Recurrent(pufferlib.models.LSTMWrapper):\n    def __init__(self, env, policy, input_size=512, hidden_size=512, num_layers=1):\n        super().__init__(env, policy, input_size, hidden_size, num_layers)\nclass PufferAgentWrapper(nn.Module):\n    def __init__(self, agent: MettaAgent, env: PettingZooPufferEnv):\n        super().__init__()\n        # self.dtype = pufferlib.pytorch.nativize_dtype(env.emulated)\n        # xcxc\n        self.atn_type = nn.Linear(agent.decoder_out_size(), env.action_space[0].n)\n        self.atn_param = nn.Linear(agent.decoder_out_size(), env.action_space[1].n)",
        "detail": "rl.pufferlib.puffer_agent_wrapper",
        "documentation": {}
    },
    {
        "label": "PufferAgentWrapper",
        "kind": 6,
        "importPath": "rl.pufferlib.puffer_agent_wrapper",
        "description": "rl.pufferlib.puffer_agent_wrapper",
        "peekOfCode": "class PufferAgentWrapper(nn.Module):\n    def __init__(self, agent: MettaAgent, env: PettingZooPufferEnv):\n        super().__init__()\n        # self.dtype = pufferlib.pytorch.nativize_dtype(env.emulated)\n        # xcxc\n        self.atn_type = nn.Linear(agent.decoder_out_size(), env.action_space[0].n)\n        self.atn_param = nn.Linear(agent.decoder_out_size(), env.action_space[1].n)\n        self._agent = agent\n        print(self)\n    def forward(self, obs):",
        "detail": "rl.pufferlib.puffer_agent_wrapper",
        "documentation": {}
    },
    {
        "label": "make_policy",
        "kind": 2,
        "importPath": "rl.pufferlib.puffer_agent_wrapper",
        "description": "rl.pufferlib.puffer_agent_wrapper",
        "peekOfCode": "def make_policy(env: PufferEnv, cfg: OmegaConf):\n    cfg.agent.observation_encoders.grid_obs.feature_names = env._grid_env.grid_features()\n    cfg.agent.observation_encoders.global_vars.feature_names = []\n    obs_space = gym.spaces.Dict({\n        \"grid_obs\": env.single_observation_space,\n        \"global_vars\": gym.spaces.Box(\n            low=-np.inf, high=np.inf,\n            shape=[ 0 ],\n            dtype=np.int32)\n    })",
        "detail": "rl.pufferlib.puffer_agent_wrapper",
        "documentation": {}
    },
    {
        "label": "train",
        "kind": 2,
        "importPath": "rl.pufferlib.train",
        "description": "rl.pufferlib.train",
        "peekOfCode": "def train(cfg: OmegaConf, load_checkpoint: bool = True):\n    train_start = time.time()\n    pcfg = cfg.framework.pufferlib\n    target_batch_size = pcfg.train.forward_pass_minibatch_target_size // cfg.env.game.num_agents\n    if target_batch_size < 2: # pufferlib bug requires batch size >= 2\n        target_batch_size = 2\n    batch_size = (target_batch_size // pcfg.train.num_workers) * pcfg.train.num_workers\n    vecenv = make_vecenv(\n        cfg,\n        num_envs = batch_size * pcfg.train.async_factor,",
        "detail": "rl.pufferlib.train",
        "documentation": {}
    },
    {
        "label": "Utilization",
        "kind": 6,
        "importPath": "rl.pufferlib.utilization",
        "description": "rl.pufferlib.utilization",
        "peekOfCode": "class Utilization(Thread):\n    def __init__(self, delay=1, maxlen=20):\n        super().__init__()\n        self.cpu_mem = deque(maxlen=maxlen)\n        self.cpu_util = deque(maxlen=maxlen)\n        self.gpu_util = deque(maxlen=maxlen)\n        self.gpu_mem = deque(maxlen=maxlen)\n        self.delay = delay\n        self.stopped = False\n        self.start()",
        "detail": "rl.pufferlib.utilization",
        "documentation": {}
    },
    {
        "label": "make_env_func",
        "kind": 2,
        "importPath": "rl.pufferlib.vecenv",
        "description": "rl.pufferlib.vecenv",
        "peekOfCode": "def make_env_func(cfg: OmegaConf, render_mode='rgb_array'):\n    env = hydra.utils.instantiate(cfg, render_mode=render_mode)\n    env.emulated = None\n    env.single_observation_space = env.observation_space\n    env.single_action_space = env.action_space\n    env.num_agents = env.player_count\n    return env\ndef make_vecenv(cfg: OmegaConf, num_envs=1, batch_size=None, num_workers=1, render_mode=None, **kwargs):\n    pcfg = cfg.framework.pufferlib\n    vec = pcfg.vectorization",
        "detail": "rl.pufferlib.vecenv",
        "documentation": {}
    },
    {
        "label": "make_vecenv",
        "kind": 2,
        "importPath": "rl.pufferlib.vecenv",
        "description": "rl.pufferlib.vecenv",
        "peekOfCode": "def make_vecenv(cfg: OmegaConf, num_envs=1, batch_size=None, num_workers=1, render_mode=None, **kwargs):\n    pcfg = cfg.framework.pufferlib\n    vec = pcfg.vectorization\n    if vec == 'serial' or num_workers == 1:\n        vec = pufferlib.vector.Serial\n    elif vec == 'multiprocessing':\n        vec = pufferlib.vector.Multiprocessing\n    elif vec == 'ray':\n        vec = pufferlib.vector.Ray\n    else:",
        "detail": "rl.pufferlib.vecenv",
        "documentation": {}
    },
    {
        "label": "init_wandb",
        "kind": 2,
        "importPath": "rl.wandb.wandb",
        "description": "rl.wandb.wandb",
        "peekOfCode": "def init_wandb(cfg, resume=True, name=None):\n    #os.environ[\"WANDB_SILENT\"] = \"true\"\n    if wandb.run is not None:\n        print(\"wandb.init() has already been called, ignoring.\")\n    wandb.init(\n        id=cfg.experiment or wandb.util.generate_id(),\n        project=cfg.wandb.project,\n        entity=cfg.wandb.entity,\n        config=OmegaConf.to_container(cfg, resolve=True),\n        group=cfg.wandb.group,",
        "detail": "rl.wandb.wandb",
        "documentation": {}
    },
    {
        "label": "EvaluationResult",
        "kind": 6,
        "importPath": "rl.rl_framework",
        "description": "rl.rl_framework",
        "peekOfCode": "class EvaluationResult(NamedTuple):\n    reward: float\n    frames: List\nclass RLFramework():\n    def __init__(self, cfg):\n        self.cfg = cfg\n    def train(self):\n        raise NotImplementedError\n    def evaluate(self) -> EvaluationResult:\n        raise NotImplementedError",
        "detail": "rl.rl_framework",
        "documentation": {}
    },
    {
        "label": "RLFramework",
        "kind": 6,
        "importPath": "rl.rl_framework",
        "description": "rl.rl_framework",
        "peekOfCode": "class RLFramework():\n    def __init__(self, cfg):\n        self.cfg = cfg\n    def train(self):\n        raise NotImplementedError\n    def evaluate(self) -> EvaluationResult:\n        raise NotImplementedError\n    def close(self):\n        pass",
        "detail": "rl.rl_framework",
        "documentation": {}
    },
    {
        "label": "MockObsPredictor",
        "kind": 6,
        "importPath": "tests.test_predicting_actor_critic",
        "description": "tests.test_predicting_actor_critic",
        "peekOfCode": "class MockObsPredictor(nn.Module):\n    def __init__(self, obs_shape):\n        super().__init__()\n        self.obs_shape = obs_shape\n        self.return_value = torch.zeros(self.obs_shape)\n    def forward(self, x):\n        return self.return_value\nclass MockEncoder(Encoder):\n    def __init__(self, cfg, obs_space):\n        super().__init__(cfg)",
        "detail": "tests.test_predicting_actor_critic",
        "documentation": {}
    },
    {
        "label": "MockEncoder",
        "kind": 6,
        "importPath": "tests.test_predicting_actor_critic",
        "description": "tests.test_predicting_actor_critic",
        "peekOfCode": "class MockEncoder(Encoder):\n    def __init__(self, cfg, obs_space):\n        super().__init__(cfg)\n        self.obs_shape = obs_space[\"obs\"].shape\n        self.obs_size = np.prod(self.obs_shape)\n    def forward(self, obs_dict):\n        return torch.zeros((obs_dict[\"obs\"].shape[0], self.obs_size))\n    def get_out_size(self) -> int:\n        return self.obs_size\nclass TestPredictingActorCritic(unittest.TestCase):",
        "detail": "tests.test_predicting_actor_critic",
        "documentation": {}
    },
    {
        "label": "TestPredictingActorCritic",
        "kind": 6,
        "importPath": "tests.test_predicting_actor_critic",
        "description": "tests.test_predicting_actor_critic",
        "peekOfCode": "class TestPredictingActorCritic(unittest.TestCase):\n    def setUp(self):\n        sf_context = SampleFactoryContext()\n        sf_context.model_factory.register_encoder_factory(MockEncoder)\n        self.cfg = SimpleNamespace(\n            normalize_input=False,\n            obs_subtract_mean=False,\n            obs_scale=1,\n            normalize_returns=False,\n            nonlinearity=\"relu\",",
        "detail": "tests.test_predicting_actor_critic",
        "documentation": {}
    },
    {
        "label": "make_env",
        "kind": 2,
        "importPath": "tools.autotune",
        "description": "tools.autotune",
        "peekOfCode": "def make_env():\n    global env_config\n    env = hydra.utils.instantiate(env_config.env, render_mode=\"human\")\n    env.emulated = None\n    env.single_observation_space = env.observation_space\n    env.single_action_space = env.action_space\n    env.num_agents = env.player_count\n    env.done = False\n    return env\n@hydra.main(version_base=None, config_path=\"../configs\", config_name=\"config\")",
        "detail": "tools.autotune",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "tools.autotune",
        "description": "tools.autotune",
        "peekOfCode": "def main(cfg):\n    global env_config\n    env_config = cfg\n    pufferlib.vector.autotune(make_env, batch_size=16320//20, max_envs=1024, max_env_ram_gb=64)\n    # pufferlib.vector.autotune(make_env, batch_size=16384//20)\nif __name__ == \"__main__\":\n    main()",
        "detail": "tools.autotune",
        "documentation": {}
    },
    {
        "label": "dump_files",
        "kind": 2,
        "importPath": "tools.dump_src",
        "description": "tools.dump_src",
        "peekOfCode": "def dump_files(paths, extensions):\n    for path in paths:\n        for root, _, files in os.walk(path):\n            for file in files:\n                if extensions is None or len(extensions) == 0 or any(file.endswith(ext) for ext in extensions):\n                    file_path = os.path.join(root, file)\n                    with open(file_path, 'r') as infile:\n                        print(f'<file: {file_path}>')\n                        print(infile.read())\n                        print('</file>')",
        "detail": "tools.dump_src",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "tools.run",
        "description": "tools.run",
        "peekOfCode": "def main(cfg):\n    traceback.install(show_locals=False)\n    print(OmegaConf.to_yaml(cfg))\n    if cfg.wandb.track:\n        init_wandb(cfg)\n    try:\n        if cfg.cmd == \"train\":\n            train(cfg)\n        if cfg.cmd == \"evaluate\":\n            evaluate(cfg)",
        "detail": "tools.run",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "tools.run_sweep",
        "description": "tools.run_sweep",
        "peekOfCode": "def main(cfg):\n    traceback.install(show_locals=False)\n    print(OmegaConf.to_yaml(cfg))\n    try:\n        from rl.carbs.carb_sweep import run_sweep\n        run_sweep(cfg)\n    except KeyboardInterrupt:\n        os._exit(0)\nif __name__ == \"__main__\":\n    main()",
        "detail": "tools.run_sweep",
        "documentation": {}
    },
    {
        "label": "generate_model_card",
        "kind": 2,
        "importPath": "util.hugging_face",
        "description": "util.hugging_face",
        "peekOfCode": "def generate_model_card(\n    dir_path: str,\n    algo: str,\n    env: str,\n    repo_id: str,\n    rewards: list = None,\n    enjoy_name: str = None,\n    train_name: str = None,\n):\n    readme_path = os.path.join(dir_path, \"README.md\")",
        "detail": "util.hugging_face",
        "documentation": {}
    },
    {
        "label": "push_to_hf",
        "kind": 2,
        "importPath": "util.hugging_face",
        "description": "util.hugging_face",
        "peekOfCode": "def push_to_hf(dir_path: str, repo_name: str):\n    repo_url = HfApi().create_repo(\n        repo_id=repo_name,\n        private=False,\n        exist_ok=True,\n    )\n    upload_folder(\n        repo_id=repo_name,\n        folder_path=dir_path,\n        path_in_repo=\".\",",
        "detail": "util.hugging_face",
        "documentation": {}
    },
    {
        "label": "load_from_hf",
        "kind": 2,
        "importPath": "util.hugging_face",
        "description": "util.hugging_face",
        "peekOfCode": "def load_from_hf(dir_path: str, repo_id: str):\n    temp = repo_id.split(\"/\")\n    repo_name = temp[1]\n    local_dir = os.path.join(dir_path, repo_name)\n    Repository(local_dir, repo_id)\n    log.info(f\"The repository {repo_id} has been cloned to {local_dir}\")",
        "detail": "util.hugging_face",
        "documentation": {}
    },
    {
        "label": "generate_replay_video",
        "kind": 2,
        "importPath": "util.replay",
        "description": "util.replay",
        "peekOfCode": "def generate_replay_video(path: str, frames: list, fps: int):\n    if not path.endswith(\".mp4\"):\n        path += \".mp4\"\n    tmp_name = os.path.join(project_tmp_dir(), os.path.basename(path))\n    if frames[0].shape[0] == 3:\n        frame_size = (frames[0].shape[2], frames[0].shape[1])\n    else:\n        frame_size = (frames[0].shape[1], frames[0].shape[0])\n    resize = False\n    if min(frame_size) < MIN_FRAME_SIZE:",
        "detail": "util.replay",
        "documentation": {}
    },
    {
        "label": "generate_replay_gif",
        "kind": 2,
        "importPath": "util.replay",
        "description": "util.replay",
        "peekOfCode": "def generate_replay_gif(path: str, frames: list, fps: int):\n    imageio.mimsave(path, frames, fps=fps)\n    log.debug(f\"Replay gif saved to {path}!\")",
        "detail": "util.replay",
        "documentation": {}
    },
    {
        "label": "MIN_FRAME_SIZE",
        "kind": 5,
        "importPath": "util.replay",
        "description": "util.replay",
        "peekOfCode": "MIN_FRAME_SIZE = 180\ndef generate_replay_video(path: str, frames: list, fps: int):\n    if not path.endswith(\".mp4\"):\n        path += \".mp4\"\n    tmp_name = os.path.join(project_tmp_dir(), os.path.basename(path))\n    if frames[0].shape[0] == 3:\n        frame_size = (frames[0].shape[2], frames[0].shape[1])\n    else:\n        frame_size = (frames[0].shape[1], frames[0].shape[0])\n    resize = False",
        "detail": "util.replay",
        "documentation": {}
    },
    {
        "label": "sample_config",
        "kind": 2,
        "importPath": "util.sample_config",
        "description": "util.sample_config",
        "peekOfCode": "def sample_config(value):\n    if isinstance(value, int):\n        return value\n    if isinstance(value, float):\n        return value\n    if isinstance(value, DictConfig):\n        return {\n            key: sample_config(value)\n            for key, value in value.items()\n        }",
        "detail": "util.sample_config",
        "documentation": {}
    },
    {
        "label": "safe_float",
        "kind": 2,
        "importPath": "util.stats",
        "description": "util.stats",
        "peekOfCode": "def safe_float(value):\n    try:\n        return float(value)\n    except (ValueError, TypeError):\n        return np.nan\ndef safe_diff(a, b):\n    a, b = safe_float(a), safe_float(b)\n    if np.isnan(a) or np.isnan(b):\n        return \"-\"\n    return a - b",
        "detail": "util.stats",
        "documentation": {}
    },
    {
        "label": "safe_diff",
        "kind": 2,
        "importPath": "util.stats",
        "description": "util.stats",
        "peekOfCode": "def safe_diff(a, b):\n    a, b = safe_float(a), safe_float(b)\n    if np.isnan(a) or np.isnan(b):\n        return \"-\"\n    return a - b\ndef safe_percent_diff(a, b):\n    a, b = safe_float(a), safe_float(b)\n    if np.isnan(a) or np.isnan(b) or b == 0:\n        return \"-\"\n    return (a - b) / b * 100",
        "detail": "util.stats",
        "documentation": {}
    },
    {
        "label": "safe_percent_diff",
        "kind": 2,
        "importPath": "util.stats",
        "description": "util.stats",
        "peekOfCode": "def safe_percent_diff(a, b):\n    a, b = safe_float(a), safe_float(b)\n    if np.isnan(a) or np.isnan(b) or b == 0:\n        return \"-\"\n    return (a - b) / b * 100\ndef safe_stdev_diff(a, b, stdev):\n    a, b, stdev = safe_float(a), safe_float(b), safe_float(stdev)\n    if np.isnan(a) or np.isnan(b) or np.isnan(stdev) or stdev == 0:\n        return \"-\"\n    return (a - b) / stdev",
        "detail": "util.stats",
        "documentation": {}
    },
    {
        "label": "safe_stdev_diff",
        "kind": 2,
        "importPath": "util.stats",
        "description": "util.stats",
        "peekOfCode": "def safe_stdev_diff(a, b, stdev):\n    a, b, stdev = safe_float(a), safe_float(b), safe_float(stdev)\n    if np.isnan(a) or np.isnan(b) or np.isnan(stdev) or stdev == 0:\n        return \"-\"\n    return (a - b) / stdev\ndef get_stat_value(stat):\n    if isinstance(stat, dict):\n        return safe_float(stat.get('sum', np.nan) / stat.get('count', 1))\n    return safe_float(stat)\ndef print_policy_stats(policy_stats):",
        "detail": "util.stats",
        "documentation": {}
    },
    {
        "label": "get_stat_value",
        "kind": 2,
        "importPath": "util.stats",
        "description": "util.stats",
        "peekOfCode": "def get_stat_value(stat):\n    if isinstance(stat, dict):\n        return safe_float(stat.get('sum', np.nan) / stat.get('count', 1))\n    return safe_float(stat)\ndef print_policy_stats(policy_stats):\n    # Create a DataFrame with policies as columns\n    df = pd.DataFrame({f\"Policy {i+1}\": {k: get_stat_value(v) for k, v in policy.items()}\n                       for i, policy in enumerate(policy_stats)})\n    # Sort the DataFrame index (stats) alphabetically\n    df = df.sort_index()",
        "detail": "util.stats",
        "documentation": {}
    },
    {
        "label": "print_policy_stats",
        "kind": 2,
        "importPath": "util.stats",
        "description": "util.stats",
        "peekOfCode": "def print_policy_stats(policy_stats):\n    # Create a DataFrame with policies as columns\n    df = pd.DataFrame({f\"Policy {i+1}\": {k: get_stat_value(v) for k, v in policy.items()}\n                       for i, policy in enumerate(policy_stats)})\n    # Sort the DataFrame index (stats) alphabetically\n    df = df.sort_index()\n    # Calculate differences from Policy 2\n    if len(policy_stats) > 1:\n        base_policy = df['Policy 2']\n        df['Policy 1 abs diff'] = df.apply(lambda row: safe_diff(row['Policy 1'], row['Policy 2']), axis=1)",
        "detail": "util.stats",
        "documentation": {}
    },
    {
        "label": "app",
        "kind": 5,
        "importPath": "webui.server",
        "description": "webui.server",
        "peekOfCode": "app = FastAPI()\n# Set up logging\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n@app.get(\"/\", response_class=HTMLResponse)\nasync def get_client():\n    try:\n        with open(\"webui/client.html\", \"r\") as file:\n            html_content = file.read()\n        return HTMLResponse(content=html_content)",
        "detail": "webui.server",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "webui.server",
        "description": "webui.server",
        "peekOfCode": "logger = logging.getLogger(__name__)\n@app.get(\"/\", response_class=HTMLResponse)\nasync def get_client():\n    try:\n        with open(\"webui/client.html\", \"r\") as file:\n            html_content = file.read()\n        return HTMLResponse(content=html_content)\n    except FileNotFoundError:\n        raise HTTPException(status_code=404, detail=\"Client HTML file not found\")\n@app.websocket(\"/ws\")",
        "detail": "webui.server",
        "documentation": {}
    },
    {
        "label": "FeatureMasker",
        "kind": 6,
        "importPath": "wrapper.feature_masker",
        "description": "wrapper.feature_masker",
        "peekOfCode": "class FeatureMasker(gym.Wrapper):\n    def __init__(self, env, masked_features):\n        super().__init__(env)\n        self._masked_grid_obs = [\n            self.env.unwrapped.grid_features.index(feature)\n            for feature in masked_features.grid_obs\n        ]\n        self._grid_obs_mask = np.ones(\n            self.env.unwrapped.observation_space[\"grid_obs\"].shape,\n            dtype=np.uint8)",
        "detail": "wrapper.feature_masker",
        "documentation": {}
    },
    {
        "label": "Kinship",
        "kind": 6,
        "importPath": "wrapper.kinship",
        "description": "wrapper.kinship",
        "peekOfCode": "class Kinship(gym.Wrapper):\n    def __init__(self, team_size: int, team_reward: float, env: gym.Env):\n        super().__init__(env)\n        self._team_size = team_size\n        self._team_reward = team_reward\n        self._num_agents = self.env.unwrapped.player_count\n        self._num_teams = int(math.ceil(self._num_agents / self._team_size))\n        self._agent_team = np.array([\n            agent // self._team_size for agent in range(self._num_agents)])\n        self._team_to_agents = {",
        "detail": "wrapper.kinship",
        "documentation": {}
    },
    {
        "label": "LastActionTracker",
        "kind": 6,
        "importPath": "wrapper.last_action_tracker",
        "description": "wrapper.last_action_tracker",
        "peekOfCode": "class LastActionTracker(gym.Wrapper):\n    def __init__(self, env):\n        super(LastActionTracker, self).__init__(env)\n        self._last_actions = None\n    def reset(self, **kwargs):\n        self._last_actions = np.zeros((self.unwrapped.player_count, 2), dtype=np.int32)\n        obs, infos = self.env.reset(**kwargs)\n        return self._augment_observations(obs), infos\n    def step(self, actions):\n        obs, rewards, terms, truncs, infos = self.env.step(actions)",
        "detail": "wrapper.last_action_tracker",
        "documentation": {}
    },
    {
        "label": "PettingZooEnvWrapper",
        "kind": 6,
        "importPath": "wrapper.petting_zoo",
        "description": "wrapper.petting_zoo",
        "peekOfCode": "class PettingZooEnvWrapper(pettingzoo.ParallelEnv):\n    def __init__(self, gym_env: gym.Env, render_mode='rgb_array'):\n        super().__init__()\n        self._gym_env = gym_env\n        self.possible_agents = [i+1 for i in range(self.num_agents)]\n        # agents gets manipulated\n        self.agents = [i+1 for i in range(self.num_agents)]\n        self.render_mode = render_mode\n    @property\n    def num_agents(self):",
        "detail": "wrapper.petting_zoo",
        "documentation": {}
    },
    {
        "label": "Replay",
        "kind": 6,
        "importPath": "wrapper.replay",
        "description": "wrapper.replay",
        "peekOfCode": "class Replay():\n    def __init__(self, filename):\n        self.filename = filename\n        self.data = {\n            \"steps\": [],\n            \"global_obs\": [],\n        }\n    def record_step(self, actions, obs, rewards, infos, global_obs):\n        self.data[\"global_obs\"].append(global_obs)\n    def close(self):",
        "detail": "wrapper.replay",
        "documentation": {}
    },
    {
        "label": "RewardTracker",
        "kind": 6,
        "importPath": "wrapper.reward_tracker",
        "description": "wrapper.reward_tracker",
        "peekOfCode": "class RewardTracker(gym.Wrapper):\n    def __init__(self, env):\n        super(RewardTracker, self).__init__(env)\n        self._last_rewards = None\n    def reset(self, **kwargs):\n        self._last_rewards = np.zeros(self.unwrapped.player_count, dtype=np.float32)\n        obs, infos = self.env.reset(**kwargs)\n        return self._augment_observations(obs), infos\n    def step(self, actions):\n        obs, rewards, terms, truncs, infos = self.env.step(actions)",
        "detail": "wrapper.reward_tracker",
        "documentation": {}
    }
]