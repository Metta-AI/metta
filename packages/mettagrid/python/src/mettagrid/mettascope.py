"""
Mettascope Python bindings wrapper.

This module provides access to the mettascope visualization tool through mettagrid.
Usage:
    import mettagrid.mettascope
    mettagrid.mettascope.init(data_dir, replay)
    mettagrid.mettascope.render(step, replay_step)
"""

import sys
from pathlib import Path
from typing import TYPE_CHECKING, Optional

# Find the Nim bindings. Published wheels bundle the generated artifacts under
# ``mettagrid/nim/mettascope`` (because our PEPâ€‘517 backend copies the Nim
# project into ``python/src`` during the build).  Editable installs, however,
# serve the package straight from the repository checkout where the canonical
# sources remain in ``packages/mettagrid/nim/mettascope`` and the copy step
# never runs.  To support both layouts we try the packaged location first and,
# if it is missing the bindings, walk upwards looking for the repository copy.
package_root = Path(__file__).resolve().parent


def _resolve_nim_root() -> tuple[Optional[Path], list[Path]]:
    search_paths: list[Path] = []

    packaged = package_root / "nim" / "mettascope"
    search_paths.append(packaged)
    if (packaged / "bindings" / "generated").exists():
        return packaged, search_paths

    current = package_root
    for _ in range(8):
        candidate = current / "packages" / "mettagrid" / "nim" / "mettascope"
        search_paths.append(candidate)
        if candidate.exists():
            return candidate, search_paths
        if current == current.parent:
            break
        current = current.parent
    return None, search_paths


nim_root, _nim_search_paths = _resolve_nim_root()
nim_bindings_path = nim_root / "bindings" / "generated" if nim_root else None

# Type stubs for static analysis
if TYPE_CHECKING:
    from typing import Any

    def init(replay: Any) -> Any: ...
    def render(step: int, replay_step: Any) -> Any: ...

    class Mettascope2Error(Exception): ...
else:
    # Runtime import
    if nim_bindings_path and nim_bindings_path.exists():
        # Insert at the beginning to ensure it's found first
        sys.path.insert(0, str(nim_bindings_path))

        try:
            # Import the mettascope2 module
            import mettascope2

            # Verify the module has the expected attributes
            required_attrs = ["init", "render", "Mettascope2Error"]
            missing_attrs = [attr for attr in required_attrs if not hasattr(mettascope2, attr)]

            if missing_attrs:
                # List what attributes are actually available
                available_attrs = [attr for attr in dir(mettascope2) if not attr.startswith("_")]
                raise ImportError(
                    f"mettascope2 module is missing required attributes: {missing_attrs}. "
                    f"Available attributes: {available_attrs or 'none'}. "
                    f"The Nim bindings may need to be regenerated."
                )

            # Re-export the functions and classes
            def init(replay):
                return mettascope2.init(data_dir=str(nim_root / "data"), replay=replay)

            render = mettascope2.render
            Mettascope2Error = mettascope2.Mettascope2Error

        except ImportError as e:
            raise ImportError(
                f"Failed to import mettascope2 from {nim_bindings_path}: {e}. "
                "Ensure the Nim bindings have been properly generated."
            ) from e
        finally:
            # Remove the path from sys.path to avoid polluting it
            if str(nim_bindings_path) in sys.path:
                sys.path.remove(str(nim_bindings_path))
    else:
        searched = ", ".join(str(path) for path in _nim_search_paths)
        raise ImportError(
            "Could not find mettascope bindings. "
            f"Searched locations: {searched}. "
            "Ensure the Nim bindings have been generated by running the appropriate build command."
        )

__all__ = ["init", "render", "Mettascope2Error"]
