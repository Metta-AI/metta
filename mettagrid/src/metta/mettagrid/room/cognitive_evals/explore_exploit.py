from typing import List, Set, Tuple

import numpy as np
from omegaconf import DictConfig

from metta.mettagrid.room.room import Room
from metta.mettagrid.room.utils import create_grid, sample_position  # New utility functions


class ExploreExploit(Room):
    """
    Maze with two regions:
      - Left (sparse): rewards are spread out and the agent is placed here.
      - Right (dense): rewards are clustered.
    A vertical wall with random gaps divides the grid.
    """

    def __init__(
        self,
        width: int,
        height: int,
        explore_exploit_params: DictConfig,
        agents: int | DictConfig = 1,
        seed=None,
        border_width: int = 1,
        border_object: str = "wall",
    ):
        super().__init__(border_width=border_width, border_object=border_object)
        self._width, self._height = width, height
        self._params = explore_exploit_params
        self._agents = agents
        self._rng = np.random.default_rng(seed)

    def _build(self) -> np.ndarray:
        # Initialize grid using our utility
        self._grid = create_grid(self._height, self._width, fill_value="empty")
        self._placed_positions: Set[Tuple[int, int]] = set()
        mid_x = self._width // 2

        self._place_obstructions(mid_x)
        self._place_sparse_region(mid_x)
        self._place_dense_region(mid_x)
        self._place_agent(mid_x)

        return self._grid

    def _place_obstructions(self, mid_x: int) -> None:
        gap_prob = self._params.get("obstruction_gap_prob", 0.2)
        for y in range(1, self._height - 1):
            if self._rng.random() > gap_prob:
                self._grid[y, mid_x] = "wall"
                self._placed_positions.add((mid_x, y))

    def _place_sparse_region(self, mid_x: int) -> None:
        # Define region A: left side (from x=1 to mid_x-1, y=1 to height-2)
        x_min, x_max, y_min, y_max = 1, mid_x - 1, 1, self._height - 2
        min_dist = self._params.get("sparse_min_distance", 5)
        rewards = ["altar", "mine", "generator"]
        positions: List[Tuple[int, int]] = []
        for reward in rewards:
            # Use the utility function instead of a custom _sample_position method.
            pos = sample_position(x_min, x_max, y_min, y_max, min_dist, positions, rng=self._rng, attempts=100)
            positions.append(pos)
            self._grid[pos[1], pos[0]] = reward
            self._placed_positions.add(pos)

    def _place_dense_region(self, mid_x: int) -> None:
        # Define region B: right side (from mid_x+1 to width-2, y=1 to height-2)
        x_min, x_max, y_min, y_max = mid_x + 1, self._width - 2, 1, self._height - 2
        center_x = int(self._rng.integers(x_min, x_max + 1))
        center_y = int(self._rng.integers(y_min, y_max + 1))
        # Create a 3x3 cluster around the random center
        cluster = [
            (x, y)
            for x in range(max(x_min, center_x - 1), min(x_max, center_x + 1) + 1)
            for y in range(max(y_min, center_y - 1), min(y_max, center_y + 1) + 1)
        ]
        available = [p for p in cluster if p not in self._placed_positions]
        # If too few positions in the cluster, use the entire region
        if len(available) < 3:
            available = [
                (x, y)
                for x in range(x_min, x_max + 1)
                for y in range(y_min, y_max + 1)
                if (x, y) not in self._placed_positions
            ]
        # Sample three distinct positions if possible
        if len(available) >= 3:
            available_arr = np.array(available)
            chosen = [tuple(pos) for pos in self._rng.choice(available_arr, size=3, replace=False)]
        else:
            chosen = available
        for pos, reward in zip(chosen, ["altar", "mine", "generator"], strict=False):
            self._grid[pos[1], pos[0]] = reward
            self._placed_positions.add(pos)

    def _place_agent(self, mid_x: int) -> None:
        # Place the agent in region A (left side)
        x_min, x_max, y_min, y_max = 1, mid_x - 1, 1, self._height - 2
        for _ in range(100):
            x = int(self._rng.integers(x_min, x_max + 1))
            y = int(self._rng.integers(y_min, y_max + 1))
            if (x, y) not in self._placed_positions:
                self._grid[y, x] = "agent.agent"
                self._placed_positions.add((x, y))
                return
        # Fallback if no free position is found.
        self._grid[y_min, x_min] = "agent.agent"
        self._placed_positions.add((x_min, y_min))
