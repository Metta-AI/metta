name: Build and publish cogames

on:
  push:
    tags:
      - cogames-v*
  workflow_dispatch:
    inputs:
      publish:
        description: "Enable publishing step"
        required: false
        default: "yes"
        type: choice
        options:
          - "yes"
          - "no"
      target:
        description: "Where to publish: testpypi (safe testing) or pypi (live release)"
        required: false
        default: testpypi
        type: choice
        options:
          - testpypi
          - pypi

permissions:
  contents: read
  id-token: write
  deployments: write

jobs:
  build:
    name: Build distributions
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          fetch-tags: true
      - uses: actions/setup-python@v5
        with:
          python-version: "3.12"
      - name: Install build tooling
        run: python -m pip install --upgrade pip build twine
      - name: Build distributions
        run: python -m build --outdir dist packages/cogames
      - name: Check distributions
        run: python -m twine check dist/*
      - uses: actions/upload-artifact@v4
        with:
          name: cogames-dist
          path: dist/*

  test:
    name: Smoke test cogames
    needs:
      # We can reuse the already built wheel for cogames to save time.
      - build
      # Instead of building the mettagrid wheel locally, which might differ from the version
      #  specified in cogames' pyproject.toml, we let mettagrid get automatically installed
      #  from PyPI. Hence we need to wait for it to be available on PyPI.
      - wait-for-mettagrid
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-python@v5
        with:
          python-version: "3.12"
      # Without this, we get "ERROR: Could not install packages due to an OSError:
      #  [Errno 28] No space left on device" when trying to install cogames' dependencies.
      #  See https://github.com/Metta-AI/metta/actions/runs/20327783664/job/58396495857
      - name: Free up disk space
        uses: jlumbroso/free-disk-space@main
      - uses: actions/download-artifact@v4
        with:
          name: cogames-dist
          path: dist
      - name: Install cogames from wheel
        run: |
          pip install dist/cogames-*.whl
      - name: Install pytest
        run: |
          pip install pytest pytest-xdist
      - name: Prepare isolated test environment
        run: |
          # Copy tests to clean directory
          mkdir -p /tmp/test-isolation
          cp -r packages/cogames/tests /tmp/test-isolation/

          # Overkill, but wipe the original source code to doubly ensure isolation
          rm -rf *

      - name: Run tests in isolation
        working-directory: /tmp/test-isolation
        run: |
          # Run from clean directory - no metta/ or other repo packages accessible
          pytest tests/ -v

  wait-for-mettagrid:
    name: Wait for mettagrid on PyPI
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ github.ref }}
          fetch-depth: 0
          fetch-tags: true

      - name: Extract mettagrid version requirement
        id: version
        run: |
          # Parse packages/cogames/pyproject.toml to find mettagrid==X.Y.Z or mettagrid>=X.Y.Z
          if grep -qE 'mettagrid[><=~!]' packages/cogames/pyproject.toml; then
            VERSION=$(grep -E 'mettagrid' packages/cogames/pyproject.toml | grep -oP '\d+\.\d+\.\d+(\.\d+)?' | head -1)
            echo "mettagrid_version=$VERSION" >> $GITHUB_OUTPUT
            echo "Found mettagrid version requirement: $VERSION"
          else
            echo "No mettagrid version found - skipping wait"
            echo "mettagrid_version=" >> $GITHUB_OUTPUT
          fi

      - name: Wait for mettagrid on PyPI
        if: steps.version.outputs.mettagrid_version != ''
        env:
          VERSION: ${{ steps.version.outputs.mettagrid_version }}
          PYPI_URL: "https://pypi.org"
        run: |
          # Timing rationale:
          # - mettagrid's build job takes ~5 minutes
          # - PyPI propagation might add a few minutes
          # - Add some buffer just in case
          # Total: 10 minutes should be sufficient
          MAX_WAIT=600  # 10 minutes total
          CHECK_INTERVAL=60  # Check every minute
          ELAPSED=0

          echo "Waiting for mettagrid==$VERSION to be available on $PYPI_URL..."
          echo "This ensures cogames can be installed with its pinned mettagrid dependency."
          echo ""

          while [ $ELAPSED -le $MAX_WAIT ]; do
            if curl -sf "$PYPI_URL/pypi/mettagrid/$VERSION/json" > /dev/null 2>&1; then
              echo "✓ mettagrid $VERSION is available on $PYPI_URL!"
              exit 0
            fi
            echo "⏳ Waiting... ($ELAPSED/$MAX_WAIT seconds elapsed)"
            sleep $CHECK_INTERVAL
            ELAPSED=$((ELAPSED + CHECK_INTERVAL))
          done

          echo "❌ ERROR: mettagrid $VERSION not found on $PYPI_URL after $MAX_WAIT seconds"
          echo "The mettagrid release workflow may have failed or is taking longer than expected."
          exit 1

  publish:
    name: Publish to PyPI
    needs: test
    if: ${{ github.event_name != 'workflow_dispatch' || github.event.inputs.publish == 'yes' }}
    runs-on: ubuntu-latest
    environment:
      name: ${{ format('cogames-{0}', github.event_name == 'workflow_dispatch' && github.event.inputs.target || 'pypi') }}
    env:
      PUBLISH_TARGET: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.target || 'pypi' }}
      DEPLOY_ENV: ${{ format('cogames-{0}', github.event_name == 'workflow_dispatch' && github.event.inputs.target || 'pypi') }}
      DEPLOY_URL: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.target == 'testpypi' && 'https://test.pypi.org/project/cogames/' || 'https://pypi.org/project/cogames/' }}
    steps:
      - uses: actions/download-artifact@v4
        with:
          name: cogames-dist
          path: dist
      - name: List distributions
        run: ls -l dist
      - name: Create deployment record
        id: create_deployment
        uses: actions/github-script@v7
        if: ${{ env.PUBLISH_TARGET == 'pypi' }}
        env:
          DEPLOY_DESCRIPTION: ${{ format('Publishing cogames to {0}', env.PUBLISH_TARGET) }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const response = await github.rest.repos.createDeployment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: context.ref,
              environment: process.env.DEPLOY_ENV,
              auto_merge: false,
              required_contexts: [],
              description: process.env.DEPLOY_DESCRIPTION,
              production_environment: process.env.PUBLISH_TARGET === 'pypi',
            });

            await github.rest.repos.createDeploymentStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              deployment_id: response.data.id,
              state: 'in_progress',
              log_url: `https://github.com/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}`,
              environment_url: process.env.DEPLOY_URL,
              description: 'Publishing in progress',
            });

            core.setOutput('deployment_id', response.data.id);
      - uses: pypa/gh-action-pypi-publish@release/v1
        with:
          repository-url: ${{ env.PUBLISH_TARGET == 'testpypi' && 'https://test.pypi.org/legacy/' || 'https://upload.pypi.org/legacy/' }}
          skip-existing: ${{ env.PUBLISH_TARGET == 'testpypi' }}
          verbose: true
      - name: Mark deployment successful
        if: ${{ env.PUBLISH_TARGET == 'pypi' && success() && steps.create_deployment.outputs.deployment_id != '' }}
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            await github.rest.repos.createDeploymentStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              deployment_id: Number('${{ steps.create_deployment.outputs.deployment_id }}'),
              state: 'success',
              log_url: `https://github.com/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}`,
              environment_url: process.env.DEPLOY_URL,
              description: 'Publish succeeded',
            });
      - name: Mark deployment failed
        if: ${{ env.PUBLISH_TARGET == 'pypi' && failure() && steps.create_deployment.outputs.deployment_id != '' }}
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            await github.rest.repos.createDeploymentStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              deployment_id: Number('${{ steps.create_deployment.outputs.deployment_id }}'),
              state: 'failure',
              log_url: `https://github.com/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}`,
              environment_url: process.env.DEPLOY_URL,
              description: 'Publish failed',
            });
