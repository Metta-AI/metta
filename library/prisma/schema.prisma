generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                      String                   @id @default(cuid())
  name                    String?
  email                   String?                  @unique(map: "user_email_unique")
  emailVerified           DateTime?
  image                   String?
  banReason               String?
  bannedAt                DateTime?
  bannedByUserId          String?
  isBanned                Boolean                  @default(false)
  accounts                Account[]
  authenticators          Authenticator[]
  comments                Comment[]
  createdGroups           Group[]
  createdInstitutions     Institution[]
  triggeredNotifications  Notification[]           @relation("NotificationActor")
  receivedNotifications   Notification[]           @relation("NotificationRecipient")
  notificationPreferences NotificationPreference[]
  posts                   Post[]
  sessions                Session[]
  bannedBy                User?                    @relation("UserBannedBy", fields: [bannedByUserId], references: [id])
  bannedUsers             User[]                   @relation("UserBannedBy")
  userGroups              UserGroup[]
  userInstitutions        UserInstitution[]
  userPaperInteractions   UserPaperInteraction[]

  @@map("user")
}

model Account {
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?
  user              User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([provider, providerAccountId])
  @@map("account")
}

model Session {
  sessionToken String   @id
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("session")
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime @db.Timestamp(6)

  @@id([identifier, token])
  @@map("verificationToken")
}

model Authenticator {
  credentialID         String  @unique(map: "authenticator_credentialID_unique")
  userId               String
  providerAccountId    String
  credentialPublicKey  String
  counter              Int
  credentialDeviceType String
  credentialBackedUp   Boolean
  transports           String?
  user                 User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([userId, credentialID])
  @@map("authenticator")
}

model Post {
  id             String         @id @default(cuid())
  authorId       String
  title          String
  createdAt      DateTime       @default(now())
  updatedAt      DateTime       @default(now()) @updatedAt
  content        String?
  postType       String         @default("user-post")
  queues         Int            @default(0)
  replies        Int            @default(0)
  paperId        String?
  images         String[]       @default([])
  quotedPostIds  String[]       @default([])
  comments       Comment[]
  notifications  Notification[]
  author         User           @relation(fields: [authorId], references: [id])
  paper          Paper?         @relation(fields: [paperId], references: [id])

  @@map("post")
}

model Comment {
  id            String         @id @default(cuid())
  content       String
  postId        String
  authorId      String
  parentId      String?
  isBot         Boolean        @default(false)
  botType       String?
  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @default(now()) @updatedAt
  author        User           @relation(fields: [authorId], references: [id], onDelete: Cascade)
  parent        Comment?       @relation("CommentReplies", fields: [parentId], references: [id], onDelete: Cascade)
  replies       Comment[]      @relation("CommentReplies")
  post          Post           @relation(fields: [postId], references: [id], onDelete: Cascade)
  notifications Notification[]

  @@map("comment")
}

model Author {
  id              String        @id @default(cuid())
  name            String        @unique
  username        String?       @unique
  email           String?
  avatar          String?
  institution     String?
  department      String?
  title           String?
  expertise       String[]
  hIndex          Int?          @default(0)
  totalCitations  Int?          @default(0)
  claimed         Boolean       @default(false)
  recentActivity  DateTime?
  orcid           String?       @unique
  googleScholarId String?
  arxivId         String?
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @default(now()) @updatedAt
  institutionId   String?
  institutionRef  Institution?  @relation("AuthorInstitution", fields: [institutionId], references: [id])
  paperAuthors    PaperAuthor[]

  @@map("author")
}

model Paper {
  id                     String                 @id @default(cuid())
  title                  String
  abstract               String?
  institutions           String[]
  tags                   String[]
  link                   String?
  source                 String?
  externalId             String?
  stars                  Int                    @default(0)
  starred                Boolean                @default(false)
  createdAt              DateTime               @default(now())
  updatedAt              DateTime               @default(now()) @updatedAt
  llmAbstract            Json?
  llmAbstractGeneratedAt DateTime?
  institutionIds         String[]               @default([])
  paperAuthors           PaperAuthor[]
  paperInstitutions      PaperInstitution[]
  posts                  Post[]
  userPaperInteractions  UserPaperInteraction[]

  @@map("paper")
}

model PaperAuthor {
  paperId  String
  authorId String
  author   Author @relation(fields: [authorId], references: [id], onDelete: Cascade)
  paper    Paper  @relation(fields: [paperId], references: [id], onDelete: Cascade)

  @@id([paperId, authorId])
  @@map("paper_author")
}

model UserPaperInteraction {
  userId  String
  paperId String
  starred Boolean?  @default(false)
  readAt  DateTime? @db.Timestamp(6)
  queued  Boolean?  @default(false)
  notes   String?
  paper   Paper     @relation(fields: [paperId], references: [id])
  user    User      @relation(fields: [userId], references: [id])

  @@id([userId, paperId], map: "user_paper_interaction_userId_paperId_pk")
  @@map("user_paper_interaction")
}

model Institution {
  id               String             @id @default(cuid())
  name             String             @unique
  domain           String?            @unique
  description      String?
  website          String?
  location         String?
  type             InstitutionType    @default(COMPANY)
  isVerified       Boolean            @default(false)
  createdAt        DateTime           @default(now())
  updatedAt        DateTime           @default(now()) @updatedAt
  createdByUserId  String?
  requiresApproval Boolean            @default(false)
  authors          Author[]           @relation("AuthorInstitution")
  groups           Group[]
  createdBy        User?              @relation(fields: [createdByUserId], references: [id])
  papers           PaperInstitution[]
  userInstitutions UserInstitution[]

  @@map("institution")
}

model UserInstitution {
  id            String                @id @default(cuid())
  userId        String
  institutionId String
  role          String?
  department    String?
  title         String?
  isActive      Boolean               @default(true)
  joinedAt      DateTime              @default(now())
  status        UserInstitutionStatus @default(APPROVED)
  institution   Institution           @relation(fields: [institutionId], references: [id], onDelete: Cascade)
  user          User                  @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, institutionId])
  @@map("user_institution")
}

model PaperInstitution {
  id            String      @id @default(cuid())
  paperId       String
  institutionId String
  institution   Institution @relation(fields: [institutionId], references: [id], onDelete: Cascade)
  paper         Paper       @relation(fields: [paperId], references: [id], onDelete: Cascade)

  @@unique([paperId, institutionId])
  @@map("paper_institution")
}

model Group {
  id              String      @id @default(cuid())
  name            String
  description     String?
  isPublic        Boolean     @default(true)
  createdAt       DateTime    @default(now())
  updatedAt       DateTime    @default(now()) @updatedAt
  createdByUserId String?
  institutionId   String
  createdBy       User?       @relation(fields: [createdByUserId], references: [id])
  institution     Institution @relation(fields: [institutionId], references: [id], onDelete: Cascade)
  userGroups      UserGroup[]

  @@unique([name, institutionId])
  @@map("group")
}

model UserGroup {
  id       String   @id @default(cuid())
  userId   String
  groupId  String
  role     String?  @default("member")
  joinedAt DateTime @default(now())
  isActive Boolean  @default(true)
  group    Group    @relation(fields: [groupId], references: [id], onDelete: Cascade)
  user     User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, groupId])
  @@map("user_group")
}

model Notification {
  id          String                 @id @default(cuid())
  userId      String
  type        NotificationType
  isRead      Boolean                @default(false)
  title       String
  message     String?
  actionUrl   String?
  createdAt   DateTime               @default(now())
  updatedAt   DateTime               @default(now()) @updatedAt
  actorId     String?
  postId      String?
  commentId   String?
  mentionText String?
  actor       User?                  @relation("NotificationActor", fields: [actorId], references: [id], onDelete: Cascade)
  comment     Comment?               @relation(fields: [commentId], references: [id], onDelete: Cascade)
  post        Post?                  @relation(fields: [postId], references: [id], onDelete: Cascade)
  user        User                   @relation("NotificationRecipient", fields: [userId], references: [id], onDelete: Cascade)
  deliveries  NotificationDelivery[]

  @@index([userId, createdAt])
  @@index([userId, isRead])
  @@map("notification")
}

model NotificationPreference {
  id              String           @id @default(cuid())
  userId          String
  type            NotificationType
  emailEnabled    Boolean          @default(true)
  discordEnabled  Boolean          @default(false)
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @default(now()) @updatedAt
  discordLinkedAt DateTime?
  discordUserId   String?
  discordUsername String?
  user            User             @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, type])
  @@unique([discordUserId, type])
  @@index([userId])
  @@index([discordUserId])
  @@map("notification_preference")
}

model NotificationDelivery {
  id             String       @id @default(cuid())
  notificationId String
  channel        String
  status         String
  attemptCount   Int          @default(0)
  lastAttempt    DateTime?
  errorMessage   String?
  deliveredAt    DateTime?
  createdAt      DateTime     @default(now())
  notification   Notification @relation(fields: [notificationId], references: [id], onDelete: Cascade)

  @@index([notificationId])
  @@index([status])
  @@index([channel, status])
  @@map("notification_delivery")
}

enum InstitutionType {
  UNIVERSITY
  COMPANY
  RESEARCH_LAB
  NONPROFIT
  GOVERNMENT
  OTHER
}

enum UserInstitutionStatus {
  PENDING
  APPROVED
  REJECTED
}

enum NotificationType {
  MENTION
  COMMENT
  REPLY
  LIKE
  FOLLOW
  PAPER_SUGGESTION
  SYSTEM
}
