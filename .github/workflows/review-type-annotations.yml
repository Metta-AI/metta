name: "Type Annotation Review"

on:
  pull_request:
    types: [opened, reopened]
    paths:
      - "**/*.py" # Only trigger on Python files

jobs:
  review-type-annotations:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write
      id-token: write
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version-file: ".python-version"

      - name: Install uv
        uses: astral-sh/setup-uv@v5
        with:
          version: "0.7.3"
          enable-cache: false

      - name: Create virtual environment with uv
        shell: bash
        run: |
          uv venv .venv
          echo "VIRTUAL_ENV=$(pwd)/.venv" >> $GITHUB_ENV
          echo "$(pwd)/.venv/bin" >> $GITHUB_PATH

      - name: Install mypy in venv
        run: |
          uv pip install mypy

      - name: Check for Python file changes
        id: check-python
        run: |
          PYTHON_FILES=$(git diff --name-only origin/${{ github.base_ref }} HEAD | grep "\.py$" || echo "")
          if [ -n "$PYTHON_FILES" ]; then
            echo "python_changes=true" >> $GITHUB_OUTPUT
            echo "Changed Python files: $PYTHON_FILES"
          else
            echo "python_changes=false" >> $GITHUB_OUTPUT
            echo "No Python files changed in this PR"
          fi

      - name: Analyze Type Annotations
        if: steps.check-python.outputs.python_changes == 'true'
        uses: anthropics/claude-code-action@beta
        with:
          anthropic_api_key: ${{ secrets.ANTHROPIC_API_KEY }}
          anthropic_model: "claude-3-7-sonnet-20250219"
          allowed_tools: "Edit,Replace,Bash(git diff HEAD~1),Bash(python -m mypy --version)" # Allow Claude to create suggested edits
          direct_prompt: |
            Please review the Python code in this PR for type annotation improvements that would enhance code readability
            and IDE support. Our philosophy is that type annotations should make code easier to understand and refactor,
            not harder.

            **Core Principle:** Only suggest type annotations that provide real value. When in doubt, trust type inference.

            **1. Function Parameters - Always annotate these:**
            - All function parameters should have type annotations
            - This is the highest value place for annotations
            - Helps both IDE tools and developers understand expected inputs

            **2. Function Return Types - Be selective:**
            **DO annotate return types for:**
            - Public API functions/methods (anything not prefixed with _)
            - Functions with complex logic or multiple branches where return type serves as an assertion
            - Functions where the return type isn't obvious from the name
            - Functions that might return None in some cases

            **DON'T annotate return types for:**
            - Private methods internal to a class (easier refactoring)
            - Functions enclosed within other functions
            - Simple getters/setters where the type is obvious
            - Very short functions (1-3 lines) with obvious returns

            **3. Variable Assignments - Usually skip these:**
            - Rarely useful and often add noise
            - Only suggest when type inference has clearly failed
            - Or when initializing empty collections that will hold specific types
            - Trust the IDE's inference for most cases

            **4. Complex Data Structures:**
            - For complex dicts, consider suggesting refactoring to dataclasses instead of TypedDict
            - Dataclasses are often cleaner and more maintainable than heavily typed dicts
            - If you must type a dict, only do so when the structure is truly complex and reused

            **5. Modern Typing Syntax:**
            - Use `list[str]` instead of `List[str]` for Python 3.9+
            - Use `type | None` instead of `Optional[type]` for Python 3.10+
            - This is minor but good for consistency

            **Review Process:**
            1. First scan for missing parameter annotations (highest priority)
            2. Then look at public function return types
            3. Check for complex/branching functions that would benefit from return type assertions
            4. Only suggest variable annotations when absolutely necessary
            5. For complex dicts, consider suggesting dataclass refactoring

            **What NOT to do:**
            - Don't annotate obvious variable assignments
            - Don't annotate private method returns unless there's a specific benefit
            - Don't add annotations just because you can
            - Don't suggest TypedDict for simple structures (prefer dataclasses)

            **Creating suggestions:**
            - Explain WHY each annotation improves the code
            - For return types, mention if it's for API clarity or as a safety assertion
            - If you see complex dict structures, suggest considering dataclasses as an alternative

            Remember: The goal is to make code easier to understand and refactor, not to achieve 100% annotation coverage.
            Good type hints guide developers and catch bugs without getting in the way.

            **TLDR Section:**
            Conclude with a brief summary organized by value:
            - **Must fix:** Missing parameter annotations
            - **Recommended:** Public API return types, complex function returns
            - **Consider:** Dataclass refactoring for complex dicts
            - **Optional:** Other minor improvements

            Keep the TLDR concise with file names and line numbers.
